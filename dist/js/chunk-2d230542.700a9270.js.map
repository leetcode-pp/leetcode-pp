{"version":3,"sources":["webpack:///./src/views/solutionCode.js"],"names":["id","name","link","list","title","codes","language","content"],"mappings":"gHAAA,OACe,cACb,CACEA,GAAI,KACJC,KAAM,SACNC,KAAM,6CACNC,KAAM,CACJ,CACEC,MAAO,UACPC,MAAO,CACL,CACEC,SAAU,SACVC,QAAS,wtBAmBX,CACED,SAAU,OACVC,QAAS,kfAsBf,CACEH,MAAO,UACPC,MAAO,CACL,CACEC,SAAU,SACVC,QAAS,8rBAqBX,CACED,SAAU,OACVC,QAAS,44BAgCf,CACEH,MAAO,UACPC,MAAO,CACL,CACEC,SAAU,SACVC,QAAS,shBAoBf,CACEH,MAAO,UACPC,MAAO,CACL,CACEC,SAAU,SACVC,QAAS,srBAqBX,CACED,SAAU,OACVC,QAAS,uiCAqCf,CACEH,MAAO,UACPC,MAAO,CACL,CACEC,SAAU,SACVC,QAAS,kdAkBf,CACEH,MAAO,UACPC,MAAO,CACL,CACEC,SAAU,SACVC,QAAS,uaAgBX,CACED,SAAU,OACVC,QAAS,g9BAmCf,CACEH,MAAO,UACPC,MAAO,CACL,CACEC,SAAU,SACVC,QAAS,qkBAwBX,CACED,SAAU,OACVC,QAAS,ggBAuBf,CACEH,MAAO,UACPC,MAAO,CACL,CACEC,SAAU,SACVC,QAAS,4vBAqBX,CACED,SAAU,OACVC,QAAS,m2BAkCf,CACEH,MAAO,UACPC,MAAO,CACL,CACEC,SAAU,SACVC,QAAS,+vCAmCX,CACED,SAAU,OACVC,QAAS,0lBA2Bf,CACEH,MAAO,WACPC,MAAO,CACL,CACEC,SAAU,SACVC,QAAS,0gBAsBX,CACED,SAAU,OACVC,QAAS,w2BAwCf,CACEH,MAAO,WACPC,MAAO,CACL,CACEC,SAAU,SACVC,QAAS,siBAoBX,CACED,SAAU,OACVC,QAAS,qrCAiDf,CACEH,MAAO,WACPC,MAAO,CACL,CACEC,SAAU,SACVC,QAAS,ooBAqBX,CACED,SAAU,OACVC,QAAS,omBA2Bf,CACEH,MAAO,UACPC,MAAO,CACL,CACEC,SAAU,SACVC,QAAS,mfAoBX,CACED,SAAU,OACVC,QAAS,kCAMf,CACEH,MAAO,UACPC,MAAO,CACL,CACEC,SAAU,SACVC,QAAS,87BA+BX,CACED,SAAU,OACVC,QAAS,o7CA8Df,CACEH,MAAO,UACPC,MAAO,CACL,CACEC,SAAU,SACVC,QAAS,4zBAyBX,CACED,SAAU,OACVC,QAAS,y+CAoEf,CACEH,MAAO,UACPC,MAAO,CACL,CACEC,SAAU,SACVC,QAAS,+7BA4BX,CACED,SAAU,OACVC,QAAS","file":"js/chunk-2d230542.700a9270.js","sourcesContent":["/* eslint-disable */\nexport default [\n  {\n    id: '01',\n    name: '01.堆专题',\n    link: 'https://lucifer.ren/blog/2021/01/19/heap-2',\n    list: [\n      {\n        title: '代码1.3.1',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass MedianFinder:\n    def __init__(self):\n        self.min_heap = []\n        self.max_heap = []\n    def addNum(self, num: int) -> None:\n        if not self.max_heap or num < -self.max_heap[0]:\n            heapq.heappush(self.max_heap, -num)\n        else:\n            heapq.heappush(self.min_heap, num)\n        if len(self.max_heap) > len(self.min_heap) + 1:\n            heappush(self.min_heap, -heappop(self.max_heap))\n        elif len(self.min_heap) > len(self.max_heap):\n            heappush(self.max_heap, -heappop(self.min_heap))\n    def findMedian(self) -> float:\n        if len(self.min_heap) == len(self.max_heap): return (self.min_heap[0] - self.max_heap[0]) / 2\n        return -self.max_heap[0]\n`\n          },\n          {\n            language: 'Java',\n            content: `\nclass MedianFinder {\n  private Queue<Long> minHeap = new PriorityQueue(),\n          maxHeap = new PriorityQueue();\n\n  public void addNum(int num) {\n      minHeap.add((long) num);\n      maxHeap.add(-minHeap.poll());\n      if (minHeap.size() < maxHeap.size())\n          minHeap.add(-maxHeap.poll());\n  }\n\n  public double findMedian() {\n      return minHeap.size() > maxHeap.size()\n              ? minHeap.peek()\n              : (minHeap.peek() - maxHeap.peek()) / 2.0;\n  }\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.2',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        eff = [(q / w, q, w) for a, b in zip(quality, wage)]\n        eff.sort(key=lambda a: -a[0])\n        ans = float('inf')\n        for i in range(K-1, len(eff)):\n            h = []\n            k = K - 1\n            rate, _, total = eff[i]\n            # 找出工作效率比它高的 k 个人，这 k 个人的工资尽可能低。\n            # 由于已经工作效率倒序排了，因此前面的都是比它高的，然后使用堆就可得到 k 个工资最低的。\n            for j in range(i):\n                heapq.heappush(h, eff[j][1] / rate)\n            while k > 0:\n                total += heapq.heappop(h)\n                k -= 1\n            ans = min(ans, total)\n        return ans\n`\n          },\n          {\n            language: 'Java',\n            content: `\npublic double mincostToHireWorkers(int[] quality, int[] wage, int K) {\n  int n = quality.length;\n  // 单位薪资\n  Pair<Double, Integer>[] pairs = new Pair[n];\n  for (int i = 0; i < n; i++) {\n      Pair<Double, Integer> pair = new Pair(wage[i] / (quality[i] * 1d), quality[i]);\n      pairs[i] = pair;\n  }\n  Arrays.sort(pairs, (o1, o2) -> o1.getKey() - o2.getKey() > 0 ? 1 : -1);\n\n  double ans = Double.MAX_VALUE;\n  // 总工时\n  int sumQuilty = 0;\n  PriorityQueue<Integer> pq = new PriorityQueue();\n  for (int i = 0; i < n; i++) {\n      Pair<Double, Integer> p = pairs[i];\n      // 这里偷懒直接使用了最小堆 借鉴官方题解，用最大堆也可以的\n      pq.offer(-p.getValue());\n      sumQuilty += p.getValue();\n      if (pq.size() > K)\n          // 如果超过k就要把当前工时/工资最高的赶走，这样才符合资本家剥夺剩余价值\n          sumQuilty += pq.poll();\n      if (pq.size() == K)\n          ans = Math.min(ans, sumQuilty * p.getKey());\n  }\n  return ans;\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.3',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        effs = [(q / w, q) for q, w in zip(quality, wage)]\n        effs.sort(key=lambda a: -a[0])\n        ans = float('inf')\n        h = []\n        total = 0\n        for rate, q in effs:\n            heapq.heappush(h, -q)\n            total += q\n            if len(h) > K:\n                total += heapq.heappop(h)\n            if len(h) == K:\n                ans = min(ans, total / rate)\n        return ans\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.4',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def kthSmallest(self, mat, k: int) -> int:\n        h = []\n        cur = (sum(vec[0] for vec in mat), tuple([0] * len(mat)))\n        heapq.heappush(h, cur)\n        seen = set(cur)\n\n        for _ in range(k):\n            acc, pointers = heapq.heappop(h)\n            for i, pointer in enumerate(pointers):\n                if pointer != len(mat[0]) - 1:\n                    t = list(pointers)\n                    t[i] = pointer + 1\n                    tt = tuple(t)\n                    if tt not in seen:\n                        seen.add(tt)\n                        heapq.heappush(h, (acc + mat[i][pointer + 1] - mat[i][pointer], tt))\n        return acc\n`\n          },\n          {\n            language: 'Java',\n            content: `\npublic int kthSmallest(int[][] mat, int k) {\n  int m = mat.length;\n  int n = mat[0].length;\n  PriorityQueue<Pair<Integer, int[]>> pq = new PriorityQueue<>((a, b) -> a.getKey() - b.getKey());\n  int[] sum = new int[m];\n  int total = 0;\n  for (int i = 0; i < m; i++) {\n      total += mat[i][0];\n  }\n  Pair<Integer, int[]> pair = new Pair<>(total, sum);\n  pq.offer(pair);\n  Set<String> seen = new HashSet<>();\n\n  // 小顶堆 执行k次 把前面k小的数组移除 之后栈顶便是我们所求之结果\n  while (--k > 0) {\n      Pair<Integer, int[]> cur = pq.poll();\n      // 行号\n      for (int i = 0; i < m; i++) {\n          if (cur.getValue()[i] < n - 1) {\n              int[] arr = Arrays.copyOf(cur.getValue(), m);\n              // 列号\n              arr[i]++;\n              if (!seen.contains(Arrays.toString(arr))) {\n                  seen.add(Arrays.toString(arr));\n                  int next = cur.getKey() - mat[i][cur.getValue()[i]] + mat[i][arr[i]];\n                  pq.offer(new Pair<>(next, arr));\n              }\n          }\n      }\n  }\n  return pq.peek().getKey();\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.5',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        h = []\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                a, b = nums[i], nums[j]\n                # 维持堆大小不超过 k\n                if len(h) == k and -abs(a - b) > h[0]:\n                    heapq.heappop(h)\n                if len(h) < k:\n                    heapq.heappush(h, -abs(a - b))\n\n        return -h[0]\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.6',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution(object):\n    def smallestDistancePair(self, nums, k):\n        nums.sort()\n        # n 种候选答案\n        h = [(nums[i+1] - nums[i], i, i+1) for i in range(len(nums) - 1)]\n        heapq.heapify(h)\n\n        for _ in range(k):\n            diff, fr, to = heapq.heappop(h)\n            if to + 1 < len(nums):\n                heapq.heappush((nums[to + 1] - nums[fr], fr, to + 1))\n\n        return diff\n`\n          },\n          {\n            language: 'Java',\n            content: `\npublic int smallestDistancePair(int[] nums, int k) {\n  // 先排序\n  Arrays.sort(nums);\n  // 小顶堆\n  PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(Comparator.comparingInt(a -> (nums[a.getValue()] - nums[a.getKey()])));\n  // i 于 i+1 可以找到最小的元素\n  for (int i = 0; i + 1 < nums.length; i++) {\n      Pair pair = new Pair(i, i + 1);\n      pq.offer(pair);\n  }\n  Pair<Integer, Integer> pair = null;\n  /**\n   * 实现原理：\n   * 数组按顺序排序\n   * 那么最小的差 以及第二小的差 在第一轮 也就是上面那个 for 里面可以求出来，\n   * 由于后续元素是在 原有基础上添加 后续元素肯定是每一轮逐渐增大的，也就是说上一轮集合小于下一轮（同样的起点情况）\n   * 证明：原有集合为 i->j  新增集合为  i->j+1 原有集合是新集合的子集，所以新的集合差肯定大于上一轮 ，新的集合同时覆盖（i->j）and (i+1->j+1) 两个集合\n   * 这样可以保证即便弹出一个元素 pq 中的堆顶依然是最小元素\n   * 如此反复\n   * 堆顶元素便是我们所求之元素\n   */\n  while (k > 0) {\n      k--;\n      pair = pq.poll();\n      if (pair.getValue() + 1 < nums.length) {\n          pq.offer(new Pair(pair.getKey(), pair.getValue() + 1));\n      }\n  }\n  return nums[pair.getValue()] - nums[pair.getKey()];\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.7',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def smallestDistancePair(self, A: List[int], K: int) -> int:\n        A.sort()\n        l, r = 0, A[-1] - A[0]\n\n        def count_ngt(mid):\n            slow = 0\n            ans = 0\n            for fast in range(len(A)):\n                while A[fast] - A[slow] > mid:\n                    slow += 1\n                ans += fast - slow\n            return ans\n\n        while l <= r:\n            mid = (l + r) // 2\n            if count_ngt(mid) >= K:\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l\n`\n          },\n          {\n            language: 'Java',\n            content: `\npublic int smallestDistancePair(int[] nums, int k) {\n  Arrays.sort(nums);\n\n  int l = 0;\n  int r = nums[nums.length - 1] - nums[0];\n  while (l < r) {\n      int mi = (l + r) / 2;\n      int count = 0, left = 0;\n      for (int right = 0; right < nums.length; ++right) {\n          while (nums[right] - nums[left] > mi) left++;\n          count += right - left;\n      }\n      //count = number of pairs with distance <= mi\n      if (count >= k) r = mi;\n      else l = mi + 1;\n  }\n  return r;\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.8',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def smallestRange(self, martrix: List[List[int]]) -> List[int]:\n        l, r = -10**9, 10**9\n        # 将每一行最小的都放到堆中，同时记录其所在的行号和列号，一共 n 个齐头并进\n        h = [(row[0], i, 0) for i, row in enumerate(martrix)]\n        heapq.heapify(h)\n        # 维护最大值\n        max_v = max(row[0] for row in martrix)\n\n        while True:\n            min_v, row, col = heapq.heappop(h)\n            # max_v - min_v 是当前的最大最小差值， r - l 为全局的最大最小差值。因为如果当前的更小，我们就更新全局结果\n            if max_v - min_v < r - l:\n                l, r = min_v, max_v\n            if col == len(martrix[row]) - 1: return [l, r]\n            # 更新指针，继续往后移动一位\n            heapq.heappush(h, (martrix[row][col + 1], row, col + 1))\n            max_v = max(max_v, martrix[row][col + 1])\n`\n          },\n          {\n            language: 'Java',\n            content: `\npublic int[] smallestRange(List<List<Integer>> nums) {\n\n  int l = -1000000000, r = 1000000000, max = -1000000000;\n\n  // 用一个 int[3] 数组来保存 len， height 以及 val\n  PriorityQueue<int[]> pq = new PriorityQueue((Comparator<int[]>) (a, b) -> a[2] - b[2]);\n\n  for (int i = 0; i < nums.size(); i++) {\n      pq.offer(new int[]{i, 0, nums.get(i).get(0)});\n      max = Math.max(max, nums.get(i).get(0));\n  }\n\n  while (!pq.isEmpty()) {\n      int[] item = pq.poll();\n      int minV = item[2], row = item[0], col = item[1];\n      if (max - minV < r - l) {\n          l = minV;\n          r = max;\n      }\n      if (col == nums.get(row).size() - 1) {\n          return new int[]{l, r};\n      }\n      int next = nums.get(row).get(col + 1);\n      pq.offer(new int[]{row, col + 1, next});\n      max = Math.max(next, max);\n  }\n\n  return new int[]{l, r};\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.9',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def smallestRange(self, martrix: List[List[int]]) -> List[int]:\n        l, r = -10**9, 10**9\n        # 将每一行最小的都放到堆中，同时记录其所在的行号和列号，一共 n 个齐头并进\n        h = [(row[0], i, 0) for i, row in enumerate(martrix)]\n        heapq.heapify(h)\n        # 维护最大值\n        max_v = max(row[0] for row in martrix)\n\n        while True:\n            min_v, row, col = heapq.heappop(h)\n            # max_v - min_v 是当前的最大最小差值， r - l 为全局的最大最小差值。因为如果当前的更小，我们就更新全局结果\n            if max_v - min_v < r - l:\n                l, r = min_v, max_v\n            if col == len(martrix[row]) - 1: return [l, r]\n            # 更新指针，继续往后移动一位\n            heapq.heappush(h, (martrix[row][col + 1], row, col + 1))\n            max_v = max(max_v, martrix[row][col + 1])\n    def minimumDeviation(self, nums: List[int]) -> int:\n        matrix = [[] for _ in range(len(nums))]\n        for i, num in enumerate(nums):\n            if num & 1 == 1:\n                matrix[i] += [num, num * 2]\n            else:\n                temp = []\n                while num and num & 1 == 0:\n                    temp += [num]\n                    num //= 2\n                temp += [num]\n                matrix[i] += temp[::-1]\n        a, b = self.smallestRange(matrix)\n        return b - a\n`\n          },\n          {\n            language: 'Java',\n            content: `\npublic int minimumDeviation(int[] nums) {\n  int n = nums.length;\n  List<List<Integer>> arr = new ArrayList<>();\n  for (int i = 0; i < n; ++i) {\n      arr.add(new ArrayList<>());\n      if ((nums[i] & 1) == 1) {\n          arr.get(i).add(nums[i]);\n          arr.get(i).add(nums[i] * 2);\n      } else {\n          while ((nums[i] & 1) != 0) {\n              arr.get(i).add(nums[i]);\n              nums[i] >>= 1;\n          }\n          arr.get(i).add(nums[i]);\n          Collections.reverse(arr.get(i));\n      }\n  }\n\n  int[] res = smallestRange(arr);\n\n  return res[1] - res[0];\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.10',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        stations += [(target, 0)]\n        cur = startFuel\n        ans = 0\n\n        h = []\n        last = 0\n        for i, fuel in stations:\n            cur -= i - last\n            while cur < 0 and h:\n                cur -= heapq.heappop(h)\n                ans += 1\n            if cur < 0:\n                return -1\n            heappush(h, -fuel)\n\n            last = i\n        return ans\n`\n          },\n          {\n            language: 'Java',\n            content: `\npublic int minRefuelStops(int target, int startFuel, int[][] stations) {\n  if (stations.length == 0) {\n      return startFuel >= target ? 0 : -1;\n  }\n\n  // 定义次数 ans，车内油量 cur\n  int ans = 0, cur = startFuel;\n  // 定义 pq 用来在车厢箱保存燃油\n  PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n\n  for (int i = 0; i < stations.length; i++) {\n      // 车上没油啦 需要到车厢找最大的一桶油来加满\n      while (cur < stations[i][0]) {\n          Integer fuel = pq.poll();\n          // 车厢没油了 mission failed\n          if (fuel == null) {\n              return -1;\n          }\n          // 行驶距离\n          cur += fuel;\n          ans++;\n      }\n      pq.offer(stations[i][1]);\n  }\n  // 判断是否到达目的地\n  while (cur < target) {\n      Integer fuel = pq.poll();\n      if (fuel == null) {\n          return -1;\n      }\n      cur += fuel;\n      ans++;\n  }\n  return ans;\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.11',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        ans = [1] * len(rains)\n        lakes = collections.defaultdict(int)\n        sunny = []\n\n        for i, rain in enumerate(rains):\n            if rain > 0:\n                ans[i] = -1\n                if lakes[rain - 1] == 1:\n                    if 0 == len(sunny):\n                        return []\n                    ans[sunny.pop()] = rain\n                lakes[rain - 1] = 1\n            else:\n                sunny.append(i)\n        return ans\n`\n          },\n          {\n            language: 'Java',\n            content: `\npublic  int[] avoidFlood(int[] rains) {\n\n    List<Integer>sunnys = new ArrayList<>();\n\n    Map<Integer,Integer> rainings = new HashMap<>();\n    int res[] = new int[rains.length];\n    for (int i = 0; i < rains.length; i++) {\n        // 当前湖泊下雨啦\n        if (rains[i]>0){\n            if (rainings.containsKey(rains[i])) {\n                int lastRainingDay = rainings.get(rains[i]);\n                int index =  getLeft(sunnys,lastRainingDay);\n                if (index>=sunnys.size()){\n                    return new int[]{};\n                }\n\n                res[sunnys.get(index)] = rains[i];\n                sunnys.remove(index);\n            }\n            rainings.put(rains[i],i);\n            res[i] = -1;\n        }else {\n            sunnys.add(i);\n        }\n    }\n    for (int i = 0; i <sunnys.size(); i++) {\n        res[sunnys.get(i)] = 1;\n    }\n    return res;\n}\npublic int getLeft(List<Integer> arr,int key){\n    int left = 0;\n    int right = arr.size();\n    while (left<right){\n        int mid = (left+right)>>1;\n\n        if (arr.get(mid)>=key){\n            right=mid;\n        }else {\n            left = mid+1;\n        }\n    }\n    return left;\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.12',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:\n        h = []\n        for i in range(1, len(heights)):\n            diff = heights[i] - heights[i - 1]\n            if diff <= 0:\n                continue\n            if bricks < diff and ladders > 0:\n                ladders -= 1\n                if h and -h[0] > diff:\n                    bricks -= heapq.heappop(h)\n                else:\n                    continue\n            bricks -= diff\n            if bricks < 0:\n                return i - 1\n            heapq.heappush(h, -diff)\n        return len(heights) - 1\n`\n          },\n          {\n            language: 'Java',\n            content: `\npublic int furthestBuilding(int[] heights, int bricks, int ladders) {\n  if (heights.length < 1) {\n      return heights.length;\n  }\n  int needBrick = 0;\n\n  PriorityQueue<Integer> pq = new PriorityQueue();\n  for (int i = 1; i < heights.length; i++) {\n      int diff = heights[i] - heights[i - 1];\n      if (diff > 0) {\n          pq.offer(diff);\n          if (pq.size() > ladders) {\n              int brick = pq.poll();\n              needBrick += brick;\n          }\n          if (needBrick > bricks) {\n              return i - 1;\n          }\n      }\n  }\n  return heights.length - 1;\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.4.1',\n        codes: [\n          {\n            language: 'Python',\n            content: `\ndef dijkstra(graph, start, end):\n    # 堆里的数据都是 (cost, i) 的二元祖，其含义是“从 start 走到 i 的距离是 cost”。\n    heap = [(0, start)]\n    visited = set()\n    while heap:\n        (cost, u) = heapq.heappop(heap)\n        if u in visited:\n            continue\n        visited.add(u)\n        if u == end:\n            return cost\n        for v, c in graph[u]:\n            if v in visited:\n                continue\n            next = cost + c\n            heapq.heappush(heap, (next, v))\n    return -1\n`\n          },\n          {\n            language: 'Java',\n            content: `\n            \n            `\n          }\n        ]\n      },\n      {\n        title: '代码1.4.2',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def dijkstra(self, graph, start, end):\n        heap = [(0, start)]\n        visited = set()\n        while heap:\n            (cost, u) = heapq.heappop(heap)\n            if u in visited:\n                continue\n            visited.add(u)\n            if u == end:\n                return cost\n            for v, c in graph[u]:\n                if v in visited:\n                    continue\n                next = cost + c\n                heapq.heappush(heap, (next, v))\n        return -1\n    def networkDelayTime(self, times: List[List[int]], N: int, K: int) -> int:\n        graph = collections.defaultdict(list)\n        for fr, to, w in times:\n            graph[fr - 1].append((to - 1, w))\n        ans = -1\n        for to in range(N):\n            # 调用封装好的 dijkstra 方法\n            dist = self.dijkstra(graph, K - 1, to)\n            if dist == -1: return -1\n            ans = max(ans, dist)\n        return ans\n`\n          },\n          {\n            language: 'Java',\n            content: `\nPriorityQueue<Node> pq;\npublic int networkDelayTime(int[][] times, int n, int k) {\n    // 用邻接表构建图\n    List<int[]>[] graph = new List[n + 1];\n    for (int i = 0; i < graph.length; i++) {\n        graph[i] = new ArrayList();\n    }\n    for (int i = 0; i < times.length; i++) {\n        int[] edge = times[i];\n        graph[edge[0]].add(edge);\n    }\n\n    int dist,ans = -1;\n\n    for (int to = 1; to <= n; to++) {\n        dist = dijkstra(graph, k, to);\n        if (dist == -1) {\n            return -1;\n        }\n        ans = Math.max(ans, dist);\n    }\n    return ans;\n}\n\npublic int dijkstra(List<int[]>[] graph, int start, int end) {\n    Arrays.fill(cost, Integer.MAX_VALUE);\n    boolean visited[] = new boolean[graph.length];\n    cost[start] = 0;\n    pq = new PriorityQueue();\n    pq.offer(new Node(start, 0));\n\n    while (!pq.isEmpty()) {\n        //每次取出距离最近的节点\n        Node node = pq.poll();\n        if (visited[node.v]) {\n            continue;\n        }\n        visited[node.v] = true;\n        if (node.v == end) {\n            return node.cost;\n        }\n\n        for (int[] edge : graph[node.v]) {\n            int c = edge[2];\n            // 如果原点经过该条边到达目标节点 花销少于之前的到目标节点花销，那么更新\n            if (visited[edge[1]]) {\n                continue;\n            }\n            int next = c + node.cost;\n            // 把目标节点加入\n            pq.offer(new Node(edge[1], next));\n\n        }\n    }\n\n    return -1;\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.4.3',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def dijkstra(self, graph, start, end):\n        heap = [(0, start)]  # cost from start node,end node\n        dist = {}\n        while heap:\n            (cost, u) = heapq.heappop(heap)\n            if u in dist:\n                continue\n            dist[u] = cost\n            for v, c in graph[u]:\n                if v in dist:\n                    continue\n                next = cost + c\n                heapq.heappush(heap, (next, v))\n        return dist\n    def networkDelayTime(self, times: List[List[int]], N: int, K: int) -> int:\n        graph = collections.defaultdict(list)\n        for fr, to, w in times:\n            graph[fr - 1].append((to - 1, w))\n        ans = -1\n        dist = self.dijkstra(graph, K - 1, to)\n        return -1 if len(dist) != N else max(dist.values())\n`\n          },\n          {\n            language: 'Java',\n            content: `\n            int dist[];\nPriorityQueue<Node> pq;\n\npublic int networkDelayTime(int[][] times, int n, int k) {\n    // 用邻接表构建图\n    List<int[]>[] graph = new List[n + 1];\n    for (int i = 0; i < graph.length; i++) {\n        graph[i] = new ArrayList();\n    }\n    for (int i = 0; i < times.length; i++) {\n        int[] edge = times[i];\n        graph[edge[0]].add(edge);\n    }\n    return dijkstra(graph, k);\n\n}\n\n\npublic int[] dijkstra(List<int[]>[] graph, int start) {\n    dist = new int[graph.length];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    boolean visited[] = new boolean[graph.length];\n    dist[start] = 0;\n    pq = new PriorityQueue();\n    pq.offer(new Node(start, 0));\n\n    while (!pq.isEmpty()) {\n        //每次取出距离最近的节点\n        Node node = pq.poll();\n        if (visited[node.v]) {\n            continue;\n        }\n        visited[node.v] = true;\n        for (int[] edge : graph[node.v]) {\n            int c = edge[2];\n            // 如果原点经过该条边到达目标节点 花销少于之前的到目标节点花销，那么更新\n            if (visited[edge[1]]) {\n                continue;\n            }\n            int next = c + node.cost;\n            // 把目标节点加入\n            pq.offer(new Node(edge[1], next));\n\n        }\n    }\n\n    return dist;\n}\n\nclass Node implements Comparable<Node> {\n    int v;\n    int cost;\n\n    public Node(int v, int cost) {\n        this.v = v;\n        this.cost = cost;\n    }\n\n    @Override\n    public int compareTo(Node o) {\n        return this.cost - o.cost;\n    }\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.4.4',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    # 改造一下，增加参数 K，堆多携带一个 steps 即可\n    def dijkstra(self, graph, start, end, K):\n        heap = [(0, start, 0)]\n        visited = set()\n        while heap:\n            (cost, u, steps) = heapq.heappop(heap)\n            if u in visited:\n                continue\n            visited.add((u, steps))\n            if steps > K: continue\n            if u == end:\n                return cost\n            for v, c in graph[u]:\n                if (v, steps) in visited:\n                    continue\n                next = cost + c\n                heapq.heappush(heap, (next, v, steps + 1))\n        return -1\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\n        graph = collections.defaultdict(list)\n        for fr, to, price in flights:\n            graph[fr].append((to, price))\n            # 调用封装好的 dijkstra 方法\n        return self.dijkstra(graph, src, dst, K + 1)\n`\n          },\n          {\n            language: 'Java',\n            content: `\nPriorityQueue<Node> pq;\nint k;\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\n    k = K + 1;\n    // 用邻接表构建图\n    List<int[]>[] graph = new List[n];\n    for (int i = 0; i < graph.length; i++) {\n        graph[i] = new ArrayList();\n    }\n    for (int i = 0; i < flights.length; i++) {\n        int[] edge = flights[i];\n        graph[edge[0]].add(edge);\n    }\n    return dijkstra(graph, src, dst);\n}\n\n\npublic int dijkstra(List<int[]>[] graph, int start, int dst) {\n    int[] dist = new int[graph.length];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    Set visited = new HashSet();\n    pq = new PriorityQueue();\n    pq.offer(new Node(start, 0, +1));\n    while (!pq.isEmpty()) {\n        //每次取出距离最近的节点\n        Node node = pq.poll();\n        if (visited.contains(node)) {\n            continue;\n        }\n        visited.add(node);\n        if (node.step > k + 1) continue;\n        if (node.v == dst)\n            return node.cost;\n\n        for (int[] edge : graph[node.v]) {\n            int money = edge[2];\n            dist[edge[1]] = money + node.cost;\n            Node nextNode = new Node(edge[1], dist[edge[1]], node.step + 1);\n            if(visited.contains(nextNode)){\n                continue;\n            }\n                // 把目标节点加入\n            pq.offer(nextNode);\n        }\n    }\n    return -1;\n}\n\n\nclass Node implements Comparable<Node> {\n    int v;\n    int cost;\n    int step;\n\n    public Node(int v, int cost, int step) {\n        this.v = v;\n        this.cost = cost;\n        this.step = step;\n    }\n    @Override\n    public int compareTo(Node o) {\n        return this.cost - o.cost;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof Node){\n            return ((Node) obj).step==this.step&&((Node) obj).v==this.v;\n        }\n        return super.equals(obj);\n    }\n}\n`\n          }\n        ]\n      }\n    ]\n  }\n]\n"],"sourceRoot":""}