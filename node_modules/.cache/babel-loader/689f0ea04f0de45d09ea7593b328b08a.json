{"remainingRequest":"/Users/luxiaopeng/github/leetcode-pp/node_modules/babel-loader/lib/index.js!/Users/luxiaopeng/github/leetcode-pp/node_modules/eslint-loader/index.js??ref--13-0!/Users/luxiaopeng/github/leetcode-pp/src/views/Book.js","dependencies":[{"path":"/Users/luxiaopeng/github/leetcode-pp/src/views/Book.js","mtime":1648364288922},{"path":"/Users/luxiaopeng/github/leetcode-pp/node_modules/cache-loader/dist/cjs.js","mtime":1582876651155},{"path":"/Users/luxiaopeng/github/leetcode-pp/node_modules/babel-loader/lib/index.js","mtime":1614915260754},{"path":"/Users/luxiaopeng/github/leetcode-pp/node_modules/eslint-loader/index.js","mtime":1584094539526}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyogZXNsaW50LWRpc2FibGUgKi8KZXhwb3J0IGRlZmF1bHQgW3sKICAiaWQiOiAiMDEiLAogICJuYW1lIjogIuesrOS4gOeroCIsCiAgImxpc3QiOiBbewogICAgInRpdGxlIjogIuS7o+eggTEuMy4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJcbmludCBzdW0oaW50IG4pIHtcbiAgaW50IHJlcyA9IDA7XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgcmVzICs9IGk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGludCBzdW0oaW50IG4pIHtcbiAgICBpbnQgcmVzID0gMDtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgcmVzICs9IGk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkpzIiwKICAgICAgImNvbnRlbnQiOiAiZnVuY3Rpb24gc3VtKG4pIHtcbiAgbGV0IHJlcyA9IDBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICByZXMgKz0gaVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJkZWYgc3VtKG46IGludCkgLT4gaW50OlxuICAgIHJlcyA9IDBcbiAgICBmb3IgaSBpbiByYW5nZSgxLCBuICsgMSk6XG4gICAgICAgIHJlcyArPSBpXG4gICAgcmV0dXJuIHJlc1xuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExLjMuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICB2ZWN0b3I8aW50PiB0d29TdW0odmVjdG9yPGludD4gJm51bXMsIGludCB0YXJnZXQpIHtcblxuICAgIHVub3JkZXJlZF9tYXA8aW50LCBpbnQ+IG1hcHBlcjtcblxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtcy5zaXplKCk7IGkrKykge1xuICAgICAgaWYgKG1hcHBlci5maW5kKHRhcmdldCAtIG51bXNbaV0pICE9IG1hcHBlci5lbmQoKSlcbiAgICAgICAgcmV0dXJuIHttYXBwZXJbdGFyZ2V0IC0gbnVtc1tpXV0sIGl9O1xuXG4gICAgICBtYXBwZXJbbnVtc1tpXV0gPSBpO1xuICAgIH1cbiAgICByZXR1cm4ge307XG4gIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBpbnRbXSB0d29TdW0oaW50W10gbnVtcywgaW50IHRhcmdldCkge1xuICAgIE1hcDxJbnRlZ2VyLCBJbnRlZ2VyPiBtYXBwZXIgPSBuZXcgSGFzaE1hcDw+KCk7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobWFwcGVyLmNvbnRhaW5zS2V5KHRhcmdldCAtIG51bXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgaW50W10ge21hcHBlci5nZXQodGFyZ2V0IC0gbnVtc1tpXSksIGl9O1xuICAgICAgfVxuICAgICAgbWFwcGVyLnB1dChudW1zW2ldLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBpbnRbXSB7fTtcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKcyIsCiAgICAgICJjb250ZW50IjogIi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gbnVtc1xuICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFxuICogQHJldHVybiB7bnVtYmVyW119XG4gKi9cbmNvbnN0IHR3b1N1bSA9IGZ1bmN0aW9uKG51bXMsIHRhcmdldCkge1xuICBjb25zdCBuID0gbnVtcy5sZW5ndGhcbiAgY29uc3QgbWFwcGVyID0ge31cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBpZiAobWFwcGVyW3RhcmdldCAtIG51bXNbaV1dICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gW21hcHBlclt0YXJnZXQgLSBudW1zW2ldXSwgaV1cbiAgICBtYXBwZXJbbnVtc1tpXV0gPSBpXG4gIH1cbiAgcmV0dXJuIFtdXG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHR3b1N1bShzZWxmLCBudW1zOiBMaXN0W2ludF0sIHRhcmdldDogaW50KSAtPiBMaXN0W2ludF06XG4gICAgICAgIG4gPSBsZW4obnVtcylcbiAgICAgICAgbWFwcGVyID0ge31cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2Uobik6XG4gICAgICAgICAgICBpZiB0YXJnZXQgLSBudW1zW2ldIGluIG1hcHBlcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW21hcHBlclt0YXJnZXQgLSBudW1zW2ldXSwgaV1cbiAgICAgICAgICAgIGVsc2U6XG4gICAgICAgICAgICAgICAgbWFwcGVyW251bXNbaV1dID0gaVxuXG4gICAgICAgIHJldHVybiBbXVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExLjMuMyIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICB2ZWN0b3I8aW50PiBkYWlseVRlbXBlcmF0dXJlcyh2ZWN0b3I8aW50PiAmVCkge1xuICAgIHN0YWNrPGludD4gc3Q7XG4gICAgdmVjdG9yPGludD4gYW5zKFQuc2l6ZSgpLCAwKTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IFQuc2l6ZSgpOyBpKyspIHtcbiAgICAgIHdoaWxlICghc3QuZW1wdHkoKSAmJiBUW2ldID4gVFtzdC50b3AoKV0pIHtcbiAgICAgICAgaW50IHRvcCA9IHN0LnRvcCgpO1xuICAgICAgICBzdC5wb3AoKTtcbiAgICAgICAgYW5zW3RvcF0gPSBpIC0gdG9wO1xuICAgICAgfVxuICAgICAgc3QucHVzaChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFucztcbiAgfVxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkpzIiwKICAgICAgImNvbnRlbnQiOiAiLyoqXG4gKiBAcGFyYW0ge251bWJlcltdfSBUXG4gKiBAcmV0dXJuIHtudW1iZXJbXX1cbiAqL1xuY29uc3QgZGFpbHlUZW1wZXJhdHVyZXMgPSBmdW5jdGlvbihUKSB7XG4gIGNvbnN0IHN0YWNrID0gW11cbiAgY29uc3QgYW5zID0gW11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IFQubGVuZ3RoOyBpKyspIHtcbiAgICBhbnNbaV0gPSAwXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCAhPT0gMCAmJiBUW2ldID4gVFtzdGFja1tzdGFjay5sZW5ndGggLSAxXV0pIHtcbiAgICAgIGNvbnN0IHBlZWsgPSBzdGFjay5wb3AoKVxuICAgICAgYW5zW3BlZWtdID0gaSAtIHBlZWtcbiAgICB9XG4gICAgc3RhY2sucHVzaChpKVxuICB9XG5cbiAgcmV0dXJuIGFuc1xufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBkYWlseVRlbXBlcmF0dXJlcyhzZWxmLCBUOiBMaXN0W2ludF0pIC0+IExpc3RbaW50XTpcbiAgICAgICAgc3RhY2sgPSBbXVxuICAgICAgICBhbnMgPSBbMF0gKiBsZW4oVClcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UobGVuKFQpKTpcbiAgICAgICAgICAgIHdoaWxlIHN0YWNrIGFuZCBUW2ldID4gVFtzdGFja1stMV1dOlxuICAgICAgICAgICAgICAgIHBlZWsgPSBzdGFjay5wb3AoLTEpXG4gICAgICAgICAgICAgICAgYW5zW3BlZWtdID0gaSAtIHBlZWtcbiAgICAgICAgICAgIHN0YWNrLmFwcGVuZChpKVxuICAgICAgICByZXR1cm4gYW5zXG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBpbnRbXSBkYWlseVRlbXBlcmF0dXJlcyhpbnRbXSBUKSB7XG4gICAgU3RhY2s8SW50ZWdlcj4gc3RhY2sgPSBuZXcgU3RhY2s8SW50ZWdlcj4oKTtcbiAgICBpbnRbXSBhbnMgPSBuZXcgaW50W1QubGVuZ3RoXTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IFQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdoaWxlICghc3RhY2suZW1wdHkoKSAmJiBUW2ldID4gVFtzdGFjay5wZWVrKCldKSB7XG4gICAgICAgIGludCB0b3AgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgYW5zW3RvcF0gPSBpIC0gdG9wO1xuICAgICAgfVxuICAgICAgc3RhY2sucHVzaChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFucztcbiAgfVxufVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExLjMuNCIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiXG5pbnQgYmluYXJ5U2VhcmNoKHZlY3RvcjxpbnQ+JiBudW1zLCBpbnQgdGFyZ2V0KXtcbiAgaWYobnVtcy5zaXplKCkgPT0gMClcbiAgICByZXR1cm4gLTE7XG5cbiAgaW50IGxlZnQgPSAwLCByaWdodCA9IG51bXMuc2l6ZSgpIC0gMTtcbiAgd2hpbGUobGVmdCA8PSByaWdodCl7XG4gICAgaW50IG1pZCA9IGxlZnQgKyAoKHJpZ2h0IC0gbGVmdCkgPj4gMSk7XG4gICAgaWYobnVtc1ttaWRdID09IHRhcmdldCl7IHJldHVybiBtaWQ7IH1cbiAgICAvLyDmkJzntKLljLrpl7Tlj5jkuLogW21pZCsxLCByaWdodF1cbiAgICBlbHNlIGlmKG51bXNbbWlkXSA8IHRhcmdldClcbiAgbGVmdCA9IG1pZCArIDE7XG4gICAgLy8g5pCc57Si5Yy66Ze05Y+Y5Li6IFtsZWZ0LCBtaWQgLSAxXVxuICAgIGVsc2VcbiAgcmlnaHQgPSBtaWQgLSAxO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbiAgICAgICAgICBcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJwdWJsaWMgaW50IGJpbmFyeVNlYXJjaChpbnRbXSBudW1zLCBpbnQgdGFyZ2V0KSB7XG4gICAgLy8g5bem5Y+z6YO96Zet5ZCI55qE5Yy66Ze0IFtsLCByXVxuICAgIGludCBsZWZ0ID0gMDtcbiAgICBpbnQgcmlnaHQgPSBudW1zLmxlbmd0aCAtIDE7XG5cbiAgICB3aGlsZShsZWZ0IDw9IHJpZ2h0KSB7XG4gICAgICAgIGludCBtaWQgPSBsZWZ0ICsgKHJpZ2h0IC0gbGVmdCkgLyAyO1xuICAgICAgICBpZihudW1zW21pZF0gPT0gdGFyZ2V0KVxuICAgICAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgICAgaWYgKG51bXNbbWlkXSA8IHRhcmdldClcbiAgICAgICAgICAgICAgICAvLyDmkJzntKLljLrpl7Tlj5jkuLogW21pZCsxLCByaWdodF1cbiAgICAgICAgICAgIGxlZnQgPSBtaWQgKyAxO1xuICAgICAgICBpZiAobnVtc1ttaWRdID4gdGFyZ2V0KVxuICAgICAgICAgICAgLy8g5pCc57Si5Yy66Ze05Y+Y5Li6IFtsZWZ0LCBtaWQgLSAxXVxuICAgICAgICAgICAgcmlnaHQgPSBtaWQgLSAxO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKcyIsCiAgICAgICJjb250ZW50IjogImZ1bmN0aW9uIGJpbmFyeVNlYXJjaChudW1zLCB0YXJnZXQpIHtcbiAgbGV0IGxlZnQgPSAwXG4gIGxldCByaWdodCA9IG51bXMubGVuZ3RoIC0gMVxuICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IobGVmdCArIChyaWdodCAtIGxlZnQpIC8gMilcbiAgICBpZiAobnVtc1ttaWRdID09IHRhcmdldCkgcmV0dXJuIG1pZFxuICAgIGlmIChudW1zW21pZF0gPCB0YXJnZXQpXG4gICAgICAvLyDmkJzntKLljLrpl7Tlj5jkuLogW21pZCsxLCByaWdodF1cbiAgICAgIGxlZnQgPSBtaWQgKyAxXG4gICAgaWYgKG51bXNbbWlkXSA+IHRhcmdldClcbiAgICAgIC8vIOaQnOe0ouWMuumXtOWPmOS4uiBbbGVmdCwgbWlkIC0gMV1cbiAgICAgIHJpZ2h0ID0gbWlkIC0gMVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImRlZiBiaW5hcnlTZWFyY2gobnVtcywgdGFyZ2V0KTpcbiAgICAjIOW3puWPs+mDvemXreWQiOeahOWMuumXtCBbbCwgcl1cbiAgICBsLCByID0gMCwgbGVuKG51bXMpIC0gMVxuICAgIHdoaWxlIGwgPD0gcjpcbiAgICAgICAgbWlkID0gKGxlZnQgKyByaWdodCkgPj4gMVxuICAgICAgICBpZiBudW1zW21pZF0gPT0gdGFyZ2V0OlxuICAgICAgICAgICAgcmV0dXJuIG1pZFxuICAgICAgICAjIOaQnOe0ouWMuumXtOWPmOS4uiBbbWlkKzEsIHJpZ2h0XVxuICAgICAgICBpZiBudW1zW21pZF0gPCB0YXJnZXQ6XG4gICAgICAgICAgICBsID0gbWlkICsgMVxuICAgICAgICAjIOaQnOe0ouWMuumXtOWPmOS4uiBbbGVmdCwgbWlkIC0gMV1cbiAgICAgICAgaWYgbnVtc1ttaWRdID4gdGFyZ2V0OlxuICAgICAgICAgICAgciA9IG1pZCAtIDFcbiAgICByZXR1cm4gLTFcbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTEuMy41IiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIGludCBmaWJvbmFjY2koaW50IG4pIHtcbiAgICBpZiAobiA8IDIpIHtcbiAgICAgIHJldHVybiBuXG4gICAgfVxuICAgIHJldHVybiBmaWJvbmFjY2kobiAtIDEpICsgZmlib25hY2NpKG4gLSAyKTtcbiAgfVxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBpbnQgZmlib25hY2NpKGludCBuKSB7XG4gICAgaWYgKG4gPCAyKSByZXR1cm4gbjtcbiAgICByZXR1cm4gZmlib25hY2NpKG4gLSAxKSArIGZpYm9uYWNjaShuIC0gMik7XG4gIH1cbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSnMiLAogICAgICAiY29udGVudCI6ICJmdW5jdGlvbiBmaWJvbmFjY2kobikge1xuICBpZiAobiA8IDIpIHJldHVybiBuXG4gIHJldHVybiBmaWJvbmFjY2kobiAtIDEpICsgZmlib25hY2NpKG4gLSAyKVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImRlZiBmaWJvbmFjY2kobjogaW50KSAtPiBpbnQ6XG4gICAgaWYgbiA8IDI6XG4gICAgICAgIHJldHVybiBuXG4gICAgcmV0dXJuIGZpYm9uYWNjaShuIC0gMSkgKyBmaWJvbmFjY2kobiAtIDIpXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTEuMy42IiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIHZlY3Rvcjx2ZWN0b3I8aW50Pj4gYW5zO1xuICB2b2lkIGRmcyhpbnQgaWR4LCB2ZWN0b3I8aW50PiBwYXRoLCB2ZWN0b3I8aW50PiBudW1zLCBpbnQgbixcbiAgICAgICAgICAgdmVjdG9yPGJvb2w+IHZpc2l0ZWQpIHtcbiAgICAvLyDnu5PmnZ/mnaHku7ZcbiAgICAvLyAxLiDmib7liLDop6NcbiAgICBpZiAocGF0aC5zaXplKCkgPT0gbikge1xuICAgICAgdmVjdG9yPGludD4gdGVtcChwYXRoLnNpemUoKSk7XG4gICAgICBzdGQ6OmNvcHkocGF0aC5iZWdpbigpLCBwYXRoLmVuZCgpLCB0ZW1wLmJlZ2luKCkpO1xuICAgICAgYW5zLnB1c2hfYmFjayh0ZW1wKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyAyLiDmkJzntKLlrozmr5VcbiAgICBpZiAoaWR4ID09IG4pXG4gICAgICByZXR1cm47XG5cbiAgICAvLyDogIPomZHlj6/og73nmoTop6PvvIzov5vlhaXkuIvkuIDlsYLpgJLlvZJcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaW50IG51bSA9IG51bXNbaV07XG4gICAgICAvLyDpnZ7ms5Xop6Plv73nlaVcbiAgICAgIGlmICh2aXNpdGVkW2ldKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIC8vIOabtOaWsOeKtuaAgVxuICAgICAgdmlzaXRlZFtpXSA9IHRydWU7XG4gICAgICBwYXRoLnB1c2hfYmFjayhudW0pO1xuICAgICAgZGZzKGlkeCArIDEsIHBhdGgsIG51bXMsIG4sIHZpc2l0ZWQpO1xuICAgICAgLy8g5oGi5aSN54q25oCBXG4gICAgICBwYXRoLnBvcF9iYWNrKCk7XG4gICAgICB2aXNpdGVkW2ldID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHZlY3Rvcjx2ZWN0b3I8aW50Pj4gcGVybXV0ZSh2ZWN0b3I8aW50PiAmbnVtcykge1xuICAgIHZlY3RvcjxpbnQ+IHBhdGg7XG4gICAgdmVjdG9yPGJvb2w+IHZpc2l0ZWQobnVtcy5zaXplKCksIGZhbHNlKTtcbiAgICBpbnQgbiA9IG51bXMuc2l6ZSgpO1xuICAgIGRmcygwLCBwYXRoLCBudW1zLCBuLCB2aXNpdGVkKTtcbiAgICByZXR1cm4gYW5zO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICBwcml2YXRlIHZvaWQgYmFja3RyYWNrKFxuICAgICAgTGlzdDxMaXN0PEludGVnZXI+PiBhbnMsIEFycmF5TGlzdDxJbnRlZ2VyPiB0ZW1wTGlzdCwgQXJyYXlMaXN0PEludGVnZXI+IG51bXMpIHtcbiAgICBpZiAodGVtcExpc3Quc2l6ZSgpID09IG51bXMuc2l6ZSgpKSB7XG4gICAgICBhbnMuYWRkKG5ldyBBcnJheUxpc3Q8SW50ZWdlcj4odGVtcExpc3QpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBudW1zLnNpemUoKTsgaSsrKSB7XG4gICAgICBpZiAodGVtcExpc3QuY29udGFpbnMobnVtcy5nZXQoaSkpKSBjb250aW51ZTtcbiAgICAgIHRlbXBMaXN0LmFkZChudW1zLmdldChpKSk7XG4gICAgICBiYWNrdHJhY2soYW5zLCB0ZW1wTGlzdCwgbnVtcyk7XG4gICAgICB0ZW1wTGlzdC5yZW1vdmUodGVtcExpc3Quc2l6ZSgpIC0gMSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIExpc3Q8TGlzdDxJbnRlZ2VyPj4gcGVybXV0ZShpbnRbXSBudW1zKSB7XG4gICAgTGlzdDxMaXN0PEludGVnZXI+PiBhbnMgPSBuZXcgTGlua2VkTGlzdCgpO1xuICAgIEFycmF5TGlzdDxJbnRlZ2VyPiB0ZW1wTGlzdCA9IG5ldyBBcnJheUxpc3Q8SW50ZWdlcj4oKTtcbiAgICBBcnJheUxpc3Q8SW50ZWdlcj4gYW51bXMgPSBuZXcgQXJyYXlMaXN0PEludGVnZXI+KCk7XG4gICAgZm9yIChpbnQgbnVtIDogbnVtcykgYW51bXMuYWRkKG51bSk7XG4gICAgYmFja3RyYWNrKGFucywgdGVtcExpc3QsIGFudW1zKTtcbiAgICByZXR1cm4gYW5zO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkpzIiwKICAgICAgImNvbnRlbnQiOiAiZnVuY3Rpb24gYmFja3RyYWNrKGxpc3QsIHRlbXBMaXN0LCBudW1zKSB7XG4gIGlmICh0ZW1wTGlzdC5sZW5ndGggPT09IG51bXMubGVuZ3RoKSByZXR1cm4gbGlzdC5wdXNoKFsuLi50ZW1wTGlzdF0pXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0ZW1wTGlzdC5pbmNsdWRlcyhudW1zW2ldKSkgY29udGludWVcbiAgICB0ZW1wTGlzdC5wdXNoKG51bXNbaV0pXG4gICAgYmFja3RyYWNrKGxpc3QsIHRlbXBMaXN0LCBudW1zKVxuICAgIHRlbXBMaXN0LnBvcCgpXG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gbnVtc1xuICogQHJldHVybiB7bnVtYmVyW11bXX1cbiAqL1xuY29uc3QgcGVybXV0ZSA9IGZ1bmN0aW9uKG51bXMpIHtcbiAgY29uc3QgbGlzdCA9IFtdXG4gIGJhY2t0cmFjayhsaXN0LCBbXSwgbnVtcylcbiAgcmV0dXJuIGxpc3Rcbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgcGVybXV0ZShzZWxmLCBudW1zOiBMaXN0W2ludF0pIC0+IExpc3RbTGlzdFtpbnRdXTpcbiAgICAgICAgZGVmIGRmcyhpZHg6IGludCwgcGF0aDogTGlzdFtpbnRdKSAtPiBOb25lOlxuICAgICAgICAgICAgIyDnu5PmnZ/mnaHku7ZcbiAgICAgICAgICAgICMgMS4g5om+5Yiw6KejXG4gICAgICAgICAgICBpZiBsZW4ocGF0aCkgPT0gbjpcbiAgICAgICAgICAgICAgICBhbnMuYXBwZW5kKHBhdGguY29weSgpKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgIyAyLiDmkJzntKLlrozmr5VcbiAgICAgICAgICAgIGlmIGlkeCA9PSBuOlxuICAgICAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgICAgICAjIOiAg+iZkeWPr+iDveeahOino++8jOi/m+WFpeS4i+S4gOWxgumAkuW9klxuICAgICAgICAgICAgZm9yIG51bSBpbiBudW1zOlxuICAgICAgICAgICAgICAgICMg6Z2e5rOV6Kej5b+955WlXG4gICAgICAgICAgICAgICAgaWYgbnVtIGluIHZpc2l0ZWQ6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgIyDmm7TmlrDnirbmgIFcbiAgICAgICAgICAgICAgICB2aXNpdGVkLmFkZChudW0pXG4gICAgICAgICAgICAgICAgcGF0aC5hcHBlbmQobnVtKVxuICAgICAgICAgICAgICAgIGRmcyhpZHggKyAxLCBwYXRoKVxuICAgICAgICAgICAgICAgICMg5oGi5aSN54q25oCBXG4gICAgICAgICAgICAgICAgcGF0aC5wb3AoKVxuICAgICAgICAgICAgICAgIHZpc2l0ZWQucmVtb3ZlKG51bSlcblxuICAgICAgICBhbnMgPSBbXVxuICAgICAgICB2aXNpdGVkID0gc2V0KClcbiAgICAgICAgbiA9IGxlbihudW1zKVxuICAgICAgICBkZnMoMCwgW10pXG4gICAgICAgIHJldHVybiBhbnNcblxuIgogICAgfV0KICB9XQp9LCB7CiAgImlkIjogIjAyIiwKICAibmFtZSI6ICLnrKzkuoznq6AiLAogICJsaXN0IjogW3sKICAgICJ0aXRsZSI6ICLku6PnoIEyLjEuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICB2ZWN0b3I8aW50PiB0d29TdW0odmVjdG9yPGludD4gJm51bXMsIGludCB0YXJnZXQpIHtcbiAgICBpbnQgbiA9IG51bXMuc2l6ZSgpO1xuICAgIHNvcnQobnVtcy5iZWdpbigpLCBudW1zLmVuZCgpKTtcbiAgICBpbnQgbCA9IDA7XG4gICAgaW50IHIgPSBuIC0gMTtcbiAgICB3aGlsZSAobCA8IHIpIHtcbiAgICAgIGlmIChudW1zW2xdICsgbnVtc1tyXSA8IHRhcmdldCkge1xuICAgICAgICBsICs9IDE7XG4gICAgICB9IGVsc2UgaWYgKG51bXNbbF0gKyBudW1zW3JdID4gdGFyZ2V0KSB7XG4gICAgICAgIHIgLT0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7bCwgcn07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7fTtcbiAgfVxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBpbnRbXSB0d29TdW0oaW50W10gbnVtcywgaW50IHRhcmdldCkge1xuICAgIGludCBuID0gbnVtcy5sZW5ndGg7XG4gICAgQXJyYXlzLnNvcnQobnVtcyk7XG4gICAgaW50IGwgPSAwO1xuICAgIGludCByID0gbiAtIDE7XG4gICAgd2hpbGUgKGwgPCByKSB7XG4gICAgICBpZiAobnVtc1tsXSArIG51bXNbcl0gPCB0YXJnZXQpIHtcbiAgICAgICAgbCArPSAxO1xuICAgICAgfSBlbHNlIGlmIChudW1zW2xdICsgbnVtc1tyXSA+IHRhcmdldCkge1xuICAgICAgICByIC09IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IGludFtdIHtsLCByfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBpbnRbXSB7fTtcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKcyIsCiAgICAgICJjb250ZW50IjogIi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gbnVtc1xuICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFxuICogQHJldHVybiB7bnVtYmVyW119XG4gKi9cbmNvbnN0IHR3b1N1bSA9IGZ1bmN0aW9uKG51bXMsIHRhcmdldCkge1xuICBjb25zdCBuID0gbnVtcy5sZW5ndGhcbiAgbnVtcy5zb3J0KChhLCBiKSA9PiBhIC0gYilcbiAgbGV0IGwgPSAwXG4gIGxldCByID0gbiAtIDFcbiAgd2hpbGUgKGwgPCByKSB7XG4gICAgaWYgKG51bXNbbF0gKyBudW1zW3JdIDwgdGFyZ2V0KSB7XG4gICAgICBsICs9IDFcbiAgICB9IGVsc2UgaWYgKG51bXNbbF0gKyBudW1zW3JdID4gdGFyZ2V0KSB7XG4gICAgICByIC09IDFcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtsLCByXVxuICAgIH1cbiAgfVxuICByZXR1cm4gW11cbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgdHdvU3VtKHNlbGYsIG51bXM6IExpc3RbaW50XSwgdGFyZ2V0OiBpbnQpIC0+IExpc3RbaW50XTpcbiAgICAgICAgbiA9IGxlbihudW1zKVxuICAgICAgICBudW1zLnNvcnQoKVxuICAgICAgICBsID0gMFxuICAgICAgICByID0gbiAtIDFcbiAgICAgICAgd2hpbGUgbCA8IHI6XG4gICAgICAgICAgICBpZiBudW1zW2xdICsgbnVtc1tyXSA8IHRhcmdldDpcbiAgICAgICAgICAgICAgICBsICs9IDFcbiAgICAgICAgICAgIGVsaWYgbnVtc1tsXSArIG51bXNbcl0gPiB0YXJnZXQ6XG4gICAgICAgICAgICAgICAgciAtPSAxXG4gICAgICAgICAgICBlbHNlOlxuICAgICAgICAgICAgICAgIHJldHVybiBbbCwgcl1cbiAgICAgICAgcmV0dXJuIFtdXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTIuMS4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIHZlY3RvcjxpbnQ+IHR3b1N1bSh2ZWN0b3I8aW50PiAmbnVtcywgaW50IHRhcmdldCkge1xuXG4gICAgdW5vcmRlcmVkX21hcDxpbnQsIGludD4gbWFwcGVyO1xuXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBudW1zLnNpemUoKTsgaSsrKSB7XG4gICAgICBpZiAobWFwcGVyLmZpbmQodGFyZ2V0IC0gbnVtc1tpXSkgIT0gbWFwcGVyLmVuZCgpKVxuICAgICAgICByZXR1cm4ge21hcHBlclt0YXJnZXQgLSBudW1zW2ldXSwgaX07XG5cbiAgICAgIG1hcHBlcltudW1zW2ldXSA9IGk7XG4gICAgfVxuICAgIHJldHVybiB7fTtcbiAgfVxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBpbnRbXSB0d29TdW0oaW50W10gbnVtcywgaW50IHRhcmdldCkge1xuICAgIE1hcDxJbnRlZ2VyLCBJbnRlZ2VyPiBtYXBwZXIgPSBuZXcgSGFzaE1hcDw+KCk7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobWFwcGVyLmNvbnRhaW5zS2V5KHRhcmdldCAtIG51bXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgaW50W10ge21hcHBlci5nZXQodGFyZ2V0IC0gbnVtc1tpXSksIGl9O1xuICAgICAgfVxuICAgICAgbWFwcGVyLnB1dChudW1zW2ldLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBpbnRbXSB7fTtcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKcyIsCiAgICAgICJjb250ZW50IjogIi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gbnVtc1xuICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFxuICogQHJldHVybiB7bnVtYmVyW119XG4gKi9cbmNvbnN0IHR3b1N1bSA9IGZ1bmN0aW9uKG51bXMsIHRhcmdldCkge1xuICBjb25zdCBuID0gbnVtcy5sZW5ndGhcbiAgY29uc3QgbWFwcGVyID0ge31cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBpZiAobWFwcGVyW3RhcmdldCAtIG51bXNbaV1dICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gW21hcHBlclt0YXJnZXQgLSBudW1zW2ldXSwgaV1cbiAgICBtYXBwZXJbbnVtc1tpXV0gPSBpXG4gIH1cbiAgcmV0dXJuIFtdXG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHR3b1N1bShzZWxmLCBudW1zOiBMaXN0W2ludF0sIHRhcmdldDogaW50KSAtPiBMaXN0W2ludF06XG4gICAgICAgIG4gPSBsZW4obnVtcylcbiAgICAgICAgbWFwcGVyID0ge31cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2Uobik6XG4gICAgICAgICAgICBpZiB0YXJnZXQgLSBudW1zW2ldIGluIG1hcHBlcjpcbiAgICAgICAgICAgICAgICAjIOWunumZheS4iui/memHjOi/lOWbnueahOe0ouW8lemhuuW6j+aYr+S4jemHjeimgeeahFxuICAgICAgICAgICAgICAgICMg5Y2z6L+U5ZueIFtpLCBtYXBwZXJbdGFyZ2V0IC0gbnVtc1tpXV1dIOS5n+aYr+ato+ehrueahFxuICAgICAgICAgICAgICAgIHJldHVybiBbbWFwcGVyW3RhcmdldCAtIG51bXNbaV1dLCBpXVxuICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICBtYXBwZXJbbnVtc1tpXV0gPSBpXG5cbiAgICAgICAgcmV0dXJuIFtdXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTIuMi4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIHZlY3Rvcjx2ZWN0b3I8aW50Pj4gdGhyZWVTdW0odmVjdG9yPGludD4gJm51bXMpIHtcbiAgICBpbnQgbiA9IG51bXMuc2l6ZSgpO1xuICAgIHNvcnQobnVtcy5iZWdpbigpLCBudW1zLmVuZCgpKTtcbiAgICB2ZWN0b3I8dmVjdG9yPGludD4+IHJlcztcblxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbiAtIDI7IGkrKykge1xuICAgICAgaWYgKGkgPiAwICYmIG51bXNbaV0gPT0gbnVtc1tpIC0gMV0pXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaW50IGwgPSBpICsgMTtcbiAgICAgIGludCByID0gbiAtIDE7XG4gICAgICB3aGlsZSAobCA8IHIpIHtcbiAgICAgICAgaWYgKG51bXNbaV0gKyBudW1zW2xdICsgbnVtc1tyXSA8IDApIHtcbiAgICAgICAgICBsICs9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtc1tpXSArIG51bXNbbF0gKyBudW1zW3JdID4gMCkge1xuICAgICAgICAgIHIgLT0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMucHVzaF9iYWNrKHZlY3RvcjxpbnQ+e251bXNbaV0sIG51bXMuYXQobCksIG51bXMuYXQocil9KTtcbiAgICAgICAgICB3aGlsZSAobCA8IHIgJiYgbnVtc1tsXSA9PSBudW1zW2wgKyAxXSkge1xuICAgICAgICAgICAgbCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAobCA8IHIgJiYgbnVtc1tyXSA9PSBudW1zW3IgLSAxXSkge1xuICAgICAgICAgICAgciAtPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsICs9IDE7XG4gICAgICAgICAgciAtPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICBwdWJsaWMgTGlzdDxMaXN0PEludGVnZXI+PiB0aHJlZVN1bShpbnRbXSBudW1zKSB7XG4gICAgaW50IG4gPSBudW1zLmxlbmd0aDtcbiAgICBBcnJheXMuc29ydChudW1zKTtcbiAgICBMaXN0PExpc3Q8SW50ZWdlcj4+IHJlcyA9IG5ldyBBcnJheUxpc3Q8PigpO1xuXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuIC0gMjsgaSsrKSB7XG4gICAgICBpZiAoaSA+IDAgJiYgbnVtc1tpXSA9PSBudW1zW2kgLSAxXSkgY29udGludWU7XG4gICAgICBpbnQgbCA9IGkgKyAxO1xuICAgICAgaW50IHIgPSBuIC0gMTtcbiAgICAgIHdoaWxlIChsIDwgcikge1xuICAgICAgICBpZiAobnVtc1tpXSArIG51bXNbbF0gKyBudW1zW3JdIDwgMCkge1xuICAgICAgICAgIGwgKz0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChudW1zW2ldICsgbnVtc1tsXSArIG51bXNbcl0gPiAwKSB7XG4gICAgICAgICAgciAtPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcy5hZGQobmV3IEFycmF5TGlzdDxJbnRlZ2VyPihBcnJheXMuYXNMaXN0KG51bXNbaV0sIG51bXNbbF0sIG51bXNbcl0pKSk7XG4gICAgICAgICAgd2hpbGUgKGwgPCByICYmIG51bXNbbF0gPT0gbnVtc1tsICsgMV0pIHtcbiAgICAgICAgICAgIGwgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKGwgPCByICYmIG51bXNbcl0gPT0gbnVtc1tyIC0gMV0pIHtcbiAgICAgICAgICAgIHIgLT0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbCArPSAxO1xuICAgICAgICAgIHIgLT0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkpzIiwKICAgICAgImNvbnRlbnQiOiAiLyoqXG4gKiBAcGFyYW0ge251bWJlcltdfSBudW1zXG4gKiBAcmV0dXJuIHtudW1iZXJbXVtdfVxuICovXG5jb25zdCB0aHJlZVN1bSA9IGZ1bmN0aW9uKG51bXMpIHtcbiAgY29uc3QgbiA9IG51bXMubGVuZ3RoXG4gIG51bXMuc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gIGNvbnN0IHJlcyA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuIC0gMjsgaSsrKSB7XG4gICAgaWYgKGkgPiAwICYmIG51bXNbaV0gPT0gbnVtc1tpIC0gMV0pIGNvbnRpbnVlXG4gICAgbGV0IGwgPSBpICsgMVxuICAgIGxldCByID0gbiAtIDFcbiAgICB3aGlsZSAobCA8IHIpIHtcbiAgICAgIGlmIChudW1zW2ldICsgbnVtc1tsXSArIG51bXNbcl0gPCAwKSB7XG4gICAgICAgIGwgKz0gMVxuICAgICAgfSBlbHNlIGlmIChudW1zW2ldICsgbnVtc1tsXSArIG51bXNbcl0gPiAwKSB7XG4gICAgICAgIHIgLT0gMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzLnB1c2goW251bXNbaV0sIG51bXNbbF0sIG51bXNbcl1dKVxuICAgICAgICB3aGlsZSAobCA8IHIgJiYgbnVtc1tsXSA9PSBudW1zW2wgKyAxXSkge1xuICAgICAgICAgIGwgKz0gMVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsIDwgciAmJiBudW1zW3JdID09IG51bXNbciAtIDFdKSB7XG4gICAgICAgICAgciAtPSAxXG4gICAgICAgIH1cbiAgICAgICAgbCArPSAxXG4gICAgICAgIHIgLT0gMVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHRocmVlU3VtKHNlbGYsIG51bXM6IExpc3RbaW50XSkgLT4gTGlzdFtMaXN0W2ludF1dOlxuICAgICAgICBuID0gbGVuKG51bXMpXG4gICAgICAgIG51bXMuc29ydCgpXG4gICAgICAgIHJlcyA9IFtdXG5cbiAgICAgICAgIyDopoHmib7liLDkuInkuKrmlbDlrZfvvIzlm6DmraTlj6rpnIDopoHmib7liLDlgJLmlbAgbi0zIOS4quaVsOWtl+WNs+WPr1xuICAgICAgICBmb3IgaSBpbiByYW5nZShuIC0gMik6XG4gICAgICAgICAgICAjIOWOu+mHjVxuICAgICAgICAgICAgaWYgaSA+IDAgYW5kIG51bXNbaV0gPT0gbnVtc1tpIC0gMV06XG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICMg5Zu65a6aIGnvvIzlr7vmib4gbCDlkowgciDvvIzkvb/nlKjlj4zmjIfpkojms5VcbiAgICAgICAgICAgIGwgPSBpICsgMVxuICAgICAgICAgICAgciA9IG4gLSAxXG4gICAgICAgICAgICB3aGlsZSBsIDwgcjpcbiAgICAgICAgICAgICAgICBpZiBudW1zW2ldICsgbnVtc1tsXSArIG51bXNbcl0gPCAwOlxuICAgICAgICAgICAgICAgICAgICBsICs9IDFcbiAgICAgICAgICAgICAgICBlbGlmIG51bXNbaV0gKyBudW1zW2xdICsgbnVtc1tyXSA+IDA6XG4gICAgICAgICAgICAgICAgICAgIHIgLT0gMVxuICAgICAgICAgICAgICAgIGVsc2U6XG4gICAgICAgICAgICAgICAgICAgIHJlcy5hcHBlbmQoW251bXNbaV0sIG51bXNbbF0sIG51bXNbcl1dKVxuICAgICAgICAgICAgICAgICAgICAjIOWOu+mHjVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSBsIDwgciBhbmQgbnVtc1tsXSA9PSBudW1zW2wgKyAxXTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgKz0gMVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSBsIDwgciBhbmQgbnVtc1tyXSA9PSBudW1zW3IgLSAxXTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgLT0gMVxuICAgICAgICAgICAgICAgICAgICBsICs9IDFcbiAgICAgICAgICAgICAgICAgICAgciAtPSAxXG5cbiAgICAgICAgcmV0dXJuIHJlc1xuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIEyLjMuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIHZlY3Rvcjx2ZWN0b3I8aW50Pj4gcmVzO1xuICBzZXQ8c3RyaW5nPiBzZXQ7XG4gIHZvaWQgYmFja3RyYWNrKHZlY3RvcjxpbnQ+ICZudW1zLCBpbnQgbiwgdmVjdG9yPGludD4gdGVtcExpc3QsIGludCByZW1haW4sXG4gICAgICAgICAgICAgICAgIGludCBzdGFydCkge1xuICAgIGlmICh0ZW1wTGlzdC5zaXplKCkgPiA0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZW1haW4gPT0gMCAmJiB0ZW1wTGlzdC5zaXplKCkgPT0gNCkge1xuICAgICAgc3RyaW5nc3RyZWFtIHNzO1xuICAgICAgY29weSh0ZW1wTGlzdC5iZWdpbigpLCB0ZW1wTGlzdC5lbmQoKSwgb3N0cmVhbV9pdGVyYXRvcjxpbnQ+KHNzLCBcIlwiKSk7XG4gICAgICBzdHJpbmcgcyA9IHNzLnN0cigpO1xuICAgICAgaWYgKHNldC5jb3VudChzKSAhPSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldC5pbnNlcnQocyk7XG4gICAgICAgIHZlY3RvcjxpbnQ+IGNvcHk7XG4gICAgICAgIGNvcHkuYXNzaWduKHRlbXBMaXN0LmJlZ2luKCksIHRlbXBMaXN0LmVuZCgpKTtcbiAgICAgICAgcmVzLnB1c2hfYmFjayhjb3B5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGludCBpID0gc3RhcnQ7IGkgPCBuOyBpKyspIHtcbiAgICAgIHRlbXBMaXN0LnB1c2hfYmFjayhudW1zW2ldKTtcbiAgICAgIGJhY2t0cmFjayhudW1zLCBuLCB0ZW1wTGlzdCwgcmVtYWluIC0gbnVtc1tpXSwgaSArIDEpO1xuICAgICAgdGVtcExpc3QucG9wX2JhY2soKTtcbiAgICB9XG4gIH1cbiAgdmVjdG9yPHZlY3RvcjxpbnQ+PiBmb3VyU3VtKHZlY3RvcjxpbnQ+ICZudW1zLCBpbnQgdGFyZ2V0KSB7XG4gICAgc29ydChudW1zLmJlZ2luKCksIG51bXMuZW5kKCkpO1xuICAgIHZlY3RvcjxpbnQ+IHRlbXBMaXN0O1xuICAgIGJhY2t0cmFjayhudW1zLCBudW1zLnNpemUoKSwgdGVtcExpc3QsIHRhcmdldCwgMCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gIHByaXZhdGUgdm9pZCBiYWNrdHJhY2soXG4gICAgICBMaXN0PExpc3Q8SW50ZWdlcj4+IHJlcyxcbiAgICAgIGludFtdIG51bXMsXG4gICAgICBpbnQgbixcbiAgICAgIExpc3Q8SW50ZWdlcj4gdGVtcExpc3QsXG4gICAgICBpbnQgcmVtYWluLFxuICAgICAgaW50IHN0YXJ0LFxuICAgICAgSGFzaFNldCBzZXQpIHtcbiAgICBpZiAodGVtcExpc3Quc2l6ZSgpID4gNCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmVtYWluID09IDAgJiYgdGVtcExpc3Quc2l6ZSgpID09IDQpIHtcbiAgICAgIGlmIChzZXQuY29udGFpbnModGVtcExpc3QudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0LmFkZCh0ZW1wTGlzdC50b1N0cmluZygpKTtcbiAgICAgICAgcmVzLmFkZChuZXcgQXJyYXlMaXN0PEludGVnZXI+KHRlbXBMaXN0KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpbnQgaSA9IHN0YXJ0OyBpIDwgbjsgaSsrKSB7XG4gICAgICB0ZW1wTGlzdC5hZGQobnVtc1tpXSk7XG4gICAgICBiYWNrdHJhY2socmVzLCBudW1zLCBuLCB0ZW1wTGlzdCwgcmVtYWluIC0gbnVtc1tpXSwgaSArIDEsIHNldCk7XG4gICAgICB0ZW1wTGlzdC5yZW1vdmUodGVtcExpc3Quc2l6ZSgpIC0gMSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIExpc3Q8TGlzdDxJbnRlZ2VyPj4gZm91clN1bShpbnRbXSBudW1zLCBpbnQgdGFyZ2V0KSB7XG4gICAgTGlzdDxMaXN0PEludGVnZXI+PiByZXMgPSBuZXcgQXJyYXlMaXN0PD4oKTtcbiAgICBIYXNoU2V0IHNldCA9IG5ldyBIYXNoU2V0KCk7XG4gICAgQXJyYXlzLnNvcnQobnVtcyk7XG4gICAgTGlzdDxJbnRlZ2VyPiB0ZW1wTGlzdCA9IG5ldyBBcnJheUxpc3Q8SW50ZWdlcj4oKTtcbiAgICBiYWNrdHJhY2socmVzLCBudW1zLCBudW1zLmxlbmd0aCwgdGVtcExpc3QsIHRhcmdldCwgMCwgc2V0KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGJhY2t0cmFjayhcbiAgICAgICAgc2VsZixcbiAgICAgICAgcmVzOiBMaXN0W0xpc3RbaW50XV0sXG4gICAgICAgIG51bXM6IExpc3RbaW50XSxcbiAgICAgICAgbjogaW50LFxuICAgICAgICB0ZW1wTGlzdDogTGlzdFtpbnRdLFxuICAgICAgICByZW1haW46IGludCxcbiAgICAgICAgc3RhcnQ6IGludCxcbiAgICAgICAgaGFzaG1hcDogZGljdCxcbiAgICApIC0+IE5vbmU6XG4gICAgICAgIGlmIGxlbih0ZW1wTGlzdCkgPiA0OlxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIGlmIHJlbWFpbiA9PSAwIGFuZCBsZW4odGVtcExpc3QpID09IDQ6XG4gICAgICAgICAgICBpZiBzdHIodGVtcExpc3QpIGluIGhhc2htYXA6XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICBlbHNlOlxuICAgICAgICAgICAgICAgIGhhc2htYXBbc3RyKHRlbXBMaXN0KV0gPSBUcnVlXG4gICAgICAgICAgICAgICAgcmVzLmFwcGVuZCh0ZW1wTGlzdC5jb3B5KCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIGZvciBpIGluIHJhbmdlKHN0YXJ0LCBuKTpcbiAgICAgICAgICAgIHRlbXBMaXN0LmFwcGVuZChudW1zW2ldKVxuICAgICAgICAgICAgc2VsZi5iYWNrdHJhY2socmVzLCBudW1zLCBuLCB0ZW1wTGlzdCwgcmVtYWluIC0gbnVtc1tpXSwgaSArIDEsIGhhc2htYXApXG4gICAgICAgICAgICB0ZW1wTGlzdC5wb3AoKVxuXG4gICAgZGVmIGZvdXJTdW0oc2VsZiwgbnVtczogTGlzdFtpbnRdLCB0YXJnZXQ6IGludCkgLT4gTGlzdFtMaXN0W2ludF1dOlxuICAgICAgICByZXMgPSBbXVxuICAgICAgICBoYXNobWFwID0ge31cbiAgICAgICAgbnVtcy5zb3J0KClcbiAgICAgICAgc2VsZi5iYWNrdHJhY2socmVzLCBudW1zLCBsZW4obnVtcyksIFtdLCB0YXJnZXQsIDAsIGhhc2htYXApXG4gICAgICAgIHJldHVybiByZXNcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMi4zLjIiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDx2ZWN0b3I+XG4jaW5jbHVkZSA8YWxnb3JpdGhtPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICB2ZWN0b3I8dmVjdG9yPGludD4gPiBmb3VyU3VtKHZlY3RvcjxpbnQ+JiBudW1zLFxuICAgICAgaW50IHRhcmdldCkge1xuICAgIHNvcnQobnVtcy5iZWdpbigpLCBudW1zLmVuZCgpKTtcbiAgICB2ZWN0b3I8dmVjdG9yPGludD4gPiByZXN1bHRzO1xuICAgIHZlY3RvcjxpbnQ+IHRlbXBMaXN0O1xuICAgIGZpbmROc3VtKG51bXMsIHRhcmdldCwgNCwgdGVtcExpc3QsIHJlc3VsdHMpO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIHZvaWQgZmluZE5zdW0odmVjdG9yPGludD4gbnVtcywgaW50IHRhcmdldCwgaW50IE4sXG4gICAgICB2ZWN0b3I8aW50PiB0ZW1wTGlzdCxcbiAgICAgIHZlY3Rvcjx2ZWN0b3I8aW50PiA+JiByZXN1bHRzKSB7XG4gICAgaWYgKG51bXMuc2l6ZSgpIDwgTiB8fCBOIDwgMikgcmV0dXJuO1xuICAgIGlmIChOID09IDIpIHtcbiAgICAgIGludCBsID0gMCwgciA9IG51bXMuc2l6ZSgpIC0gMTtcbiAgICAgIHdoaWxlIChsIDwgcikge1xuICAgICAgICBpZiAobnVtc1tsXSArIG51bXNbcl0gPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgdmVjdG9yPGludD4gYnVmTGlzdCA9IHRlbXBMaXN0O1xuICAgICAgICAgIGJ1Zkxpc3QucHVzaF9iYWNrKG51bXNbbF0pO1xuICAgICAgICAgIGJ1Zkxpc3QucHVzaF9iYWNrKG51bXNbcl0pO1xuICAgICAgICAgIHJlc3VsdHMucHVzaF9iYWNrKGJ1Zkxpc3QpO1xuICAgICAgICAgIGwgKz0gMTtcbiAgICAgICAgICByIC09IDE7XG4gICAgICAgICAgd2hpbGUgKGwgPCByICYmIG51bXNbbF0gPT0gbnVtc1tsIC0gMV0pXG4gICAgICAgICAgICBsICs9IDE7XG4gICAgICAgICAgd2hpbGUgKHIgPiBsICYmIG51bXNbcl0gPT0gbnVtc1tyICsgMV0pXG4gICAgICAgICAgICByIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobnVtc1tsXSArIG51bXNbcl0gPCB0YXJnZXQpIGwgKz0gMTtcbiAgICAgICAgZWxzZSByIC09IDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtcy5zaXplKCk7IGkrKylcbiAgICAgICAgaWYgKGkgPT0gMCB8fCBpID4gMCAmJiBudW1zW2kgLSAxXSAhPSBudW1zW2ldKSB7XG4gICAgICAgICAgdmVjdG9yPGludD4gYnVmX251bXM7XG4gICAgICAgICAgZm9yIChpbnQgaiA9IGkgKyAxOyBqIDwgbnVtcy5zaXplKCk7IGorKylcbiAgICAgICAgICAgIGJ1Zl9udW1zLnB1c2hfYmFjayhudW1zW2pdKTtcbiAgICAgICAgICB2ZWN0b3I8aW50PiBidWZMaXN0ID0gdGVtcExpc3Q7XG4gICAgICAgICAgYnVmTGlzdC5wdXNoX2JhY2sobnVtc1tpXSk7XG4gICAgICAgICAgZmluZE5zdW0oYnVmX251bXMsIHRhcmdldCAtIG51bXNbaV0sXG4gICAgICAgICAgICAgIE4gLSAxLCBidWZMaXN0LCByZXN1bHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBqYXZhLnV0aWwuKjtcbmltcG9ydCBqYXZhLmxhbmcuTWF0aDtcblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIExpc3Q8TGlzdDxJbnRlZ2VyPiA+IGZvdXJTdW0oXG4gICAgICBpbnRbXSBudW1zLCBpbnQgdGFyZ2V0XG4gICAgICApIHtcbiAgICBBcnJheXMuc29ydChudW1zKTtcbiAgICBMaXN0PExpc3Q8SW50ZWdlcj4gPiByZXN1bHRzID0gbmV3IEFycmF5TGlzdDxMaXN0PEludGVnZXI+ID4oKTtcbiAgICBMaXN0PEludGVnZXI+IHRlbXBMaXN0ID0gbmV3IEFycmF5TGlzdDw+KCk7XG4gICAgZmluZE5zdW0obnVtcywgdGFyZ2V0LCA0LCB0ZW1wTGlzdCwgcmVzdWx0cyk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgdm9pZCBmaW5kTnN1bShpbnRbXSBudW1zLCBpbnQgdGFyZ2V0LCBpbnQgTixcbiAgICAgIExpc3Q8SW50ZWdlcj4gdGVtcExpc3QsXG4gICAgICBMaXN0PExpc3Q8SW50ZWdlcj4gPiByZXN1bHRzKSB7XG4gICAgaWYgKG51bXMubGVuZ3RoIDwgTiB8fCBOIDwgMikgcmV0dXJuO1xuICAgIGlmIChOID09IDIpIHtcbiAgICAgIGludCBsID0gMCwgciA9IG51bXMubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChsIDwgcikge1xuICAgICAgICBpZiAobnVtc1tsXSArIG51bXNbcl0gPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgTGlzdDxJbnRlZ2VyPiBidWZMaXN0ID0gbmV3IEFycmF5TGlzdDw+KCk7XG4gICAgICAgICAgZm9yIChpbnQgd3cgPSAwOyB3dyA8IHRlbXBMaXN0LnNpemUoKTsgd3crKylcbiAgICAgICAgICAgIGJ1Zkxpc3QuYWRkKHRlbXBMaXN0LmdldCh3dykpO1xuICAgICAgICAgIGJ1Zkxpc3QuYWRkKG51bXNbbF0pO1xuICAgICAgICAgIGJ1Zkxpc3QuYWRkKG51bXNbcl0pO1xuICAgICAgICAgIHJlc3VsdHMuYWRkKGJ1Zkxpc3QpO1xuICAgICAgICAgIGwgKz0gMTtcbiAgICAgICAgICByIC09IDE7XG4gICAgICAgICAgd2hpbGUgKGwgPCByICYmIG51bXNbbF0gPT0gbnVtc1tsIC0gMV0pXG4gICAgICAgICAgICBsICs9IDE7XG4gICAgICAgICAgd2hpbGUgKHIgPiBsICYmIG51bXNbcl0gPT0gbnVtc1tyICsgMV0pXG4gICAgICAgICAgICByIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobnVtc1tsXSArIG51bXNbcl0gPCB0YXJnZXQpIGwgKz0gMTtcbiAgICAgICAgZWxzZSByIC09IDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKGkgPT0gMCB8fCBpID4gMCAmJiBudW1zW2kgLSAxXSAhPSBudW1zW2ldKSB7XG4gICAgICAgICAgaW50W10gYnVmX251bXMgPSBuZXcgaW50W251bXMubGVuZ3RoIC0gaSAtIDFdO1xuICAgICAgICAgIGZvciAoaW50IGogPSBpICsgMTsgaiA8IG51bXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICBidWZfbnVtc1tqIC0gaSAtIDFdID0gbnVtc1tqXTtcbiAgICAgICAgICBMaXN0PEludGVnZXI+IGJ1Zkxpc3QgPSBuZXcgQXJyYXlMaXN0PD4oKTtcbiAgICAgICAgICBmb3IgKGludCB3dyA9IDA7IHd3IDwgdGVtcExpc3Quc2l6ZSgpOyB3dysrKVxuICAgICAgICAgICAgYnVmTGlzdC5hZGQodGVtcExpc3QuZ2V0KHd3KSk7XG4gICAgICAgICAgYnVmTGlzdC5hZGQobnVtc1tpXSk7XG4gICAgICAgICAgZmluZE5zdW0oYnVmX251bXMsIHRhcmdldCAtIG51bXNbaV0sIE4gLSAxLFxuICAgICAgICAgICAgICBidWZMaXN0LCByZXN1bHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBmb3VyU3VtKHNlbGYsIG51bXM6IExpc3RbaW50XSwgdGFyZ2V0OiBpbnQpOlxuICAgICAgICBudW1zLnNvcnQoKVxuICAgICAgICByZXN1bHRzID0gW11cbiAgICAgICAgc2VsZi5maW5kTnN1bShudW1zLCB0YXJnZXQsIDQsIFtdLCByZXN1bHRzKVxuICAgICAgICByZXR1cm4gcmVzdWx0c1xuXG4gICAgZGVmIGZpbmROc3VtKFxuICAgICAgICBzZWxmLFxuICAgICAgICBudW1zOiBMaXN0W2ludF0sXG4gICAgICAgIHRhcmdldDogaW50LFxuICAgICAgICBOOiBpbnQsXG4gICAgICAgIHRlbXBMaXN0OiBMaXN0W2ludF0sXG4gICAgICAgIHJlc3VsdHM6IExpc3RbTGlzdFtpbnRdXSxcbiAgICApIC0+IE5vbmU6XG4gICAgICAgIGlmIGxlbihudW1zKSA8IE4gb3IgTiA8IDI6XG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAjIHR3by1zdW1cbiAgICAgICAgaWYgTiA9PSAyOlxuICAgICAgICAgICAgbCA9IDBcbiAgICAgICAgICAgIHIgPSBsZW4obnVtcykgLSAxXG4gICAgICAgICAgICB3aGlsZSBsIDwgcjpcbiAgICAgICAgICAgICAgICBpZiBudW1zW2xdICsgbnVtc1tyXSA9PSB0YXJnZXQ6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuYXBwZW5kKHRlbXBMaXN0ICsgW251bXNbbF0sIG51bXNbcl1dKVxuICAgICAgICAgICAgICAgICAgICBsICs9IDFcbiAgICAgICAgICAgICAgICAgICAgciAtPSAxXG4gICAgICAgICAgICAgICAgICAgICMgc2tpcCBkdXBsaWNhdGVkXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIGwgPCByIGFuZCBudW1zW2xdID09IG51bXNbbCAtIDFdOlxuICAgICAgICAgICAgICAgICAgICAgICAgbCArPSAxXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIHIgPiBsIGFuZCBudW1zW3JdID09IG51bXNbciArIDFdOlxuICAgICAgICAgICAgICAgICAgICAgICAgciAtPSAxXG4gICAgICAgICAgICAgICAgZWxpZiBudW1zW2xdICsgbnVtc1tyXSA8IHRhcmdldDpcbiAgICAgICAgICAgICAgICAgICAgbCArPSAxXG4gICAgICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICAgICAgciAtPSAxXG4gICAgICAgICMg57yp5YeP6Zeu6aKY6KeE5qihXG4gICAgICAgIGVsc2U6XG4gICAgICAgICAgICBmb3IgaSBpbiByYW5nZSgwLCBsZW4obnVtcykpOlxuICAgICAgICAgICAgICAgICMgc2tpcCBkdXBsaWNhdGVkXG4gICAgICAgICAgICAgICAgaWYgaSA9PSAwIG9yIGkgPiAwIGFuZCBudW1zW2kgLSAxXSAhPSBudW1zW2ldOlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmZpbmROc3VtKFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtc1tpICsgMSA6XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCAtIG51bXNbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBOIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBMaXN0ICsgW251bXNbaV1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICByZXR1cm5cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMi40LjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDx2ZWN0b3I+XG4jaW5jbHVkZSA8bWFwPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICBpbnQgZm91clN1bUNvdW50KGNvbnN0IHZlY3RvcjxpbnQ+JiBBLFxuICAgICAgY29uc3QgdmVjdG9yPGludD4mIEIsXG4gICAgICBjb25zdCB2ZWN0b3I8aW50PiYgQyxcbiAgICAgIGNvbnN0IHZlY3RvcjxpbnQ+JiBEKSB7XG4gICAgbWFwPGludCwgaW50PiBtYXBwZXI7XG4gICAgaW50IHJlcyA9IDA7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBBLnNpemUoKTsgaSsrKVxuICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBCLnNpemUoKTsgaisrKSB7XG4gICAgICAgIGlmIChtYXBwZXIuY291bnQoQVtpXSArIEJbal0pKVxuICAgICAgICAgIG1hcHBlcltBW2ldICsgQltqXV0gPSBtYXBwZXJbQVtpXSArIEJbal1dICsgMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG1hcHBlcltBW2ldICsgQltqXV0gPSAxO1xuICAgICAgfVxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQy5zaXplKCk7IGkrKylcbiAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgRC5zaXplKCk7IGorKylcbiAgICAgICAgaWYgKG1hcHBlci5jb3VudCgtMSAqIChDW2ldICsgRFtqXSkpKVxuICAgICAgICAgIHJlcyArPSBtYXBwZXJbLTEgKiAoQ1tpXSArIERbal0pXTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiaW1wb3J0IGphdmEudXRpbC4qO1xuXG5wdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICBwdWJsaWMgaW50IGZvdXJTdW1Db3VudChpbnRbXSBBLFxuICAgICAgaW50W10gQiwgaW50W10gQywgaW50W10gRCkge1xuICAgIE1hcDxJbnRlZ2VyLCBJbnRlZ2VyPiBtYXBwZXIgPSBuZXcgSGFzaE1hcDxJbnRlZ2VyLCBJbnRlZ2VyPigpO1xuICAgIGludCByZXMgPSAwO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQS5sZW5ndGg7IGkrKylcbiAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQi5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAobWFwcGVyLmdldChBW2ldICsgQltqXSkgIT0gbnVsbClcbiAgICAgICAgICBtYXBwZXIucHV0KEFbaV0gKyBCW2pdLCBtYXBwZXIuZ2V0KEFbaV0gKyBCW2pdKSArIDEpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbWFwcGVyLnB1dChBW2ldICsgQltqXSwgMSk7XG4gICAgICB9XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDLmxlbmd0aDsgaSsrKVxuICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBELmxlbmd0aDsgaisrKVxuICAgICAgICBpZiAobWFwcGVyLmdldCgtMSAqIChDW2ldICsgRFtqXSkpICE9IG51bGwpXG4gICAgICAgICAgcmVzICs9IG1hcHBlci5nZXQoLTEgKiAoQ1tpXSArIERbal0pKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGZvdXJTdW1Db3VudChcbiAgICAgICAgc2VsZiwgQTogTGlzdFtpbnRdLCBCOiBMaXN0W2ludF0sIEM6IExpc3RbaW50XSwgRDogTGlzdFtpbnRdXG4gICAgKSAtPiBpbnQ6XG4gICAgICAgIG1hcHBlciA9IHt9XG4gICAgICAgIHJlcyA9IDBcbiAgICAgICAgZm9yIGkgaW4gQTpcbiAgICAgICAgICAgIGZvciBqIGluIEI6XG4gICAgICAgICAgICAgICAgbWFwcGVyW2kgKyBqXSA9IG1hcHBlci5nZXQoaSArIGosIDApICsgMVxuXG4gICAgICAgIGZvciBpIGluIEM6XG4gICAgICAgICAgICBmb3IgaiBpbiBEOlxuICAgICAgICAgICAgICAgIHJlcyArPSBtYXBwZXIuZ2V0KC0xICogKGkgKyBqKSwgMClcbiAgICAgICAgcmV0dXJuIHJlc1xuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIEyLjUuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI2luY2x1ZGUgPHZlY3Rvcj5cbiNpbmNsdWRlIDxjbWF0aD5cbiNpbmNsdWRlIDxjc3RkbGliPlxuI2luY2x1ZGUgPGFsZ29yaXRobT5cbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgaW50IHRocmVlU3VtQ2xvc2VzdCh2ZWN0b3I8aW50PiYgbnVtcywgaW50IHRhcmdldCkge1xuICAgIGludCBuID0gbnVtcy5zaXplKCk7XG4gICAgLy9pZiAobiA8IDMpIHJldHVybjtcbiAgICBzb3J0KG51bXMuYmVnaW4oKSwgbnVtcy5lbmQoKSk7XG4gICAgaW50IHJlcyA9IG51bXNbMF0gKyBudW1zWzFdICsgbnVtc1syXTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG4gLSAyOyBpKyspIHtcbiAgICAgIGlmIChpICYmIG51bXNbaV0gPT0gbnVtc1tpIC0gMV0pIGNvbnRpbnVlO1xuICAgICAgaW50IGwgPSBpICsgMSwgciA9IG4gLSAxO1xuICAgICAgd2hpbGUgKGwgPCByKSB7XG4gICAgICAgIGludCBzID0gbnVtc1tpXSArIG51bXNbbF0gKyBudW1zW3JdO1xuICAgICAgICBpZiAocyA9PSB0YXJnZXQpIHJldHVybiBzO1xuICAgICAgICBpZiAoYWJzKHMgLSB0YXJnZXQpIDwgYWJzKHJlcyAtIHRhcmdldCkpXG4gICAgICAgICAgcmVzID0gcztcbiAgICAgICAgaWYgKHMgPCB0YXJnZXQpIGwgKz0gMTtcbiAgICAgICAgZWxzZSBpZiAocyA+IHRhcmdldCkgciAtPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiaW1wb3J0IGphdmEubGFuZy5NYXRoO1xuaW1wb3J0IGphdmEudXRpbC4qO1xuXG5wdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICBwdWJsaWMgaW50IHRocmVlU3VtQ2xvc2VzdChpbnRbXSBudW1zLCBpbnQgdGFyZ2V0KSB7XG4gICAgaW50IG4gPSBudW1zLmxlbmd0aDtcbiAgICAvL2lmIChuIDwgMykgcmV0dXJuO1xuICAgIEFycmF5cy5zb3J0KG51bXMpO1xuICAgIGludCByZXMgPSBudW1zWzBdICsgbnVtc1sxXSArIG51bXNbMl07XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuIC0gMjsgaSArKykge1xuICAgICAgaWYgKGkgIT0gMCAmJiBudW1zW2ldID09IG51bXNbaSAtIDFdKSBjb250aW51ZTtcbiAgICAgIGludCBsID0gaSArIDEsIHIgPSBuIC0gMTtcbiAgICAgIHdoaWxlIChsIDwgcikge1xuICAgICAgICBpbnQgcyA9IG51bXNbaV0gKyBudW1zW2xdICsgbnVtc1tyXTtcbiAgICAgICAgaWYgKHMgPT0gdGFyZ2V0KSByZXR1cm4gcztcbiAgICAgICAgaWYgKE1hdGguYWJzKHMgLSB0YXJnZXQpIDwgTWF0aC5hYnMocmVzIC0gdGFyZ2V0KSlcbiAgICAgICAgICByZXMgPSBzO1xuICAgICAgICBpZiAocyA8IHRhcmdldCkgbCArPSAxO1xuICAgICAgICBlbHNlIGlmIChzID4gdGFyZ2V0KSByIC09IDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgdGhyZWVTdW1DbG9zZXN0KHNlbGYsIG51bXM6IExpc3RbaW50XSwgdGFyZ2V0OiBpbnQpIC0+IGludDpcbiAgICAgICAgbiA9IGxlbihudW1zKVxuICAgICAgICBpZiBuIDwgMzpcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICBudW1zLnNvcnQoKVxuICAgICAgICByZXMgPSBudW1zWzBdICsgbnVtc1sxXSArIG51bXNbMl1cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UobiAtIDIpOlxuICAgICAgICAgICAgIyDljrvph41cbiAgICAgICAgICAgIGlmIGkgPiAwIGFuZCBudW1zW2ldID09IG51bXNbaSAtIDFdOlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAjIOWbuuWumiBp77yM5a+75om+IGwg5ZKMIHLvvIzkvb/nlKjlj4zmjIfpkojms5VcbiAgICAgICAgICAgIGwgPSBpICsgMVxuICAgICAgICAgICAgciA9IG4gLSAxXG4gICAgICAgICAgICB3aGlsZSBsIDwgcjpcbiAgICAgICAgICAgICAgICBzID0gbnVtc1tpXSArIG51bXNbbF0gKyBudW1zW3JdXG4gICAgICAgICAgICAgICAgaWYgcyA9PSB0YXJnZXQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzXG5cbiAgICAgICAgICAgICAgICBpZiBhYnMocyAtIHRhcmdldCkgPCBhYnMocmVzIC0gdGFyZ2V0KTpcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gc1xuXG4gICAgICAgICAgICAgICAgaWYgcyA8IHRhcmdldDpcbiAgICAgICAgICAgICAgICAgICAgbCArPSAxXG4gICAgICAgICAgICAgICAgZWxpZiBzID4gdGFyZ2V0OlxuICAgICAgICAgICAgICAgICAgICByIC09IDFcblxuICAgICAgICByZXR1cm4gcmVzXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTIuNi4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8YWxnb3JpdGhtPlxuI2luY2x1ZGUgPHZlY3Rvcj5cbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgaW50IG1heFN1YkFycmF5KGNvbnN0IHZlY3RvcjxpbnQ+JiBudW1zKSB7XG4gICAgaW50IG4gPSBudW1zLnNpemUoKTtcbiAgICBpbnQgbWF4U3VtID0gLTB4N2ZmZmZmZmYsIHRvdGFsID0gMDtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgdG90YWwgPSAwO1xuICAgICAgZm9yIChpbnQgaiA9IGk7IGogPCBuOyBqKyspIHtcbiAgICAgICAgdG90YWwgKz0gbnVtc1tqXTtcbiAgICAgICAgbWF4U3VtID0gbWF4KG1heFN1bSwgdG90YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4U3VtO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiaW1wb3J0IGphdmEubGFuZy5NYXRoO1xuXG5wdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICBwdWJsaWMgaW50IG1heFN1YkFycmF5KGludFtdIG51bXMpIHtcbiAgICBpbnQgbiA9IG51bXMubGVuZ3RoO1xuICAgIGludCBtYXhTdW0gPSAtMHg3ZmZmZmZmZiwgdG90YWwgPSAwO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICB0b3RhbCA9IDA7XG4gICAgICBmb3IgKGludCBqID0gaTsgaiA8IG47IGorKykge1xuICAgICAgICB0b3RhbCArPSBudW1zW2pdO1xuICAgICAgICBtYXhTdW0gPSBNYXRoLm1heChtYXhTdW0sIHRvdGFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heFN1bTtcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBtYXhTdWJBcnJheShzZWxmLCBudW1zOiBMaXN0W2ludF0pIC0+IGludDpcbiAgICAgICAgbiA9IGxlbihudW1zKVxuICAgICAgICBtYXhTdW0gPSBmbG9hdChcIi1pbmZcIilcbiAgICAgICAgdG90YWwgPSAwXG4gICAgICAgIGZvciBpIGluIHJhbmdlKG4pOlxuICAgICAgICAgICAgdG90YWwgPSAwXG4gICAgICAgICAgICBmb3IgaiBpbiByYW5nZShpLCBuKTpcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBudW1zW2pdXG4gICAgICAgICAgICAgICAgbWF4U3VtID0gbWF4KG1heFN1bSwgdG90YWwpXG5cbiAgICAgICAgcmV0dXJuIG1heFN1bVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIEyLjYuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI2luY2x1ZGUgPHZlY3Rvcj5cbiNpbmNsdWRlIDxhbGdvcml0aG0+XG51c2luZyBuYW1lc3BhY2Ugc3RkO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIGludCBoZWxwZXIoY29uc3QgdmVjdG9yPGludD4mIG51bXMsIGludCBsLCBpbnQgcikge1xuICAgIGlmIChsID4gcikgcmV0dXJuIC0weDdmZmZmZmZmO1xuICAgIGludCBtaWQgPSAobCArIHIpIC8gMjtcbiAgICBpbnQgbGVmdCA9IGhlbHBlcihudW1zLCBsLCBtaWQgLSAxKTtcbiAgICBpbnQgcmlnaHQgPSBoZWxwZXIobnVtcywgbWlkICsgMSwgcik7XG4gICAgaW50IGxlZnRfc3VmZml4X21heF9zdW0gPSAwO1xuICAgIGludCByaWdodF9wcmVmaXhfbWF4X3N1bSA9IDA7XG4gICAgaW50IHRvdGFsID0gMDtcbiAgICBmb3IgKGludCBpID0gbWlkIC0gMTsgaSA+PSBsOyBpLS0pIHtcbiAgICAgIHRvdGFsICs9IG51bXNbaV07XG4gICAgICBsZWZ0X3N1ZmZpeF9tYXhfc3VtID0gbWF4KGxlZnRfc3VmZml4X21heF9zdW0sXG4gICAgICAgICAgdG90YWwpO1xuICAgIH1cbiAgICB0b3RhbCA9IDA7XG4gICAgZm9yIChpbnQgaSA9IG1pZCArIDE7IGkgPCByICsgMTsgaSsrKSB7XG4gICAgICB0b3RhbCArPSBudW1zW2ldO1xuICAgICAgcmlnaHRfcHJlZml4X21heF9zdW0gPSBtYXgocmlnaHRfcHJlZml4X21heF9zdW0sXG4gICAgICAgICAgdG90YWwpO1xuICAgIH1cbiAgICBpbnQgY3Jvc3NfbWF4X3N1bSA9IGxlZnRfc3VmZml4X21heF9zdW0gKyBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRfcHJlZml4X21heF9zdW0gKyBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtc1ttaWRdO1xuICAgIHJldHVybiBtYXgoY3Jvc3NfbWF4X3N1bSwgbWF4KGxlZnQsIHJpZ2h0KSk7XG4gIH1cbiAgaW50IG1heFN1YkFycmF5KGNvbnN0IHZlY3RvcjxpbnQ+JiBudW1zKSB7XG4gICAgcmV0dXJuIGhlbHBlcihudW1zLCAwLCBudW1zLnNpemUoKSAtIDEpO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiaW1wb3J0IGphdmEubGFuZy5NYXRoO1xuXG5wdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICBwdWJsaWMgaW50IGhlbHBlcihpbnRbXSBudW1zLCBpbnQgbCwgaW50IHIpIHtcbiAgICBpZiAobCA+IHIpIHJldHVybiAtMHg3ZmZmZmZmZjtcbiAgICBpbnQgbWlkID0gKGwgKyByKSAvIDI7XG4gICAgaW50IGxlZnQgPSBoZWxwZXIobnVtcywgbCwgbWlkIC0gMSk7XG4gICAgaW50IHJpZ2h0ID0gaGVscGVyKG51bXMsIG1pZCArIDEsIHIpO1xuICAgIGludCBsZWZ0X3N1ZmZpeF9tYXhfc3VtID0gMDtcbiAgICBpbnQgcmlnaHRfcHJlZml4X21heF9zdW0gPSAwO1xuICAgIGludCB0b3RhbCA9IDA7XG4gICAgZm9yIChpbnQgaSA9IG1pZCAtIDE7IGkgPj0gbDsgaS0tKSB7XG4gICAgICB0b3RhbCArPSBudW1zW2ldO1xuICAgICAgbGVmdF9zdWZmaXhfbWF4X3N1bSA9IE1hdGgubWF4KGxlZnRfc3VmZml4X21heF9zdW0sXG4gICAgICAgICAgdG90YWwpO1xuICAgIH1cbiAgICB0b3RhbCA9IDA7XG4gICAgZm9yIChpbnQgaSA9IG1pZCArIDE7IGkgPCByICsgMTsgaSArKykge1xuICAgICAgdG90YWwgKz0gbnVtc1tpXTtcbiAgICAgIHJpZ2h0X3ByZWZpeF9tYXhfc3VtID0gTWF0aC5tYXgocmlnaHRfcHJlZml4X21heF9zdW0sXG4gICAgICAgICAgdG90YWwpO1xuICAgIH1cbiAgICBpbnQgY3Jvc3NfbWF4X3N1bSA9IGxlZnRfc3VmZml4X21heF9zdW1cbiAgICAgICsgcmlnaHRfcHJlZml4X21heF9zdW1cbiAgICAgICsgbnVtc1ttaWRdO1xuICAgIHJldHVybiBNYXRoLm1heChjcm9zc19tYXhfc3VtLCBNYXRoLm1heChsZWZ0LCByaWdodCkpO1xuICB9XG4gIHB1YmxpYyBpbnQgbWF4U3ViQXJyYXkoaW50W10gbnVtcykge1xuICAgIHJldHVybiBoZWxwZXIobnVtcywgMCwgbnVtcy5sZW5ndGggLSAxKTtcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBtYXhTdWJBcnJheShzZWxmLCBudW1zOiBMaXN0W2ludF0pIC0+IGludDpcbiAgICAgICAgcmV0dXJuIHNlbGYuaGVscGVyKG51bXMsIDAsIGxlbihudW1zKSAtIDEpXG5cbiAgICBkZWYgaGVscGVyKHNlbGYsIG51bXM6IExpc3RbaW50XSwgbDogaW50LCByOiBpbnQpIC0+IGludDpcbiAgICAgICAgaWYgbCA+IHI6XG4gICAgICAgICAgICByZXR1cm4gZmxvYXQoXCItaW5mXCIpXG4gICAgICAgIG1pZCA9IChsICsgcikgLy8gMlxuICAgICAgICBsZWZ0ID0gc2VsZi5oZWxwZXIobnVtcywgbCwgbWlkIC0gMSlcbiAgICAgICAgcmlnaHQgPSBzZWxmLmhlbHBlcihudW1zLCBtaWQgKyAxLCByKVxuICAgICAgICBsZWZ0X3N1ZmZpeF9tYXhfc3VtID0gcmlnaHRfcHJlZml4X21heF9zdW0gPSAwXG4gICAgICAgIHRvdGFsID0gMFxuICAgICAgICBmb3IgaSBpbiByZXZlcnNlZChyYW5nZShsLCBtaWQpKTpcbiAgICAgICAgICAgIHRvdGFsICs9IG51bXNbaV1cbiAgICAgICAgICAgIGxlZnRfc3VmZml4X21heF9zdW0gPSBtYXgobGVmdF9zdWZmaXhfbWF4X3N1bSwgdG90YWwpXG4gICAgICAgIHRvdGFsID0gMFxuICAgICAgICBmb3IgaSBpbiByYW5nZShtaWQgKyAxLCByICsgMSk6XG4gICAgICAgICAgICB0b3RhbCArPSBudW1zW2ldXG4gICAgICAgICAgICByaWdodF9wcmVmaXhfbWF4X3N1bSA9IG1heChyaWdodF9wcmVmaXhfbWF4X3N1bSwgdG90YWwpXG4gICAgICAgIGNyb3NzX21heF9zdW0gPSBsZWZ0X3N1ZmZpeF9tYXhfc3VtICsgcmlnaHRfcHJlZml4X21heF9zdW0gKyBudW1zW21pZF1cbiAgICAgICAgcmV0dXJuIG1heChjcm9zc19tYXhfc3VtLCBsZWZ0LCByaWdodClcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMi42LjMiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDx2ZWN0b3I+XG4jaW5jbHVkZSA8YWxnb3JpdGhtPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICBpbnQgbWF4U3ViQXJyYXkoY29uc3QgdmVjdG9yPGludD4mIG51bXMpIHtcbiAgICBpbnQgbiA9IG51bXMuc2l6ZSgpO1xuICAgIGludCBtYXhfc3VtX2VuZGluZ19jdXJyX2lkeCA9IG51bXNbMF07XG4gICAgaW50IG1heF9zdW0gPSBudW1zWzBdO1xuICAgIGZvciAoaW50IGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICBtYXhfc3VtX2VuZGluZ19jdXJyX2lkeCA9IG1heChcbiAgICAgICAgICBtYXhfc3VtX2VuZGluZ19jdXJyX2lkeCArIG51bXNbaV0sXG4gICAgICAgICAgbnVtc1tpXVxuICAgICAgICAgICk7XG4gICAgICBtYXhfc3VtID0gbWF4KFxuICAgICAgICAgIG1heF9zdW1fZW5kaW5nX2N1cnJfaWR4LFxuICAgICAgICAgIG1heF9zdW1cbiAgICAgICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbWF4X3N1bTtcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBqYXZhLmxhbmcuTWF0aDtcblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGludCBtYXhTdWJBcnJheShpbnRbXSBudW1zKSB7XG4gICAgaW50IG4gPSBudW1zLmxlbmd0aDtcbiAgICBpbnQgbWF4X3N1bV9lbmRpbmdfY3Vycl9pZHggPSBudW1zWzBdO1xuICAgIGludCBtYXhfc3VtID0gbnVtc1swXTtcbiAgICBmb3IgKGludCBpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgbWF4X3N1bV9lbmRpbmdfY3Vycl9pZHggPSBNYXRoLm1heChcbiAgICAgICAgICBtYXhfc3VtX2VuZGluZ19jdXJyX2lkeCArIG51bXNbaV0sXG4gICAgICAgICAgbnVtc1tpXVxuICAgICAgICAgICk7XG4gICAgICBtYXhfc3VtID0gTWF0aC5tYXgoXG4gICAgICAgICAgbWF4X3N1bV9lbmRpbmdfY3Vycl9pZHgsXG4gICAgICAgICAgbWF4X3N1bVxuICAgICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBtYXhfc3VtO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIG1heFN1YkFycmF5KHNlbGYsIG51bXM6IExpc3RbaW50XSkgLT4gaW50OlxuICAgICAgICBuID0gbGVuKG51bXMpXG4gICAgICAgIG1heF9zdW1fZW5kaW5nX2N1cnJfaW5kZXggPSBtYXhfc3VtID0gbnVtc1swXVxuICAgICAgICBmb3IgaSBpbiByYW5nZSgxLCBuKTpcbiAgICAgICAgICAgIG1heF9zdW1fZW5kaW5nX2N1cnJfaW5kZXggPSBtYXgoXG4gICAgICAgICAgICAgICAgbWF4X3N1bV9lbmRpbmdfY3Vycl9pbmRleCArIG51bXNbaV0sIG51bXNbaV1cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIG1heF9zdW0gPSBtYXgobWF4X3N1bV9lbmRpbmdfY3Vycl9pbmRleCwgbWF4X3N1bSlcblxuICAgICAgICByZXR1cm4gbWF4X3N1bVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIEyLjYuNCIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI2luY2x1ZGUgPGFsZ29yaXRobT5cbiNpbmNsdWRlIDx2ZWN0b3I+XG51c2luZyBuYW1lc3BhY2Ugc3RkO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIGludCBtYXhTdWJBcnJheShjb25zdCB2ZWN0b3I8aW50PiYgbnVtcykge1xuICAgIGludCBuID0gbnVtcy5zaXplKCk7XG4gICAgaW50IG1heFN1bSA9IG51bXNbMF0sIG1pblN1bSA9IDAsIHN1bSA9IDA7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIHN1bSArPSBudW1zW2ldO1xuICAgICAgbWF4U3VtID0gbWF4KG1heFN1bSwgc3VtIC0gbWluU3VtKTtcbiAgICAgIG1pblN1bSA9IG1pbihtaW5TdW0sIHN1bSk7XG4gICAgfVxuICAgIHJldHVybiBtYXhTdW07XG4gIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJpbXBvcnQgamF2YS5sYW5nLk1hdGg7XG5cbnB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBpbnQgbWF4U3ViQXJyYXkoaW50W10gbnVtcykge1xuICAgIGludCBuID0gbnVtcy5sZW5ndGg7XG4gICAgaW50IG1heFN1bSA9IG51bXNbMF0sIG1pblN1bSA9IDAsIHN1bSA9IDA7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIHN1bSArPSBudW1zW2ldO1xuICAgICAgbWF4U3VtID0gTWF0aC5tYXgobWF4U3VtLCBzdW0gLSBtaW5TdW0pO1xuICAgICAgbWluU3VtID0gTWF0aC5taW4obWluU3VtLCBzdW0pO1xuICAgIH1cbiAgICByZXR1cm4gbWF4U3VtO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIG1heFN1YkFycmF5KHNlbGYsIG51bXM6IExpc3RbaW50XSkgLT4gaW50OlxuICAgICAgICBuID0gbGVuKG51bXMpXG4gICAgICAgIG1heFN1bSA9IG51bXNbMF1cbiAgICAgICAgbWluU3VtID0gc3VtID0gMFxuICAgICAgICBmb3IgaSBpbiByYW5nZShuKTpcbiAgICAgICAgICAgIHN1bSArPSBudW1zW2ldXG4gICAgICAgICAgICBtYXhTdW0gPSBtYXgobWF4U3VtLCBzdW0gLSBtaW5TdW0pXG4gICAgICAgICAgICBtaW5TdW0gPSBtaW4obWluU3VtLCBzdW0pXG5cbiAgICAgICAgcmV0dXJuIG1heFN1bVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIEyLjcuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI2luY2x1ZGUgPHN0cmluZz5cbiNpbmNsdWRlIDx2ZWN0b3I+XG4jaW5jbHVkZSA8YWxnb3JpdGhtPlxuI2luY2x1ZGUgPGNzdGRsaWI+XG4jaW5jbHVkZSA8Y3N0ZGlvPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuc3RydWN0IG15X3N0ciB7XG4gIHN0cmluZyBzdHI7XG4gIG15X3N0cihpbnQgbnVtKTogc3RyKHRvX3N0cmluZyhudW0pKSB7fVxuICBib29sIG9wZXJhdG9yIDwgKGNvbnN0IG15X3N0ciYgcmhzKSBjb25zdCB7XG4gICAgcmV0dXJuIHN0ciArIHJocy5zdHIgPiByaHMuc3RyICsgc3RyO1xuICB9XG59O1xuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIHN0cmluZyBsYXJnZXN0TnVtYmVyKGNvbnN0IHZlY3RvcjxpbnQ+JiBudW1zKSB7XG4gICAgdmVjdG9yPG15X3N0cj4gcztcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG51bXMuc2l6ZSgpOyBpKyspXG4gICAgICBzLnB1c2hfYmFjayhteV9zdHIobnVtc1tpXSkpO1xuICAgIHNvcnQocy5iZWdpbigpLCBzLmVuZCgpKTtcbiAgICBzdHJpbmcgYW5zKFwiXCIpO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtcy5zaXplKCk7IGkrKylcbiAgICAgIGFucyArPSBzW2ldLnN0cjtcbiAgICBzdHJpbmcgcmVhbF9hbnMoXCJcIik7XG4gICAgYm9vbCBmbGFnID0gZmFsc2U7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBhbnMubGVuZ3RoKCk7IGkrKykge1xuICAgICAgaWYgKCFmbGFnKSBmbGFnID0gIShhbnNbaV0gPT0gJzAnKTtcbiAgICAgIGlmIChmbGFnKSByZWFsX2Fucy5wdXNoX2JhY2soYW5zW2ldKTtcbiAgICB9XG4gICAgaWYgKCFmbGFnKSByZXR1cm4gc3RyaW5nKFwiMFwiKTtcbiAgICBlbHNlIHJldHVybiByZWFsX2FucztcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBqYXZhLnV0aWwuKjtcblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGNsYXNzIG15X3N0ciB7XG4gICAgcHVibGljIFN0cmluZyBzdHI7XG4gICAgcHVibGljIHZvaWQgc2V0U3RyKGludCBudW0pIHtcbiAgICAgICAgSW50ZWdlciBidWZfbnVtID0gbmV3IEludGVnZXIobnVtKTtcbiAgICAgICAgdGhpcy5zdHIgPSBidWZfbnVtLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG4gIHB1YmxpYyBjbGFzcyBteV9jbXAgaW1wbGVtZW50cyBDb21wYXJhdG9yPG15X3N0cj4ge1xuICAgIEBPdmVycmlkZVxuICAgIHB1YmxpYyBpbnQgY29tcGFyZShteV9zdHIgYSwgbXlfc3RyIGIpIHtcbiAgICAgIGlmIChhICE9IG51bGwgJiYgYiAhPSBudWxsKSB7XG4gICAgICAgIFN0cmluZyBsZWZ0ID0gYS5zdHIgKyBiLnN0cjtcbiAgICAgICAgU3RyaW5nIHJpZ2h0ID0gYi5zdHIgKyBhLnN0cjtcbiAgICAgICAgcmV0dXJuIHJpZ2h0LmNvbXBhcmVUbyhsZWZ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuICBTdHJpbmcgbGFyZ2VzdE51bWJlcihpbnRbXSBudW1zKSB7XG4gICAgbXlfc3RyW10gcztcbiAgICBzID0gbmV3IG15X3N0cltudW1zLmxlbmd0aF07XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNbaV0gPSBuZXcgbXlfc3RyKCk7XG4gICAgICAgIHNbaV0uc2V0U3RyKG51bXNbaV0pO1xuICAgIH1cbiAgICBBcnJheXMuc29ydChzLCBuZXcgbXlfY21wKCkpO1xuICAgIFN0cmluZyBhbnMgPSBcIlwiO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKylcbiAgICAgIGlmIChzW2ldICE9IG51bGwpIGFucyA9IGFucyArIHNbaV0uc3RyO1xuICAgIFN0cmluZyByZWFsX2FucyA9IFwiXCI7XG4gICAgYm9vbGVhbiBmbGFnID0gZmFsc2U7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBhbnMubGVuZ3RoKCk7IGkrKykge1xuICAgICAgaWYgKCFmbGFnKSBmbGFnID0gIShhbnMuY2hhckF0KGkpID09ICcwJyk7XG4gICAgICBpZiAoZmxhZykgcmVhbF9hbnMgPSByZWFsX2FucyArIGFucy5zdWJzdHJpbmcoaSwgaSArIDEpO1xuICAgIH1cbiAgICBpZiAoIWZsYWcpIHJldHVybiBcIjBcIjtcbiAgICBlbHNlIHJldHVybiByZWFsX2FucztcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBmdW5jdG9vbHNcblxuXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgbGFyZ2VzdE51bWJlcihzZWxmLCBudW1zOiBMaXN0W2ludF0pIC0+IHN0cjpcbiAgICAgICAgcyA9IFtzdHIoaSkgZm9yIGkgaW4gbnVtc11cblxuICAgICAgICBkZWYgY29tcChhLCBiKTpcbiAgICAgICAgICAgIGlmIChhICsgYikgPiAoYiArIGEpOlxuICAgICAgICAgICAgICAgIHJldHVybiAxXG4gICAgICAgICAgICBpZiAoYSArIGIpIDwgKGIgKyBhKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgICAgIHJldHVybiAwXG5cbiAgICAgICAgIyDov5nph4zliqDkuobkuIDmrKEgaW50IOi9rOaNoui/h+eoi++8jOeUqOS6juWkhOeQhuesrOS4gOS4quaVsOWtl+S4uiAwIOeahOaDheWGtVxuICAgICAgICBzLnNvcnQocmV2ZXJzZT1UcnVlLCBrZXk9ZnVuY3Rvb2xzLmNtcF90b19rZXkoY29tcCkpXG4gICAgICAgIHJldHVybiBzdHIoaW50KFwiXCIuam9pbihzKSkpXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTIuNy4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8dmVjdG9yPlxuI2luY2x1ZGUgPGFsZ29yaXRobT5cbiNpbmNsdWRlIDxjc3RkaW8+XG4jaW5jbHVkZSA8c3RyaW5nPlxuI2luY2x1ZGUgPGNzdGRsaWI+XG51c2luZyBuYW1lc3BhY2Ugc3RkO1xuXG5zdHJpbmcgbGFyZ2VzdE51bWJlcihjb25zdCB2ZWN0b3I8aW50PiYgbnVtcykge1xuICB2ZWN0b3I8c3RyaW5nPiBzO1xuICBmb3IgKGludCBpID0gMDsgaSA8IG51bXMuc2l6ZSgpOyBpKyspXG4gICAgcy5wdXNoX2JhY2sodG9fc3RyaW5nKG51bXNbaV0pKTtcbiAgLy8gY2xhbmcrKy9nKys6IG5lZWQgcGFyYW1ldGVyICctc3RkPWMrKzExJ1xuICBzb3J0KHMuYmVnaW4oKSwgcy5lbmQoKSwgW10oc3RyaW5nIGEsIHN0cmluZyBiKVxuICAgICAgLT4gYm9vbCB7XG4gICAgICByZXR1cm4gYSArIGIgPiBiICsgYTtcbiAgICAgIH0pO1xuICBzdHJpbmcgYW5zKFwiXCIpO1xuICBmb3IgKGludCBpID0gMDsgaSA8IG51bXMuc2l6ZSgpOyBpKyspXG4gICAgYW5zICs9IHNbaV07XG4gICAgc3RyaW5nIHJlYWxfYW5zKFwiXCIpO1xuICAgIGJvb2wgZmxhZyA9IGZhbHNlO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgYW5zLmxlbmd0aCgpOyBpKyspIHtcbiAgICAgIGlmICghZmxhZykgZmxhZyA9ICEoYW5zW2ldID09ICcwJyk7XG4gICAgICBpZiAoZmxhZykgcmVhbF9hbnMucHVzaF9iYWNrKGFuc1tpXSk7XG4gICAgfVxuICAgIGlmICghZmxhZykgcmV0dXJuIHN0cmluZyhcIjBcIik7XG4gICAgZWxzZSByZXR1cm4gcmVhbF9hbnM7XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJpbXBvcnQgamF2YS51dGlsLio7XG5cbnB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBTdHJpbmcgbGFyZ2VzdE51bWJlcihpbnRbXSBudW1zKSB7XG4gICAgU3RyaW5nW10gcyA9IG5ldyBTdHJpbmdbbnVtcy5sZW5ndGhdO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKylcbiAgICAgIHNbaV0gPSBTdHJpbmcudmFsdWVPZihudW1zW2ldKTtcbiAgICBMaXN0PFN0cmluZz4gc3RyID0gQXJyYXlzLmFzTGlzdChzKTtcbiAgICBzdHIuc29ydCgoU3RyaW5nIGEsIFN0cmluZyBiKSAtPiB7XG4gICAgICBTdHJpbmcgbGVmdCA9IGEgKyBiLCByaWdodCA9IGIgKyBhO1xuICAgICAgcmV0dXJuIHJpZ2h0LmNvbXBhcmVUbyhsZWZ0KTtcbiAgICB9KTtcbiAgICBTdHJpbmcgYW5zID0gXCJcIjtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspXG4gICAgICBhbnMgPSBhbnMgKyBzdHIuZ2V0KGkpO1xuICAgIFN0cmluZyByZWFsX2FucyA9IFwiXCI7XG4gICAgYm9vbGVhbiBmbGFnID0gZmFsc2U7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBhbnMubGVuZ3RoKCk7IGkrKykge1xuICAgICAgaWYgKCFmbGFnKSBmbGFnID0gIShhbnMuY2hhckF0KGkpID09ICcwJyk7XG4gICAgICBpZiAoZmxhZykgcmVhbF9hbnMgPSByZWFsX2FucyArIGFucy5zdWJzdHJpbmcoaSwgaSArIDEpO1xuICAgIH1cbiAgICBpZiAoIWZsYWcpIHJldHVybiBcIjBcIjtcbiAgICBlbHNlIHJldHVybiByZWFsX2FucztcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImRlZiBsYXJnZXN0TnVtYmVyKHNlbGYsIG51bXM6IExpc3RbaW50XSkgLT4gc3RyOlxuICAgIHJldHVybiBzdHIoaW50KFwiXCIuam9pbihzb3J0ZWQobWFwKHN0ciwgbnVtcyksIGNtcD1sYW1iZGEgYSwgYjogY21wKGIgKyBhLCBhICsgYikpKSkpXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTIuOC4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8Y3N0ZGxpYj5cbiNpbmNsdWRlIDxjbWF0aD5cbiNpbmNsdWRlIDxzdHJpbmc+XG4jaW5jbHVkZSA8bWFwPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxudHlwZWRlZiBsb25nIGxvbmcgbGw7XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgc3RyaW5nIGZyYWN0aW9uVG9EZWNpbWFsKGxsIG51bWVyYXRvcixcbiAgICAgIGxsIGRlbm9taW5hdG9yKSB7XG4gICAgc3RyaW5nIHJlcyhcIlwiKTtcbiAgICBpZiAoZG91YmxlKG51bWVyYXRvcikgLyBkb3VibGUoZGVub21pbmF0b3IpIDwgMC4wKSByZXMgKz0gXCItXCI7XG4gICAgbnVtZXJhdG9yID0gbGxhYnMobnVtZXJhdG9yKTtcbiAgICBkZW5vbWluYXRvciA9IGxsYWJzKGRlbm9taW5hdG9yKTtcbiAgICBsbCBuID0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XG4gICAgbGwgcmVtYWluZGVyID0gbnVtZXJhdG9yICUgZGVub21pbmF0b3I7XG4gICAgcmVzICs9IHRvX3N0cmluZyhuKTtcbiAgICBpZiAoIXJlbWFpbmRlcikgcmV0dXJuIHJlcztcbiAgICByZXMgKz0gXCIuXCI7XG4gICAgaW50IGlkeCA9IHJlcy5zaXplKCk7XG4gICAgbWFwPGxsLCBpbnQ+IHNlZW47XG4gICAgd2hpbGUgKHJlbWFpbmRlciAmJiAhc2Vlbi5jb3VudChyZW1haW5kZXIpKSB7XG4gICAgICBzZWVuW3JlbWFpbmRlcl0gPSBpZHgrKztcbiAgICAgIG4gPSAocmVtYWluZGVyICogMTBMTCkgLyBkZW5vbWluYXRvcjtcbiAgICAgIHJlbWFpbmRlciA9IChyZW1haW5kZXIgKiAxMExMKSAlIGRlbm9taW5hdG9yO1xuICAgICAgcmVzICs9IHRvX3N0cmluZyhuKTtcbiAgICB9XG4gICAgaWYgKHJlbWFpbmRlcikge1xuICAgICAgcmVzLmluc2VydChzZWVuW3JlbWFpbmRlcl0sIDEsICcoJyk7XG4gICAgICByZXMgKz0gXCIpXCI7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbn07XG5cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBqYXZhLnV0aWwuKjtcbmltcG9ydCBqYXZhLmxhbmcuTWF0aDtcblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIFN0cmluZyBmcmFjdGlvblRvRGVjaW1hbChsb25nIG51bWVyYXRvcixcbiAgICAgIGxvbmcgZGVub21pbmF0b3IpIHtcbiAgICBTdHJpbmcgcmVzID0gXCJcIjtcbiAgICBpZiAoKGRvdWJsZSludW1lcmF0b3IgLyAoZG91YmxlKWRlbm9taW5hdG9yIDwgMC4wKSByZXMgPSByZXMgKyBcIi1cIjtcbiAgICBudW1lcmF0b3IgPSBNYXRoLmFicyhudW1lcmF0b3IpO1xuICAgIGRlbm9taW5hdG9yID0gTWF0aC5hYnMoZGVub21pbmF0b3IpO1xuICAgIGxvbmcgbiA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xuICAgIGxvbmcgcmVtYWluZGVyID0gbnVtZXJhdG9yICUgZGVub21pbmF0b3I7XG4gICAgcmVzID0gcmVzICsgU3RyaW5nLnZhbHVlT2Yobik7XG4gICAgaWYgKHJlbWFpbmRlciA9PSAwKSByZXR1cm4gcmVzO1xuICAgIHJlcyA9IHJlcyArIFwiLlwiO1xuICAgIGludCBpZHggPSByZXMubGVuZ3RoKCk7XG4gICAgTWFwPExvbmcsIEludGVnZXI+IHNlZW4gPSBuZXcgSGFzaE1hcDxMb25nLFxuICAgICAgSW50ZWdlcj4oKTtcbiAgICB3aGlsZSAocmVtYWluZGVyICE9IDAgJiYgc2Vlbi5nZXQocmVtYWluZGVyKSA9PSBudWxsKSB7XG4gICAgICBzZWVuLnB1dChyZW1haW5kZXIsIGlkeCk7XG4gICAgICBpZHggPSBpZHggKyAxO1xuICAgICAgbiA9IChyZW1haW5kZXIgKiAxMCkgLyBkZW5vbWluYXRvcjtcbiAgICAgIHJlbWFpbmRlciA9IChyZW1haW5kZXIgKiAxMCkgJSBkZW5vbWluYXRvcjtcbiAgICAgIHJlcyA9IHJlcyArIFN0cmluZy52YWx1ZU9mKG4pO1xuICAgIH1cbiAgICBpZiAocmVtYWluZGVyICE9IDApIHtcbiAgICAgIFN0cmluZ0J1ZmZlciBhbm9fc3RyID0gIG5ldyBTdHJpbmdCdWZmZXIocmVzKTtcbiAgICAgIGFub19zdHIuaW5zZXJ0KHNlZW4uZ2V0KHJlbWFpbmRlciksIFwiKFwiKTtcbiAgICAgIHJlcyA9IGFub19zdHIudG9TdHJpbmcoKTtcbiAgICAgIHJlcyArPSBcIilcIjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBmcmFjdGlvblRvRGVjaW1hbChzZWxmLCBudW1lcmF0b3I6IGludCwgZGVub21pbmF0b3I6IGludCkgLT4gc3RyOlxuICAgICAgICAjIOacgOe7iOe7k+aenOeUseS4pOmDqOWIhue7hOaIkO+8jCDnrKblj7flkozlgLxcbiAgICAgICAgIyDnroDljZXotbfop4HvvIzlhajpg6jlj5bnu53lr7nlgLzvvIzorqHnrpflh7rmnIDnu4jnu5PmnpznmoTlgLxcbiAgICAgICAgIyDnrKblj7fmiJHku6zlj6/ku6XpgJrov4fpmaTmmK/lkKblpKfkuo4w5p2l5Yik5patXG5cbiAgICAgICAgIyDplb/pmaTms5VcbiAgICAgICAgbiwgcmVtYWluZGVyID0gZGl2bW9kKGFicyhudW1lcmF0b3IpLCBhYnMoZGVub21pbmF0b3IpKVxuICAgICAgICBzaWduID0gXCJcIlxuICAgICAgICBpZiBudW1lcmF0b3IgLy8gZGVub21pbmF0b3IgPCAwOlxuICAgICAgICAgICAgc2lnbiA9IFwiLVwiXG5cbiAgICAgICAgcmVzID0gW3N0cihuKSwgXCIuXCJdXG4gICAgICAgIHNlZW4gPSBbXVxuICAgICAgICB3aGlsZSByZW1haW5kZXIgbm90IGluIHNlZW46XG4gICAgICAgICAgICBzZWVuLmFwcGVuZChyZW1haW5kZXIpXG4gICAgICAgICAgICBuLCByZW1haW5kZXIgPSBkaXZtb2QocmVtYWluZGVyICogMTAsIGFicyhkZW5vbWluYXRvcikpXG4gICAgICAgICAgICByZXMuYXBwZW5kKHN0cihuKSlcbiAgICAgICAgIyDlpITnkIblvqrnjq/oioLnmoTmoLzlvI9cbiAgICAgICAgaW5kZXggPSBzZWVuLmluZGV4KHJlbWFpbmRlcilcbiAgICAgICAgcmVzLmluc2VydChpbmRleCArIDIsIFwiKFwiKVxuICAgICAgICByZXMuYXBwZW5kKFwiKVwiKVxuXG4gICAgICAgIHJldHVybiBzaWduICsgXCJcIi5qb2luKHJlcykucmVwbGFjZShcIigwKVwiLCBcIlwiKS5yc3RyaXAoXCIuXCIpXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTIuOS4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8dmVjdG9yPlxuI2luY2x1ZGUgPHNldD5cbiNpbmNsdWRlIDxtYXA+XG4jaW5jbHVkZSA8YWxnb3JpdGhtPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuc3RydWN0IG5vZGUge1xuICBzZXQ8aW50PiBzO1xuICBub2RlKCkge1xuICAgIHMuY2xlYXIoKTtcbiAgfVxuICBib29sIG9wZXJhdG9yIDwgKGNvbnN0IG5vZGUmIHJocykgY29uc3Qge1xuICAgIHJldHVybiBzLnNpemUoKSA+IHJocy5zLnNpemUoKTtcbiAgfVxuICB2b2lkIG9wZXJhdG9yID0gKGNvbnN0IG5vZGUmIHJocykge1xuICAgIHMgPSByaHMucztcbiAgfVxufTtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICB2ZWN0b3I8aW50PiBsYXJnZXN0RGl2aXNpYmxlU3Vic2V0KFxuICAgICAgdmVjdG9yPGludD4mIG51bXNcbiAgICAgICkge1xuICAgIG1hcDxpbnQsIG5vZGU+IFM7XG4gICAgU1stMV0gPSBub2RlKCk7XG4gICAgc29ydChudW1zLmJlZ2luKCksIG51bXMuZW5kKCkpO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtcy5zaXplKCk7IGkrKykge1xuICAgICAgaW50IHggPSBudW1zW2ldO1xuICAgICAgdmVjdG9yPG5vZGU+IHRlbXA7XG4gICAgICBmb3IgKG1hcDxpbnQsIG5vZGU+OjppdGVyYXRvciBpdCA9IFMuYmVnaW4oKTtcbiAgICAgICAgICBpdCAhPSBTLmVuZCgpOyBpdCsrKSB7XG4gICAgICAgIGludCBkID0gaXQtPmZpcnN0O1xuICAgICAgICBpZiAoeCAlIGQgPT0gMCkge1xuICAgICAgICAgIFNbZF0ucy5pbnNlcnQoeCk7XG4gICAgICAgICAgdGVtcC5wdXNoX2JhY2soU1tkXSk7XG4gICAgICAgICAgU1tkXS5zLmVyYXNlKHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlIGJ1ZiA9IG5vZGUoKTtcbiAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgdGVtcC5zaXplKCk7IGorKylcbiAgICAgICAgaWYgKHRlbXBbal0gPCBidWYpIGJ1ZiA9IHRlbXBbal07XG4gICAgICBpZiAoIWJ1Zi5zLmNvdW50KHgpKSBidWYucy5pbnNlcnQoeCk7XG4gICAgICBTW3hdID0gYnVmO1xuICAgIH1cbiAgICB2ZWN0b3I8aW50PiBhbnM7XG4gICAgbm9kZSBidWYgPSBub2RlKCk7XG4gICAgZm9yIChtYXA8aW50LCBub2RlPjo6aXRlcmF0b3IgaXQgPSBTLmJlZ2luKCk7XG4gICAgICAgIGl0ICE9IFMuZW5kKCk7IGl0KyspXG4gICAgICBpZiAoaXQtPnNlY29uZCA8IGJ1ZikgYnVmID0gaXQtPnNlY29uZDtcbiAgICBmb3IgKHNldDxpbnQ+OjppdGVyYXRvciBpdCA9IGJ1Zi5zLmJlZ2luKCk7XG4gICAgICAgIGl0ICE9IGJ1Zi5zLmVuZCgpOyBpdCsrKVxuICAgICAgYW5zLnB1c2hfYmFjaygqaXQpO1xuICAgIHJldHVybiBhbnM7XG4gIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJpbXBvcnQgamF2YS51dGlsLio7XG5cbnB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBjbGFzcyBub2RlIHtcbiAgICBTZXQ8SW50ZWdlcj4gcztcbiAgICBub2RlKCkge1xuICAgICAgdGhpcy5zID0gbmV3IEhhc2hTZXQ8SW50ZWdlcj4oKTtcbiAgICB9XG4gICAgYm9vbGVhbiBsZXNzIChub2RlIHJocykge1xuICAgICAgcmV0dXJuIHRoaXMucy5zaXplKCkgPiByaHMucy5zaXplKCk7XG4gICAgfVxuICB9XG4gIHB1YmxpYyBMaXN0PEludGVnZXI+IGxhcmdlc3REaXZpc2libGVTdWJzZXQoaW50W10gbnVtcykge1xuICAgIE1hcDxJbnRlZ2VyLCBub2RlPiBTID0gbmV3IEhhc2hNYXA8SW50ZWdlciwgbm9kZT4oKTtcbiAgICBTLnB1dCgtMSwgbmV3IG5vZGUoKSk7XG4gICAgQXJyYXlzLnNvcnQobnVtcyk7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnQgeCA9IG51bXNbaV07XG4gICAgICBMaXN0PG5vZGU+IHRlbXAgPSBuZXcgQXJyYXlMaXN0PD4oKTtcbiAgICAgIFNldDxNYXAuRW50cnk8SW50ZWdlciwgbm9kZT4gPiBrZXlfc2V0ID0gUy5lbnRyeVNldCgpO1xuICAgICAgSXRlcmF0b3I8TWFwLkVudHJ5PEludGVnZXIsIG5vZGU+ID4gaXQgPSBrZXlfc2V0Lml0ZXJhdG9yKCk7XG4gICAgICB3aGlsZSAoaXQuaGFzTmV4dCgpKSB7XG4gICAgICAgIE1hcC5FbnRyeTxJbnRlZ2VyLCBub2RlPiBlbnRyeSA9IGl0Lm5leHQoKTtcbiAgICAgICAgaW50IGQgPSBlbnRyeS5nZXRLZXkoKTtcbiAgICAgICAgaWYgKHggJSBkID09IDApIHtcbiAgICAgICAgICBlbnRyeS5nZXRWYWx1ZSgpLnMuYWRkKHgpO1xuICAgICAgICAgIHRlbXAuYWRkKFMuZ2V0KGQpKTtcbiAgICAgICAgICBTLmdldChkKS5zLnJlbW92ZSh4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZSBidWYgPSBuZXcgbm9kZSgpO1xuICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCB0ZW1wLnNpemUoKTsgaisrKVxuICAgICAgICBpZiAodGVtcC5nZXQoaikubGVzcyhidWYpKSB7XG4gICAgICAgICAgYnVmLnMgPSBuZXcgSGFzaFNldDxJbnRlZ2VyPigpO1xuICAgICAgICAgIEl0ZXJhdG9yPEludGVnZXI+IGNvcHlfaXQgPSB0ZW1wLmdldChqKS5zLml0ZXJhdG9yKCk7XG4gICAgICAgICAgd2hpbGUgKGNvcHlfaXQuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICBJbnRlZ2VyIGJ1Zl92YWwgPSBjb3B5X2l0Lm5leHQoKTtcbiAgICAgICAgICAgIGJ1Zi5zLmFkZChidWZfdmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGlmICghYnVmLnMuY29udGFpbnMoeCkpIGJ1Zi5zLmFkZCh4KTtcbiAgICAgIFMucHV0KHgsIGJ1Zik7XG4gICAgfVxuICAgIExpc3Q8SW50ZWdlcj4gYW5zID0gbmV3IEFycmF5TGlzdDw+KCk7XG4gICAgbm9kZSBidWYgPSBuZXcgbm9kZSgpO1xuICAgIFNldDxNYXAuRW50cnk8SW50ZWdlciwgbm9kZT4gPiBrZXlfc2V0ID0gUy5lbnRyeVNldCgpO1xuICAgIEl0ZXJhdG9yPE1hcC5FbnRyeTxJbnRlZ2VyLCBub2RlPiA+IGl0ID0ga2V5X3NldC5pdGVyYXRvcigpO1xuICAgIHdoaWxlIChpdC5oYXNOZXh0KCkpIHtcbiAgICAgIE1hcC5FbnRyeTxJbnRlZ2VyLCBub2RlPiBlbnRyeSA9IGl0Lm5leHQoKTtcbiAgICAgIG5vZGUgbWlkID0gZW50cnkuZ2V0VmFsdWUoKTtcbiAgICAgIGlmIChtaWQubGVzcyhidWYpKSBidWYucyA9IG1pZC5zO1xuICAgIH1cbiAgICBJdGVyYXRvcjxJbnRlZ2VyPiBhbm9faXQgPSBidWYucy5pdGVyYXRvcigpO1xuICAgIHdoaWxlIChhbm9faXQuaGFzTmV4dCgpKSB7XG4gICAgICBJbnRlZ2VyIHZhbCA9IGFub19pdC5uZXh0KCk7XG4gICAgICBhbnMuYWRkKHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBhbnM7XG4gIH1cbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgbGFyZ2VzdERpdmlzaWJsZVN1YnNldChzZWxmLCBudW1zOiBMaXN0W2ludF0pIC0+IExpc3RbaW50XTpcbiAgICAgICAgIyBiYXNlIGNhc2UgZm9yIHNpbXBsaWNpdHlcbiAgICAgICAgUyA9IHstMTogc2V0KCl9XG4gICAgICAgIG51bXMuc29ydCgpXG4gICAgICAgIGZvciB4IGluIG51bXM6XG4gICAgICAgICAgICB0ZW1wID0gW11cbiAgICAgICAgICAgIGZvciBkIGluIFM6XG4gICAgICAgICAgICAgICAgaWYgeCAlIGQgPT0gMDpcbiAgICAgICAgICAgICAgICAgICAgU1tkXS5hZGQoeClcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5hcHBlbmQoU1tkXSlcbiAgICAgICAgICAgICAgICAgICAgU1tkXS5yZW1vdmUoeClcbiAgICAgICAgICAgIFNbeF0gPSBtYXgodGVtcCwga2V5PWxlbikgfCB7eH1cbiAgICAgICAgcmV0dXJuIGxpc3QobWF4KFMudmFsdWVzKCksIGtleT1sZW4pKVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIEyLjkuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiLy8gcmVmZXJlbmNlIDIuOS4xLmxhcmdlc3REaXZpc2libGVTdWJzZXQuY3BwXG5cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogIi8vIHJlZmVyZW5jZSAyLjkuMS5sYXJnZXN0RGl2aXNpYmxlU3Vic2V0LmphdmFcblxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBsYXJnZXN0RGl2aXNpYmxlU3Vic2V0KHNlbGYsIG51bXM6IExpc3RbaW50XSkgLT4gTGlzdFtpbnRdOlxuICAgICAgICBTID0gey0xOiBzZXQoKX1cbiAgICAgICAgZm9yIHggaW4gc29ydGVkKG51bXMpOlxuICAgICAgICAgICAgU1t4XSA9IG1heCgoU1tkXSBmb3IgZCBpbiBTIGlmIHggJSBkID09IDApLCBrZXk9bGVuKSB8IHt4fVxuICAgICAgICByZXR1cm4gbGlzdChtYXgoUy52YWx1ZXMoKSwga2V5PWxlbikpXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTIuMTAuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAidHlwZWRlZiBsb25nIGxvbmcgbGw7XG5cbmNvbnN0IGxsIG1hZ2ljID0gMTAwMDAwMDAwN0xMO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIGxsIGZhY3RvcmlhbChsbCBuKSB7XG4gICAgcmV0dXJuIChuIDw9IDFMTCkgPyAxTEwgOiBuICUgbWFnaWMgKiAoZmFjdG9yaWFsKG4gLSAxKSAlIG1hZ2ljKSAlIG1hZ2ljO1xuICB9XG4gIGxsIG51bVByaW1lQXJyYW5nZW1lbnRzKGxsIG4pIHtcbiAgICBsbCBwcmltZXNbXSA9IHtcbiAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAzLFxuICAgICAgICAgICAgNSxcbiAgICAgICAgICAgIDcsXG4gICAgICAgICAgICAxMSxcbiAgICAgICAgICAgIDEzLFxuICAgICAgICAgICAgMTcsXG4gICAgICAgICAgICAxOSxcbiAgICAgICAgICAgIDIzLFxuICAgICAgICAgICAgMjksXG4gICAgICAgICAgICAzMSxcbiAgICAgICAgICAgIDM3LFxuICAgICAgICAgICAgNDEsXG4gICAgICAgICAgICA0MyxcbiAgICAgICAgICAgIDQ3LFxuICAgICAgICAgICAgNTMsXG4gICAgICAgICAgICA1OSxcbiAgICAgICAgICAgIDYxLFxuICAgICAgICAgICAgNjcsXG4gICAgICAgICAgICA3MSxcbiAgICAgICAgICAgIDczLFxuICAgICAgICAgICAgNzksXG4gICAgICAgICAgICA4MyxcbiAgICAgICAgICAgIDg5LFxuICAgICAgICAgICAgOTcsXG4gICAgICAgICAgICAxMDEsXG4gICAgfTtcbiAgICBpbnQgcHJpbWVDb3VudCA9IDA7XG4gICAgd2hpbGUgKHByaW1lc1twcmltZUNvdW50XSA8PSBuKVxuICAgICAgcHJpbWVDb3VudCArPSAxO1xuICAgIHJldHVybiBmYWN0b3JpYWwocHJpbWVDb3VudCkgJSBtYWdpYyAqIFxcXG4gICAgICAoZmFjdG9yaWFsKG4gLSBwcmltZUNvdW50KSAlIG1hZ2ljKSAlIG1hZ2ljO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGZpbmFsIGxvbmcgbWFnaWMgPSAobG9uZykxMDAwMDAwMDA3O1xuICBwdWJsaWMgbG9uZyBmYWN0b3JpYWwobG9uZyBuKSB7XG4gICAgcmV0dXJuIChuIDw9IDEpID8gMSA6IG4gJSBtYWdpYyAqIChmYWN0b3JpYWwobiAtIDEpICUgbWFnaWMpICUgbWFnaWM7XG4gIH1cbiAgcHVibGljIGludCBudW1QcmltZUFycmFuZ2VtZW50cyhpbnQgbikge1xuICAgIGludFtdIHByaW1lcyA9IHtcbiAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAzLFxuICAgICAgICAgICAgNSxcbiAgICAgICAgICAgIDcsXG4gICAgICAgICAgICAxMSxcbiAgICAgICAgICAgIDEzLFxuICAgICAgICAgICAgMTcsXG4gICAgICAgICAgICAxOSxcbiAgICAgICAgICAgIDIzLFxuICAgICAgICAgICAgMjksXG4gICAgICAgICAgICAzMSxcbiAgICAgICAgICAgIDM3LFxuICAgICAgICAgICAgNDEsXG4gICAgICAgICAgICA0MyxcbiAgICAgICAgICAgIDQ3LFxuICAgICAgICAgICAgNTMsXG4gICAgICAgICAgICA1OSxcbiAgICAgICAgICAgIDYxLFxuICAgICAgICAgICAgNjcsXG4gICAgICAgICAgICA3MSxcbiAgICAgICAgICAgIDczLFxuICAgICAgICAgICAgNzksXG4gICAgICAgICAgICA4MyxcbiAgICAgICAgICAgIDg5LFxuICAgICAgICAgICAgOTcsXG4gICAgICAgICAgICAxMDFcbiAgICB9O1xuICAgIGludCBwcmltZUNvdW50ID0gMDtcbiAgICB3aGlsZSAocHJpbWVzW3ByaW1lQ291bnRdIDw9IG4pXG4gICAgICBwcmltZUNvdW50ICs9IDE7XG4gICAgcmV0dXJuIChpbnQpKGZhY3RvcmlhbCgobG9uZylwcmltZUNvdW50KSAlIG1hZ2ljICpcbiAgICAgIChmYWN0b3JpYWwoKGxvbmcpbiAtIChsb25nKXByaW1lQ291bnQpICUgbWFnaWMpICUgbWFnaWMpO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIG51bVByaW1lQXJyYW5nZW1lbnRzKHNlbGYsIG46IGludCkgLT4gaW50OlxuICAgICAgICBkZWYgZmFjdG9yaWFsKG4pIC0+IGludDpcbiAgICAgICAgICAgIGlmIG4gPD0gMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICAgICAgcmV0dXJuIG4gKiBmYWN0b3JpYWwobiAtIDEpXG5cbiAgICAgICAgcHJpbWVzID0gW1xuICAgICAgICAgICAgMixcbiAgICAgICAgICAgIDMsXG4gICAgICAgICAgICA1LFxuICAgICAgICAgICAgNyxcbiAgICAgICAgICAgIDExLFxuICAgICAgICAgICAgMTMsXG4gICAgICAgICAgICAxNyxcbiAgICAgICAgICAgIDE5LFxuICAgICAgICAgICAgMjMsXG4gICAgICAgICAgICAyOSxcbiAgICAgICAgICAgIDMxLFxuICAgICAgICAgICAgMzcsXG4gICAgICAgICAgICA0MSxcbiAgICAgICAgICAgIDQzLFxuICAgICAgICAgICAgNDcsXG4gICAgICAgICAgICA1MyxcbiAgICAgICAgICAgIDU5LFxuICAgICAgICAgICAgNjEsXG4gICAgICAgICAgICA2NyxcbiAgICAgICAgICAgIDcxLFxuICAgICAgICAgICAgNzMsXG4gICAgICAgICAgICA3OSxcbiAgICAgICAgICAgIDgzLFxuICAgICAgICAgICAgODksXG4gICAgICAgICAgICA5NyxcbiAgICAgICAgICAgIDEwMSxcbiAgICAgICAgXVxuXG4gICAgICAgIHByaW1lQ291bnQgPSAwXG4gICAgICAgIHdoaWxlIHByaW1lc1twcmltZUNvdW50XSA8PSBuOlxuICAgICAgICAgICAgcHJpbWVDb3VudCArPSAxXG4gICAgICAgIHJldHVybiBmYWN0b3JpYWwocHJpbWVDb3VudCkgKiBmYWN0b3JpYWwobiAtIHByaW1lQ291bnQpICUgKDEwICoqIDkgKyA3KVxuXG4iCiAgICB9XQogIH1dCn0sIHsKICAiaWQiOiAiMDMiLAogICJuYW1lIjogIuesrOS4ieeroCIsCiAgImxpc3QiOiBbewogICAgInRpdGxlIjogIuS7o+eggTMuMS4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8aW9zdHJlYW0+XG4jaW5jbHVkZSA8c3RyaW5nPlxuXG5ib29sIGlzUGFsaW5kcm9tZShzdGQ6OnN0cmluZyBzLCBpbnQgbikge1xuICBpbnQgbCA9IDA7XG4gIGludCByID0gbiAtIDE7XG4gIHdoaWxlIChsIDwgcikge1xuICAgIGlmIChzW2xdICE9IHNbcl0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgbCArPSAxO1xuICAgIHIgLT0gMTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGJvb2xlYW4gaXNQYWxpbmRyb21lKFN0cmluZyBzLCBpbnQgbikge1xuICAgIGludCBsID0gMDtcbiAgICBpbnQgciA9IG4gLSAxO1xuICAgIHdoaWxlIChsIDwgcikge1xuICAgICAgaWYgKHMuY2hhckF0KGwpICE9IHMuY2hhckF0KHIpKSByZXR1cm4gZmFsc2U7XG4gICAgICBsICs9IDE7XG4gICAgICByIC09IDE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkpzIiwKICAgICAgImNvbnRlbnQiOiAiZnVuY3Rpb24gaXNQYWxpbmRyb21lKHMsIG4pIHtcbiAgbGV0IGwgPSAwXG4gIGxldCByID0gbiAtIDFcbiAgd2hpbGUgKGwgPCByKSB7XG4gICAgaWYgKHNbbF0gIT09IHNbcl0pIHJldHVybiBmYWxzZVxuICAgIGwgKz0gMVxuICAgIHIgLT0gMVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZGVmIGlzUGFsaW5kcm9tZShzOiBzdHIsIG46IGludCkgLT4gYm9vbDpcbiAgICBsID0gMFxuICAgIHIgPSBuIC0gMVxuICAgIHdoaWxlIGwgPCByOlxuICAgICAgICBpZiBzW2xdICE9IHNbcl06XG4gICAgICAgICAgICByZXR1cm4gRmFsc2VcbiAgICAgICAgbCArPSAxXG4gICAgICAgIHIgLT0gMVxuXG4gICAgcmV0dXJuIFRydWVcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMy4xLjIiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgYm9vbCBpc1BhbGluZHJvbWUoc3RyaW5nIHMsIGludCBpLCBpbnQgbikge1xuICAgIGludCBsID0gMDtcbiAgICBpbnQgciA9IG4gLSAxO1xuICAgIHdoaWxlIChsIDwgcikge1xuICAgICAgaWYgKGwgPT0gaSlcbiAgICAgICAgbCArPSAxO1xuICAgICAgZWxzZSBpZiAociA9PSBpKVxuICAgICAgICByIC09IDE7XG4gICAgICBpZiAoc1tsXSAhPSBzW3JdKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBsICs9IDE7XG4gICAgICByIC09IDE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGJvb2wgdmFsaWRQYWxpbmRyb21lKHN0cmluZyBzKSB7XG4gICAgaW50IG4gPSBzLmxlbmd0aCgpO1xuICAgIGludCBsID0gMDtcbiAgICBpbnQgciA9IG4gLSAxO1xuICAgIHdoaWxlIChsIDwgcikge1xuICAgICAgaWYgKHNbbF0gIT0gc1tyXSkge1xuICAgICAgICByZXR1cm4gaXNQYWxpbmRyb21lKHMsIGwsIG4pIHx8IGlzUGFsaW5kcm9tZShzLCByLCBuKTtcbiAgICAgIH1cbiAgICAgIGwgKz0gMTtcbiAgICAgIHIgLT0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICBwcml2YXRlIGJvb2xlYW4gaXNQYWxpbmRyb21lKFN0cmluZyBzLCBpbnQgaSwgaW50IG4pIHtcbiAgICBpbnQgbCA9IDA7XG4gICAgaW50IHIgPSBuIC0gMTtcbiAgICB3aGlsZSAobCA8IHIpIHtcbiAgICAgIGlmIChsID09IGkpIGwgKz0gMTtcbiAgICAgIGVsc2UgaWYgKHIgPT0gaSkgciAtPSAxO1xuICAgICAgaWYgKHMuY2hhckF0KGwpICE9IHMuY2hhckF0KHIpKSByZXR1cm4gZmFsc2U7XG4gICAgICBsICs9IDE7XG4gICAgICByIC09IDE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIGJvb2xlYW4gdmFsaWRQYWxpbmRyb21lKFN0cmluZyBzKSB7XG4gICAgaW50IG4gPSBzLmxlbmd0aCgpO1xuICAgIGludCBsID0gMDtcbiAgICBpbnQgciA9IG4gLSAxO1xuICAgIHdoaWxlIChsIDwgcikge1xuICAgICAgaWYgKHMuY2hhckF0KGwpICE9IHMuY2hhckF0KHIpKSB7XG4gICAgICAgIHJldHVybiBpc1BhbGluZHJvbWUocywgbCwgbikgfHwgaXNQYWxpbmRyb21lKHMsIHIsIG4pO1xuICAgICAgfVxuICAgICAgbCArPSAxO1xuICAgICAgciAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKcyIsCiAgICAgICJjb250ZW50IjogIi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IHZhbGlkUGFsaW5kcm9tZSA9IGZ1bmN0aW9uKHMpIHtcbiAgZnVuY3Rpb24gaXNQYWxpbmRyb21lKHMsIGksIG4pIHtcbiAgICBsZXQgbCA9IDBcbiAgICBsZXQgciA9IG4gLSAxXG4gICAgd2hpbGUgKGwgPCByKSB7XG4gICAgICBpZiAobCA9PSBpKSBsICs9IDFcbiAgICAgIGVsc2UgaWYgKHIgPT0gaSkgciAtPSAxXG4gICAgICBpZiAocy5jaGFyQXQobCkgIT0gcy5jaGFyQXQocikpIHJldHVybiBmYWxzZVxuICAgICAgbCArPSAxXG4gICAgICByIC09IDFcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNvbnN0IG4gPSBzLmxlbmd0aFxuICBsZXQgbCA9IDBcbiAgbGV0IHIgPSBuIC0gMVxuICB3aGlsZSAobCA8IHIpIHtcbiAgICBpZiAocy5jaGFyQXQobCkgIT0gcy5jaGFyQXQocikpIHtcbiAgICAgIHJldHVybiBpc1BhbGluZHJvbWUocywgbCwgbikgfHwgaXNQYWxpbmRyb21lKHMsIHIsIG4pXG4gICAgfVxuICAgIGwgKz0gMVxuICAgIHIgLT0gMVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHZhbGlkUGFsaW5kcm9tZShzZWxmLCBzOiBzdHIpIC0+IGJvb2w6XG4gICAgICAgIG4gPSBsZW4ocylcblxuICAgICAgICBkZWYgaXNQYWxpbmRyb21lKHM6IHN0ciwgaTogaW50LCBuOiBpbnQpIC0+IGJvb2w6XG4gICAgICAgICAgICBsID0gMFxuICAgICAgICAgICAgciA9IG4gLSAxXG4gICAgICAgICAgICB3aGlsZSBsIDwgcjpcbiAgICAgICAgICAgICAgICBpZiBsID09IGk6XG4gICAgICAgICAgICAgICAgICAgIGwgKz0gMVxuICAgICAgICAgICAgICAgIGVsaWYgciA9PSBpOlxuICAgICAgICAgICAgICAgICAgICByIC09IDFcbiAgICAgICAgICAgICAgICBpZiBzW2xdICE9IHNbcl06XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGYWxzZVxuICAgICAgICAgICAgICAgIGwgKz0gMVxuICAgICAgICAgICAgICAgIHIgLT0gMVxuXG4gICAgICAgICAgICByZXR1cm4gVHJ1ZVxuXG4gICAgICAgIGwgPSAwXG4gICAgICAgIHIgPSBuIC0gMVxuXG4gICAgICAgIHdoaWxlIGwgPCByOlxuICAgICAgICAgICAgaWYgc1tsXSAhPSBzW3JdOlxuICAgICAgICAgICAgICAgIHJldHVybiBpc1BhbGluZHJvbWUocywgbCwgbikgb3IgaXNQYWxpbmRyb21lKHMsIHIsIG4pXG4gICAgICAgICAgICBsICs9IDFcbiAgICAgICAgICAgIHIgLT0gMVxuICAgICAgICByZXR1cm4gVHJ1ZVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIEzLjIuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI2luY2x1ZGUgPGNzdGRpbz5cbiNpbmNsdWRlIDxjc3RkbGliPlxuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIExpc3ROb2RlICpyZXZlcnNlTGlzdChMaXN0Tm9kZSAqaGVhZCkge1xuICAgIGlmICghaGVhZCkgcmV0dXJuIE5VTEw7XG4gICAgTGlzdE5vZGUgKnByZXYgPSBOVUxMLCAqY3VyID0gaGVhZDtcbiAgICB3aGlsZSAoY3VyKSB7XG4gICAgICBjdXItPm5leHQgPSBwcmV2O1xuICAgICAgcHJldiA9IGN1cjtcbiAgICAgIGN1ciA9IGN1ci0+bmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHByZXY7XG4gIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJwdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICBwdWJsaWMgTGlzdE5vZGUgcmV2ZXJzZUxpc3QoTGlzdE5vZGUgaGVhZCkge1xuICAgIGlmICghaGVhZCkgcmV0dXJuIG51bGw7XG4gICAgTGlzdE5vZGUgcHJldiA9IG51bGwsIGN1ciA9IGhlYWQ7XG4gICAgd2hpbGUgKGN1cikge1xuICAgICAgY3VyLm5leHQgPSBwcmV2O1xuICAgICAgcHJldiA9IGN1cjtcbiAgICAgIGN1ciA9IGN1ci5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcHJldjtcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiByZXZlcnNlTGlzdChzZWxmLCBoZWFkOiBMaXN0Tm9kZSkgLT4gTGlzdE5vZGU6XG4gICAgICAgIGlmIG5vdCBoZWFkOlxuICAgICAgICAgICAgcmV0dXJuIE5vbmVcbiAgICAgICAgcHJldiA9IE5vbmVcbiAgICAgICAgY3VyID0gaGVhZFxuICAgICAgICB3aGlsZSBjdXI6XG4gICAgICAgICAgICBjdXIubmV4dCwgcHJldiwgY3VyID0gcHJldiwgY3VyLCBjdXIubmV4dFxuICAgICAgICByZXR1cm4gcHJldlxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIEzLjIuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI2luY2x1ZGUgPGNzdGRpbz5cbiNpbmNsdWRlIDxjc3RkbGliPlxuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIGJvb2wgaXNQYWxpbmRyb21lKExpc3ROb2RlICpoZWFkKSB7XG4gICAgTGlzdE5vZGUgKnByZSA9IE5VTEw7XG4gICAgTGlzdE5vZGUgKnNsb3cgPSBoZWFkLCAqZmFzdCA9IGhlYWQ7XG4gICAgd2hpbGUgKGZhc3QgJiYgZmFzdC0+bmV4dCkge1xuICAgICAgZmFzdCA9IGZhc3QtPm5leHQtPm5leHQ7XG4gICAgICBMaXN0Tm9kZSAqbmV4dCA9IHNsb3ctPm5leHQ7XG4gICAgICBzbG93LT5uZXh0ID0gcHJlO1xuICAgICAgcHJlID0gc2xvdztcbiAgICAgIHNsb3cgPSBuZXh0O1xuICAgIH1cbiAgICBpZiAoZmFzdCkgc2xvdyA9IHNsb3ctPm5leHQ7XG4gICAgd2hpbGUgKHNsb3cpIHtcbiAgICAgIGlmIChzbG93LT52YWwgIT0gcHJlLT52YWwpIHJldHVybiBmYWxzZTtcbiAgICAgIHByZSA9IHByZS0+bmV4dDtcbiAgICAgIHNsb3cgPSBzbG93LT5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogInB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBib29sZWFuIGlzUGFsaW5kcm9tZShMaXN0Tm9kZSBoZWFkKSB7XG4gICAgTGlzdE5vZGUgcHJlID0gbnVsbDtcbiAgICBMaXN0Tm9kZSBzbG93ID0gaGVhZCwgZmFzdCA9IGhlYWQ7XG4gICAgd2hpbGUgKGZhc3QgIT0gbnVsbCAmJiBmYXN0Lm5leHQgIT0gbnVsbCkge1xuICAgICAgZmFzdCA9IGZhc3QubmV4dC5uZXh0O1xuICAgICAgTGlzdE5vZGUgbmV4dCA9IHNsb3cubmV4dDtcbiAgICAgIHNsb3cubmV4dCA9IHByZTtcbiAgICAgIHByZSA9IHNsb3c7XG4gICAgICBzbG93ID0gbmV4dDtcbiAgICB9XG4gICAgaWYgKGZhc3QgIT0gbnVsbCkgc2xvdyA9IHNsb3cubmV4dDtcbiAgICB3aGlsZSAoc2xvdyAhPSBudWxsKSB7XG4gICAgICBpZiAoc2xvdy52YWwgIT0gcHJlLnZhbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgcHJlID0gcHJlLm5leHQ7XG4gICAgICBzbG93ID0gc2xvdy5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBpc1BhbGluZHJvbWUoc2VsZiwgaGVhZDogTGlzdE5vZGUpIC0+IGJvb2w6XG4gICAgICAgIHByZSA9IE5vbmVcbiAgICAgICAgc2xvdyA9IGZhc3QgPSBoZWFkXG5cbiAgICAgICAgIyDkuIDovrnlj43ovazliY3ljYrpg6jliIbvvIzkuIDovrnmib7kuK3ngrlcbiAgICAgICAgd2hpbGUgZmFzdCBhbmQgZmFzdC5uZXh0OlxuICAgICAgICAgICAgIyDlhYjmm7TmlrBmYXN05oyH6ZKIXG4gICAgICAgICAgICBmYXN0ID0gZmFzdC5uZXh0Lm5leHRcbiAgICAgICAgICAgICMg5YaN5Y+N6L2s5ZKM5pu05pawc2xvd+aMh+mSiFxuICAgICAgICAgICAgbmV4dCA9IHNsb3cubmV4dFxuICAgICAgICAgICAgc2xvdy5uZXh0ID0gcHJlXG4gICAgICAgICAgICBwcmUgPSBzbG93XG4gICAgICAgICAgICBzbG93ID0gbmV4dFxuICAgICAgICAjIOWkhOeQhuWlh+aVsOS4quiKgueCueeahOaDheWGtVxuICAgICAgICBpZiBmYXN0OlxuICAgICAgICAgICAgc2xvdyA9IHNsb3cubmV4dFxuICAgICAgICAjIOS7juS4reeCueW8gOWni+WIhuWIq+WQkeWJjeWSjOWQjumBjeWOhu+8jOmAkOS4quavlOi+g+aYr+WQpuebuOWQjOWNs+WPr1xuICAgICAgICB3aGlsZSBzbG93OlxuICAgICAgICAgICAgaWYgc2xvdy52YWwgIT0gcHJlLnZhbDpcbiAgICAgICAgICAgICAgICByZXR1cm4gRmFsc2VcbiAgICAgICAgICAgIHByZSA9IHByZS5uZXh0XG4gICAgICAgICAgICBzbG93ID0gc2xvdy5uZXh0XG4gICAgICAgIHJldHVybiBUcnVlXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTMuMy4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIGJvb2wgaXNQYWxpbmRyb21lKGludCB4KSB7XG4gICAgaWYgKHggPCAwKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHggPT0gMCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHggJSAxMCA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgaW50IHJlcyA9IDAsIGNvcHkgPSB4O1xuICAgIHdoaWxlICh4ID4gMCkge1xuICAgICAgcmVzID0gcmVzICogMTAgKyAoeCAlIDEwKTtcbiAgICAgIHggLz0gMTA7XG4gICAgfVxuICAgIHJldHVybiBjb3B5ID09IHJlcztcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogInB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBib29sZWFuIGlzUGFsaW5kcm9tZShpbnQgeCkge1xuICAgIGlmICh4IDwgMCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh4ID09IDApIHJldHVybiB0cnVlO1xuICAgIGlmICh4ICUgMTAgPT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIGludCByZXMgPSAwLCBjb3B5ID0geDtcbiAgICB3aGlsZSAoeCAgPiAwKSB7XG4gICAgICByZXMgPSByZXMgKiAxMCArICh4ICUgMTApO1xuICAgICAgeCA9IHggLyAxMDtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHkgPT0gcmVzO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGlzUGFsaW5kcm9tZShzZWxmLCB4OiBpbnQpIC0+IGJvb2w6XG4gICAgICAgIGlmIHggPCAwOlxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXG4gICAgICAgIGlmIHggPT0gMDpcbiAgICAgICAgICAgIHJldHVybiBUcnVlXG4gICAgICAgIGlmIHggJSAxMCA9PSAwOlxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXG5cbiAgICAgICAgcmVzID0gMFxuICAgICAgICBjb3B5ID0geFxuICAgICAgICB3aGlsZSB4ID4gMDpcbiAgICAgICAgICAgIHJlcyA9IHJlcyAqIDEwICsgKHggJSAxMClcbiAgICAgICAgICAgIHggPSB4IC8vIDEwXG5cbiAgICAgICAgcmV0dXJuIGNvcHkgPT0gcmVzXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTMuNC4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8c3RyaW5nPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICBzdHJpbmcgZXh0ZW5kKGludCBpLCBpbnQgaiwgc3RyaW5nIHMpIHtcbiAgICB3aGlsZSAoaSA+PSAwICYmIGogPCBzLmxlbmd0aCgpICYmIHNbaV0gPT0gc1tqXSkge1xuICAgICAgaSAtPSAxO1xuICAgICAgaiArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gcy5zdWJzdHIoaSArIDEsIGogLSBpIC0gMSk7XG4gIH1cbiAgc3RyaW5nIGxvbmdlc3RQYWxpbmRyb21lKHN0cmluZyBzKSB7XG4gICAgaW50IG4gPSBzLmxlbmd0aCgpO1xuICAgIGlmIChuID09IDApIHJldHVybiBcIlwiO1xuICAgIHN0cmluZyByZXMgPSBzLnN1YnN0cigwLCAxKTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgIHN0cmluZyBlMSA9IGV4dGVuZChpLCBpLCBzKTtcbiAgICAgIHN0cmluZyBlMiA9IGV4dGVuZChpLCBpICsgMSwgcyk7XG4gICAgICBpZiAobWF4KGUxLmxlbmd0aCgpLCBlMi5sZW5ndGgoKSkgPiByZXMubGVuZ3RoKCkpXG4gICAgICAgIHJlcyA9ICgoZTEubGVuZ3RoKCkgPiBlMi5sZW5ndGgoKSkgPyBlMSA6IGUyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBqYXZhLnV0aWwuKjtcbmltcG9ydCBqYXZhLmxhbmcuTWF0aDtcblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIFN0cmluZyBleHRlbmQoaW50IGksIGludCBqLCBTdHJpbmcgcykge1xuICAgIHdoaWxlIChpID49IDAgJiYgaiA8IHMubGVuZ3RoKCkgJiYgcy5jaGFyQXQoaSkgPT1cbiAgICAgICAgcy5jaGFyQXQoaikpIHtcbiAgICAgIGkgLT0gMTtcbiAgICAgIGogKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHMuc3Vic3RyaW5nKGkgKyAxLCBqKTtcbiAgfVxuICBwdWJsaWMgU3RyaW5nIGxvbmdlc3RQYWxpbmRyb21lKFN0cmluZyBzKSB7XG4gICAgaW50IG4gPSBzLmxlbmd0aCgpO1xuICAgIGlmIChuID09IDApIHJldHVybiBcIlwiO1xuICAgIFN0cmluZyByZXMgPSBzLnN1YnN0cmluZygwLCAxKTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgIFN0cmluZyBlMSA9IGV4dGVuZChpLCBpLCBzKTtcbiAgICAgIFN0cmluZyBlMiA9IGV4dGVuZChpLCBpICsgMSwgcyk7XG4gICAgICBpZiAoTWF0aC5tYXgoZTEubGVuZ3RoKCksIGUyLmxlbmd0aCgpKSA+IHJlcy5sZW5ndGgoKSlcbiAgICAgICAgcmVzID0gKChlMS5sZW5ndGgoKSA+IGUyLmxlbmd0aCgpKSA/IGUxIDogZTIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGxvbmdlc3RQYWxpbmRyb21lKHNlbGYsIHM6IHN0cikgLT4gc3RyOlxuICAgICAgICBuID0gbGVuKHMpXG4gICAgICAgIGlmIG4gPT0gMDpcbiAgICAgICAgICAgIHJldHVybiBcIlwiXG4gICAgICAgIHJlcyA9IHNbMF1cblxuICAgICAgICBkZWYgZXh0ZW5kKGk6IGludCwgajogaW50LCBzOiBzdHIpIC0+IHN0cjpcbiAgICAgICAgICAgIHdoaWxlIGkgPj0gMCBhbmQgaiA8IGxlbihzKSBhbmQgc1tpXSA9PSBzW2pdOlxuICAgICAgICAgICAgICAgIGkgLT0gMVxuICAgICAgICAgICAgICAgIGogKz0gMVxuICAgICAgICAgICAgcmV0dXJuIHNbaSArIDEgOiBqXVxuXG4gICAgICAgIGZvciBpIGluIHJhbmdlKG4gLSAxKTpcbiAgICAgICAgICAgICMg5Lul6Ieq6Lqr5Li65Lit5b+D54K5XG4gICAgICAgICAgICBlMSA9IGV4dGVuZChpLCBpLCBzKVxuICAgICAgICAgICAgIyDku6Xoh6rouqvlkozoh6rouqvnmoTkuIvkuIDkuKrlhYPntKDkuLrkuK3lv4PngrlcbiAgICAgICAgICAgIGUyID0gZXh0ZW5kKGksIGkgKyAxLCBzKVxuICAgICAgICAgICAgaWYgbWF4KGxlbihlMSksIGxlbihlMikpID4gbGVuKHJlcyk6XG4gICAgICAgICAgICAgICAgcmVzID0gZTEgaWYgbGVuKGUxKSA+IGxlbihlMikgZWxzZSBlMlxuICAgICAgICByZXR1cm4gcmVzXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTMuNS4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8Y3N0ZGxpYj5cbiNpbmNsdWRlIDxzdHJpbmc+XG4jaW5jbHVkZSA8YWxnb3JpdGhtPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICBpbnQgbG9uZ2VzdFBhbGluZHJvbWVTdWJzZXEoc3RyaW5nIHMpIHtcbiAgICBpbnQgbiA9IHMubGVuZ3RoKCk7XG4gICAgaW50ICoqZHAgPSAoaW50ICoqKW1hbGxvYyhuICogc2l6ZW9mKGludCAqKSk7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGRwW2ldID0gKGludCAqKW1hbGxvYyhuICogc2l6ZW9mKGludCkpO1xuICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBuOyBqKyspIGRwW2ldW2pdID0gMDtcbiAgICB9XG4gICAgZm9yIChpbnQgaSA9IG4gLSAxOyBpID49IDA7IGktLSlcbiAgICAgIGZvciAoaW50IGogPSBpOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGlmIChpID09IGopIGRwW2ldW2pdID0gMTtcbiAgICAgICAgZWxzZSBpZiAoc1tpXSA9PSBzW2pdKVxuICAgICAgICAgIGRwW2ldW2pdID0gZHBbaSArIDFdW2ogLSAxXSArIDI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBkcFtpXVtqXSA9IG1heChkcFtpICsgMV1bal0sIGRwW2ldW2ogLSAxXSk7XG4gICAgICB9XG4gICAgaW50IGFucyA9IGRwWzBdW24gLSAxXTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG47IGkrKykgZnJlZShkcFtpXSk7XG4gICAgZnJlZShkcCk7XG4gICAgcmV0dXJuIGFucztcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBqYXZhLmxhbmcuTWF0aDtcblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGludCBsb25nZXN0UGFsaW5kcm9tZVN1YnNlcShTdHJpbmcgcykge1xuICAgIGludCBuID0gcy5sZW5ndGgoKTtcbiAgICBpbnRbXVtdIGRwID0gbmV3IGludFtuXVtuXTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG47IGkrKylcbiAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgbjsgaisrKSBkcFtpXVtqXSA9IDA7XG4gICAgZm9yIChpbnQgaSA9IG4gLSAxOyBpID49IDA7IGktLSlcbiAgICAgIGZvciAoaW50IGogPSBpOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGlmIChpID09IGopIGRwW2ldW2pdID0gMTtcbiAgICAgICAgZWxzZSBpZiAocy5jaGFyQXQoaSkgPT0gcy5jaGFyQXQoaikpXG4gICAgICAgICAgZHBbaV1bal0gPSBkcFtpICsgMV1baiAtIDFdICsgMjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGRwW2ldW2pdID0gTWF0aC5tYXgoZHBbaSArIDFdW2pdLCBkcFtpXVtqIC0gMV0pO1xuICAgICAgfVxuICAgIHJldHVybiBkcFswXVtuIC0gMV07XG4gIH1cbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgbG9uZ2VzdFBhbGluZHJvbWVTdWJzZXEoc2VsZiwgczogc3RyKSAtPiBpbnQ6XG4gICAgICAgIG4gPSBsZW4ocylcbiAgICAgICAgZHAgPSBbWzBdICogbiBmb3IgaSBpbiByYW5nZShuKV1cblxuICAgICAgICBmb3IgaSBpbiByZXZlcnNlZChyYW5nZShuKSk6XG4gICAgICAgICAgICBmb3IgaiBpbiByYW5nZShpLCBuKTpcbiAgICAgICAgICAgICAgICBpZiBpID09IGo6XG4gICAgICAgICAgICAgICAgICAgIGRwW2ldW2pdID0gMVxuICAgICAgICAgICAgICAgIGVsaWYgc1tpXSA9PSBzW2pdOlxuICAgICAgICAgICAgICAgICAgICBkcFtpXVtqXSA9IGRwW2kgKyAxXVtqIC0gMV0gKyAyXG4gICAgICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICAgICAgZHBbaV1bal0gPSBtYXgoZHBbaSArIDFdW2pdLCBkcFtpXVtqIC0gMV0pXG4gICAgICAgIHJldHVybiBkcFswXVtuIC0gMV1cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMy41LjIiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDxjc3RkbGliPlxuI2luY2x1ZGUgPHN0cmluZz5cbiNpbmNsdWRlIDxhbGdvcml0aG0+XG51c2luZyBuYW1lc3BhY2Ugc3RkO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIGludCBsb25nZXN0UGFsaW5kcm9tZVN1YnNlcShzdHJpbmcgcykge1xuICAgIGludCBuID0gcy5sZW5ndGgoKTtcbiAgICBpbnQgKnByZSA9IChpbnQgKiltYWxsb2MobiAqIHNpemVvZihpbnQpKTtcbiAgICBpbnQgKmN1ciA9IChpbnQgKiltYWxsb2MobiAqIHNpemVvZihpbnQpKTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG47IGkrKylcbiAgICAgIHByZVtpXSA9IGN1cltpXSA9IDA7XG4gICAgZm9yIChpbnQgaSA9IG4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgZm9yIChpbnQgaiA9IGk7IGogPCBuOyBqKyspIHtcbiAgICAgICAgaWYgKGkgPT0gaikgY3VyW2pdID0gMTtcbiAgICAgICAgZWxzZSBpZiAoc1tpXSA9PSBzW2pdKVxuICAgICAgICAgIGN1cltqXSA9IHByZVtqIC0gMV0gKyAyO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgY3VyW2pdID0gbWF4KHByZVtqXSwgY3VyW2ogLSAxXSk7XG4gICAgICB9XG4gICAgICBmb3IgKGludCBqID0gMDsgaiA8IG47IGorKykgcHJlW2pdID0gY3VyW2pdO1xuICAgIH1cbiAgICBpbnQgYW5zID0gcHJlW24gLSAxXTtcbiAgICBmcmVlKHByZSk7XG4gICAgZnJlZShjdXIpO1xuICAgIHJldHVybiBhbnM7XG4gIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJpbXBvcnQgamF2YS5sYW5nLk1hdGg7XG5cbnB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBpbnQgbG9uZ2VzdFBhbGluZHJvbWVTdWJzZXEoU3RyaW5nIHMpIHtcbiAgICBpbnQgbiA9IHMubGVuZ3RoKCk7XG4gICAgaW50W10gcHJlID0gbmV3IGludFtuXTtcbiAgICBpbnRbXSBjdXIgPSBuZXcgaW50W25dO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKSBwcmVbaV0gPSBjdXJbaV0gPSAwO1xuICAgIGZvciAoaW50IGkgPSBuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGZvciAoaW50IGogPSBpOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGlmIChpID09IGopIGN1cltqXSA9IDE7XG4gICAgICAgIGVsc2UgaWYgKHMuY2hhckF0KGkpID09IHMuY2hhckF0KGopKVxuICAgICAgICAgIGN1cltqXSA9IHByZVtqIC0gMV0gKyAyO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgY3VyW2pdID0gTWF0aC5tYXgocHJlW2pdLCBjdXJbaiAtIDFdKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgbjsgaisrKSBwcmVbal0gPSBjdXJbal07XG4gICAgfVxuICAgIHJldHVybiBwcmVbbiAtIDFdO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGxvbmdlc3RQYWxpbmRyb21lU3Vic2VxKHNlbGYsIHM6IHN0cikgLT4gaW50OlxuICAgICAgICBuID0gbGVuKHMpXG4gICAgICAgIHByZSA9IFswXSAqIG5cbiAgICAgICAgY3VyID0gWzBdICogblxuXG4gICAgICAgIGZvciBpIGluIHJldmVyc2VkKHJhbmdlKG4pKTpcbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKGksIG4pOlxuICAgICAgICAgICAgICAgIGlmIGkgPT0gajpcbiAgICAgICAgICAgICAgICAgICAgY3VyW2pdID0gMVxuICAgICAgICAgICAgICAgIGVsaWYgc1tpXSA9PSBzW2pdOlxuICAgICAgICAgICAgICAgICAgICBjdXJbal0gPSBwcmVbaiAtIDFdICsgMlxuICAgICAgICAgICAgICAgIGVsc2U6XG4gICAgICAgICAgICAgICAgICAgIGN1cltqXSA9IG1heChwcmVbal0sIGN1cltqIC0gMV0pXG4gICAgICAgICAgICBwcmUgPSBjdXIuY29weSgpXG4gICAgICAgIHJldHVybiBwcmVbLTFdXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTMuNi4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8Y21hdGg+XG4jaW5jbHVkZSA8Y3N0ZGxpYj5cbiNpbmNsdWRlIDxzdHJpbmc+XG51c2luZyBuYW1lc3BhY2Ugc3RkO1xuXG50eXBlZGVmIGxvbmcgbG9uZyBsbDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICBib29sIHZhbGlkUGFsaW5kcm9tZShzdHJpbmcgcykge1xuICAgIGludCBsID0gMCwgciA9IHMubGVuZ3RoKCkgLSAxO1xuICAgIHdoaWxlIChsIDwgcikge1xuICAgICAgaWYgKHNbbF0gIT0gc1tyXSkgcmV0dXJuIGZhbHNlO1xuICAgICAgbCArPSAxO1xuICAgICAgciAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbnQgc3VwZXJwYWxpbmRyb21lc0luUmFuZ2Uoc3RyaW5nIEwsIHN0cmluZyBSKSB7XG4gICAgaW50IGNudCA9IDA7XG4gICAgbGwgbF9udW0gPSAwTEwsIHJfbnVtID0gMExMO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgTC5sZW5ndGgoKTsgaSsrKVxuICAgICAgbF9udW0gPSAobF9udW0gKiAxMExMKSArIGxsKExbaV0gLSAnMCcpO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUi5sZW5ndGgoKTsgaSsrKVxuICAgICAgcl9udW0gPSAocl9udW0gKiAxMExMKSArIGxsKFJbaV0gLSAnMCcpO1xuICAgIGZvciAobGwgaSA9IGxsKGZsb29yKHNxcnQoZG91YmxlKGxfbnVtKSkpKTtcbiAgICAgICAgaSA8IGxsKGNlaWwoc3FydChkb3VibGUocl9udW0pKSkpOyBpICs9IDFMTClcbiAgICAgIGlmICh2YWxpZFBhbGluZHJvbWUodG9fc3RyaW5nKGkpKSAmJiBcXFxuICAgICAgICAgIHZhbGlkUGFsaW5kcm9tZSh0b19zdHJpbmcoaSAqIGkpKSkgY250ICs9IDE7XG4gICAgcmV0dXJuIGNudDtcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBqYXZhLmxhbmcuTWF0aDtcblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGJvb2xlYW4gdmFsaWRQYWxpbmRyb21lKFN0cmluZyBzKSB7XG4gICAgaW50IGwgPSAwLCByID0gcy5sZW5ndGgoKSAtIDE7XG4gICAgd2hpbGUgKGwgPCByKSB7XG4gICAgICBpZiAocy5jaGFyQXQobCkgIT0gcy5jaGFyQXQocikpIHJldHVybiBmYWxzZTtcbiAgICAgIGwgKz0gMTtcbiAgICAgIHIgLT0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcHVibGljIGludCBzdXBlcnBhbGluZHJvbWVzSW5SYW5nZShTdHJpbmcgTCwgU3RyaW5nIFIpIHtcbiAgICBpbnQgY250ID0gMDtcbiAgICBsb25nIGxib3VuZCA9IChsb25nKU1hdGguZmxvb3IoTWF0aC5zcXJ0KExvbmcucGFyc2VMb25nKEwpKSk7XG4gICAgbG9uZyByYm91bmQgPSAobG9uZylNYXRoLmNlaWwoTWF0aC5zcXJ0KExvbmcucGFyc2VMb25nKFIpKSk7XG4gICAgZm9yIChsb25nIGkgPSBsYm91bmQ7IGkgPCByYm91bmQ7IGkgKz0gKGxvbmcpMSlcbiAgICAgIGlmICh2YWxpZFBhbGluZHJvbWUoU3RyaW5nLnZhbHVlT2YoaSkpICYmXG4gICAgICAgICAgdmFsaWRQYWxpbmRyb21lKFN0cmluZy52YWx1ZU9mKGkgKiBpKSkpXG4gICAgICAgIGNudCA9IGNudCArIDE7XG4gICAgcmV0dXJuIGNudDtcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBtYXRoXG5cblxuY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHN1cGVycGFsaW5kcm9tZXNJblJhbmdlKHNlbGYsIEw6IHN0ciwgUjogc3RyKSAtPiBpbnQ6XG4gICAgICAgIGNudCA9IDBcblxuICAgICAgICBkZWYgdmFsaWRQYWxpbmRyb21lKHM6IHN0cikgLT4gYm9vbDpcbiAgICAgICAgICAgIGwgPSAwXG4gICAgICAgICAgICByID0gbGVuKHMpIC0gMVxuICAgICAgICAgICAgd2hpbGUgbCA8IHI6XG4gICAgICAgICAgICAgICAgaWYgc1tsXSAhPSBzW3JdOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFsc2VcbiAgICAgICAgICAgICAgICBsICs9IDFcbiAgICAgICAgICAgICAgICByIC09IDFcbiAgICAgICAgICAgIHJldHVybiBUcnVlXG5cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UobWF0aC5mbG9vcihpbnQoTCkgKiogMC41KSwgbWF0aC5jZWlsKGludChSKSAqKiAwLjUpKTpcbiAgICAgICAgICAgIGlmIHZhbGlkUGFsaW5kcm9tZShzdHIoaSkpIGFuZCB2YWxpZFBhbGluZHJvbWUoc3RyKGkgKiogMikpOlxuICAgICAgICAgICAgICAgIGNudCArPSAxXG4gICAgICAgIHJldHVybiBjbnRcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMy42LjIiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDxtYXA+XG4jaW5jbHVkZSA8c3RyaW5nPlxuI2luY2x1ZGUgPGNtYXRoPlxuI2luY2x1ZGUgPGNzdGRsaWI+XG4jaW5jbHVkZSA8aW9zdHJlYW0+XG4jaW5jbHVkZSA8bGltaXRzLmg+XG51c2luZyBuYW1lc3BhY2Ugc3RkO1xuXG50eXBlZGVmIGxvbmcgbG9uZyBsbDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICBib29sIHZhbGlkUGFsaW5kcm9tZShzdHJpbmcgcykge1xuICAgIGludCBsID0gMCwgciA9IHMubGVuZ3RoKCkgLSAxO1xuICAgIHdoaWxlIChsIDwgcikge1xuICAgICAgaWYgKHNbbF0gIT0gc1tyXSkgcmV0dXJuIGZhbHNlO1xuICAgICAgbCArPSAxO1xuICAgICAgciAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbnQgc3VwZXJwYWxpbmRyb21lc0luUmFuZ2Uoc3RyaW5nIEwsIHN0cmluZyBSKSB7XG4gICAgaW50IGNudCA9IDA7XG4gICAgbGwgaSA9IDE7XG4gICAgbWFwPGxsLCBib29sPiBzZWVuO1xuICAgIHNlZW4uY2xlYXIoKTtcbiAgICB3aGlsZSAoaSA8IDEwMDAwMExMKSB7XG4gICAgICBsbCBwb3dlciA9IGxsKGZsb29yKGxvZyhpKSAvIGxvZygxMC4wKSArIDAuNSkpO1xuICAgICAgbGwgeCA9IGksIHIgPSAwO1xuICAgICAgd2hpbGUgKHggPiAwTEwpIHtcbiAgICAgICAgciA9IHIgKiAxMExMICsgKHggJSAxMExMKTtcbiAgICAgICAgeCAvPSAxMExMO1xuICAgICAgfVxuICAgICAgbGwgUSA9IGxsKGkgKiBwb3coMTAsIHBvd2VyKSArIFxcXG4gICAgICAgICAgciAlIGxsKHBvdygxMCwgcG93ZXIpKSk7XG4gICAgICBpZiAoTExPTkdfTUFYIC8gUSA8IFEpIHJldHVybiBjbnQ7XG4gICAgICBRID0gUSAqIFE7XG4gICAgICBsbCBsX251bSA9IDBMTCwgcl9udW0gPSAwTEw7XG4gICAgICBmb3IgKGludCB3dyA9IDA7IHd3IDwgTC5zaXplKCk7IHd3KyspXG4gICAgICAgIGxfbnVtID0gKGxfbnVtICogMTBMTCkgKyBsbChMW3d3XSAtICcwJyk7XG4gICAgICBmb3IgKGludCB3dyA9IDA7IHd3IDwgUi5zaXplKCk7IHd3KyspXG4gICAgICAgIHJfbnVtID0gKHJfbnVtICogMTBMTCkgKyBsbChSW3d3XSAtICcwJyk7XG4gICAgICBpZiAoUSA+IHJfbnVtKSByZXR1cm4gY250O1xuICAgICAgaWYgKFEgPj0gbF9udW0gJiYgdmFsaWRQYWxpbmRyb21lKHRvX3N0cmluZyhRKSkpXG4gICAgICAgIGlmICghc2Vlbi5jb3VudChRKSkge1xuICAgICAgICAgIGNudCArPSAxO1xuICAgICAgICAgIHNlZW5bUV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICBRID0gaSAqIHBvdygxMCwgcG93ZXIgKyAxTEwpICsgcjtcbiAgICAgIGlmIChMTE9OR19NQVggLyBRIDwgUSkgcmV0dXJuIGNudDtcbiAgICAgIFEgPSBRICogUTtcbiAgICAgIGlmIChRID49IGxfbnVtICYmIFEgPD0gcl9udW0gJiYgdmFsaWRQYWxpbmRyb21lKHRvX3N0cmluZyhRKSkpXG4gICAgICAgIGlmICghc2Vlbi5jb3VudChRKSkge1xuICAgICAgICAgIGNudCArPSAxO1xuICAgICAgICAgIHNlZW5bUV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICBpICs9IDFMTDtcbiAgICB9XG4gICAgcmV0dXJuIGNudDtcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBqYXZhLnV0aWwuKjtcbmltcG9ydCBqYXZhLmxhbmcuTWF0aDtcblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGJvb2xlYW4gdmFsaWRQYWxpbmRyb21lKFN0cmluZyBzKSB7XG4gICAgaW50IGwgPSAwLCByID0gcy5sZW5ndGgoKSAtIDE7XG4gICAgd2hpbGUgKGwgPCByKSB7XG4gICAgICBpZiAocy5jaGFyQXQobCkgIT0gcy5jaGFyQXQocikpIHJldHVybiBmYWxzZTtcbiAgICAgIGwgKz0gMTtcbiAgICAgIHIgLT0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcHVibGljIGludCBzdXBlcnBhbGluZHJvbWVzSW5SYW5nZShTdHJpbmcgTCwgU3RyaW5nIFIpIHtcbiAgICBpbnQgY250ID0gMDtcbiAgICBsb25nIGkgPSAxO1xuICAgIFNldDxMb25nPiBzZWVuID0gbmV3IEhhc2hTZXQ8TG9uZz4oKTtcbiAgICB3aGlsZSAoaSA8IChsb25nKTEwMDAwMCkge1xuICAgICAgbG9uZyBwb3dlciA9IChsb25nKU1hdGguZmxvb3IoTWF0aC5sb2coaSkgLyBNYXRoLmxvZygxMC4wKSArIDAuNSk7XG4gICAgICBsb25nIHggPSBpLCByID0gMDtcbiAgICAgIHdoaWxlICh4ID4gMCkge1xuICAgICAgICByID0gciAqIChsb25nKTEwICsgKHggJSAobG9uZykxMCk7XG4gICAgICAgIHggLz0gKGxvbmcpMTA7XG4gICAgICB9XG4gICAgICBsb25nIFEgPSAobG9uZykoaSAqIE1hdGgucG93KDEwLCBwb3dlcikgK1xuICAgICAgICAgIHIgJSAobG9uZylNYXRoLnBvdygxMCwgcG93ZXIpKTtcbiAgICAgIGlmIChMb25nLk1BWF9WQUxVRSAvIFEgPCBRKSByZXR1cm4gY250O1xuICAgICAgUSA9IFEgKiBRO1xuICAgICAgaWYgKFEgPiBMb25nLnBhcnNlTG9uZyhSKSkgcmV0dXJuIGNudDtcbiAgICAgIGlmIChRID49IExvbmcucGFyc2VMb25nKEwpICYmXG4gICAgICAgICAgdmFsaWRQYWxpbmRyb21lKFN0cmluZy52YWx1ZU9mKFEpKSlcbiAgICAgICAgaWYgKCFzZWVuLmNvbnRhaW5zKFEpKSB7XG4gICAgICAgICAgY250ID0gY250ICsgMTtcbiAgICAgICAgICBzZWVuLmFkZChRKTtcbiAgICAgICAgfVxuICAgICAgUSA9IChsb25nKShpICogTWF0aC5wb3coMTAsIHBvd2VyICsgMSkgKyByKTtcbiAgICAgIGlmIChMb25nLk1BWF9WQUxVRSAvIFEgPCBRKSByZXR1cm4gY250O1xuICAgICAgUSA9IFEgKiBRO1xuICAgICAgaWYgKFEgPj0gTG9uZy5wYXJzZUxvbmcoTCkgJiYgUSA8PSBMb25nLnBhcnNlTG9uZyhSKSAmJlxuICAgICAgICAgIHZhbGlkUGFsaW5kcm9tZShTdHJpbmcudmFsdWVPZihRKSkpXG4gICAgICAgIGlmICghc2Vlbi5jb250YWlucyhRKSkge1xuICAgICAgICAgIGNudCA9IGNudCArIDE7XG4gICAgICAgICAgc2Vlbi5hZGQoUSk7XG4gICAgICAgIH1cbiAgICAgIGkgPSBpICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGNudDtcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBtYXRoXG5cblxuY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHN1cGVycGFsaW5kcm9tZXNJblJhbmdlKHNlbGYsIEw6IHN0ciwgUjogc3RyKSAtPiBpbnQ6XG4gICAgICAgIGNudCA9IDBcbiAgICAgICAgaSA9IDFcbiAgICAgICAgIyDpmLLmraLph43lpI3nmoTmlbDmja5cbiAgICAgICAgc2VlbiA9IHt9XG5cbiAgICAgICAgZGVmIHZhbGlkUGFsaW5kcm9tZShzOiBzdHIpIC0+IGJvb2w6XG4gICAgICAgICAgICBsID0gMFxuICAgICAgICAgICAgciA9IGxlbihzKSAtIDFcbiAgICAgICAgICAgIHdoaWxlIGwgPCByOlxuICAgICAgICAgICAgICAgIGlmIHNbbF0gIT0gc1tyXTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZhbHNlXG4gICAgICAgICAgICAgICAgbCArPSAxXG4gICAgICAgICAgICAgICAgciAtPSAxXG4gICAgICAgICAgICByZXR1cm4gVHJ1ZVxuXG4gICAgICAgIHdoaWxlIGkgPCAxMCAqKiA1OlxuICAgICAgICAgICAgIyBsb2cxMCDpmLLmraLnsr7luqbkuKLlpLHpl67pophcbiAgICAgICAgICAgIHBvd2VyID0gbWF0aC5mbG9vcihtYXRoLmxvZzEwKGkpKVxuICAgICAgICAgICAgeCA9IGlcbiAgICAgICAgICAgIHIgPSAwXG4gICAgICAgICAgICB3aGlsZSB4ID4gMDpcbiAgICAgICAgICAgICAgICByID0gciAqIDEwICsgKHggJSAxMClcbiAgICAgICAgICAgICAgICB4ID0geCAvLyAxMFxuICAgICAgICAgICAgIyDlpoLmnpxp562J5LqOMTIzXG4gICAgICAgICAgICAjIOmCo+S5iFHlsLHmmK8xMjMyMVxuICAgICAgICAgICAgUSA9IChpICogMTAgKiogcG93ZXIgKyByICUgMTAgKiogcG93ZXIpICoqIDJcblxuICAgICAgICAgICAgaWYgUSA+IGludChSKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gY250XG4gICAgICAgICAgICBpZiBRID49IGludChMKSBhbmQgdmFsaWRQYWxpbmRyb21lKHN0cihRKSk6XG4gICAgICAgICAgICAgICAgaWYgUSBub3QgaW4gc2VlbjpcbiAgICAgICAgICAgICAgICAgICAgY250ICs9IDFcbiAgICAgICAgICAgICAgICAgICAgc2VlbltRXSA9IFRydWVcbiAgICAgICAgICAgICMg6YKj5LmI5bCx5pivMTIzMzIxXG4gICAgICAgICAgICBRID0gKGkgKiAxMCAqKiAocG93ZXIgKyAxKSArIHIpICoqIDJcbiAgICAgICAgICAgIGlmIFEgPj0gaW50KEwpIGFuZCBRIDw9IGludChSKSBhbmQgdmFsaWRQYWxpbmRyb21lKHN0cihRKSk6XG4gICAgICAgICAgICAgICAgaWYgUSBub3QgaW4gc2VlbjpcbiAgICAgICAgICAgICAgICAgICAgY250ICs9IDFcbiAgICAgICAgICAgICAgICAgICAgc2VlbltRXSA9IFRydWVcbiAgICAgICAgICAgIGkgKz0gMVxuXG4gICAgICAgIHJldHVybiBjbnRcblxuIgogICAgfV0KICB9XQp9LCB7CiAgImlkIjogIjA0IiwKICAibmFtZSI6ICLnrKzlm5vnq6AiLAogICJsaXN0IjogW3sKICAgICJ0aXRsZSI6ICLku6PnoIE0LjEuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIHN0cmluZyBjb3VudEFuZFNheShpbnQgbikge1xuICAgICAgICBzdHJpbmcgcmVzID0gXCIxXCI7XG4gICAgICAgIFxuICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgc3RyaW5nIHRtcCA9IFwiXCI7XG4gICAgICAgICAgICBjaGFyIGN1cnJlbnRfY2hhciA9IHJlc1swXTtcbiAgICAgICAgICAgIGludCAgY2hhcl9jb3VudCAgID0gMDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCByZXMuc2l6ZSgpOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzW2pdICE9IGN1cnJlbnRfY2hhcikge1xuICAgICAgICAgICAgICAgICAgICB0bXAgKz0gaXRvYShjaGFyX2NvdW50KSArIGN1cnJlbnRfY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF9jaGFyID0gcmVzW2pdO1xuICAgICAgICAgICAgICAgICAgICBjaGFyX2NvdW50ID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGFyX2NvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0bXAgKz0gaXRvYShjaGFyX2NvdW50KSArIGN1cnJlbnRfY2hhcjtcbiAgICAgICAgICAgIHJlcyA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicHVibGljIGNsYXNzIENvdW50QW5kU2F5IHtcbiAgICBwdWJsaWMgU3RyaW5nIGNvdW50QW5kU2F5KGludCBuKSB7XG4gICAgICAgIFN0cmluZyBhbnMgPSBcIjFcIjtcbiAgICAgICAgZm9yIChpbnQgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIFN0cmluZ0J1ZmZlciBzdHJpbmdCdWZmZXIgPSBuZXcgU3RyaW5nQnVmZmVyKCk7XG4gICAgICAgICAgICBjaGFyIGN1cnJlbnRDaGFyID0gYW5zLmNoYXJBdCgwKTtcbiAgICAgICAgICAgIGludCBjaGFyQ291bnQgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IGFucy5sZW5ndGgoKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFucy5jaGFyQXQoaikgIT0gY3VycmVudENoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nQnVmZmVyLmFwcGVuZChjaGFyQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdCdWZmZXIuYXBwZW5kKGN1cnJlbnRDaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYXIgPSBhbnMuY2hhckF0KGopO1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmluZ0J1ZmZlci5hcHBlbmQoY2hhckNvdW50KTtcbiAgICAgICAgICAgIHN0cmluZ0J1ZmZlci5hcHBlbmQoY3VycmVudENoYXIpO1xuICAgICAgICAgICAgYW5zID0gc3RyaW5nQnVmZmVyLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFucztcbiAgICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBjb3VudEFuZFNheShzZWxmLCBuOiBpbnQpIC0+IHN0cjpcbiAgICAgICAgYW5zID0gXCIxXCJcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMSwgbik6XG4gICAgICAgICAgICB0bXAgPSBcIlwiXG4gICAgICAgICAgICBjdXJyZW50X2NoYXIsIGNoYXJfY291bnQgPSBhbnNbMF0sIDBcbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKGxlbihhbnMpKTpcbiAgICAgICAgICAgICAgICBpZiBhbnNbal0gIT0gY3VycmVudF9jaGFyOlxuICAgICAgICAgICAgICAgICAgICB0bXAgKz0gc3RyKGNoYXJfY291bnQpICsgY3VycmVudF9jaGFyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfY2hhciwgY2hhcl9jb3VudCA9IGFuc1tqXSwgMVxuICAgICAgICAgICAgICAgIGVsc2U6XG4gICAgICAgICAgICAgICAgICAgIGNoYXJfY291bnQgKz0gMVxuICAgICAgICAgICAgdG1wICs9IHN0cihjaGFyX2NvdW50KSArIGN1cnJlbnRfY2hhclxuICAgICAgICAgICAgYW5zID0gdG1wXG4gICAgICAgIHJldHVybiBhbnNcblxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIE0LjEuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIHN0cmluZyBjb3VudEFuZFNheShpbnQgbikge1xuICAgICAgICBpZiAobiA9PSAxKSByZXR1cm4gXCIxXCI7XG4gICAgICAgIFxuICAgICAgICBzdHJpbmcgcHJlX3N0ciA9IGNvdW50QW5kU2F5KG4gLSAxKTtcbiAgICAgICAgXG4gICAgICAgIGludCBjaGFyX2luZGV4ID0gMCwgY2hhcl9jb3VudCA9IDE7XG4gICAgICAgIHN0cmluZyBjdXJfc3RyID0gXCJcIjtcbiAgICAgICAgXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcHJlX3N0ci5sZW5ndGgoKSAtIDE7IGkrKykge1xuICAgICAgICAgICAgaWYgKHByZV9zdHJbY2hhcl9pbmRleF0gPT0gcHJlX3N0cltpICsgMV0pXG4gICAgICAgICAgICAgICAgY2hhcl9jb3VudCArPSAxO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VyX3N0ciArPSB0b19zdHJpbmcoY2hhcl9jb3VudCkgKyBwcmVfc3RyW2NoYXJfaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNoYXJfaW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgICAgICBjaGFyX2NvdW50ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY3VyX3N0ciArPSB0b19zdHJpbmcoY2hhcl9jb3VudCkgKyBwcmVfc3RyW2NoYXJfaW5kZXhdO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGN1cl9zdHI7XG4gICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogInB1YmxpYyBjbGFzcyBDb3VudEFuZFNheSB7XG4gICAgcHVibGljIFN0cmluZyBjb3VudEFuZFNheShpbnQgbikge1xuICAgICAgICBTdHJpbmcgYW5zID0gXCIxXCI7XG4gICAgICAgIGZvciAoaW50IGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBTdHJpbmcgdG1wID0gXCJcIjtcbiAgICAgICAgICAgIGNoYXIgY3VycmVudENoYXIgPSBhbnMuY2hhckF0KDApO1xuICAgICAgICAgICAgaW50IGNoYXJDb3VudCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgYW5zLmxlbmd0aCgpOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYW5zLmNoYXJBdChqKSAhPSBjdXJyZW50Q2hhcikge1xuICAgICAgICAgICAgICAgICAgICB0bXAgKz0gKGNoYXJDb3VudCArIFwiXCIgKyBjdXJyZW50Q2hhcik7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFyID0gYW5zLmNoYXJBdChqKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0bXAgKz0gKGNoYXJDb3VudCArIFwiXCIgKyBjdXJyZW50Q2hhcik7XG4gICAgICAgICAgICBhbnMgPSB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFucztcbiAgICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBjb3VudEFuZFNheShzZWxmLCBuOiBpbnQpIC0+IHN0cjpcbiAgICAgICAgaWYgbiA9PSAxOlxuICAgICAgICAgICAgcmV0dXJuIFwiMVwiXG4gICAgICAgIGVsc2U6XG4gICAgICAgICAgICBwcmV2aW91c19zdHJpbmcgPSBzZWxmLmNvdW50QW5kU2F5KG4gLSAxKVxuICAgICAgICAgICAgY2hhcl9pbmRleCwgY2hhcl9jb3VudCA9IDAsIDFcbiAgICAgICAgICAgIGN1cnJlbnRfc3RyaW5nID0gXCJcIlxuICAgICAgICAgICAgZm9yIGkgaW4gcmFuZ2UobGVuKHByZXZpb3VzX3N0cmluZykpOlxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgaSArIDEgPCBsZW4ocHJldmlvdXNfc3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBhbmQgcHJldmlvdXNfc3RyaW5nW2NoYXJfaW5kZXhdID09IHByZXZpb3VzX3N0cmluZ1tpICsgMV1cbiAgICAgICAgICAgICAgICApOlxuICAgICAgICAgICAgICAgICAgICBjaGFyX2NvdW50ICs9IDFcbiAgICAgICAgICAgICAgICBlbHNlOlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3N0cmluZyArPSBzdHIoY2hhcl9jb3VudCkgKyBwcmV2aW91c19zdHJpbmdbY2hhcl9pbmRleF1cbiAgICAgICAgICAgICAgICAgICAgY2hhcl9pbmRleCwgY2hhcl9jb3VudCA9IGkgKyAxLCAxXG5cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50X3N0cmluZ1xuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIE0LjIuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHJpdmF0ZTpcbiAgICBib29sIGNvbXB1dGUoZG91YmxlIGEpIHtcbiAgICAgICAgcmV0dXJuIGZhYnMoMjQgLSBhKSA8IDFlLTg7XG4gICAgfVxuICAgIGJvb2wgY29tcHV0ZShkb3VibGUgYSwgZG91YmxlIGIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGUoYSArIGIpIHx8IGNvbXB1dGUoYSAtIGIpIHx8IGNvbXB1dGUoYSAqIGIpIHx8IChiICYmIGNvbXB1dGUoYSAvIGIpKTtcbiAgICB9XG4gICAgYm9vbCBjb21wdXRlKGRvdWJsZSBhLCBkb3VibGUgYiwgZG91YmxlIGMpIHtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGUoYSArIGIsIGMpIHx8IGNvbXB1dGUoYSAtIGIsIGMpIHx8IGNvbXB1dGUoYSAqIGIsIGMpIHx8IChiICYmIGNvbXB1dGUoYSAvIGIsIGMpKSB8fFxuICAgICAgICAgICAgICAgY29tcHV0ZShhLCBiICsgYykgfHwgY29tcHV0ZShhLCBiIC0gYykgfHwgY29tcHV0ZShhLCBiICogYykgfHwgKGMgJiYgY29tcHV0ZShhLCBiIC8gYykpO1xuICAgIH1cbiAgICBib29sIGNvbXB1dGUoZG91YmxlIGEsIGRvdWJsZSBiLCBkb3VibGUgYywgZG91YmxlIGQpIHtcbiAgICAgICAgYm9vbCByZXMgPSBjb21wdXRlKGEgKyBiLCBjLCBkKSB8fCBjb21wdXRlKGEgLSBiLCBjLCBkKSB8fCBjb21wdXRlKGEgKiBiLCBjLCBkKSB8fCAoYiAmJiBjb21wdXRlKGEgLyBiLCBjLCBkKSkgfHxcbiAgICAgICAgICAgICAgICAgICBjb21wdXRlKGEsIGIgKyBjLCBkKSB8fCBjb21wdXRlKGEsIGIgLSBjLCBkKSB8fCBjb21wdXRlKGEsIGIgKiBjLCBkKSB8fCAoYyAmJiBjb21wdXRlKGEsIGIgLyBjLCBkKSkgfHxcbiAgICAgICAgICAgICAgICAgICBjb21wdXRlKGEsIGIsIGMgKyBkKSB8fCBjb21wdXRlKGEsIGIsIGMgLSBkKSB8fCBjb21wdXRlKGEsIGIsIGMgKiBkKSB8fCAoZCAmJiBjb21wdXRlKGEsIGIsIGMgLyBkKSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbnB1YmxpYzpcbiAgICBib29sIGp1ZGdlUG9pbnQyNCh2ZWN0b3I8aW50PiYgbnVtcykge1xuICAgICAgICBzb3J0IChudW1zLmJlZ2luKCksIG51bXMuZW5kKCkpO1xuICAgICAgICBcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGNvbXB1dGUobnVtc1swXSwgbnVtc1sxXSwgbnVtc1syXSwgbnVtc1szXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gd2hpbGUgKG5leHRfcGVybXV0YXRpb24obnVtcy5iZWdpbigpLCBudW1zLmVuZCgpKSk7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJwYWNrYWdlIGNoMDQuY29kZTtcblxuaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7XG5pbXBvcnQgamF2YS51dGlsLkFycmF5cztcbmltcG9ydCBqYXZhLnV0aWwuTGlzdDtcblxucHVibGljIGNsYXNzIFR3ZW50eUZvdXJHYW1lIHtcbiAgICBMaXN0PExpc3Q8RG91YmxlPj4gcGVybXV0YXRpb25MaXN0ID0gbmV3IEFycmF5TGlzdDw+KCk7XG5cbiAgICAvLyA5bXMgYXQgYmVzdFxuICAgIHB1YmxpYyBib29sZWFuIGp1ZGdlUG9pbnQyNChpbnRbXSBudW1zKSB7XG4gICAgICAgIHBlcm11dGVVbmlxdWUobnVtcyk7XG4gICAgICAgIGZvciAoTGlzdDxEb3VibGU+IHBlcm11dGF0aW9uIDogcGVybXV0YXRpb25MaXN0KSB7XG4gICAgICAgICAgICBpZiAoY29tcHV0ZShwZXJtdXRhdGlvbikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHByaXZhdGUgYm9vbGVhbiBjb21wdXRlKExpc3Q8RG91YmxlPiBudW1zKSB7XG4gICAgICAgIGlmIChudW1zLnNpemUoKSA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKG51bXMuZ2V0KDApIC0gMjQpIDw9IDFlLTY7XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBudW1zLnNpemUoKSAtIDE7IGkrKykge1xuICAgICAgICAgICAgLy8gY29tcHV0ZSBwb3NzaWJsZSByZXN1bHQgZnJvbSArIC0gKiAvXG4gICAgICAgICAgICBMaXN0PERvdWJsZT4gdG1wUmVzdWx0TGlzdCA9IG5ldyBBcnJheUxpc3Q8PigpO1xuICAgICAgICAgICAgdG1wUmVzdWx0TGlzdC5hZGQobnVtcy5nZXQoaSkgKyBudW1zLmdldChpICsgMSkpO1xuICAgICAgICAgICAgdG1wUmVzdWx0TGlzdC5hZGQobnVtcy5nZXQoaSkgLSBudW1zLmdldChpICsgMSkpO1xuICAgICAgICAgICAgdG1wUmVzdWx0TGlzdC5hZGQobnVtcy5nZXQoaSkgKiBudW1zLmdldChpICsgMSkpO1xuICAgICAgICAgICAgaWYgKG51bXMuZ2V0KGkgKyAxKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgdG1wUmVzdWx0TGlzdC5hZGQobnVtcy5nZXQoaSkgLyBudW1zLmdldChpICsgMSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXBsYWNlIG51bXNbaV0gYW5kIG51bXNbaSsxXSB3aXRoIHRoZSByZXN1bHRcbiAgICAgICAgICAgIC8vIGNvbnRpbnVlIHdpdGggdGhlIG5ldyBsaXN0XG4gICAgICAgICAgICBmb3IgKERvdWJsZSBuZXdOdW0gOiB0bXBSZXN1bHRMaXN0KSB7XG4gICAgICAgICAgICAgICAgTGlzdDxEb3VibGU+IG5ld0xpc3QgPSBuZXcgQXJyYXlMaXN0PD4obnVtcyk7XG4gICAgICAgICAgICAgICAgbmV3TGlzdC5zZXQoaSwgbmV3TnVtKTtcbiAgICAgICAgICAgICAgICBuZXdMaXN0LnJlbW92ZShpICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXB1dGUobmV3TGlzdCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIHB1YmxpYyB2b2lkIHBlcm11dGVVbmlxdWUoaW50W10gbnVtcykge1xuICAgICAgICBib29sZWFuW10gdmlzaXRlZCA9IG5ldyBib29sZWFuW251bXMubGVuZ3RoXTtcbiAgICAgICAgQXJyYXlzLnNvcnQobnVtcyk7XG4gICAgICAgIGJhY2t0cmFja2luZyhudW1zLCBuZXcgQXJyYXlMaXN0PD4oKSwgdmlzaXRlZCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2b2lkIGJhY2t0cmFja2luZyhpbnRbXSBudW1zLCBMaXN0PERvdWJsZT4gdG1wLCBib29sZWFuW10gdmlzaXRlZCkge1xuICAgICAgICBpZiAodG1wLnNpemUoKSA9PSBudW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgcGVybXV0YXRpb25MaXN0LmFkZChuZXcgQXJyYXlMaXN0PD4odG1wKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh2aXNpdGVkW2ldKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gIXZpc2l0ZWRbaSAtIDFdIOivtOaYjuW3sue7j+mBjeWOhuWujOiiq+aSpOmUgOS6hueKtuaAgeiusOW9lVxuICAgICAgICAgICAgaWYgKGkgPiAwICYmIG51bXNbaV0gPT0gbnVtc1tpIC0gMV0gJiYgIXZpc2l0ZWRbaSAtIDFdKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmlzaXRlZFtpXSA9IHRydWU7XG4gICAgICAgICAgICB0bXAuYWRkKChkb3VibGUpIG51bXNbaV0pO1xuICAgICAgICAgICAgYmFja3RyYWNraW5nKG51bXMsIHRtcCwgdmlzaXRlZCk7XG5cbiAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSBmYWxzZTtcbiAgICAgICAgICAgIHRtcC5yZW1vdmUodG1wLnNpemUoKSAtIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBqdWRnZVBvaW50MjQoc2VsZiwgbnVtczogTGlzdFtpbnRdKSAtPiBib29sOlxuICAgICAgICBwZXJtdXRhdGlvbnMgPSBzZWxmLnBlcm11dGVVbmlxdWUobnVtcylcbiAgICAgICAgZm9yIHBlcm11dGF0aW9uIGluIHBlcm11dGF0aW9uczpcbiAgICAgICAgICAgIGlmIHNlbGYuY29tcHV0ZShwZXJtdXRhdGlvbik6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRydWVcbiAgICAgICAgcmV0dXJuIEZhbHNlXG5cbiAgICBkZWYgY29tcHV0ZShzZWxmLCBudW1zOiBMaXN0W2Zsb2F0XSkgLT4gYm9vbDpcbiAgICAgICAgaWYgbGVuKG51bXMpID09IDE6XG4gICAgICAgICAgICByZXR1cm4gYWJzKG51bXNbMF0gLSAyNCkgPD0gMC4wMDAwMVxuICAgICAgICBmb3IgaSBpbiByYW5nZShsZW4obnVtcykgLSAxKTpcbiAgICAgICAgICAgICMgY29tcHV0ZSBwb3NzaWJsZSByZXN1bHQgZnJvbSArIC0gKiAvXG4gICAgICAgICAgICB0bXAgPSBbXVxuICAgICAgICAgICAgdG1wLmFwcGVuZChudW1zW2ldICsgbnVtc1tpICsgMV0pXG4gICAgICAgICAgICB0bXAuYXBwZW5kKG51bXNbaV0gLSBudW1zW2kgKyAxXSlcbiAgICAgICAgICAgIHRtcC5hcHBlbmQobnVtc1tpXSAqIG51bXNbaSArIDFdKVxuICAgICAgICAgICAgaWYgbnVtc1tpICsgMV0gIT0gMDpcbiAgICAgICAgICAgICAgICB0bXAuYXBwZW5kKG51bXNbaV0gLyBudW1zW2kgKyAxXSlcblxuICAgICAgICAgICAgZm9yIG51bSBpbiB0bXA6XG4gICAgICAgICAgICAgICAgbmV3X2xpc3QgPSBudW1zWzpdXG4gICAgICAgICAgICAgICAgbmV3X2xpc3RbaV0gPSBudW1cbiAgICAgICAgICAgICAgICBuZXdfbGlzdC5wb3AoaSArIDEpXG4gICAgICAgICAgICAgICAgaWYgc2VsZi5jb21wdXRlKG5ld19saXN0KTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRydWVcbiAgICAgICAgcmV0dXJuIEZhbHNlXG5cbiAgICBkZWYgcGVybXV0ZVVuaXF1ZShzZWxmLCBudW1zOiBMaXN0W2ludF0pIC0+IExpc3RbTGlzdFtpbnRdXTpcbiAgICAgICAgcGVybXV0YXRpb25zID0gW11cbiAgICAgICAgbnVtcy5zb3J0KClcbiAgICAgICAgdG1wID0gW11cbiAgICAgICAgdmlzaXRlZCA9IFtGYWxzZV0gKiBsZW4obnVtcylcblxuICAgICAgICBzZWxmLmJhY2t0cmFja2luZyhudW1zLCB0bXAsIHZpc2l0ZWQsIHBlcm11dGF0aW9ucylcbiAgICAgICAgcmV0dXJuIHBlcm11dGF0aW9uc1xuXG4gICAgZGVmIGJhY2t0cmFja2luZyhcbiAgICAgICAgc2VsZiwgbnVtczogTGlzdFtpbnRdLCB0bXA6IExpc3RbZmxvYXRdLCB2aXNpdGVkOiBMaXN0W2Jvb2xdLCBwZXJtOiBMaXN0W2ludF0sXG4gICAgKSAtPiBOb25lOlxuICAgICAgICBpZiBsZW4obnVtcykgPT0gbGVuKHRtcCk6XG4gICAgICAgICAgICBwZXJtLmFwcGVuZCh0bXBbOl0pXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UobGVuKG51bXMpKTpcbiAgICAgICAgICAgIGlmIHZpc2l0ZWRbaV06XG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIGlmIGkgPiAwIGFuZCBudW1zW2ldID09IG51bXNbaSAtIDFdIGFuZCBub3QgdmlzaXRlZFtpIC0gMV06XG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSBUcnVlXG4gICAgICAgICAgICB0bXAuYXBwZW5kKG51bXNbaV0pXG4gICAgICAgICAgICBzZWxmLmJhY2t0cmFja2luZyhudW1zLCB0bXAsIHZpc2l0ZWQsIHBlcm0pXG4gICAgICAgICAgICB2aXNpdGVkW2ldID0gRmFsc2VcbiAgICAgICAgICAgIHRtcC5wb3AoKVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIE0LjIuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHJpdmF0ZTpcbiAgICBib29sIGNvbXB1dGUodmVjdG9yPGRvdWJsZT4mIG51bXMpIHtcbiAgICAgICAgaWYgKG51bXMuc2l6ZSgpID09IDEpXG4gICAgICAgICAgICByZXR1cm4gZmFicyhudW1zWzBdIC0gMjQuMCkgPCAxZS04O1xuICAgICAgICBcbiAgICAgICAgZm9yIChpbnQgbGVmdCA9IDA7IGxlZnQgPCBudW1zLnNpemUoKSAtIDE7IGxlZnQrKykge1xuICAgICAgICAgICAgZm9yIChpbnQgcmlnaHQgPSBsZWZ0ICsgMTsgcmlnaHQgPCBudW1zLnNpemUoKTsgcmlnaHQrKykge1xuICAgICAgICAgICAgICAgIHZlY3Rvcjxkb3VibGU+IHRtcDtcbiAgICAgICAgICAgICAgICBmb3IgKGludCBrID0gMDsgayA8IG51bXMuc2l6ZSgpOyBrKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChrICE9IGxlZnQgJiYgayAhPSByaWdodCkgdG1wLnB1c2hfYmFjayhudW1zW2tdKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0bXAucHVzaF9iYWNrKG51bXNbbGVmdF0gKyBudW1zW3JpZ2h0XSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXB1dGUodG1wKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICB0cnVlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRtcC5iYWNrKCkgPSBudW1zW2xlZnRdICogbnVtc1tyaWdodF07XG4gICAgICAgICAgICAgICAgaWYgKGNvbXB1dGUodG1wKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdG1wLmJhY2soKSA9IG51bXNbbGVmdF0gLSBudW1zW3JpZ2h0XTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZSh0bXApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0bXAuYmFjaygpID0gbnVtc1tsZWZ0XSAvIG51bXNbcmlnaHRdO1xuICAgICAgICAgICAgICAgIGlmIChjb21wdXRlKHRtcCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRtcC5iYWNrKCkgPSBudW1zW3JpZ2h0XSAtIG51bXNbbGVmdF07XG4gICAgICAgICAgICAgICAgaWYgKGNvbXB1dGUodG1wKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdG1wLmJhY2soKSA9IG51bXNbcmlnaHRdIC8gbnVtc1tsZWZ0XTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZSh0bXApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbnB1YmxpYzpcbiAgICBib29sIGp1ZGdlUG9pbnQyNCh2ZWN0b3I8aW50PiYgbnVtcykge1xuICAgICAgICB2ZWN0b3I8ZG91YmxlPiB0bXAobnVtcy5iZWdpbigpLCBudW1zLmVuZCgpKTtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGUodG1wKTtcbiAgICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicGFja2FnZSBjaDA0LmNvZGU7XG5cbmltcG9ydCBqYXZhLnV0aWwuQXJyYXlMaXN0O1xuaW1wb3J0IGphdmEudXRpbC5BcnJheXM7XG5pbXBvcnQgamF2YS51dGlsLkxpc3Q7XG5cbnB1YmxpYyBjbGFzcyBUd2VudHlGb3VyR2FtZSB7XG4gICAgcHVibGljIGJvb2xlYW4ganVkZ2VQb2ludDI0KGludFtdIG51bXMpIHtcbiAgICAgICAgZG91YmxlW10gbnVtczEgPSBuZXcgZG91YmxlW251bXMubGVuZ3RoXTtcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBudW1zMVtpXSA9IG51bXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlbHBlcihudW1zMSwgNCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBib29sZWFuIGhlbHBlcihkb3VibGVbXSBudW1zLCBpbnQgbikge1xuICAgICAgICBpZiAobiA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKG51bXNbMF0gLSAyNCkgPD0gMWUtNjtcblxuICAgICAgICBkb3VibGUgbmV3TnVtc1tdID0gbmV3IGRvdWJsZVs0XTtcblxuICAgICAgICBmb3IgKGludCBsZWZ0ID0gMDsgbGVmdCA8IG4gLSAxOyBsZWZ0KyspIHtcbiAgICAgICAgICAgIGZvciAoaW50IHJpZ2h0ID0gbGVmdCArIDE7IHJpZ2h0IDwgbjsgcmlnaHQrKykge1xuICAgICAgICAgICAgICAgIGludCBtID0gMDtcbiAgICAgICAgICAgICAgICAvLyBwdXQgYWxsIG90aGVyIG51bSBhdCB0aGUgYmVnaW5uaW5nIGZpcnN0XG4gICAgICAgICAgICAgICAgZm9yIChpbnQgayA9IDA7IGsgPCBuOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgIT0gbGVmdCAmJiBrICE9IHJpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TnVtc1ttKytdID0gbnVtc1trXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcHV0IG5ld051bSBpbiBhZnRlciArID0gKiAvXG4gICAgICAgICAgICAgICAgbmV3TnVtc1ttXSA9IG51bXNbbGVmdF0gKyBudW1zW3JpZ2h0XTtcbiAgICAgICAgICAgICAgICBpZiAoaGVscGVyKG5ld051bXMsIG0gKyAxKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgbmV3TnVtc1ttXSA9IG51bXNbbGVmdF0gLSBudW1zW3JpZ2h0XTtcbiAgICAgICAgICAgICAgICBpZiAoaGVscGVyKG5ld051bXMsIG0gKyAxKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgbmV3TnVtc1ttXSA9IG51bXNbcmlnaHRdIC0gbnVtc1tsZWZ0XTtcbiAgICAgICAgICAgICAgICBpZiAoaGVscGVyKG5ld051bXMsIG0gKyAxKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgbmV3TnVtc1ttXSA9IG51bXNbbGVmdF0gKiBudW1zW3JpZ2h0XTtcbiAgICAgICAgICAgICAgICBpZiAoaGVscGVyKG5ld051bXMsIG0gKyAxKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG51bXNbcmlnaHRdICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3TnVtc1ttXSA9IG51bXNbbGVmdF0gLyBudW1zW3JpZ2h0XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlbHBlcihuZXdOdW1zLCBtICsgMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG51bXNbbGVmdF0gIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdOdW1zW21dID0gbnVtc1tyaWdodF0gLyBudW1zW2xlZnRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGVscGVyKG5ld051bXMsIG0gKyAxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBqdWRnZVBvaW50MjQoc2VsZiwgbnVtczogTGlzdFtpbnRdKSAtPiBib29sOlxuICAgICAgICByZXR1cm4gc2VsZi5jb21wdXRlKFtmbG9hdChpKSBmb3IgaSBpbiBudW1zXSwgNClcblxuICAgIGRlZiBjb21wdXRlKHNlbGYsIG51bXM6IExpc3RbaW50XSwgbjogaW50KSAtPiBib29sOlxuICAgICAgICBpZiBuID09IDE6XG4gICAgICAgICAgICByZXR1cm4gYWJzKG51bXNbMF0gLSAyNCkgPCAwLjAwMDAwMVxuICAgICAgICBuZXdfbnVtcyA9IFswXSAqIDRcblxuICAgICAgICBmb3IgbGVmdCBpbiByYW5nZShuIC0gMSk6XG4gICAgICAgICAgICBmb3IgcmlnaHQgaW4gcmFuZ2UobGVmdCArIDEsIG4pOlxuICAgICAgICAgICAgICAgIGluZGV4ID0gMFxuICAgICAgICAgICAgICAgIGZvciBpIGluIHJhbmdlKG4pOlxuICAgICAgICAgICAgICAgICAgICBpZiBpICE9IGxlZnQgYW5kIGkgIT0gcmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdfbnVtc1tpbmRleF0gPSBudW1zW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAxXG5cbiAgICAgICAgICAgICAgICBuZXdfbnVtc1tpbmRleF0gPSBudW1zW2xlZnRdICsgbnVtc1tyaWdodF1cbiAgICAgICAgICAgICAgICBpZiBzZWxmLmNvbXB1dGUobmV3X251bXMsIGluZGV4ICsgMSk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUcnVlXG4gICAgICAgICAgICAgICAgbmV3X251bXNbaW5kZXhdID0gbnVtc1tsZWZ0XSAtIG51bXNbcmlnaHRdXG4gICAgICAgICAgICAgICAgaWYgc2VsZi5jb21wdXRlKG5ld19udW1zLCBpbmRleCArIDEpOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHJ1ZVxuICAgICAgICAgICAgICAgIG5ld19udW1zW2luZGV4XSA9IG51bXNbcmlnaHRdIC0gbnVtc1tsZWZ0XVxuICAgICAgICAgICAgICAgIGlmIHNlbGYuY29tcHV0ZShuZXdfbnVtcywgaW5kZXggKyAxKTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRydWVcbiAgICAgICAgICAgICAgICBuZXdfbnVtc1tpbmRleF0gPSBudW1zW3JpZ2h0XSAqIG51bXNbbGVmdF1cbiAgICAgICAgICAgICAgICBpZiBzZWxmLmNvbXB1dGUobmV3X251bXMsIGluZGV4ICsgMSk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUcnVlXG4gICAgICAgICAgICAgICAgaWYgbnVtc1tsZWZ0XSAhPSAwOlxuICAgICAgICAgICAgICAgICAgICBuZXdfbnVtc1tpbmRleF0gPSBudW1zW3JpZ2h0XSAvIG51bXNbbGVmdF1cbiAgICAgICAgICAgICAgICAgICAgaWYgc2VsZi5jb21wdXRlKG5ld19udW1zLCBpbmRleCArIDEpOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRydWVcbiAgICAgICAgICAgICAgICBpZiBudW1zW3JpZ2h0XSAhPSAwOlxuICAgICAgICAgICAgICAgICAgICBuZXdfbnVtc1tpbmRleF0gPSBudW1zW2xlZnRdIC8gbnVtc1tyaWdodF1cbiAgICAgICAgICAgICAgICAgICAgaWYgc2VsZi5jb21wdXRlKG5ld19udW1zLCBpbmRleCArIDEpOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRydWVcbiAgICAgICAgcmV0dXJuIEZhbHNlXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTQuMy4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wcml2YXRlOlxuICAgIHZlY3Rvcjx2ZWN0b3I8Ym9vbD4+IHJvd19zdGF0ZTtcbiAgICB2ZWN0b3I8dmVjdG9yPGJvb2w+PiBjb2x1bW5fc3RhdGU7XG4gICAgdmVjdG9yPHZlY3Rvcjxib29sPj4gYm94X3N0YXRlO1xuICAgIFxucHJpdmF0ZTpcbiAgICB2b2lkIHBsYWNlTnVtYmVyKHZlY3Rvcjx2ZWN0b3I8Y2hhcj4+JiBib2FyZCwgaW50IHJvdywgaW50IGNvbHVtbiwgY2hhciBkKSB7XG4gICAgICAgIGJvYXJkW3Jvd11bY29sdW1uXSA9IGQ7XG4gICAgICAgIHJvd19zdGF0ZVtyb3ddW2QgLSAnMSddICAgID0gdHJ1ZTtcbiAgICAgICAgY29sdW1uX3N0YXRlW2NvbHVtbl1bZCAtICcxJ10gPSB0cnVlO1xuICAgICAgICBib3hfc3RhdGVbKChyb3cgLyAzKSAqIDMpICsgKGNvbHVtbiAvIDMpXVtkIC0gJzEnXSA9IHRydWU7XG4gICAgfVxuXG4gICAgdm9pZCB1bmRvTnVtYmVyUGxhY2UodmVjdG9yPHZlY3RvcjxjaGFyPj4mIGJvYXJkLCBpbnQgcm93LCBpbnQgY29sdW1uLCBjaGFyIGQpIHtcbiAgICAgICAgYm9hcmRbcm93XVtjb2x1bW5dID0gJy4nO1xuICAgICAgICByb3dfc3RhdGVbcm93XVtkIC0gJzEnXSA9IGZhbHNlO1xuICAgICAgICBjb2x1bW5fc3RhdGVbY29sdW1uXVtkIC0gJzEnXSA9IGZhbHNlO1xuICAgICAgICBib3hfc3RhdGVbKChyb3cgLyAzKSAqIDMpICsgKGNvbHVtbiAvIDMpXVtkIC0gJzEnXSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZvaWQgaW5pdGlhbFN0YXRlKHZlY3Rvcjx2ZWN0b3I8Y2hhcj4+JiBib2FyZCkge1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDk7IGkrKylcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgOTsgaisrKVxuICAgICAgICAgICAgICAgIGlmIChib2FyZFtpXVtqXSAhPSAnLicpXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlTnVtYmVyKGJvYXJkLCBpLCBqLCBib2FyZFtpXVtqXSk7XG4gICAgfVxuICAgIFxuICAgIGJvb2wgcmVjdXJzaXZlUGxhY2VOdW1iZXIodmVjdG9yPHZlY3RvcjxjaGFyPj4mIGJvYXJkLCBpbnQgcm93LCBpbnQgY29sdW1uKSB7XG4gICAgICAgIGlmIChyb3cgPT0gOSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChjb2x1bW4gPT0gOSkgcmV0dXJuIHJlY3Vyc2l2ZVBsYWNlTnVtYmVyKGJvYXJkLCByb3cgKyAxLCAwKTtcbiAgICAgICAgaWYgKGJvYXJkW3Jvd11bY29sdW1uXSAhPSAnLicpIHJldHVybiByZWN1cnNpdmVQbGFjZU51bWJlcihib2FyZCwgcm93LCBjb2x1bW4gKyAxKTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoaW50IGkgPSAnMSc7IGkgPD0gJzknOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghKHJvd19zdGF0ZVtyb3ddW2kgLSAnMSddIFxuICAgICAgICAgICAgICAgICAgfHwgY29sdW1uX3N0YXRlW2NvbHVtbl1baSAtICcxJ10gXG4gICAgICAgICAgICAgICAgICB8fCBib3hfc3RhdGVbKChyb3cgLyAzKSAqIDMpICsgKGNvbHVtbiAvIDMpXVtpIC0gJzEnXSkpIHtcbiAgICAgICAgICAgICAgICBwbGFjZU51bWJlcihib2FyZCwgcm93LCBjb2x1bW4sIGkpO1xuICAgICAgICAgICAgICAgIGlmIChyZWN1cnNpdmVQbGFjZU51bWJlcihib2FyZCwgcm93LCBjb2x1bW4gKyAxKSA9PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB1bmRvTnVtYmVyUGxhY2UoYm9hcmQsIHJvdywgY29sdW1uLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbnB1YmxpYzpcbiAgICB2b2lkIHNvbHZlU3Vkb2t1KHZlY3Rvcjx2ZWN0b3I8Y2hhcj4+JiBib2FyZCkge1xuICAgICAgICByb3dfc3RhdGUgICAgPSB2ZWN0b3I8dmVjdG9yPGJvb2w+Pig5LCB2ZWN0b3I8Ym9vbD4oOSwgZmFsc2UpKTtcbiAgICAgICAgY29sdW1uX3N0YXRlID0gdmVjdG9yPHZlY3Rvcjxib29sPj4oOSwgdmVjdG9yPGJvb2w+KDksIGZhbHNlKSk7XG4gICAgICAgIGJveF9zdGF0ZSAgICA9IHZlY3Rvcjx2ZWN0b3I8Ym9vbD4+KDksIHZlY3Rvcjxib29sPig5LCBmYWxzZSkpO1xuICAgICAgICBcbiAgICAgICAgaW5pdGlhbFN0YXRlKGJvYXJkKTtcbiAgICAgICAgXG4gICAgICAgIHJlY3Vyc2l2ZVBsYWNlTnVtYmVyKGJvYXJkLCAwLCAwKTtcbiAgICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicHVibGljIGNsYXNzIFN1ZG9rdVNvbHZlciB7XG4gICAgcHVibGljIHZvaWQgc29sdmVTdWRva3UoY2hhcltdW10gYm9hcmQpIHtcbiAgICAgICAgYm9vbGVhbiByb3dTdGF0ZVtdW10gPSBuZXcgYm9vbGVhbls5XVsxMF07XG4gICAgICAgIGJvb2xlYW4gY29sdW1uU3RhdGVbXVtdID0gbmV3IGJvb2xlYW5bOV1bMTBdO1xuICAgICAgICBib29sZWFuIGJveFN0YXRlW11bXSA9IG5ldyBib29sZWFuWzldWzEwXTtcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCA5OyBpKyspIHtcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgOTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJvYXJkW2ldW2pdICE9ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBpbnQgaW5kZXggPSBib2FyZFtpXVtqXSAtICcwJztcbiAgICAgICAgICAgICAgICAgICAgcm93U3RhdGVbaV1baW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uU3RhdGVbal1baW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYm94U3RhdGVbKGkgLyAzKSAqIDMgKyBqIC8gM11baW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVjdXJzaXZlUGxhY2VOdW1iZXIoYm9hcmQsIHJvd1N0YXRlLCBjb2x1bW5TdGF0ZSwgYm94U3RhdGUsIDAsIDApO1xuICAgIH1cblxuICAgIHByaXZhdGUgYm9vbGVhbiByZWN1cnNpdmVQbGFjZU51bWJlcihjaGFyW11bXSBib2FyZCwgYm9vbGVhbltdW10gcm93U3RhdGUsIGJvb2xlYW5bXVtdIGNvbHVtblN0YXRlLCBib29sZWFuW11bXSBib3hTdGF0ZSwgaW50IHJvdywgaW50IGNvbHVtbikge1xuICAgICAgICBpZiAoY29sdW1uID09IDkpIHtcbiAgICAgICAgICAgIGNvbHVtbiA9IDA7XG4gICAgICAgICAgICByb3crKztcbiAgICAgICAgICAgIGlmIChyb3cgPT0gOSkge1xuICAgICAgICAgICAgICAgIC8vIGdhbWUgY29tcGxldGVcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChib2FyZFtyb3ddW2NvbHVtbl0gIT0gJy4nKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdXJzaXZlUGxhY2VOdW1iZXIoYm9hcmQsIHJvd1N0YXRlLCBjb2x1bW5TdGF0ZSwgYm94U3RhdGUsIHJvdywgY29sdW1uICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocm93U3RhdGVbcm93XVtpXSB8fCBjb2x1bW5TdGF0ZVtjb2x1bW5dW2ldIHx8IGJveFN0YXRlWyhyb3cgLyAzKSAqIDMgKyBjb2x1bW4gLyAzXVtpXSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwbGFjZU51bWJlcihib2FyZCwgcm93U3RhdGUsIGNvbHVtblN0YXRlLCBib3hTdGF0ZSwgcm93LCBjb2x1bW4sIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdXJzaXZlUGxhY2VOdW1iZXIoYm9hcmQsIHJvd1N0YXRlLCBjb2x1bW5TdGF0ZSwgYm94U3RhdGUsIHJvdywgY29sdW1uICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVuZG9OdW1iZXJQbGFjZW1lbnQoYm9hcmQsIHJvd1N0YXRlLCBjb2x1bW5TdGF0ZSwgYm94U3RhdGUsIHJvdywgY29sdW1uLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFpbGVkIHRvIGdldCBhbiBhbnN3ZXJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHByaXZhdGUgdm9pZCBwbGFjZU51bWJlcihjaGFyW11bXSBib2FyZCwgYm9vbGVhbltdW10gcm93U3RhdGUsIGJvb2xlYW5bXVtdIGNvbHVtblN0YXRlLCBib29sZWFuW11bXSBib3hTdGF0ZSwgaW50IHJvdywgaW50IGNvbHVtbiwgaW50IGkpIHtcbiAgICAgICAgcm93U3RhdGVbcm93XVtpXSA9IHRydWU7XG4gICAgICAgIGNvbHVtblN0YXRlW2NvbHVtbl1baV0gPSB0cnVlO1xuICAgICAgICBib3hTdGF0ZVsocm93IC8gMykgKiAzICsgY29sdW1uIC8gM11baV0gPSB0cnVlO1xuICAgICAgICBib2FyZFtyb3ddW2NvbHVtbl0gPSAoY2hhcikgKCcwJyArIGkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdm9pZCB1bmRvTnVtYmVyUGxhY2VtZW50KGNoYXJbXVtdIGJvYXJkLCBib29sZWFuW11bXSByb3dTdGF0ZSwgYm9vbGVhbltdW10gY29sdW1uU3RhdGUsIGJvb2xlYW5bXVtdIGJveFN0YXRlLCBpbnQgcm93LCBpbnQgY29sdW1uLCBpbnQgaSkge1xuICAgICAgICByb3dTdGF0ZVtyb3ddW2ldID0gZmFsc2U7XG4gICAgICAgIGNvbHVtblN0YXRlW2NvbHVtbl1baV0gPSBmYWxzZTtcbiAgICAgICAgYm94U3RhdGVbKHJvdyAvIDMpICogMyArIGNvbHVtbiAvIDNdW2ldID0gZmFsc2U7XG4gICAgICAgIGJvYXJkW3Jvd11bY29sdW1uXSA9ICcuJztcbiAgICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImZyb20gdHlwaW5nIGltcG9ydCBMaXN0XG5cblxuY2xhc3MgU29sdXRpb246XG4gICAgcm93X3N0YXRlID0gW1tGYWxzZSBmb3IgaSBpbiByYW5nZSgxMCldIGZvciBfIGluIHJhbmdlKDkpXVxuICAgIGNvbHVtbl9zdGF0ZSA9IFtbRmFsc2UgZm9yIGkgaW4gcmFuZ2UoMTApXSBmb3IgXyBpbiByYW5nZSg5KV1cbiAgICBib3hfc3RhdGUgPSBbW0ZhbHNlIGZvciBpIGluIHJhbmdlKDEwKV0gZm9yIF8gaW4gcmFuZ2UoOSldXG4gICAgYm9hcmQgPSBbXVxuXG4gICAgZGVmIHNvbHZlU3Vkb2t1KHNlbGYsIGJvYXJkOiBMaXN0W0xpc3Rbc3RyXV0pIC0+IE5vbmU6XG4gICAgICAgICMgbGVldGNvZGUg5Yik5a6a5pe25Lya6YeN5aSN6LCD55So5Ye95pWw77yM5Zug5q2k6ZyA6KaB5Y+N5aSN5Yid5aeL5YyW54q25oCB6KGoXG4gICAgICAgIHNlbGYucm93X3N0YXRlID0gW1tGYWxzZSBmb3IgaSBpbiByYW5nZSgxMCldIGZvciBfIGluIHJhbmdlKDkpXVxuICAgICAgICBzZWxmLmNvbHVtbl9zdGF0ZSA9IFtbRmFsc2UgZm9yIGkgaW4gcmFuZ2UoMTApXSBmb3IgXyBpbiByYW5nZSg5KV1cbiAgICAgICAgc2VsZi5ib3hfc3RhdGUgPSBbW0ZhbHNlIGZvciBpIGluIHJhbmdlKDEwKV0gZm9yIF8gaW4gcmFuZ2UoOSldXG4gICAgICAgIHNlbGYuYm9hcmQgPSBib2FyZFxuICAgICAgICBmb3IgaSBpbiByYW5nZSg5KTpcbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKDkpOlxuICAgICAgICAgICAgICAgIGlmIHNlbGYuYm9hcmRbaV1bal0gIT0gXCIuXCI6XG4gICAgICAgICAgICAgICAgICAgIG51bSA9IGludChzZWxmLmJvYXJkW2ldW2pdKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnJvd19zdGF0ZVtpXVtudW1dID0gVHJ1ZVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbHVtbl9zdGF0ZVtqXVtudW1dID0gVHJ1ZVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmJveF9zdGF0ZVsoaSAvLyAzKSAqIDMgKyBqIC8vIDNdW251bV0gPSBUcnVlXG5cbiAgICAgICAgZGVmIHJlY3Vyc2l2ZV9wbGFjZV9udW1iZXIoc2VsZiwgcm93OiBpbnQsIGNvbHVtbjogaW50LCkgLT4gYm9vbDpcbiAgICAgICAgICAgIGlmIGNvbHVtbiA9PSA5OlxuICAgICAgICAgICAgICAgIHJvdyArPSAxXG4gICAgICAgICAgICAgICAgY29sdW1uID0gMFxuICAgICAgICAgICAgICAgIGlmIHJvdyA9PSA5OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHJ1ZVxuXG4gICAgICAgICAgICBpZiBzZWxmLmJvYXJkW3Jvd11bY29sdW1uXSAhPSBcIi5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdXJzaXZlX3BsYWNlX251bWJlcihzZWxmLCByb3csIGNvbHVtbiArIDEpXG4gICAgICAgICAgICBlbHNlOlxuICAgICAgICAgICAgICAgIGZvciBpIGluIHJhbmdlKDEsIDEwKTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yb3dfc3RhdGVbcm93XVtpXVxuICAgICAgICAgICAgICAgICAgICAgICAgb3Igc2VsZi5jb2x1bW5fc3RhdGVbY29sdW1uXVtpXVxuICAgICAgICAgICAgICAgICAgICAgICAgb3Igc2VsZi5ib3hfc3RhdGVbKHJvdyAvLyAzKSAqIDMgKyBjb2x1bW4gLy8gM11baV1cbiAgICAgICAgICAgICAgICAgICAgKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIGVsc2U6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBsYWNlX251bWJlcihyb3csIGNvbHVtbiwgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIHJlY3Vyc2l2ZV9wbGFjZV9udW1iZXIoc2VsZiwgcm93LCBjb2x1bW4gKyAxLCk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudW5kb19udW1iZXJfcGxhY2VtZW50KHJvdywgY29sdW1uLCBpKVxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXG5cbiAgICAgICAgcmVjdXJzaXZlX3BsYWNlX251bWJlcihzZWxmLCAwLCAwKVxuXG4gICAgZGVmIHBsYWNlX251bWJlcihzZWxmLCByb3c6IGludCwgY29sdW1uOiBpbnQsIGk6IGludCwpIC0+IGJvb2w6XG4gICAgICAgIHNlbGYucm93X3N0YXRlW3Jvd11baV0gPSBUcnVlXG4gICAgICAgIHNlbGYuY29sdW1uX3N0YXRlW2NvbHVtbl1baV0gPSBUcnVlXG4gICAgICAgIHNlbGYuYm94X3N0YXRlWyhyb3cgLy8gMykgKiAzICsgY29sdW1uIC8vIDNdW2ldID0gVHJ1ZVxuICAgICAgICBzZWxmLmJvYXJkW3Jvd11bY29sdW1uXSA9IHN0cihpKVxuXG4gICAgZGVmIHVuZG9fbnVtYmVyX3BsYWNlbWVudChzZWxmLCByb3c6IGludCwgY29sdW1uOiBpbnQsIGk6IGludCwpIC0+IGJvb2w6XG4gICAgICAgIHNlbGYucm93X3N0YXRlW3Jvd11baV0gPSBGYWxzZVxuICAgICAgICBzZWxmLmNvbHVtbl9zdGF0ZVtjb2x1bW5dW2ldID0gRmFsc2VcbiAgICAgICAgc2VsZi5ib3hfc3RhdGVbKHJvdyAvLyAzKSAqIDMgKyBjb2x1bW4gLy8gM11baV0gPSBGYWxzZVxuICAgICAgICBzZWxmLmJvYXJkW3Jvd11bY29sdW1uXSA9IFwiLlwiXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTQuMy4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wcml2YXRlOlxuICAgIHZlY3Rvcjx2ZWN0b3I8Ym9vbD4+IHJvd19zdGF0ZTtcbiAgICB2ZWN0b3I8dmVjdG9yPGJvb2w+PiBjb2x1bW5fc3RhdGU7XG4gICAgdmVjdG9yPHZlY3Rvcjxib29sPj4gYm94X3N0YXRlO1xuXG5wcml2YXRlOlxuICAgIHBhaXI8aW50LCBpbnQ+IGdldE1heFBvc3NpYmxlQ29vcmRpbmF0ZSh2ZWN0b3I8dmVjdG9yPGNoYXI+PiYgYm9hcmQpIHtcbiAgICAgICAgaW50IHggPSAtMSwgeSA9IC0xLCBtaW5fY291bnQgPSA5O1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDk7IGkrKylcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgOTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJvYXJkW2ldW2pdICE9ICcuJykgY29udGludWU7XG4gICAgICAgICAgICAgICAgaW50IHRtcF9jb3VudCA9IDk7XG4gICAgICAgICAgICAgICAgZm9yIChpbnQgayA9IDA7IGsgPCA5OyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvd19zdGF0ZVtpXVtrXSB8fCBjb2x1bW5fc3RhdGVbal1ba10gfHwgYm94X3N0YXRlWyhpIC8gMykgKiAzICsgaiAvIDNdW2tdKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wX2NvdW50IC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICh0bXBfY291bnQgPT0gMSkgcmV0dXJuIG1ha2VfcGFpcihpLCBqKTtcbiAgICAgICAgICAgICAgICBpZiAobWluX2NvdW50ID4gdG1wX2NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbl9jb3VudCA9IHRtcF9jb3VudDtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBtYWtlX3BhaXIoeCwgeSk7XG4gICAgfVxuXG4gICAgdm9pZCBwbGFjZU51bWJlcih2ZWN0b3I8dmVjdG9yPGNoYXI+PiYgYm9hcmQsIGludCByb3csIGludCBjb2x1bW4sIGludCBpKSB7XG4gICAgICAgIGJvYXJkW3Jvd11bY29sdW1uXSA9IGkgKyAnMCc7XG4gICAgICAgIHJvd19zdGF0ZVtyb3ddW2ldICAgID0gdHJ1ZTtcbiAgICAgICAgY29sdW1uX3N0YXRlW2NvbHVtbl1baV0gPSB0cnVlO1xuICAgICAgICBib3hfc3RhdGVbKChyb3cgLyAzKSAqIDMpICsgKGNvbHVtbiAvIDMpXVtpXSA9IHRydWU7XG4gICAgfVxuXG4gICAgdm9pZCB1bmRvTnVtYmVyUGxhY2UodmVjdG9yPHZlY3RvcjxjaGFyPj4mIGJvYXJkLCBpbnQgcm93LCBpbnQgY29sdW1uLCBpbnQgaSkge1xuICAgICAgICBib2FyZFtyb3ddW2NvbHVtbl0gPSAnLic7XG4gICAgICAgIHJvd19zdGF0ZVtyb3ddW2ldID0gZmFsc2U7XG4gICAgICAgIGNvbHVtbl9zdGF0ZVtjb2x1bW5dW2ldID0gZmFsc2U7XG4gICAgICAgIGJveF9zdGF0ZVsoKHJvdyAvIDMpICogMykgKyAoY29sdW1uIC8gMyldW2ldID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdm9pZCBpbml0aWFsU3RhdGUodmVjdG9yPHZlY3RvcjxjaGFyPj4mIGJvYXJkKSB7XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgOTsgaSsrKVxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCA5OyBqKyspXG4gICAgICAgICAgICAgICAgaWYgKGJvYXJkW2ldW2pdICE9ICcuJykge1xuICAgICAgICAgICAgICAgICAgICByb3dfc3RhdGVbaV1bYm9hcmRbaV1bal0gLSAnMCddICAgICA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9zdGF0ZVtqXVtib2FyZFtpXVtqXSAtICcwJ10gID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYm94X3N0YXRlWyhpIC8gMykgKiAzICsgaiAvIDNdW2JvYXJkW2ldW2pdIC0gJzAnXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgIH1cblxuICAgIGJvb2wgcmVjdXJzaXZlUGxhY2VOdW1iZXIodmVjdG9yPHZlY3RvcjxjaGFyPj4mIGJvYXJkLCBpbnQgcm93LCBpbnQgY29sdW1uKSB7XG4gICAgICAgIGlmIChyb3cgPT0gLTEgYW5kIGNvbHVtbiA9PSAtMSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChib2FyZFtyb3ddW2NvbHVtbl0gIT0gJy4nKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IDE7IGkgPCAxMDsgaSArKykge1xuICAgICAgICAgICAgaWYgKHJvd19zdGF0ZVtyb3ddW2ldIHx8XG4gICAgICAgICAgICAgICAgY29sdW1uX3N0YXRlW2NvbHVtbl1baV0gfHxcbiAgICAgICAgICAgICAgICBib3hfc3RhdGVbKHJvdyAvIDMpICogMyArIGNvbHVtbiAvIDNdW2ldKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsYWNlTnVtYmVyKGJvYXJkLCByb3csIGNvbHVtbiwgaSk7XG4gICAgICAgICAgICAgICAgcGFpcjxpbnQsIGludD4gY29vcmRpbmF0ZSA9IGdldE1heFBvc3NpYmxlQ29vcmRpbmF0ZShib2FyZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3Vyc2l2ZVBsYWNlTnVtYmVyKGJvYXJkLCBjb29yZGluYXRlLmZpcnN0LCBjb29yZGluYXRlLnNlY29uZCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIHVuZG9OdW1iZXJQbGFjZShib2FyZCwgcm93LCBjb2x1bW4sIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5wdWJsaWM6XG4gICAgdm9pZCBzb2x2ZVN1ZG9rdSh2ZWN0b3I8dmVjdG9yPGNoYXI+PiYgYm9hcmQpIHtcbiAgICAgICAgcm93X3N0YXRlICAgID0gdmVjdG9yPHZlY3Rvcjxib29sPj4oOSwgdmVjdG9yPGJvb2w+KDEwLCBmYWxzZSkpO1xuICAgICAgICBjb2x1bW5fc3RhdGUgPSB2ZWN0b3I8dmVjdG9yPGJvb2w+Pig5LCB2ZWN0b3I8Ym9vbD4oMTAsIGZhbHNlKSk7XG4gICAgICAgIGJveF9zdGF0ZSAgICA9IHZlY3Rvcjx2ZWN0b3I8Ym9vbD4+KDksIHZlY3Rvcjxib29sPigxMCwgZmFsc2UpKTtcbiAgICAgICAgXG4gICAgICAgIGluaXRpYWxTdGF0ZShib2FyZCk7XG5cbiAgICAgICAgcGFpcjxpbnQsIGludD4gY29vciA9IGdldE1heFBvc3NpYmxlQ29vcmRpbmF0ZShib2FyZCk7XG4gICAgICAgIFxuICAgICAgICByZWN1cnNpdmVQbGFjZU51bWJlcihib2FyZCwgY29vci5maXJzdCwgY29vci5zZWNvbmQpO1xuICAgIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJwdWJsaWMgY2xhc3MgU3Vkb2t1U29sdmVyIHtcbiAgICBwdWJsaWMgdm9pZCBzb2x2ZVN1ZG9rdShjaGFyW11bXSBib2FyZCkge1xuICAgICAgICBib29sZWFuIHJvd1N0YXRlW11bXSA9IG5ldyBib29sZWFuWzldWzEwXTtcbiAgICAgICAgYm9vbGVhbiBjb2x1bW5TdGF0ZVtdW10gPSBuZXcgYm9vbGVhbls5XVsxMF07XG4gICAgICAgIGJvb2xlYW4gYm94U3RhdGVbXVtdID0gbmV3IGJvb2xlYW5bOV1bMTBdO1xuXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IDk7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChib2FyZFtpXVtqXSAhPSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50IGluZGV4ID0gYm9hcmRbaV1bal0gLSAnMCc7XG4gICAgICAgICAgICAgICAgICAgIHJvd1N0YXRlW2ldW2luZGV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtblN0YXRlW2pdW2luZGV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJveFN0YXRlWyhpIC8gMykgKiAzICsgaiAvIDNdW2luZGV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGludFtdIGNvb3JkaW5hdGUgPSBnZXRNYXhQb3NzaWJsZUNvb3JkaW5hdGUoYm9hcmQsIHJvd1N0YXRlLCBjb2x1bW5TdGF0ZSwgYm94U3RhdGUpO1xuXG4gICAgICAgIHJlY3Vyc2l2ZVBsYWNlTnVtYmVyMihib2FyZCwgcm93U3RhdGUsIGNvbHVtblN0YXRlLCBib3hTdGF0ZSwgY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbnRbXSBnZXRNYXhQb3NzaWJsZUNvb3JkaW5hdGUoY2hhcltdW10gYm9hcmQsIGJvb2xlYW5bXVtdIHJvd1N0YXRlLCBib29sZWFuW11bXSBjb2x1bW5TdGF0ZSwgYm9vbGVhbltdW10gYm94U3RhdGUpIHtcbiAgICAgICAgaW50IHggPSAtMSwgeSA9IC0xLCBtaW5Db3VudCA9IDk7XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IDk7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChib2FyZFtpXVtqXSAhPSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGludCB0bXBDb3VudCA9IDk7XG4gICAgICAgICAgICAgICAgZm9yIChpbnQgayA9IDA7IGsgPCA5OyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvd1N0YXRlW2ldW2tdIHx8IGNvbHVtblN0YXRlW2pdW2tdIHx8IGJveFN0YXRlWyhpIC8gMykgKiAzICsgaiAvIDNdW2tdKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wQ291bnQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRtcENvdW50ID09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW50W117aSwgan07XG5cbiAgICAgICAgICAgICAgICBpZiAobWluQ291bnQgPiB0bXBDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBtaW5Db3VudCA9IHRtcENvdW50O1xuICAgICAgICAgICAgICAgICAgICB4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgaW50W117eCwgeX07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBib29sZWFuIHJlY3Vyc2l2ZVBsYWNlTnVtYmVyMihjaGFyW11bXSBib2FyZCwgYm9vbGVhbltdW10gcm93U3RhdGUsIGJvb2xlYW5bXVtdIGNvbHVtblN0YXRlLCBib29sZWFuW11bXSBib3hTdGF0ZSwgaW50IHJvdywgaW50IGNvbHVtbikge1xuICAgICAgICBpZiAocm93ID09IC0xICYmIGNvbHVtbiA9PSAtMSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoYm9hcmRbcm93XVtjb2x1bW5dICE9ICcuJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyb3dTdGF0ZVtyb3ddW2ldIHx8IGNvbHVtblN0YXRlW2NvbHVtbl1baV0gfHwgYm94U3RhdGVbKHJvdyAvIDMpICogMyArIGNvbHVtbiAvIDNdW2ldKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsYWNlTnVtYmVyKGJvYXJkLCByb3dTdGF0ZSwgY29sdW1uU3RhdGUsIGJveFN0YXRlLCByb3csIGNvbHVtbiwgaSk7XG4gICAgICAgICAgICAgICAgaW50W10gY29vcmRpbmF0ZSA9IGdldE1heFBvc3NpYmxlQ29vcmRpbmF0ZShib2FyZCwgcm93U3RhdGUsIGNvbHVtblN0YXRlLCBib3hTdGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3Vyc2l2ZVBsYWNlTnVtYmVyMihib2FyZCwgcm93U3RhdGUsIGNvbHVtblN0YXRlLCBib3hTdGF0ZSwgY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuZG9OdW1iZXJQbGFjZW1lbnQoYm9hcmQsIHJvd1N0YXRlLCBjb2x1bW5TdGF0ZSwgYm94U3RhdGUsIHJvdywgY29sdW1uLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmYWlsZWQgdG8gZ2V0IGFuIGFuc3dlclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2b2lkIHBsYWNlTnVtYmVyKGNoYXJbXVtdIGJvYXJkLCBib29sZWFuW11bXSByb3dTdGF0ZSwgYm9vbGVhbltdW10gY29sdW1uU3RhdGUsIGJvb2xlYW5bXVtdIGJveFN0YXRlLCBpbnQgcm93LCBpbnQgY29sdW1uLCBpbnQgaSkge1xuICAgICAgICByb3dTdGF0ZVtyb3ddW2ldID0gdHJ1ZTtcbiAgICAgICAgY29sdW1uU3RhdGVbY29sdW1uXVtpXSA9IHRydWU7XG4gICAgICAgIGJveFN0YXRlWyhyb3cgLyAzKSAqIDMgKyBjb2x1bW4gLyAzXVtpXSA9IHRydWU7XG4gICAgICAgIGJvYXJkW3Jvd11bY29sdW1uXSA9IChjaGFyKSAoJzAnICsgaSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2b2lkIHVuZG9OdW1iZXJQbGFjZW1lbnQoY2hhcltdW10gYm9hcmQsIGJvb2xlYW5bXVtdIHJvd1N0YXRlLCBib29sZWFuW11bXSBjb2x1bW5TdGF0ZSwgYm9vbGVhbltdW10gYm94U3RhdGUsIGludCByb3csIGludCBjb2x1bW4sIGludCBpKSB7XG4gICAgICAgIHJvd1N0YXRlW3Jvd11baV0gPSBmYWxzZTtcbiAgICAgICAgY29sdW1uU3RhdGVbY29sdW1uXVtpXSA9IGZhbHNlO1xuICAgICAgICBib3hTdGF0ZVsocm93IC8gMykgKiAzICsgY29sdW1uIC8gM11baV0gPSBmYWxzZTtcbiAgICAgICAgYm9hcmRbcm93XVtjb2x1bW5dID0gJy4nO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZnJvbSB0eXBpbmcgaW1wb3J0IExpc3RcblxuXG5jbGFzcyBTb2x1dGlvbjpcbiAgICByb3dfc3RhdGUgPSBbW0ZhbHNlIGZvciBpIGluIHJhbmdlKDEwKV0gZm9yIF8gaW4gcmFuZ2UoOSldXG4gICAgY29sdW1uX3N0YXRlID0gW1tGYWxzZSBmb3IgaSBpbiByYW5nZSgxMCldIGZvciBfIGluIHJhbmdlKDkpXVxuICAgIGJveF9zdGF0ZSA9IFtbRmFsc2UgZm9yIGkgaW4gcmFuZ2UoMTApXSBmb3IgXyBpbiByYW5nZSg5KV1cbiAgICBib2FyZCA9IFtdXG5cbiAgICBkZWYgc29sdmVTdWRva3Uoc2VsZiwgYm9hcmQ6IExpc3RbTGlzdFtzdHJdXSkgLT4gTm9uZTpcblxuICAgICAgICBzZWxmLnJvd19zdGF0ZSA9IFtbRmFsc2UgZm9yIGkgaW4gcmFuZ2UoMTApXSBmb3IgXyBpbiByYW5nZSg5KV1cbiAgICAgICAgc2VsZi5jb2x1bW5fc3RhdGUgPSBbW0ZhbHNlIGZvciBpIGluIHJhbmdlKDEwKV0gZm9yIF8gaW4gcmFuZ2UoOSldXG4gICAgICAgIHNlbGYuYm94X3N0YXRlID0gW1tGYWxzZSBmb3IgaSBpbiByYW5nZSgxMCldIGZvciBfIGluIHJhbmdlKDkpXVxuICAgICAgICBzZWxmLmJvYXJkID0gYm9hcmRcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoOSk6XG4gICAgICAgICAgICBmb3IgaiBpbiByYW5nZSg5KTpcbiAgICAgICAgICAgICAgICBpZiBzZWxmLmJvYXJkW2ldW2pdICE9IFwiLlwiOlxuICAgICAgICAgICAgICAgICAgICBudW0gPSBpbnQoc2VsZi5ib2FyZFtpXVtqXSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yb3dfc3RhdGVbaV1bbnVtXSA9IFRydWVcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb2x1bW5fc3RhdGVbal1bbnVtXSA9IFRydWVcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ib3hfc3RhdGVbKGkgLy8gMykgKiAzICsgaiAvLyAzXVtudW1dID0gVHJ1ZVxuXG4gICAgICAgIGRlZiByZWN1cnNpdmVfcGxhY2VfbnVtYmVyKHNlbGYsIHJvdzogaW50LCBjb2x1bW46IGludCwpIC0+IGJvb2w6XG4gICAgICAgICAgICBpZiByb3cgPT0gLTEgYW5kIGNvbHVtbiA9PSAtMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJ1ZVxuICAgICAgICAgICAgaWYgYm9hcmRbcm93XVtjb2x1bW5dICE9IFwiLlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBGYWxzZVxuXG4gICAgICAgICAgICBmb3IgaSBpbiByYW5nZSgxLCAxMCk6XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBzZWxmLnJvd19zdGF0ZVtyb3ddW2ldXG4gICAgICAgICAgICAgICAgICAgIG9yIHNlbGYuY29sdW1uX3N0YXRlW2NvbHVtbl1baV1cbiAgICAgICAgICAgICAgICAgICAgb3Igc2VsZi5ib3hfc3RhdGVbKHJvdyAvLyAzKSAqIDMgKyBjb2x1bW4gLy8gM11baV1cbiAgICAgICAgICAgICAgICApOlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgIGVsc2U6XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGxhY2VfbnVtYmVyKHJvdywgY29sdW1uLCBpKVxuICAgICAgICAgICAgICAgICAgICB4LCB5ID0gc2VsZi5nZXRfbWF4X3Bvc3NpYmxlX2Nvb3JkaW5hdGUoKVxuICAgICAgICAgICAgICAgICAgICBpZiByZWN1cnNpdmVfcGxhY2VfbnVtYmVyKHNlbGYsIHgsIHksKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBUcnVlXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudW5kb19udW1iZXJfcGxhY2VtZW50KHJvdywgY29sdW1uLCBpKVxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXG5cbiAgICAgICAgeCwgeSA9IHNlbGYuZ2V0X21heF9wb3NzaWJsZV9jb29yZGluYXRlKClcbiAgICAgICAgcmVjdXJzaXZlX3BsYWNlX251bWJlcihzZWxmLCB4LCB5KVxuXG4gICAgZGVmIHBsYWNlX251bWJlcihzZWxmLCByb3c6IGludCwgY29sdW1uOiBpbnQsIGk6IGludCwpIC0+IGJvb2w6XG4gICAgICAgIHNlbGYucm93X3N0YXRlW3Jvd11baV0gPSBUcnVlXG4gICAgICAgIHNlbGYuY29sdW1uX3N0YXRlW2NvbHVtbl1baV0gPSBUcnVlXG4gICAgICAgIHNlbGYuYm94X3N0YXRlWyhyb3cgLy8gMykgKiAzICsgY29sdW1uIC8vIDNdW2ldID0gVHJ1ZVxuICAgICAgICBzZWxmLmJvYXJkW3Jvd11bY29sdW1uXSA9IHN0cihpKVxuXG4gICAgZGVmIHVuZG9fbnVtYmVyX3BsYWNlbWVudChzZWxmLCByb3c6IGludCwgY29sdW1uOiBpbnQsIGk6IGludCwpIC0+IGJvb2w6XG4gICAgICAgIHNlbGYucm93X3N0YXRlW3Jvd11baV0gPSBGYWxzZVxuICAgICAgICBzZWxmLmNvbHVtbl9zdGF0ZVtjb2x1bW5dW2ldID0gRmFsc2VcbiAgICAgICAgc2VsZi5ib3hfc3RhdGVbKHJvdyAvLyAzKSAqIDMgKyBjb2x1bW4gLy8gM11baV0gPSBGYWxzZVxuICAgICAgICBzZWxmLmJvYXJkW3Jvd11bY29sdW1uXSA9IFwiLlwiXG5cbiAgICBkZWYgZ2V0X21heF9wb3NzaWJsZV9jb29yZGluYXRlKHNlbGYpIC0+IChpbnQsIGludCk6XG4gICAgICAgIHgsIHksIG1pbl9jb3VudCA9IC0xLCAtMSwgOVxuICAgICAgICBmb3IgaSBpbiByYW5nZSg5KTpcbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKDkpOlxuICAgICAgICAgICAgICAgIGlmIHNlbGYuYm9hcmRbaV1bal0gIT0gXCIuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgdG1wX2NvdW50ID0gOVxuICAgICAgICAgICAgICAgIGZvciBrIGluIHJhbmdlKDkpOlxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJvd19zdGF0ZVtpXVtrXVxuICAgICAgICAgICAgICAgICAgICAgICAgb3Igc2VsZi5jb2x1bW5fc3RhdGVbal1ba11cbiAgICAgICAgICAgICAgICAgICAgICAgIG9yIHNlbGYuYm94X3N0YXRlWyhpIC8vIDMpICogMyArIGogLy8gM11ba11cbiAgICAgICAgICAgICAgICAgICAgKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcF9jb3VudCAtPSAxXG4gICAgICAgICAgICAgICAgaWYgdG1wX2NvdW50ID09IDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpLCBqXG4gICAgICAgICAgICAgICAgaWYgbWluX2NvdW50ID4gdG1wX2NvdW50OlxuICAgICAgICAgICAgICAgICAgICBtaW5fY291bnQgPSB0bXBfY291bnRcbiAgICAgICAgICAgICAgICAgICAgeCA9IGlcbiAgICAgICAgICAgICAgICAgICAgeSA9IGpcbiAgICAgICAgcmV0dXJuIHgsIHlcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBNC40LjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbnByaXZhdGU6XG4gICAgaW50IGdldF9uZWlnaGJvcl9jb3VudChpbnQgaSwgaW50IGosIHZlY3Rvcjx2ZWN0b3I8aW50Pj4mIGJvYXJkKSB7XG4gICAgICAgIGludCB0b3AgPSBzdGQ6Om1heCgwLCBpIC0gMSk7XG4gICAgICAgIGludCBib3R0b20gPSBzdGQ6Om1pbjxpbnQ+KGJvYXJkLnNpemUoKSAtIDEsIGkgKyAxKTtcbiAgICAgICAgaW50IGxlZnQgPSBzdGQ6Om1heCgwLCBqIC0gMSk7XG4gICAgICAgIGludCByaWdodCA9IHN0ZDo6bWluPGludD4oYm9hcmRbMF0uc2l6ZSgpIC0gMSwgaiArIDEpO1xuICAgICAgICBcbiAgICAgICAgaW50IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIChpbnQgeCA9IHRvcDsgeCA8IGJvdHRvbSArIDE7IHgrKylcbiAgICAgICAgICAgIGZvciAoaW50IHkgPSBsZWZ0OyB5IDwgcmlnaHQgKyAxOyB5KyspXG4gICAgICAgICAgICAgICAgaWYgKGJvYXJkW3hdW3ldID09IDEgfHwgYm9hcmRbeF1beV0gPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxucHVibGljOlxuICAgIHZvaWQgZ2FtZU9mTGlmZSh2ZWN0b3I8dmVjdG9yPGludD4+JiBib2FyZCkge1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGJvYXJkLnNpemUoKTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IGJvYXJkWzBdLnNpemUoKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaW50IHJlcyA9IGdldF9uZWlnaGJvcl9jb3VudChpLCBqLCBib2FyZCk7XG4gICAgICAgICAgICAgICAgaWYgKGJvYXJkW2ldW2pdID09IDEgJiYgKHJlcyA9PSAzIHx8IHJlcyA9PSA0KSlcbiAgICAgICAgICAgICAgICAgICAgYm9hcmRbaV1bal0gPSAxO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJvYXJkW2ldW2pdID09IDEpXG4gICAgICAgICAgICAgICAgICAgIGJvYXJkW2ldW2pdID0gLTE7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYm9hcmRbaV1bal0gPT0gMCAmJiByZXMgPT0gMylcbiAgICAgICAgICAgICAgICAgICAgYm9hcmRbaV1bal0gPSAtMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBib2FyZC5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBib2FyZFswXS5zaXplKCk7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChib2FyZFtpXVtqXSA9PSAtMilcbiAgICAgICAgICAgICAgICAgICAgYm9hcmRbaV1bal0gPSAxO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJvYXJkW2ldW2pdID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBib2FyZFtpXVtqXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicHVibGljIGNsYXNzIEdhbWVPZkxpZmUge1xuICAgIHB1YmxpYyB2b2lkIGdhbWVPZkxpZmUoaW50W11bXSBib2FyZCkge1xuICAgICAgICAvLyBkbyBpbiBwbGFjZSBsaWZlIGNoZWNrXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgYm9hcmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgYm9hcmRbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBib2FyZFtpXVtqXSA9IGNoZWNrTGlmZUluUGxhY2UoYm9hcmQsIGJvYXJkW2ldW2pdLCBpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0cmFuc2xhdGVcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBib2FyZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBib2FyZFtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChib2FyZFtpXVtqXSA9PSAyKVxuICAgICAgICAgICAgICAgICAgICBib2FyZFtpXVtqXSA9IDE7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYm9hcmRbaV1bal0gPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGJvYXJkW2ldW2pdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaW50IGNoZWNrTGlmZUluUGxhY2UoaW50W11bXSBib2FyZCwgaW50IHByZVN0YXRlLCBpbnQgaSwgaW50IGopIHtcbiAgICAgICAgaW50IG5laWdoYm9yQ291bnQgPSBnZXROZWlnaGJvckNvdW50Rm9ySW5QbGFjZShib2FyZCwgcHJlU3RhdGUsIGksIGopO1xuICAgICAgICBpZiAobmVpZ2hib3JDb3VudCA8IDIgfHwgbmVpZ2hib3JDb3VudCA+IDMpXG4gICAgICAgICAgICByZXR1cm4gcHJlU3RhdGUgPT0gMCA/IDAgOiAtMTtcbiAgICAgICAgZWxzZSBpZiAobmVpZ2hib3JDb3VudCA9PSAzKVxuICAgICAgICAgICAgcmV0dXJuIHByZVN0YXRlID09IDEgPyAxIDogMjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHByZVN0YXRlO1xuICAgIH1cblxuICAgIC8vICAgICAgLTEgYXMgZm9yIDEgdG8gMDtcbiAgICAvLyAgICAgIDIgYXMgZm9yIDAgdG8gMTtcbiAgICBwcml2YXRlIGludCBnZXROZWlnaGJvckNvdW50Rm9ySW5QbGFjZShpbnRbXVtdIGJvYXJkLCBpbnQgcHJlU3RhdGUsIGludCBpLCBpbnQgaikge1xuICAgICAgICBpbnQgY291bnQgPSAwO1xuICAgICAgICBpbnQgbWF4Um93ID0gYm9hcmQubGVuZ3RoIC0gMSwgbWF4Q29sdW1uID0gYm9hcmRbMF0ubGVuZ3RoIC0gMTtcblxuICAgICAgICBpZiAoaSAhPSAwKSB7XG4gICAgICAgICAgICBjb3VudCArPSBib2FyZFtpIC0gMV1bal0gPT0gMSB8fCBib2FyZFtpIC0gMV1bal0gPT0gLTEgPyAxIDogMDtcbiAgICAgICAgICAgIGlmIChqICE9IDApIHtcbiAgICAgICAgICAgICAgICBjb3VudCArPSBib2FyZFtpIC0gMV1baiAtIDFdID09IDEgfHwgYm9hcmRbaSAtIDFdW2ogLSAxXSA9PSAtMSA/IDEgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGogIT0gbWF4Q29sdW1uKSB7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gYm9hcmRbaSAtIDFdW2ogKyAxXSA9PSAxIHx8IGJvYXJkW2kgLSAxXVtqICsgMV0gPT0gLTEgPyAxIDogMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgIT0gbWF4Um93KSB7XG4gICAgICAgICAgICBjb3VudCArPSBib2FyZFtpICsgMV1bal0gPT0gMSB8fCBib2FyZFtpICsgMV1bal0gPT0gLTEgPyAxIDogMDtcbiAgICAgICAgICAgIGlmIChqICE9IDApIHtcbiAgICAgICAgICAgICAgICBjb3VudCArPSBib2FyZFtpICsgMV1baiAtIDFdID09IDEgfHwgYm9hcmRbaSArIDFdW2ogLSAxXSA9PSAtMSA/IDEgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGogIT0gbWF4Q29sdW1uKSB7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gYm9hcmRbaSArIDFdW2ogKyAxXSA9PSAxIHx8IGJvYXJkW2kgKyAxXVtqICsgMV0gPT0gLTEgPyAxIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqICE9IDApIHtcbiAgICAgICAgICAgIGNvdW50ICs9IGJvYXJkW2ldW2ogLSAxXSA9PSAxIHx8IGJvYXJkW2ldW2ogLSAxXSA9PSAtMSA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqICE9IG1heENvbHVtbikge1xuICAgICAgICAgICAgY291bnQgKz0gYm9hcmRbaV1baiArIDFdID09IDEgfHwgYm9hcmRbaV1baiArIDFdID09IC0xID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZnJvbSB0eXBpbmcgaW1wb3J0IExpc3RcblxuXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgZ2FtZU9mTGlmZShzZWxmLCBib2FyZDogTGlzdFtMaXN0W2ludF1dKSAtPiBOb25lOlxuICAgICAgICBkZWYgZ2V0X25laWdoYm9yX2NvdW50KGksIGosIGJvYXJkKTpcbiAgICAgICAgICAgIHRvcCA9IG1heCgwLCBpIC0gMSlcbiAgICAgICAgICAgIGJvdHRvbSA9IG1pbihsZW4oYm9hcmQpIC0gMSwgaSArIDEpXG4gICAgICAgICAgICBsZWZ0ID0gbWF4KDAsIGogLSAxKVxuICAgICAgICAgICAgcmlnaHQgPSBtaW4obGVuKGJvYXJkWzBdKSAtIDEsIGogKyAxKVxuXG4gICAgICAgICAgICBjb3VudCA9IDBcbiAgICAgICAgICAgIGZvciB4IGluIHJhbmdlKHRvcCwgYm90dG9tICsgMSk6XG4gICAgICAgICAgICAgICAgZm9yIHkgaW4gcmFuZ2UobGVmdCwgcmlnaHQgKyAxKTpcbiAgICAgICAgICAgICAgICAgICAgaWYgYm9hcmRbeF1beV0gPT0gMSBvciBib2FyZFt4XVt5XSA9PSAtMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IDFcbiAgICAgICAgICAgIHJldHVybiBjb3VudFxuXG4gICAgICAgIGZvciBpIGluIHJhbmdlKGxlbihib2FyZCkpOlxuICAgICAgICAgICAgZm9yIGogaW4gcmFuZ2UobGVuKGJvYXJkWzBdKSk6XG4gICAgICAgICAgICAgICAgcmVzID0gZ2V0X25laWdoYm9yX2NvdW50KGksIGosIGJvYXJkKVxuICAgICAgICAgICAgICAgIGlmIGJvYXJkW2ldW2pdID09IDEgYW5kIHJlcyBpbiBbMywgNF06XG4gICAgICAgICAgICAgICAgICAgIGJvYXJkW2ldW2pdID0gMVxuICAgICAgICAgICAgICAgIGVsaWYgYm9hcmRbaV1bal0gPT0gMTpcbiAgICAgICAgICAgICAgICAgICAgYm9hcmRbaV1bal0gPSAtMVxuICAgICAgICAgICAgICAgIGVsaWYgYm9hcmRbaV1bal0gPT0gMCBhbmQgcmVzID09IDM6XG4gICAgICAgICAgICAgICAgICAgIGJvYXJkW2ldW2pdID0gLTJcblxuICAgICAgICBmb3IgaSBpbiByYW5nZShsZW4oYm9hcmQpKTpcbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKGxlbihib2FyZFswXSkpOlxuICAgICAgICAgICAgICAgIGlmIGJvYXJkW2ldW2pdID09IC0yOlxuICAgICAgICAgICAgICAgICAgICBib2FyZFtpXVtqXSA9IDFcbiAgICAgICAgICAgICAgICBlbGlmIGJvYXJkW2ldW2pdID09IC0xOlxuICAgICAgICAgICAgICAgICAgICBib2FyZFtpXVtqXSA9IDBcblxuIgogICAgfV0KICB9XQp9LCB7CiAgImlkIjogIjA1IiwKICAibmFtZSI6ICLnrKzkupTnq6AiLAogICJsaXN0IjogW3sKICAgICJ0aXRsZSI6ICLku6PnoIE1LjEuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiIHN0cnVjdCBUcmVlTm9kZSB7XG4gICAgaW50IHZhbDtcbiAgICBUcmVlTm9kZSAqbGVmdDtcbiAgICBUcmVlTm9kZSAqcmlnaHQ7XG4gICAgVHJlZU5vZGUoaW50IHgpIDogdmFsKHgpLCBsZWZ0KE5VTEwpLCByaWdodChOVUxMKSB7fVxufTtcbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgICBib29sIGhhc1BhdGhTdW0oVHJlZU5vZGUqIHJvb3QsIGludCBzdW0pIHtcbiAgICAgICAgaWYocm9vdCA9PSBOVUxMKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaWYocm9vdC0+bGVmdCA9PSBOVUxMICYmIHJvb3QtPnJpZ2h0ID09IE5VTEwpIHtcbiAgICAgICAgICAgIGlmKHJvb3QtPnZhbCA9PSBzdW0pIHJldHVybiB0cnVlO1xuICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYXNQYXRoU3VtKHJvb3QtPmxlZnQsIHN1bSAtIHJvb3QtPnZhbCkgfHwgaGFzUGF0aFN1bShyb290LT5yaWdodCwgc3VtIC0gcm9vdC52YWwpO1xuICAgIH1cblxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJwdWJsaWMgY2xhc3MgVHJlZU5vZGUge1xuICBpbnQgdmFsO1xuICBUcmVlTm9kZSBsZWZ0O1xuICBUcmVlTm9kZSByaWdodDtcblxuICBUcmVlTm9kZShpbnQgeCkge1xuICAgIHZhbCA9IHg7XG4gIH1cbn1cblxuY2xhc3MgU29sdXRpb24ge1xuICBwdWJsaWMgYm9vbGVhbiBoYXNQYXRoU3VtKFRyZWVOb2RlIHJvb3QsIGludCBzdW0pIHtcbiAgICBpZiAocm9vdCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICBzdW0gLT0gcm9vdC52YWw7XG5cbiAgICBpZiAoKHJvb3QubGVmdCA9PSBudWxsKSAmJiAocm9vdC5yaWdodCA9PSBudWxsKSkgcmV0dXJuIChzdW0gPT0gMCk7XG5cbiAgICByZXR1cm4gaGFzUGF0aFN1bShyb290LmxlZnQsIHN1bSkgfHwgaGFzUGF0aFN1bShyb290LnJpZ2h0LCBzdW0pO1xuICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFRyZWVOb2RlOlxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCB4KTpcbiAgICAgICAgc2VsZi52YWwgPSB4XG4gICAgICAgIHNlbGYubGVmdCA9IE5vbmVcbiAgICAgICAgc2VsZi5yaWdodCA9IE5vbmVcblxuXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgaGFzUGF0aFN1bShzZWxmLCByb290OiBUcmVlTm9kZSwgc3VtOiBpbnQpIC0+IGJvb2w6XG4gICAgICAgIGlmIG5vdCByb290OlxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXG5cbiAgICAgICAgaWYgcm9vdC5sZWZ0IGlzIE5vbmUgYW5kIHJvb3QucmlnaHQgaXMgTm9uZTpcbiAgICAgICAgICAgIGlmIHJvb3QudmFsID09IHN1bTpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJ1ZVxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXG5cbiAgICAgICAgcmV0dXJuIHNlbGYuaGFzUGF0aFN1bShyb290LmxlZnQsIHN1bSAtIHJvb3QudmFsKSBvciBzZWxmLmhhc1BhdGhTdW0oXG4gICAgICAgICAgICByb290LnJpZ2h0LCBzdW0gLSByb290LnZhbFxuICAgICAgICApXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTUuMS4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIvKipcbiAqIERlZmluaXRpb24gZm9yIGEgYmluYXJ5IHRyZWUgbm9kZS5cbiAqIHN0cnVjdCBUcmVlTm9kZSB7XG4gKiAgICAgaW50IHZhbDtcbiAqICAgICBUcmVlTm9kZSAqbGVmdDtcbiAqICAgICBUcmVlTm9kZSAqcmlnaHQ7XG4gKiAgICAgVHJlZU5vZGUoaW50IHgpIDogdmFsKHgpLCBsZWZ0KE5VTEwpLCByaWdodChOVUxMKSB7fVxuICogfTtcbiAqL1xuIHN0cnVjdCBUcmVlTm9kZSB7XG4gICAgaW50IHZhbDtcbiAgICBUcmVlTm9kZSAqbGVmdDtcbiAgICBUcmVlTm9kZSAqcmlnaHQ7XG4gICAgVHJlZU5vZGUoaW50IHgpIDogdmFsKHgpLCBsZWZ0KE5VTEwpLCByaWdodChOVUxMKSB7fVxuIH07XG4gXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgYm9vbCBoYXNQYXRoU3VtKFRyZWVOb2RlKiByb290LCBpbnQgc3VtKSB7XG4gICAgICAgIGlmKHJvb3QgPT0gTlVMTCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGlmKHJvb3QtPmxlZnQgPT0gTlVMTCAmJiByb290LT5yaWdodCA9PSBOVUxMKSB7XG4gICAgICAgICAgICBpZihyb290LT52YWwgPT0gc3VtKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGFzUGF0aFN1bShyb290LT5sZWZ0LCBzdW0gLSByb290LT52YWwpIHx8IGhhc1BhdGhTdW0ocm9vdC0+cmlnaHQsIHN1bSAtIHJvb3QudmFsKTtcbiAgICB9XG5cbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicHVibGljIGNsYXNzIFRyZWVOb2RlIHtcbiAgaW50IHZhbDtcbiAgVHJlZU5vZGUgbGVmdDtcbiAgVHJlZU5vZGUgcmlnaHQ7XG5cbiAgVHJlZU5vZGUoaW50IHgpIHtcbiAgICB2YWwgPSB4O1xuICB9XG59XG5cbmNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGJvb2xlYW4gaGFzUGF0aFN1bShUcmVlTm9kZSByb290LCBpbnQgc3VtKSB7XG4gICAgaWYgKHJvb3QgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgRGVxdWU8UGFpcjxUcmVlTm9kZSwgSW50ZWdlcj4+IHN0YWNrID0gbmV3IEFycmF5RGVxdWU8UGFpcjxUcmVlTm9kZSwgSW50ZWdlcj4+KCk7XG4gICAgc3RhY2suYWRkTGFzdChuZXcgUGFpcjxUcmVlTm9kZSwgSW50ZWdlcj4ocm9vdCwgc3VtIC0gcm9vdC52YWwpKTtcblxuICAgIHdoaWxlICghc3RhY2suaXNFbXB0eSgpKSB7XG4gICAgICBQYWlyPFRyZWVOb2RlLCBJbnRlZ2VyPiB0b3AgPSBzdGFjay5yZW1vdmVMYXN0KCk7XG4gICAgICBUcmVlTm9kZSBub2RlID0gdG9wLmdldEtleSgpO1xuICAgICAgaW50IHJlbWFpbiA9IHRvcC5nZXRWYWx1ZSgpO1xuXG4gICAgICBpZiAoKG5vZGUucmlnaHQgPT0gbnVsbCkgJiYgKG5vZGUubGVmdCA9PSBudWxsKSAmJiAocmVtYWluID09IDApKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChub2RlLnJpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgc3RhY2suYWRkTGFzdChuZXcgUGFpcjxUcmVlTm9kZSwgSW50ZWdlcj4obm9kZS5yaWdodCwgcmVtYWluIC0gbm9kZS5yaWdodC52YWwpKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmxlZnQgIT0gbnVsbCkge1xuICAgICAgICBzdGFjay5hZGRMYXN0KG5ldyBQYWlyPFRyZWVOb2RlLCBJbnRlZ2VyPihub2RlLmxlZnQsIHJlbWFpbiAtIG5vZGUubGVmdC52YWwpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgVHJlZU5vZGU6XG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIHgpOlxuICAgICAgICBzZWxmLnZhbCA9IHhcbiAgICAgICAgc2VsZi5sZWZ0ID0gTm9uZVxuICAgICAgICBzZWxmLnJpZ2h0ID0gTm9uZVxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBoYXNQYXRoU3VtKHNlbGYsIHJvb3Q6IFRyZWVOb2RlLCBzdW06IGludCkgLT4gYm9vbDpcbiAgICAgICAgaWYgcm9vdCBpcyBOb25lOlxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXG5cbiAgICAgICAgc3RhY2sgPSBbKHJvb3QsIHN1bSAtIHJvb3QudmFsKV1cbiAgICAgICAgd2hpbGUgc3RhY2s6XG4gICAgICAgICAgICBub2RlLCByZW1haW4gPSBzdGFjay5wb3AoKVxuICAgICAgICAgICAgaWYgbm90IG5vZGUubGVmdCBhbmQgbm90IG5vZGUucmlnaHQgYW5kIHJlbWFpbiA9PSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBUcnVlXG4gICAgICAgICAgICBpZiBub2RlLnJpZ2h0OlxuICAgICAgICAgICAgICAgIHN0YWNrLmFwcGVuZCgobm9kZS5yaWdodCwgcmVtYWluIC0gbm9kZS5yaWdodC52YWwpKVxuICAgICAgICAgICAgaWYgbm9kZS5sZWZ0OlxuICAgICAgICAgICAgICAgIHN0YWNrLmFwcGVuZCgobm9kZS5sZWZ0LCByZW1haW4gLSBub2RlLmxlZnQudmFsKSlcbiAgICAgICAgcmV0dXJuIEZhbHNlXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTUuMS4zIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgVHJlZU5vZGUge1xuICAgIGludCB2YWw7XG4gICAgVHJlZU5vZGUgbGVmdDtcbiAgICBUcmVlTm9kZSByaWdodDtcblxuICAgIFRyZWVOb2RlKGludCB4KSB7XG4gICAgICAgIHZhbCA9IHg7XG4gICAgfVxufVxuXG5wdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICAgIHB1YmxpYyBMaXN0PExpc3Q8SW50ZWdlcj4+IHBhdGhTdW0oVHJlZU5vZGUgcm9vdCwgaW50IHN1bSkge1xuICAgICAgICBMaXN0PExpc3Q8SW50ZWdlcj4+IHJlcyA9IG5ldyBBcnJheUxpc3Q8PigpO1xuXG4gICAgICAgIGlmKHJvb3QgPT0gbnVsbCkgcmV0dXJuIHJlcztcblxuICAgICAgICBEZXF1ZTxJbnRlZ2VyPiBwYXRoID0gbmV3IEFycmF5RGVxdWU8PigpO1xuICAgICAgICBwYXRoU3VtKHJvb3QsIHN1bSwgcGF0aCwgcmVzKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIHB1YmxpYyB2b2lkIHBhdGhTdW0oVHJlZU5vZGUgbm9kZSwgaW50IHN1bSwgRGVxdWU8SW50ZWdlcj4gcGF0aCwgTGlzdDxMaXN0PEludGVnZXI+PiByZXMpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkgIHJldHVybjtcblxuICAgICAgICAvLyDmsr/pgJTnu5Pngrnlv4XpobvpgInmi6nvvIzov5nkuKrml7blgJnopoHlgZrkuKTku7bkuovvvJox44CBc3VtIOWHj+WOu+i/meS4que7k+eCueeahOWAvO+8mzLjgIHmt7vliqDliLAgcGF0aCDph4xcbiAgICAgICAgc3VtIC09IG5vZGUudmFsO1xuICAgICAgICBwYXRoLmFkZExhc3Qobm9kZS52YWwpO1xuXG4gICAgICAgIGlmIChzdW0gPT0gMCAmJiBub2RlLmxlZnQgPT0gbnVsbCAmJiBub2RlLnJpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHBhdGgg5YWo5bGA5Y+q5pyJ5LiA5Lu977yM5b+F6aG75YGa5ou36LSdXG4gICAgICAgICAgICByZXMuYWRkKG5ldyBBcnJheUxpc3Q8PihwYXRoKSk7XG4gICAgICAgICAgICAvLyDms6jmhI/vvJrov5nph4wgcmV0dXJuIOS5i+WJjeW/hemhu+mHjee9rlxuICAgICAgICAgICAgcGF0aC5yZW1vdmVMYXN0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoU3VtKG5vZGUubGVmdCwgc3VtLCBwYXRoLCByZXMpO1xuICAgICAgICBwYXRoU3VtKG5vZGUucmlnaHQsIHN1bSwgcGF0aCwgcmVzKTtcbiAgICAgICAgLy8g6YCS5b2S5a6M5oiQ5Lul5ZCO77yM5b+F6aG76YeN572u5Y+Y6YePXG4gICAgICAgIHBhdGgucmVtb3ZlTGFzdCgpOyAgICAgIFxuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZnJvbSB0eXBpbmcgaW1wb3J0IExpc3RcblxuXG5jbGFzcyBUcmVlTm9kZTpcbiAgICBkZWYgX19pbml0X18oc2VsZiwgeCk6XG4gICAgICAgIHNlbGYudmFsID0geFxuICAgICAgICBzZWxmLmxlZnQgPSBOb25lXG4gICAgICAgIHNlbGYucmlnaHQgPSBOb25lXG5cblxuY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHBhdGhTdW0oc2VsZiwgcm9vdDogVHJlZU5vZGUsIHN1bTogaW50KSAtPiBMaXN0W0xpc3RbaW50XV06XG4gICAgICAgIGRlZiBoZWxwZXIocm9vdDogVHJlZU5vZGUsIHN1bTogaW50LCBwYXRoOiBMaXN0KTpcbiAgICAgICAgICAgIGlmIG5vdCByb290OlxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgaWYgbm90IHJvb3QubGVmdCBhbmQgbm90IHJvb3QucmlnaHQgYW5kIHN1bSAtIHJvb3QudmFsID09IDA6XG4gICAgICAgICAgICAgICAgcGF0aCArPSBbcm9vdC52YWxdXG4gICAgICAgICAgICAgICAgYW5zLmFwcGVuZChwYXRoKVxuICAgICAgICAgICAgaGVscGVyKHJvb3QubGVmdCwgc3VtIC0gcm9vdC52YWwsIHBhdGggKyBbcm9vdC52YWxdKVxuICAgICAgICAgICAgaGVscGVyKHJvb3QucmlnaHQsIHN1bSAtIHJvb3QudmFsLCBwYXRoICsgW3Jvb3QudmFsXSlcblxuICAgICAgICBhbnMgPSBbXVxuICAgICAgICBoZWxwZXIocm9vdCwgc3VtLCBbXSlcbiAgICAgICAgcmV0dXJuIGFuc1xuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIE1LjEuNCIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFRyZWVOb2RlIHtcbiAgICBpbnQgdmFsO1xuICAgIFRyZWVOb2RlIGxlZnQ7XG4gICAgVHJlZU5vZGUgcmlnaHQ7XG5cbiAgICBUcmVlTm9kZShpbnQgeCkge1xuICAgICAgICB2YWwgPSB4O1xuICAgIH1cbn1cblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgICBwdWJsaWMgTGlzdDxMaXN0PEludGVnZXI+PiBwYXRoU3VtKFRyZWVOb2RlIHJvb3QsIGludCBzdW0pIHtcbiAgICAgICAgTGlzdDxMaXN0PEludGVnZXI+PiByZXMgPSBuZXcgQXJyYXlMaXN0PD4oKTtcblxuICAgICAgICBpZihyb290ID09IG51bGwpIHJldHVybiByZXM7XG5cbiAgICAgICAgRGVxdWU8SW50ZWdlcj4gcGF0aCA9IG5ldyBBcnJheURlcXVlPD4oKTtcbiAgICAgICAgRGVxdWU8UGFpcjxUcmVlTm9kZSwgSW50ZWdlcj4+IHN0YWNrID0gbmV3IEFycmF5RGVxdWU8PigpO1xuXG4gICAgICAgIHN0YWNrLmFkZExhc3QobmV3IFBhaXI8VHJlZU5vZGUsIEludGVnZXI+KHJvb3QsIHJvb3QudmFsKSk7XG4gICAgICAgIHBhdGguYWRkTGFzdChyb290LnZhbClcblxuICAgICAgICB3aGlsZSAoIXN0YWNrLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgUGFpcjxUcmVlTm9kZSwgSW50ZWdlcj4gdG9wID0gc3RhY2sucmVtb3ZlTGFzdCgpO1xuICAgICAgICAgICAgVHJlZU5vZGUgbm9kZSA9IHRvcC5nZXRLZXkoKTtcbiAgICAgICAgICAgIGludCB0b3RhbCA9IHRvcC5nZXRWYWx1ZSgpO1xuXG4gICAgICAgICAgICBpZiAoKG5vZGUucmlnaHQgPT0gbnVsbCkgJiYgKG5vZGUubGVmdCA9PSBudWxsKSAmJiAodG90YWwgPT0gc3VtKSkge1xuICAgICAgICAgICAgICAgIHJlcy5hZGQobmV3IEFycmF5TGlzdDw+KHBhdGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnJpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5hZGRMYXN0KG5ldyBQYWlyPFRyZWVOb2RlLCBJbnRlZ2VyPihub2RlLnJpZ2h0LCB0b3RhbCArIG5vZGUucmlnaHQudmFsKSk7XG4gICAgICAgICAgICAgICAgcGF0aC5hZGRMYXN0KG5vZGUucmlnaHQudmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmxlZnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YWNrLmFkZExhc3QobmV3IFBhaXI8VHJlZU5vZGUsIEludGVnZXI+KG5vZGUubGVmdCwgdG90YWwgKyBub2RlLmxlZnQudmFsKSk7XG4gICAgICAgICAgICAgICAgcGF0aC5hZGRMYXN0KG5vZGUubGVmdC52YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImZyb20gdHlwaW5nIGltcG9ydCBMaXN0XG5cblxuY2xhc3MgVHJlZU5vZGU6XG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIHgpOlxuICAgICAgICBzZWxmLnZhbCA9IHhcbiAgICAgICAgc2VsZi5sZWZ0ID0gTm9uZVxuICAgICAgICBzZWxmLnJpZ2h0ID0gTm9uZVxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBwYXRoU3VtKHNlbGYsIHJvb3Q6IFRyZWVOb2RlLCBzdW06IGludCkgLT4gTGlzdFtMaXN0W2ludF1dOlxuICAgICAgICBpZiBub3Qgcm9vdDpcbiAgICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICBzdGFjayA9IFsocm9vdCwgW3Jvb3QudmFsXSwgcm9vdC52YWwpXVxuICAgICAgICBhbnMgPSBbXVxuICAgICAgICB3aGlsZSBzdGFjazpcbiAgICAgICAgICAgIG5vZGUsIHBhdGgsIHRvdGFsID0gc3RhY2sucG9wKClcbiAgICAgICAgICAgIGlmIG5vdCBub2RlLnJpZ2h0IGFuZCBub3Qgbm9kZS5sZWZ0IGFuZCB0b3RhbCA9PSBzdW06XG4gICAgICAgICAgICAgICAgYW5zLmFwcGVuZChwYXRoKVxuICAgICAgICAgICAgaWYgbm9kZS5yaWdodDpcbiAgICAgICAgICAgICAgICBzdGFjay5hcHBlbmQoKG5vZGUucmlnaHQsIHBhdGggKyBbbm9kZS5yaWdodC52YWxdLCB0b3RhbCArIG5vZGUucmlnaHQudmFsKSlcbiAgICAgICAgICAgIGlmIG5vZGUubGVmdDpcbiAgICAgICAgICAgICAgICBzdGFjay5hcHBlbmQoKG5vZGUubGVmdCwgcGF0aCArIFtub2RlLmxlZnQudmFsXSwgdG90YWwgKyBub2RlLmxlZnQudmFsKSlcbiAgICAgICAgcmV0dXJuIGFuc1xuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIE1LjEuNSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHJpdmF0ZTpcbiAgICBpbnQgbWF4U3VtID0gSU5UX01JTjtcblxucHVibGljOlxuICAgIGludCBoZWxwZXIoVHJlZU5vZGUqIG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbHB0cikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIOmAkuW9kuiuoeeul+W3puWPs+WtkOiKgueCueeahOacgOWkp+i0oeeMruWAvFxuICAgICAgICAvLyDlj6rmnInlnKjmnIDlpKfotKHnjK7lgLzlpKfkuo4gMCDml7bvvIzmiY3kvJrpgInlj5blr7nlupTlrZDoioLngrlcbiAgICAgICAgaW50IGxlZnRHYWluID0gbWF4KGhlbHBlcihub2RlLT5sZWZ0KSwgMCk7XG4gICAgICAgIGludCByaWdodEdhaW4gPSBtYXgoaGVscGVyKG5vZGUtPnJpZ2h0KSwgMCk7XG5cbiAgICAgICAgLy8g6IqC54K555qE5pyA5aSn6Lev5b6E5ZKM5Y+W5Yaz5LqO6K+l6IqC54K555qE5YC85LiO6K+l6IqC54K555qE5bem5Y+z5a2Q6IqC54K555qE5pyA5aSn6LSh54yu5YC8XG4gICAgICAgIGludCBwcmljZU5ld3BhdGggPSBub2RlLT52YWwgKyBsZWZ0R2FpbiArIHJpZ2h0R2FpbjtcblxuICAgICAgICAvLyDmm7TmlrDnrZTmoYhcbiAgICAgICAgbWF4U3VtID0gbWF4KG1heFN1bSwgcHJpY2VOZXdwYXRoKTtcblxuICAgICAgICAvLyDov5Tlm57oioLngrnnmoTmnIDlpKfotKHnjK7lgLxcbiAgICAgICAgcmV0dXJuIG5vZGUtPnZhbCArIG1heChsZWZ0R2FpbiwgcmlnaHRHYWluKTtcbiAgICB9XG5cbiAgICBpbnQgbWF4UGF0aFN1bShUcmVlTm9kZSogcm9vdCkge1xuICAgICAgICBoZWxwZXIocm9vdCk7XG4gICAgICAgIHJldHVybiBtYXhTdW07XG4gICAgfVxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gICAgaW50IG1heFN1bSA9IEludGVnZXIuTUlOX1ZBTFVFO1xuXG4gICAgcHVibGljIGludCBtYXhQYXRoU3VtKFRyZWVOb2RlIHJvb3QpIHtcbiAgICAgICAgaGVscGVyKHJvb3QpO1xuICAgICAgICByZXR1cm4gbWF4U3VtO1xuICAgIH1cblxuICAgIHB1YmxpYyBpbnQgaGVscGVyKFRyZWVOb2RlIG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIOmAkuW9kuiuoeeul+W3puWPs+WtkOiKgueCueeahOacgOWkp+i0oeeMruWAvFxuICAgICAgICAvLyDlj6rmnInlnKjmnIDlpKfotKHnjK7lgLzlpKfkuo4gMCDml7bvvIzmiY3kvJrpgInlj5blr7nlupTlrZDoioLngrlcbiAgICAgICAgaW50IGxlZnRHYWluID0gTWF0aC5tYXgoaGVscGVyKG5vZGUubGVmdCksIDApO1xuICAgICAgICBpbnQgcmlnaHRHYWluID0gTWF0aC5tYXgoaGVscGVyKG5vZGUucmlnaHQpLCAwKTtcblxuICAgICAgICAvLyDoioLngrnnmoTmnIDlpKfot6/lvoTlkozlj5blhrPkuo7or6XoioLngrnnmoTlgLzkuI7or6XoioLngrnnmoTlt6blj7PlrZDoioLngrnnmoTmnIDlpKfotKHnjK7lgLxcbiAgICAgICAgaW50IHByaWNlTmV3cGF0aCA9IG5vZGUudmFsICsgbGVmdEdhaW4gKyByaWdodEdhaW47XG5cbiAgICAgICAgLy8g5pu05paw562U5qGIXG4gICAgICAgIG1heFN1bSA9IE1hdGgubWF4KG1heFN1bSwgcHJpY2VOZXdwYXRoKTtcblxuICAgICAgICAvLyDov5Tlm57oioLngrnnmoTmnIDlpKfotKHnjK7lgLxcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsICsgTWF0aC5tYXgobGVmdEdhaW4sIHJpZ2h0R2Fpbik7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuXG5cbmNsYXNzIFRyZWVOb2RlOlxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCB4KTpcbiAgICAgICAgc2VsZi52YWwgPSB4XG4gICAgICAgIHNlbGYubGVmdCA9IE5vbmVcbiAgICAgICAgc2VsZi5yaWdodCA9IE5vbmVcblxuXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgbWF4UGF0aFN1bShzZWxmLCByb290OiBUcmVlTm9kZSkgLT4gaW50OlxuICAgICAgICBzZWxmLm1heFN1bSA9IGZsb2F0KFwiLWluZlwiKVxuXG4gICAgICAgIGRlZiBoZWxwZXIocm9vdDogVHJlZU5vZGUpOlxuICAgICAgICAgICAgaWYgbm90IHJvb3Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDBcblxuICAgICAgICAgICAgbWF4TGVmdCA9IG1heChoZWxwZXIocm9vdC5sZWZ0KSwgMClcbiAgICAgICAgICAgIG1heFJpZ2h0ID0gbWF4KGhlbHBlcihyb290LnJpZ2h0KSwgMClcbiAgICAgICAgICAgIHNlbGYubWF4U3VtID0gbWF4KHNlbGYubWF4U3VtLCBtYXhMZWZ0ICsgbWF4UmlnaHQgKyByb290LnZhbClcblxuICAgICAgICAgICAgcmV0dXJuIHJvb3QudmFsICsgbWF4KG1heExlZnQsIG1heFJpZ2h0KVxuXG4gICAgICAgIGhlbHBlcihyb290KVxuICAgICAgICByZXR1cm4gc2VsZi5tYXhTdW1cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBNS4yLjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbnByaXZhdGU6XG4gICAgdm9pZCBkZnModmVjdG9yPHZlY3RvcjxjaGFyPj4mIGdyaWQsIGludCByLCBpbnQgYykge1xuICAgICAgICBpbnQgbnIgPSBncmlkLnNpemUoKTtcbiAgICAgICAgaW50IG5jID0gZ3JpZFswXS5zaXplKCk7XG5cbiAgICAgICAgZ3JpZFtyXVtjXSA9ICcwJztcbiAgICAgICAgaWYgKHIgLSAxID49IDAgJiYgZ3JpZFtyLTFdW2NdID09ICcxJykgZGZzKGdyaWQsIHIgLSAxLCBjKTtcbiAgICAgICAgaWYgKHIgKyAxIDwgbnIgJiYgZ3JpZFtyKzFdW2NdID09ICcxJykgZGZzKGdyaWQsIHIgKyAxLCBjKTtcbiAgICAgICAgaWYgKGMgLSAxID49IDAgJiYgZ3JpZFtyXVtjLTFdID09ICcxJykgZGZzKGdyaWQsIHIsIGMgLSAxKTtcbiAgICAgICAgaWYgKGMgKyAxIDwgbmMgJiYgZ3JpZFtyXVtjKzFdID09ICcxJykgZGZzKGdyaWQsIHIsIGMgKyAxKTtcbiAgICB9XG5cbnB1YmxpYzpcbiAgICBpbnQgbnVtSXNsYW5kcyh2ZWN0b3I8dmVjdG9yPGNoYXI+PiYgZ3JpZCkge1xuICAgICAgICBpbnQgbnIgPSBncmlkLnNpemUoKTtcbiAgICAgICAgaWYgKCFucikgcmV0dXJuIDA7XG4gICAgICAgIGludCBuYyA9IGdyaWRbMF0uc2l6ZSgpO1xuXG4gICAgICAgIGludCBudW1faXNsYW5kcyA9IDA7XG4gICAgICAgIGZvciAoaW50IHIgPSAwOyByIDwgbnI7ICsrcikge1xuICAgICAgICAgICAgZm9yIChpbnQgYyA9IDA7IGMgPCBuYzsgKytjKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyaWRbcl1bY10gPT0gJzEnKSB7XG4gICAgICAgICAgICAgICAgICAgICsrbnVtX2lzbGFuZHM7XG4gICAgICAgICAgICAgICAgICAgIGRmcyhncmlkLCByLCBjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVtX2lzbGFuZHM7XG4gICAgfVxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gICAgdm9pZCBkZnMoY2hhcltdW10gZ3JpZCwgaW50IHIsIGludCBjKSB7XG4gICAgICAgIGludCBuciA9IGdyaWQubGVuZ3RoO1xuICAgICAgICBpbnQgbmMgPSBncmlkWzBdLmxlbmd0aDtcblxuICAgICAgICBpZiAociA8IDAgfHwgYyA8IDAgfHwgciA+PSBuciB8fCBjID49IG5jIHx8IGdyaWRbcl1bY10gPT0gJzAnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBncmlkW3JdW2NdID0gJzAnO1xuICAgICAgICBkZnMoZ3JpZCwgciAtIDEsIGMpO1xuICAgICAgICBkZnMoZ3JpZCwgciArIDEsIGMpO1xuICAgICAgICBkZnMoZ3JpZCwgciwgYyAtIDEpO1xuICAgICAgICBkZnMoZ3JpZCwgciwgYyArIDEpO1xuICAgIH1cblxuICAgIHB1YmxpYyBpbnQgbnVtSXNsYW5kcyhjaGFyW11bXSBncmlkKSB7XG4gICAgICAgIGlmIChncmlkID09IG51bGwgfHwgZ3JpZC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBpbnQgbnIgPSBncmlkLmxlbmd0aDtcbiAgICAgICAgaW50IG5jID0gZ3JpZFswXS5sZW5ndGg7XG4gICAgICAgIGludCBudW1faXNsYW5kcyA9IDA7XG4gICAgICAgIGZvciAoaW50IHIgPSAwOyByIDwgbnI7ICsrcikge1xuICAgICAgICAgICAgZm9yIChpbnQgYyA9IDA7IGMgPCBuYzsgKytjKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyaWRbcl1bY10gPT0gJzEnKSB7XG4gICAgICAgICAgICAgICAgICAgICsrbnVtX2lzbGFuZHM7XG4gICAgICAgICAgICAgICAgICAgIGRmcyhncmlkLCByLCBjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVtX2lzbGFuZHM7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBudW1Jc2xhbmRzKHNlbGYsIGdyaWQ6IExpc3RbTGlzdFtzdHJdXSkgLT4gaW50OlxuICAgICAgICBpZiBub3QgZ3JpZCBvciBub3QgZ3JpZFswXTpcbiAgICAgICAgICAgIHJldHVybiAwXG5cbiAgICAgICAgbSA9IGxlbihncmlkKVxuICAgICAgICBuID0gbGVuKGdyaWRbMF0pXG4gICAgICAgIGFucyA9IDBcblxuICAgICAgICBkZWYgZGZzKHIsIGMpOlxuICAgICAgICAgICAgZ3JpZFtyXVtjXSA9IFwiMFwiXG5cbiAgICAgICAgICAgIGlmIHIgLSAxID49IDAgYW5kIGdyaWRbciAtIDFdW2NdID09IFwiMVwiOlxuICAgICAgICAgICAgICAgIGRmcyhyIC0gMSwgYylcbiAgICAgICAgICAgIGlmIHIgKyAxIDwgbSBhbmQgZ3JpZFtyICsgMV1bY10gPT0gXCIxXCI6XG4gICAgICAgICAgICAgICAgZGZzKHIgKyAxLCBjKVxuICAgICAgICAgICAgaWYgYyAtIDEgPj0gMCBhbmQgZ3JpZFtyXVtjIC0gMV0gPT0gXCIxXCI6XG4gICAgICAgICAgICAgICAgZGZzKHIsIGMgLSAxKVxuICAgICAgICAgICAgaWYgYyArIDEgPCBuIGFuZCBncmlkW3JdW2MgKyAxXSA9PSBcIjFcIjpcbiAgICAgICAgICAgICAgICBkZnMociwgYyArIDEpXG5cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UobSk6XG4gICAgICAgICAgICBmb3IgaiBpbiByYW5nZShuKTpcbiAgICAgICAgICAgICAgICBpZiBncmlkW2ldW2pdID09IFwiMVwiOlxuICAgICAgICAgICAgICAgICAgICBhbnMgKz0gMVxuICAgICAgICAgICAgICAgICAgICBkZnMoaSwgailcblxuICAgICAgICByZXR1cm4gYW5zXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTUuMi4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImZyb20gdHlwaW5nIGltcG9ydCBMaXN0XG5cblxuY2xhc3MgU29sdXRpb246XG4gICAgZGVmIG51bUlzbGFuZHMoc2VsZiwgZ3JpZDogTGlzdFtMaXN0W3N0cl1dKSAtPiBpbnQ6XG4gICAgICAgIGlmIG5vdCBncmlkIG9yIG5vdCBncmlkWzBdOlxuICAgICAgICAgICAgcmV0dXJuIDBcblxuICAgICAgICBtID0gbGVuKGdyaWQpXG4gICAgICAgIG4gPSBsZW4oZ3JpZFswXSlcbiAgICAgICAgYW5zID0gMFxuXG4gICAgICAgIGRlZiBkZnMocm93LCBjb2wpOlxuICAgICAgICAgICAgZ3JpZFtyb3ddW2NvbF0gPSBcIjBcIlxuICAgICAgICAgICAgc3RhY2sgPSBbW3JvdywgY29sXV1cbiAgICAgICAgICAgIHdoaWxlIHN0YWNrOlxuICAgICAgICAgICAgICAgIHIsIGMgPSBzdGFja1stMV1cbiAgICAgICAgICAgICAgICBpZiByIC0gMSA+PSAwIGFuZCBncmlkW3IgLSAxXVtjXSA9PSBcIjFcIjpcbiAgICAgICAgICAgICAgICAgICAgc3RhY2suYXBwZW5kKFtyIC0gMSwgY10pXG4gICAgICAgICAgICAgICAgICAgIGdyaWRbciAtIDFdW2NdID0gXCIwXCJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICBpZiByICsgMSA8IG0gYW5kIGdyaWRbciArIDFdW2NdID09IFwiMVwiOlxuICAgICAgICAgICAgICAgICAgICBzdGFjay5hcHBlbmQoW3IgKyAxLCBjXSlcbiAgICAgICAgICAgICAgICAgICAgZ3JpZFtyICsgMV1bY10gPSBcIjBcIlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgIGlmIGMgLSAxID49IDAgYW5kIGdyaWRbcl1bYyAtIDFdID09IFwiMVwiOlxuICAgICAgICAgICAgICAgICAgICBzdGFjay5hcHBlbmQoW3IsIGMgLSAxXSlcbiAgICAgICAgICAgICAgICAgICAgZ3JpZFtyXVtjIC0gMV0gPSBcIjBcIlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgIGlmIGMgKyAxIDwgbiBhbmQgZ3JpZFtyXVtjICsgMV0gPT0gXCIxXCI6XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLmFwcGVuZChbciwgYyArIDFdKVxuICAgICAgICAgICAgICAgICAgICBncmlkW3JdW2MgKyAxXSA9IFwiMFwiXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgc3RhY2sucG9wKClcblxuICAgICAgICBmb3IgaSBpbiByYW5nZShtKTpcbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKG4pOlxuICAgICAgICAgICAgICAgIGlmIGdyaWRbaV1bal0gPT0gXCIxXCI6XG4gICAgICAgICAgICAgICAgICAgIGFucyArPSAxXG4gICAgICAgICAgICAgICAgICAgIGRmcyhpLCBqKVxuXG4gICAgICAgIHJldHVybiBhbnNcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBNS4yLjMiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgICBpbnQgbnVtSXNsYW5kcyh2ZWN0b3I8dmVjdG9yPGNoYXI+PiYgZ3JpZCkge1xuICAgICAgICBpbnQgbnIgPSBncmlkLnNpemUoKTtcbiAgICAgICAgaWYgKCFucikgcmV0dXJuIDA7XG4gICAgICAgIGludCBuYyA9IGdyaWRbMF0uc2l6ZSgpO1xuXG4gICAgICAgIGludCBudW1faXNsYW5kcyA9IDA7XG4gICAgICAgIGZvciAoaW50IHIgPSAwOyByIDwgbnI7ICsrcikge1xuICAgICAgICAgICAgZm9yIChpbnQgYyA9IDA7IGMgPCBuYzsgKytjKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyaWRbcl1bY10gPT0gJzEnKSB7XG4gICAgICAgICAgICAgICAgICAgICsrbnVtX2lzbGFuZHM7XG4gICAgICAgICAgICAgICAgICAgIGdyaWRbcl1bY10gPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlPHBhaXI8aW50LCBpbnQ+PiBuZWlnaGJvcnM7XG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKHtyLCBjfSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICghbmVpZ2hib3JzLmVtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG8gcmMgPSBuZWlnaGJvcnMuZnJvbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludCByb3cgPSByYy5maXJzdCwgY29sID0gcmMuc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvdyAtIDEgPj0gMCAmJiBncmlkW3Jvdy0xXVtjb2xdID09ICcxJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKHtyb3ctMSwgY29sfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZFtyb3ctMV1bY29sXSA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3cgKyAxIDwgbnIgJiYgZ3JpZFtyb3crMV1bY29sXSA9PSAnMScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaCh7cm93KzEsIGNvbH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRbcm93KzFdW2NvbF0gPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sIC0gMSA+PSAwICYmIGdyaWRbcm93XVtjb2wtMV0gPT0gJzEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goe3JvdywgY29sLTF9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkW3Jvd11bY29sLTFdID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbCArIDEgPCBuYyAmJiBncmlkW3Jvd11bY29sKzFdID09ICcxJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKHtyb3csIGNvbCsxfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZFtyb3ddW2NvbCsxXSA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudW1faXNsYW5kcztcbiAgICB9XG59O1xuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgICBwdWJsaWMgaW50IG51bUlzbGFuZHMoY2hhcltdW10gZ3JpZCkge1xuICAgICAgICBpZiAoZ3JpZCA9PSBudWxsIHx8IGdyaWQubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaW50IG5yID0gZ3JpZC5sZW5ndGg7XG4gICAgICAgIGludCBuYyA9IGdyaWRbMF0ubGVuZ3RoO1xuICAgICAgICBpbnQgbnVtX2lzbGFuZHMgPSAwO1xuXG4gICAgICAgIGZvciAoaW50IHIgPSAwOyByIDwgbnI7ICsrcikge1xuICAgICAgICAgICAgZm9yIChpbnQgYyA9IDA7IGMgPCBuYzsgKytjKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyaWRbcl1bY10gPT0gJzEnKSB7XG4gICAgICAgICAgICAgICAgICAgICsrbnVtX2lzbGFuZHM7XG4gICAgICAgICAgICAgICAgICAgIGdyaWRbcl1bY10gPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgIFF1ZXVlPEludGVnZXI+IG5laWdoYm9ycyA9IG5ldyBMaW5rZWRMaXN0PD4oKTtcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLmFkZChyICogbmMgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFuZWlnaGJvcnMuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnQgaWQgPSBuZWlnaGJvcnMucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnQgcm93ID0gaWQgLyBuYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGludCBjb2wgPSBpZCAlIG5jO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvdyAtIDEgPj0gMCAmJiBncmlkW3Jvdy0xXVtjb2xdID09ICcxJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5hZGQoKHJvdy0xKSAqIG5jICsgY29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkW3Jvdy0xXVtjb2xdID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvdyArIDEgPCBuciAmJiBncmlkW3JvdysxXVtjb2xdID09ICcxJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5hZGQoKHJvdysxKSAqIG5jICsgY29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkW3JvdysxXVtjb2xdID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbCAtIDEgPj0gMCAmJiBncmlkW3Jvd11bY29sLTFdID09ICcxJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5hZGQocm93ICogbmMgKyBjb2wtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZFtyb3ddW2NvbC0xXSA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2wgKyAxIDwgbmMgJiYgZ3JpZFtyb3ddW2NvbCsxXSA9PSAnMScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMuYWRkKHJvdyAqIG5jICsgY29sKzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRbcm93XVtjb2wrMV0gPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVtX2lzbGFuZHM7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBudW1Jc2xhbmRzKHNlbGYsIGdyaWQ6IExpc3RbTGlzdFtzdHJdXSkgLT4gaW50OlxuICAgICAgICBmcm9tIGNvbGxlY3Rpb25zIGltcG9ydCBkZXF1ZVxuXG4gICAgICAgIGlmIG5vdCBncmlkIG9yIG5vdCBncmlkWzBdOlxuICAgICAgICAgICAgcmV0dXJuIDBcblxuICAgICAgICBtID0gbGVuKGdyaWQpXG4gICAgICAgIG4gPSBsZW4oZ3JpZFswXSlcbiAgICAgICAgYW5zID0gMFxuICAgICAgICBxdWV1ZSA9IGRlcXVlKClcblxuICAgICAgICBmb3IgaSBpbiByYW5nZShtKTpcbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKG4pOlxuICAgICAgICAgICAgICAgIGlmIGdyaWRbaV1bal0gPT0gXCIxXCI6XG4gICAgICAgICAgICAgICAgICAgIGFucyArPSAxXG4gICAgICAgICAgICAgICAgICAgIGdyaWRbaV1bal0gPSBcIjBcIlxuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5hcHBlbmQoKGksIGopKVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSBsZW4ocXVldWUpID4gMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IHF1ZXVlLnBvcGxlZnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHRvcFswXVxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRvcFsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgciAtIDEgPj0gMCBhbmQgZ3JpZFtyIC0gMV1bY10gPT0gXCIxXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZFtyIC0gMV1bY10gPSBcIjBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLmFwcGVuZCgociAtIDEsIGMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgciArIDEgPCBtIGFuZCBncmlkW3IgKyAxXVtjXSA9PSBcIjFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkW3IgKyAxXVtjXSA9IFwiMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuYXBwZW5kKChyICsgMSwgYykpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiBjIC0gMSA+PSAwIGFuZCBncmlkW3JdW2MgLSAxXSA9PSBcIjFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkW3JdW2MgLSAxXSA9IFwiMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuYXBwZW5kKChyLCBjIC0gMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiBjICsgMSA8IG4gYW5kIGdyaWRbcl1bYyArIDFdID09IFwiMVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRbcl1bYyArIDFdID0gXCIwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5hcHBlbmQoKHIsIGMgKyAxKSlcblxuICAgICAgICByZXR1cm4gYW5zXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTUuMi40IiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBVbmlvbkZpbmQge1xucHVibGljOlxuICAgIFVuaW9uRmluZCh2ZWN0b3I8dmVjdG9yPGNoYXI+PiYgZ3JpZCkge1xuICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgIGludCBtID0gZ3JpZC5zaXplKCk7XG4gICAgICAgIGludCBuID0gZ3JpZFswXS5zaXplKCk7XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IG47ICsraikge1xuICAgICAgICAgICAgICAgIGlmIChncmlkW2ldW2pdID09ICcxJykge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucHVzaF9iYWNrKGkgKiBuICsgaik7XG4gICAgICAgICAgICAgICAgICAgICsrY291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucHVzaF9iYWNrKC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmFuay5wdXNoX2JhY2soMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbnQgZmluZChpbnQgaSkge1xuICAgICAgICBpZiAocGFyZW50W2ldICE9IGkpIHtcbiAgICAgICAgICAgIHBhcmVudFtpXSA9IGZpbmQocGFyZW50W2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50W2ldO1xuICAgIH1cblxuICAgIHZvaWQgdW5pb24oaW50IHgsIGludCB5KSB7XG4gICAgICAgIGludCByb290eCA9IGZpbmQoeCk7XG4gICAgICAgIGludCByb290eSA9IGZpbmQoeSk7XG4gICAgICAgIGlmIChyb290eCAhPSByb290eSkge1xuICAgICAgICAgICAgaWYgKHJhbmtbcm9vdHhdIDwgcmFua1tyb290eV0pIHtcbiAgICAgICAgICAgICAgICBzd2FwKHJvb3R4LCByb290eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnRbcm9vdHldID0gcm9vdHg7XG4gICAgICAgICAgICBpZiAocmFua1tyb290eF0gPT0gcmFua1tyb290eV0pIHJhbmtbcm9vdHhdICs9IDE7XG4gICAgICAgICAgICAtLWNvdW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW50IGdldENvdW50KCkgY29uc3Qge1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuXG5wcml2YXRlOlxuICAgIHZlY3RvcjxpbnQ+IHBhcmVudDtcbiAgICB2ZWN0b3I8aW50PiByYW5rO1xuICAgIGludCBjb3VudDtcbn07XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgICBpbnQgbnVtSXNsYW5kcyh2ZWN0b3I8dmVjdG9yPGNoYXI+PiYgZ3JpZCkge1xuICAgICAgICBpbnQgbnIgPSBncmlkLnNpemUoKTtcbiAgICAgICAgaWYgKCFucikgcmV0dXJuIDA7XG4gICAgICAgIGludCBuYyA9IGdyaWRbMF0uc2l6ZSgpO1xuXG4gICAgICAgIFVuaW9uRmluZCB1ZihncmlkKTtcbiAgICAgICAgaW50IG51bV9pc2xhbmRzID0gMDtcbiAgICAgICAgZm9yIChpbnQgciA9IDA7IHIgPCBucjsgKytyKSB7XG4gICAgICAgICAgICBmb3IgKGludCBjID0gMDsgYyA8IG5jOyArK2MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JpZFtyXVtjXSA9PSAnMScpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZFtyXVtjXSA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgLSAxID49IDAgJiYgZ3JpZFtyLTFdW2NdID09ICcxJykgdWYudW5pb24ociAqIG5jICsgYywgKHItMSkgKiBuYyArIGMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAociArIDEgPCBuciAmJiBncmlkW3IrMV1bY10gPT0gJzEnKSB1Zi51bmlvbihyICogbmMgKyBjLCAocisxKSAqIG5jICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjIC0gMSA+PSAwICYmIGdyaWRbcl1bYy0xXSA9PSAnMScpIHVmLnVuaW9uKHIgKiBuYyArIGMsIHIgKiBuYyArIGMgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgKyAxIDwgbmMgJiYgZ3JpZFtyXVtjKzFdID09ICcxJykgdWYudW5pb24ociAqIG5jICsgYywgciAqIG5jICsgYyArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1Zi5nZXRDb3VudCgpO1xuICAgIH1cbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICAgIGNsYXNzIFVuaW9uRmluZCB7XG4gICAgICAgIGludCBjb3VudDtcbiAgICAgICAgaW50W10gcGFyZW50O1xuICAgICAgICBpbnRbXSByYW5rO1xuXG4gICAgICAgIHB1YmxpYyBVbmlvbkZpbmQoY2hhcltdW10gZ3JpZCkge1xuICAgICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAgICAgaW50IG0gPSBncmlkLmxlbmd0aDtcbiAgICAgICAgICAgIGludCBuID0gZ3JpZFswXS5sZW5ndGg7XG4gICAgICAgICAgICBwYXJlbnQgPSBuZXcgaW50W20gKiBuXTtcbiAgICAgICAgICAgIHJhbmsgPSBuZXcgaW50W20gKiBuXTtcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbTsgKytpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyaWRbaV1bal0gPT0gJzEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRbaSAqIG4gKyBqXSA9IGkgKiBuICsgajtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmFua1tpICogbiArIGpdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwdWJsaWMgaW50IGZpbmQoaW50IGkpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRbaV0gIT0gaSkgcGFyZW50W2ldID0gZmluZChwYXJlbnRbaV0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB1YmxpYyB2b2lkIHVuaW9uKGludCB4LCBpbnQgeSkge1xuICAgICAgICAgICAgaW50IHJvb3R4ID0gZmluZCh4KTtcbiAgICAgICAgICAgIGludCByb290eSA9IGZpbmQoeSk7XG4gICAgICAgICAgICBpZiAocm9vdHggIT0gcm9vdHkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFua1tyb290eF0gPiByYW5rW3Jvb3R5XSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRbcm9vdHldID0gcm9vdHg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyYW5rW3Jvb3R4XSA8IHJhbmtbcm9vdHldKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFtyb290eF0gPSByb290eTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRbcm9vdHldID0gcm9vdHg7XG4gICAgICAgICAgICAgICAgICAgIHJhbmtbcm9vdHhdICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC0tY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwdWJsaWMgaW50IGdldENvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGludCBudW1Jc2xhbmRzKGNoYXJbXVtdIGdyaWQpIHtcbiAgICAgICAgaWYgKGdyaWQgPT0gbnVsbCB8fCBncmlkLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGludCBuciA9IGdyaWQubGVuZ3RoO1xuICAgICAgICBpbnQgbmMgPSBncmlkWzBdLmxlbmd0aDtcbiAgICAgICAgaW50IG51bV9pc2xhbmRzID0gMDtcbiAgICAgICAgVW5pb25GaW5kIHVmID0gbmV3IFVuaW9uRmluZChncmlkKTtcbiAgICAgICAgZm9yIChpbnQgciA9IDA7IHIgPCBucjsgKytyKSB7XG4gICAgICAgICAgICBmb3IgKGludCBjID0gMDsgYyA8IG5jOyArK2MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JpZFtyXVtjXSA9PSAnMScpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZFtyXVtjXSA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgLSAxID49IDAgJiYgZ3JpZFtyLTFdW2NdID09ICcxJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWYudW5pb24ociAqIG5jICsgYywgKHItMSkgKiBuYyArIGMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyICsgMSA8IG5yICYmIGdyaWRbcisxXVtjXSA9PSAnMScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVmLnVuaW9uKHIgKiBuYyArIGMsIChyKzEpICogbmMgKyBjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYyAtIDEgPj0gMCAmJiBncmlkW3JdW2MtMV0gPT0gJzEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1Zi51bmlvbihyICogbmMgKyBjLCByICogbmMgKyBjIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgKyAxIDwgbmMgJiYgZ3JpZFtyXVtjKzFdID09ICcxJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWYudW5pb24ociAqIG5jICsgYywgciAqIG5jICsgYyArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVmLmdldENvdW50KCk7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGNsYXNzIFVuaW9uRmluZDpcbiAgICAgICAgZGVmIF9faW5pdF9fKHNlbGYsIGdyaWQpOlxuICAgICAgICAgICAgc2VsZi5jb3VudCA9IDBcbiAgICAgICAgICAgIG0gPSBsZW4oZ3JpZClcbiAgICAgICAgICAgIG4gPSBsZW4oZ3JpZFswXSlcbiAgICAgICAgICAgIHNlbGYucGFyZW50ID0gWzAgZm9yIF8gaW4gcmFuZ2UobSAqIG4pXVxuICAgICAgICAgICAgc2VsZi5yYW5rID0gWzAgZm9yIF8gaW4gcmFuZ2UobSAqIG4pXVxuICAgICAgICAgICAgZm9yIGkgaW4gcmFuZ2UobSk6ICMg6L+Z6YeM5oiR5Lus6L+b6KGM5Yid5aeL5YyW55qE5bel5L2cXG4gICAgICAgICAgICAgICAgZm9yIGogaW4gcmFuZ2Uobik6XG4gICAgICAgICAgICAgICAgICAgIGlmIGdyaWRbaV1bal0gPT0gXCIxXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBhcmVudFtpICogbiArIGpdID0gaSAqIG4gKyBqXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvdW50ICs9IDFcblxuICAgICAgICBkZWYgZmluZChzZWxmLCBpKTpcbiAgICAgICAgICAgIGlmIHNlbGYucGFyZW50W2ldICE9IGk6XG4gICAgICAgICAgICAgICAgc2VsZi5wYXJlbnRbaV0gPSBzZWxmLmZpbmQoc2VsZi5wYXJlbnRbaV0pXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5wYXJlbnRbaV1cblxuICAgICAgICBkZWYgdW5pb24oc2VsZiwgeCwgeSk6XG4gICAgICAgICAgICByb290eCA9IHNlbGYuZmluZCh4KVxuICAgICAgICAgICAgcm9vdHkgPSBzZWxmLmZpbmQoeSlcbiAgICAgICAgICAgIGlmIHJvb3R4ICE9IHJvb3R5OlxuICAgICAgICAgICAgICAgIGlmIHNlbGYucmFua1tyb290eF0gPiBzZWxmLnJhbmtbcm9vdHldOlxuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhcmVudFtyb290eV0gPSByb290eFxuICAgICAgICAgICAgICAgIGVsaWYgc2VsZi5yYW5rW3Jvb3R4XSA8IHNlbGYucmFua1tyb290eV06XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFyZW50W3Jvb3R4XSA9IHJvb3R5XG4gICAgICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXJlbnRbcm9vdHldID0gcm9vdHhcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yYW5rW3Jvb3R4XSArPSAxXG5cbiAgICAgICAgICAgICAgICBzZWxmLmNvdW50IC09IDFcblxuICAgICAgICBkZWYgZ2V0Q291bnQoc2VsZik6XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jb3VudFxuXG4gICAgZGVmIG51bUlzbGFuZHMoc2VsZiwgZ3JpZDogTGlzdFtMaXN0W3N0cl1dKSAtPiBpbnQ6XG4gICAgICAgIGlmIG5vdCBncmlkIG9yIG5vdCBncmlkWzBdOlxuICAgICAgICAgICAgcmV0dXJuIDBcblxuICAgICAgICAjIGFucyA9IDBcbiAgICAgICAgbnIgPSBsZW4oZ3JpZClcbiAgICAgICAgbmMgPSBsZW4oZ3JpZFswXSlcbiAgICAgICAgdWYgPSBzZWxmLlVuaW9uRmluZChncmlkKVxuXG4gICAgICAgIGZvciBpIGluIHJhbmdlKG5yKTpcbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKG5jKTpcbiAgICAgICAgICAgICAgICBpZiBncmlkW2ldW2pdID09IFwiMVwiOlxuICAgICAgICAgICAgICAgICAgICBncmlkW2ldW2pdID0gXCIwXCJcbiAgICAgICAgICAgICAgICAgICAgaWYgaSAtIDEgPj0gMCBhbmQgZ3JpZFtpIC0gMV1bal0gPT0gXCIxXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB1Zi51bmlvbihpICogbmMgKyBqLCAoaSAtIDEpICogbmMgKyBqKVxuICAgICAgICAgICAgICAgICAgICBpZiBpICsgMSA8IG5yIGFuZCBncmlkW2kgKyAxXVtqXSA9PSBcIjFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVmLnVuaW9uKGkgKiBuYyArIGosIChpICsgMSkgKiBuYyArIGopXG4gICAgICAgICAgICAgICAgICAgIGlmIGogLSAxID49IDAgYW5kIGdyaWRbaV1baiAtIDFdID09IFwiMVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdWYudW5pb24oaSAqIG5jICsgaiwgaSAqIG5jICsgaiAtIDEpXG4gICAgICAgICAgICAgICAgICAgIGlmIGogKyAxIDwgbmMgYW5kIGdyaWRbaV1baiArIDFdID09IFwiMVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdWYudW5pb24oaSAqIG5jICsgaiwgaSAqIG5jICsgaiArIDEpXG4gICAgICAgIHJldHVybiB1Zi5nZXRDb3VudCgpXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTUuMi41IiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGNsYXNzIFVuaW9uRmluZDpcbiAgICAgICAgZGVmIF9faW5pdF9fKHNlbGYsIGdyaWQpOlxuICAgICAgICAgICAgc2VsZi5jb3VudCA9IDBcbiAgICAgICAgICAgIG0gPSBsZW4oZ3JpZClcbiAgICAgICAgICAgIG4gPSBsZW4oZ3JpZFswXSlcbiAgICAgICAgICAgIHNlbGYucGFyZW50ID0gWzAgZm9yIF8gaW4gcmFuZ2UobSAqIG4pXVxuICAgICAgICAgICAgc2VsZi5yYW5rID0gWzAgZm9yIF8gaW4gcmFuZ2UobSAqIG4pXVxuICAgICAgICAgICAgZm9yIGkgaW4gcmFuZ2UobSk6XG4gICAgICAgICAgICAgICAgZm9yIGogaW4gcmFuZ2Uobik6XG4gICAgICAgICAgICAgICAgICAgIGlmIGdyaWRbaV1bal0gPT0gXCIxXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBhcmVudFtpICogbiArIGpdID0gaSAqIG4gKyBqXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvdW50ICs9IDFcblxuICAgICAgICBkZWYgZmluZChzZWxmLCBpKTpcbiAgICAgICAgICAgIGlmIHNlbGYucGFyZW50W2ldICE9IGk6XG4gICAgICAgICAgICAgICAgc2VsZi5wYXJlbnRbaV0gPSBzZWxmLmZpbmQoc2VsZi5wYXJlbnRbaV0pXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5wYXJlbnRbaV1cblxuICAgICAgICBkZWYgdW5pb24oc2VsZiwgeCwgeSk6XG4gICAgICAgICAgICByb290eCA9IHNlbGYuZmluZCh4KVxuICAgICAgICAgICAgcm9vdHkgPSBzZWxmLmZpbmQoeSlcbiAgICAgICAgICAgIGlmIHJvb3R4ICE9IHJvb3R5OlxuICAgICAgICAgICAgICAgIGlmIHNlbGYucmFua1tyb290eF0gPiBzZWxmLnJhbmtbcm9vdHldOlxuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhcmVudFtyb290eV0gPSByb290eFxuICAgICAgICAgICAgICAgIGVsaWYgc2VsZi5yYW5rW3Jvb3R4XSA8IHNlbGYucmFua1tyb290eV06XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFyZW50W3Jvb3R4XSA9IHJvb3R5XG4gICAgICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXJlbnRbcm9vdHldID0gcm9vdHhcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yYW5rW3Jvb3R4XSArPSAxXG5cbiAgICAgICAgICAgICAgICBzZWxmLmNvdW50IC09IDFcblxuICAgICAgICBkZWYgZ2V0Q291bnQoc2VsZik6XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jb3VudFxuXG4gICAgICAgIGRlZiBzZXRDb3VudChzZWxmLCBjb3VudCk6XG4gICAgICAgICAgICBzZWxmLmNvdW50ID0gY291bnRcblxuICAgICAgICBkZWYgc2V0UGFyZW50KHNlbGYsIGksIHZhbCk6XG4gICAgICAgICAgICBzZWxmLnBhcmVudFtpXSA9IHZhbFxuXG4gICAgZGVmIG51bUlzbGFuZHMoc2VsZiwgbSwgbiwgcG9zaXRpb25zKTpcbiAgICAgICAgaWYgbSA8PSAwIG9yIG4gPD0gMDpcbiAgICAgICAgICAgIHJldHVybiBbXVxuXG4gICAgICAgIGFucyA9IFtdXG4gICAgICAgIGdyaWQgPSBbWzAgZm9yIF8gaW4gcmFuZ2UobildIGZvciBfIGluIHJhbmdlKG0pXVxuXG4gICAgICAgIHVmID0gc2VsZi5VbmlvbkZpbmQoZ3JpZClcblxuICAgICAgICBmb3IgaSBpbiByYW5nZShsZW4ocG9zaXRpb25zKSk6XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uc1tpXVxuICAgICAgICAgICAgdWYuc2V0Q291bnQodWYuZ2V0Q291bnQoKSArIDEpXG4gICAgICAgICAgICB1Zi5zZXRQYXJlbnQocG9zaXRpb25bMF0gKiBuICsgcG9zaXRpb25bMV0sIHBvc2l0aW9uWzBdICogbiArIHBvc2l0aW9uWzFdKVxuICAgICAgICAgICAgZ3JpZFtwb3NpdGlvblswXV1bcG9zaXRpb25bMV1dID0gXCIxXCJcbiAgICAgICAgICAgIGlmIHBvc2l0aW9uWzBdIC0gMSA+PSAwIGFuZCBncmlkW3Bvc2l0aW9uWzBdIC0gMV1bcG9zaXRpb25bMV1dID09IFwiMVwiOlxuICAgICAgICAgICAgICAgIHVmLnVuaW9uKFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblswXSAqIG4gKyBwb3NpdGlvblsxXSwgKHBvc2l0aW9uWzBdIC0gMSkgKiBuICsgcG9zaXRpb25bMV1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICBpZiBwb3NpdGlvblswXSArIDEgPCBtIGFuZCBncmlkW3Bvc2l0aW9uWzBdICsgMV1bcG9zaXRpb25bMV1dID09IFwiMVwiOlxuICAgICAgICAgICAgICAgIHVmLnVuaW9uKFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblswXSAqIG4gKyBwb3NpdGlvblsxXSwgKHBvc2l0aW9uWzBdICsgMSkgKiBuICsgcG9zaXRpb25bMV1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICBpZiBwb3NpdGlvblsxXSAtIDEgPj0gMCBhbmQgZ3JpZFtwb3NpdGlvblswXV1bcG9zaXRpb25bMV0gLSAxXSA9PSBcIjFcIjpcbiAgICAgICAgICAgICAgICB1Zi51bmlvbihcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25bMF0gKiBuICsgcG9zaXRpb25bMV0sIHBvc2l0aW9uWzBdICogbiArIHBvc2l0aW9uWzFdIC0gMVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIGlmIHBvc2l0aW9uWzFdICsgMSA8IG4gYW5kIGdyaWRbcG9zaXRpb25bMF1dW3Bvc2l0aW9uWzFdICsgMV0gPT0gXCIxXCI6XG4gICAgICAgICAgICAgICAgdWYudW5pb24oXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uWzBdICogbiArIHBvc2l0aW9uWzFdLCBwb3NpdGlvblswXSAqIG4gKyBwb3NpdGlvblsxXSArIDFcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICBhbnMuYXBwZW5kKHVmLmdldENvdW50KCkpXG5cbiAgICAgICAgcmV0dXJuIGFuc1xuXG4iCiAgICB9XQogIH1dCn0sIHsKICAiaWQiOiAiMDYiLAogICJuYW1lIjogIuesrOWFreeroCIsCiAgImxpc3QiOiBbewogICAgInRpdGxlIjogIuS7o+eggTYuMS4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XHJcbnB1YmxpYzpcclxuICAgIGludCBzZWFyY2godmVjdG9yPGludD4mIG51bXMsIGludCB0YXJnZXQpIHtcclxuICAgICAgICBpbnQgbiA9IG51bXMuc2l6ZSgpO1xyXG4gICAgICAgIGludCBsID0gMCwgaCA9IG4gLSAxO1xyXG4gICAgICAgIHdoaWxlIChsIDw9IGgpIHtcclxuICAgICAgICAgICAgaW50IG1pZCA9IGwgKyAoaCAtIGwpIC8gMjtcclxuICAgICAgICAgICAgaWYgKG51bXNbbWlkXSA9PSB0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtaWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtc1ttaWRdIDwgdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBsID0gbWlkICsgMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGggPSBtaWQgLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XHJcbiAgICBwdWJsaWMgaW50IHNlYXJjaChpbnRbXSBudW1zLCBpbnQgdGFyZ2V0KSB7XHJcbiAgICAgICAgaW50IG4gPSBudW1zLmxlbmd0aDtcclxuICAgICAgICBpbnQgbCA9IDAsIGggPSBuIC0gMTtcclxuICAgICAgICB3aGlsZSAobCA8PSBoKSB7XHJcbiAgICAgICAgICAgIGludCBtaWQgPSBsICsgKGggLSBsKSAvIDI7XHJcbiAgICAgICAgICAgIGlmIChudW1zW21pZF0gPT0gdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlkO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bXNbbWlkXSA8IHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgbCA9IG1pZCArIDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoID0gbWlkIC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbn1cclxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogIiMg5p+l5om+IG51bXMg5pWw57uE5Lit5YWD57Sg5YC85Li6IHRhcmdldCDnmoTkuIvmoIfvvIzlpoLmnpzkuI3lrZjlnKjliJnov5Tlm54gLTFcbmRlZiBiaW5hcnlfc2VhcmNoKG51bXM6IFtdLCB0YXJnZXQ6IGludCkgLT4gaW50OlxuICAgIG4gPSBsZW4obnVtcylcbiAgICBsLCBoID0gMCwgbiAtIDFcbiAgICB3aGlsZSBsIDw9IGg6XG4gICAgICAgIG1pZCA9IGwgKyAoaCAtIGwpIC8vIDJcbiAgICAgICAgaWYgbnVtc1ttaWRdID09IHRhcmdldDpcbiAgICAgICAgICAgIHJldHVybiBtaWRcbiAgICAgICAgZWxpZiBudW1zW21pZF0gPCB0YXJnZXQ6XG4gICAgICAgICAgICBsID0gbWlkICsgMVxuICAgICAgICBlbHNlOlxuICAgICAgICAgICAgaCA9IG1pZCAtIDFcbiAgICByZXR1cm4gLTFcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBNi4yLjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcclxucHVibGljOlxyXG4gICAgaW50IGZpbmRNaW4odmVjdG9yPGludD4mIG51bXMpIHtcclxuICAgICAgICBpbnQgbCA9IDAsIGggPSBudW1zLnNpemUoKSAtIDE7XHJcbiAgICAgICAgd2hpbGUgKGwgPD0gaCkge1xyXG4gICAgICAgICAgICBpbnQgbWlkID0gbCArIChoIC0gbCkgLyAyO1xyXG4gICAgICAgICAgICBpZiAobCA9PSBoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtc1tsXTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1zW21pZF0gPiBudW1zW2hdKSB7XHJcbiAgICAgICAgICAgICAgICBsID0gbWlkICsgMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGggPSBtaWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG59O1xuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcclxuICAgIHB1YmxpYyBpbnQgZmluZE1pbihpbnRbXSBudW1zKSB7XHJcbiAgICAgICAgaW50IGwgPSAwLCBoID0gbnVtcy5sZW5ndGggLSAxO1xyXG4gICAgICAgIHdoaWxlIChsIDw9IGgpIHtcclxuICAgICAgICAgICAgaW50IG1pZCA9IGwgKyAoaCAtIGwpIC8gMjtcclxuICAgICAgICAgICAgaWYgKGwgPT0gaCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bXNbbF07XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtc1ttaWRdID4gbnVtc1toXSkge1xyXG4gICAgICAgICAgICAgICAgbCA9IG1pZCArIDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoID0gbWlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxufVxyXG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGZpbmRNaW4oc2VsZiwgbnVtczogTGlzdFtpbnRdKSAtPiBpbnQ6XG4gICAgICAgIGwsIGggPSAwLCBsZW4obnVtcykgLSAxXG4gICAgICAgIHdoaWxlIGwgPD0gaDpcbiAgICAgICAgICAgIG1pZCA9IGwgKyAoaCAtIGwpIC8vIDJcbiAgICAgICAgICAgIGlmIGwgPT0gaDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtc1tsXVxuICAgICAgICAgICAgZWxpZiBudW1zW21pZF0gPiBudW1zW2hdOlxuICAgICAgICAgICAgICAgIGwgPSBtaWQgKyAxXG4gICAgICAgICAgICBlbGlmIG51bXNbbWlkXSA8IG51bXNbaF06XG4gICAgICAgICAgICAgICAgaCA9IG1pZFxuICAgICAgICByZXR1cm4gLTFcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBNi4zLjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcclxucHVibGljOlxyXG4gICAgaW50IG1pbkVhdGluZ1NwZWVkKHZlY3RvcjxpbnQ+JiBwaWxlcywgaW50IEgpIHtcclxuICAgICAgICBpbnQgbWF4UGlsZSA9IHBpbGVzWzBdO1xyXG4gICAgICAgIGZvciAoaW50IHBpbGUgOiBwaWxlcykge1xyXG4gICAgICAgICAgICBpZiAocGlsZSA+IG1heFBpbGUpIHtcclxuICAgICAgICAgICAgICAgIG1heFBpbGUgPSBwaWxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGludCBsID0gMSwgaCA9IG1heFBpbGU7XHJcbiAgICAgICAgd2hpbGUgKGwgPD0gaCkge1xyXG4gICAgICAgICAgICBpbnQgbWlkID0gbCArIChoIC0gbCkgLyAyO1xyXG4gICAgICAgICAgICBpZiAobCA9PSBoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChoZWxwKHBpbGVzLCBtaWQsIEgpKSB7XHJcbiAgICAgICAgICAgICAgICBoID0gbWlkO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbCA9IG1pZCArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgLy8g5Yik5pat6YCf5bqmIGsg5piv5ZCm5ruh6Laz5p2h5Lu2XHJcbiAgICBib29sIGhlbHAodmVjdG9yPGludD4mIHBpbGVzLCBpbnQgaywgaW50IEgpIHtcclxuICAgICAgICBpbnQgY250ID0gMDtcclxuICAgICAgICBmb3IgKGludCBwaWxlIDogcGlsZXMpIHtcclxuICAgICAgICAgICAgY250ICs9IChwaWxlIC0gMSkgLyBrICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNudCA8PSBIO1xyXG4gICAgfVxyXG59O1xuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcclxuICAgIHB1YmxpYyBpbnQgbWluRWF0aW5nU3BlZWQoaW50W10gcGlsZXMsIGludCBIKSB7XHJcbiAgICAgICAgaW50IG1heFBpbGUgPSBwaWxlc1swXTtcclxuICAgICAgICBmb3IgKGludCBwaWxlIDogcGlsZXMpIHtcclxuICAgICAgICAgICAgbWF4UGlsZSA9IE1hdGgubWF4KHBpbGUsIG1heFBpbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnQgbCA9IDEsIGggPSBtYXhQaWxlO1xyXG4gICAgICAgIHdoaWxlIChsIDw9IGgpIHtcclxuICAgICAgICAgICAgaW50IG1pZCA9IGwgKyAoaCAtIGwpIC8gMjtcclxuICAgICAgICAgICAgaWYgKGwgPT0gaCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVscChwaWxlcywgbWlkLCBIKSkge1xyXG4gICAgICAgICAgICAgICAgaCA9IG1pZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGwgPSBtaWQgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIC8vIOWIpOaWremAn+W6piBrIOaYr+WQpua7oei2s+adoeS7tlxyXG4gICAgcHVibGljIGJvb2xlYW4gaGVscChpbnRbXSBwaWxlcywgaW50IGssIGludCBIKSB7XHJcbiAgICAgICAgaW50IGNudCA9IDA7XHJcbiAgICAgICAgZm9yIChpbnQgcGlsZSA6IHBpbGVzKSB7XHJcbiAgICAgICAgICAgIGNudCArPSAocGlsZSAtIDEpIC8gayArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbnQgPD0gSDtcclxuICAgIH1cclxufVxyXG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIG1pbkVhdGluZ1NwZWVkKHNlbGYsIHBpbGVzOiBMaXN0W2ludF0sIEg6IGludCkgLT4gaW50OlxuICAgICAgICAjIOWIpOaWremAn+W6piBrIOaYr+WQpua7oei2s+adoeS7tlxuICAgICAgICBkZWYgaGVscChrOiBpbnQpIC0+IGJvb2xlYW46XG4gICAgICAgICAgICBjbnQgPSAwXG4gICAgICAgICAgICBmb3IgcGlsZSBpbiBwaWxlczpcbiAgICAgICAgICAgICAgICBjbnQgKz0gKHBpbGUgLSAxKSAvLyBrICsgMVxuICAgICAgICAgICAgcmV0dXJuIGNudCA8PSBIXG5cbiAgICAgICAgbCwgaCA9IDEsIG1heChwaWxlcylcbiAgICAgICAgd2hpbGUgbCA8PSBoOlxuICAgICAgICAgICAgbWlkID0gbCArIChoIC0gbCkgLy8gMlxuICAgICAgICAgICAgaWYgbCA9PSBoOlxuICAgICAgICAgICAgICAgIHJldHVybiBsXG4gICAgICAgICAgICBpZiBoZWxwKG1pZCk6XG4gICAgICAgICAgICAgICAgaCA9IG1pZFxuICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICBsID0gbWlkICsgMVxuICAgICAgICByZXR1cm4gLTFcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBNi40LjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcclxucHVibGljOlxyXG4gICAgaW50IG15U3FydChpbnQgeCkge1xyXG4gICAgICAgIGxvbmcgbCA9IDAsIGggPSB4O1xyXG4gICAgICAgIHdoaWxlIChsIDw9IGgpIHtcclxuICAgICAgICAgICAgbG9uZyBtaWQgPSBsICsgKGggLSBsKSAvIDI7XHJcbiAgICAgICAgICAgIGlmIChsID09IGggfHwgbCArIDEgPT0gaCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWlkICogbWlkID4geCkge1xyXG4gICAgICAgICAgICAgICAgaCA9IG1pZCAtIDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsID0gbWlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoICogaCA8PSB4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoaW50KWg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIChpbnQpbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xyXG4gICAgcHVibGljIGludCBteVNxcnQoaW50IHgpIHtcclxuICAgICAgICBsb25nIGwgPSAwLCBoID0geDtcclxuICAgICAgICB3aGlsZSAobCA8PSBoKSB7XHJcbiAgICAgICAgICAgIGxvbmcgbWlkID0gbCArIChoIC0gbCkgLyAyO1xyXG4gICAgICAgICAgICBpZiAobCA9PSBoIHx8IGwgKyAxID09IGgpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1pZCAqIG1pZCA+IHgpIHtcclxuICAgICAgICAgICAgICAgIGggPSBtaWQgLSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbCA9IG1pZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaCAqIGggPD0geCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKGludCkgaDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gKGludCkgbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBteVNxcnQoc2VsZiwgeDogaW50KSAtPiBpbnQ6XG4gICAgICAgIGwsIGggPSAwLCB4XG4gICAgICAgIHdoaWxlIGwgPD0gaDpcbiAgICAgICAgICAgIG1pZCA9IGwgKyAoaCAtIGwpIC8vIDJcbiAgICAgICAgICAgIGlmIGwgPT0gaCBvciBsICsgMSA9PSBoOlxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBlbGlmIG1pZCAqIG1pZCA+IHg6XG4gICAgICAgICAgICAgICAgaCA9IG1pZCAtIDFcbiAgICAgICAgICAgIGVsc2U6XG4gICAgICAgICAgICAgICAgbCA9IG1pZFxuICAgICAgICBpZiBoICogaCA8PSB4OlxuICAgICAgICAgICAgcmV0dXJuIGhcbiAgICAgICAgZWxzZTpcbiAgICAgICAgICAgIHJldHVybiBsXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTYuNC4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJpbnQgYnModmVjdG9yPGludD4mIG51bXMsIGludCB4KSB7XHJcbiAgICBpbnQgbCA9IDAsIGggPSBudW1zLnNpemUoKSAtIDE7XHJcbiAgICB3aGlsZSAobCA8PSBoKSB7XHJcbiAgICAgICAgaW50IG1pZCA9IGwgKyAoaCAtIGwpIC8gMjtcclxuICAgICAgICBpZiAobCA9PSBoKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobnVtc1ttaWRdID49IHgpIHtcclxuICAgICAgICAgICAgaCA9IG1pZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsID0gbWlkICsgMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVtc1tsXTtcclxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogInB1YmxpYyBpbnQgYnMoaW50W10gbnVtcywgaW50IHgpIHtcclxuXHRpbnQgbCA9IDAsIGggPSBudW1zLmxlbmd0aCAtIDE7XHJcblx0d2hpbGUgKGwgPD0gaCkge1xyXG5cdFx0aW50IG1pZCA9IGwgKyAoaCAtIGwpIC8gMjtcclxuXHRcdGlmIChsID09IGgpIHtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHR9IGVsc2UgaWYgKG51bXNbbWlkXSA+PSB4KSB7XHJcblx0XHRcdGggPSBtaWQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsID0gbWlkICsgMTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG51bXNbbF07XHJcbn1cclxuXHJcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICIjIOafpeaJvuesrOS4gOS4quWkp+S6juetieS6jiB4IOeahOWFg+e0oFxuZGVmIGJzKG51bXM6IExpc3RbaW50XSwgeDogaW50KSAtPiBpbnQ6XG4gICAgbCwgaCA9IDAsIGxlbihudW1zKSAtIDFcbiAgICB3aGlsZSBsIDw9IGg6XG4gICAgICAgIG1pZCA9IGwgKyAoaCAtIGwpIC8vIDJcbiAgICAgICAgaWYgbCA9PSBoOlxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgZWxpZiBudW1zW21pZF0gPj0geDpcbiAgICAgICAgICAgIGggPSBtaWRcbiAgICAgICAgZWxzZTpcbiAgICAgICAgICAgIGwgPSBtaWQgKyAxXG4gICAgcmV0dXJuIG51bXNbbF1cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBNi40LjMiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImludCBicyh2ZWN0b3I8aW50PiYgbnVtcywgaW50IHgpIHtcclxuICAgIGludCBsID0gMCwgaCA9IG51bXMuc2l6ZSgpIC0gMTtcclxuICAgIHdoaWxlIChsIDw9IGgpIHtcclxuICAgICAgICBpbnQgbWlkID0gbCArIChoIC0gbCkgLyAyO1xyXG4gICAgICAgIGlmIChsID09IGggfHwgbCArIDEgPT0gaCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2UgaWYgKG51bXNbbWlkXSA8PSB4KSB7XHJcbiAgICAgICAgICAgIGwgPSBtaWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaCA9IG1pZCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG51bXNbaF0gPD0geCkge1xyXG4gICAgICAgIHJldHVybiBudW1zW2hdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVtc1tsXTtcclxuICAgIH1cclxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogInB1YmxpYyBpbnQgYnMoaW50W10gbnVtcywgaW50IHgpIHtcclxuICAgIGludCBsID0gMCwgaCA9IG51bXMubGVuZ3RoIC0gMTtcclxuICAgIHdoaWxlIChsIDw9IGgpIHtcclxuICAgICAgICBpbnQgbWlkID0gbCArIChoIC0gbCkgLyAyO1xyXG4gICAgICAgIGlmIChsID09IGggfHwgbCArIDEgPT0gaCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2UgaWYgKG51bXNbbWlkXSA8PSB4KSB7XHJcbiAgICAgICAgICAgIGwgPSBtaWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaCA9IG1pZCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG51bXNbaF0gPD0geCkge1xyXG4gICAgICAgIHJldHVybiBudW1zW2hdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVtc1tsXTtcclxuICAgIH1cclxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICIjIOafpeaJvuacgOWQjuS4gOS4quWwj+S6juetieS6jiB4IOeahOWFg+e0oFxuZGVmIGJzKG51bXM6IExpc3RbaW50XSwgeDogaW50KSAtPiBpbnQ6XG4gICAgbCwgaCA9IDAsIGxlbihudW1zKSAtIDFcbiAgICB3aGlsZSBsIDw9IGg6XG4gICAgICAgIG1pZCA9IGwgKyAoaCAtIGwpIC8vIDJcbiAgICAgICAgaWYgbCA9PSBoIG9yIGwgKyAxID09IGg6XG4gICAgICAgICAgICBicmVha1xuICAgICAgICBlbGlmIG51bXNbbWlkXSA8PSB4OlxuICAgICAgICAgICAgbCA9IG1pZFxuICAgICAgICBlbHNlOlxuICAgICAgICAgICAgaCA9IG1pZCAtIDFcbiAgICBpZiBudW1zW2hdIDw9IHg6XG4gICAgICAgIHJldHVybiBudW1zW2hdXG4gICAgZWxzZTpcbiAgICAgICAgcmV0dXJuIG51bXNbbF1cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBNi41LjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcclxucHVibGljOlxyXG4gICAgaW50IGZpbmRQZWFrRWxlbWVudCh2ZWN0b3I8aW50PiYgbnVtcykge1xyXG4gICAgICAgIGludCBuID0gbnVtcy5zaXplKCk7XHJcbiAgICAgICAgaW50IGwgPSAwLCBoID0gbiAtIDE7XHJcbiAgICAgICAgd2hpbGUgKGwgPD0gaCkge1xyXG4gICAgICAgICAgICBpbnQgbWlkID0gbCArIChoIC0gbCkgLyAyO1xyXG4gICAgICAgICAgICBpZiAobWlkICsgMSA8IG4gJiYgbnVtc1ttaWRdIDwgbnVtc1ttaWQgKyAxXSkge1xyXG4gICAgICAgICAgICAgICAgbCA9IG1pZCArIDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWlkIC0gMSA+PSAwICYmIG51bXNbbWlkXSA8IG51bXNbbWlkIC0gMV0pIHtcclxuICAgICAgICAgICAgICAgIGggPSBtaWQgLSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xyXG4gICAgcHVibGljIGludCBmaW5kUGVha0VsZW1lbnQoaW50W10gbnVtcykge1xyXG4gICAgICAgIGludCBuID0gbnVtcy5sZW5ndGg7XHJcbiAgICAgICAgaW50IGwgPSAwLCBoID0gbiAtIDE7XHJcbiAgICAgICAgd2hpbGUgKGwgPD0gaCkge1xyXG4gICAgICAgICAgICBpbnQgbWlkID0gbCArIChoIC0gbCkgLyAyO1xyXG4gICAgICAgICAgICBpZiAobWlkICsgMSA8IG4gJiYgbnVtc1ttaWRdIDwgbnVtc1ttaWQgKyAxXSkge1xyXG4gICAgICAgICAgICAgICAgbCA9IG1pZCArIDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWlkIC0gMSA+PSAwICYmIG51bXNbbWlkXSA8IG51bXNbbWlkIC0gMV0pIHtcclxuICAgICAgICAgICAgICAgIGggPSBtaWQgLSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbn1cclxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBmaW5kUGVha0VsZW1lbnQoc2VsZiwgbnVtczogTGlzdFtpbnRdKSAtPiBpbnQ6XG4gICAgICAgIG4gPSBsZW4obnVtcylcbiAgICAgICAgbCwgaCA9IDAsIG4gLSAxXG4gICAgICAgIHdoaWxlIGwgPD0gaDpcbiAgICAgICAgICAgIG1pZCA9IGwgKyAoaCAtIGwpIC8vIDJcbiAgICAgICAgICAgIGlmIG1pZCArIDEgPCBuIGFuZCBudW1zW21pZF0gPCBudW1zW21pZCArIDFdOlxuICAgICAgICAgICAgICAgIGwgPSBtaWQgKyAxXG4gICAgICAgICAgICBlbGlmIG1pZCAtIDEgPj0gMCBhbmQgbnVtc1ttaWRdIDwgbnVtc1ttaWQgLSAxXTpcbiAgICAgICAgICAgICAgICBoID0gbWlkIC0gMVxuICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlkXG4gICAgICAgIHJldHVybiAtMVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIE2LjYuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xyXG5wdWJsaWM6XHJcbiAgICBpbnQgc3BsaXRBcnJheSh2ZWN0b3I8aW50PiYgbnVtcywgaW50IG0pIHtcclxuICAgICAgICBsb25nIG1heE51bSA9IG51bXNbMF0sIHN1bU51bSA9IDA7XHJcbiAgICAgICAgZm9yIChsb25nIG51bSA6IG51bXMpIHtcclxuICAgICAgICAgICAgaWYgKG51bSA+IG1heE51bSkge1xyXG4gICAgICAgICAgICAgICAgbWF4TnVtID0gbnVtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN1bU51bSArPSBudW07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxvbmcgbCA9IG1heE51bSwgaCA9IHN1bU51bTtcclxuICAgICAgICB3aGlsZSAobCA8PSBoKSB7XHJcbiAgICAgICAgICAgIGxvbmcgbWlkID0gbCArIChoIC0gbCkgLyAyO1xyXG4gICAgICAgICAgICBpZiAobCA9PSBoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGludClsO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhlbHAobnVtcywgbWlkLCBtKSkge1xyXG4gICAgICAgICAgICAgICAgaCA9IG1pZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGwgPSBtaWQgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGJvb2wgaGVscCh2ZWN0b3I8aW50PiYgbnVtcywgbG9uZyBhbnMsIGludCBtKSB7XHJcbiAgICAgICAgbG9uZyBjbnQgPSAxLCBjdXIgPSAwO1xyXG4gICAgICAgIGZvciAobG9uZyBudW0gOiBudW1zKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXIgKyBudW0gPiBhbnMpIHtcclxuICAgICAgICAgICAgICAgIGN1ciA9IG51bTtcclxuICAgICAgICAgICAgICAgIGNudCArPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VyICs9IG51bTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY250IDw9IG07XHJcbiAgICB9XHJcbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xyXG4gICAgcHVibGljIGludCBzcGxpdEFycmF5KGludFtdIG51bXMsIGludCBtKSB7XHJcbiAgICAgICAgbG9uZyBtYXhOdW0gPSBudW1zWzBdLCBzdW1OdW0gPSAwO1xyXG4gICAgICAgIGZvciAobG9uZyBudW0gOiBudW1zKSB7XHJcbiAgICAgICAgICAgIG1heE51bSA9IE1hdGgubWF4KG1heE51bSwgbnVtKTtcclxuICAgICAgICAgICAgc3VtTnVtICs9IG51bTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbG9uZyBsID0gbWF4TnVtLCBoID0gc3VtTnVtO1xyXG4gICAgICAgIHdoaWxlIChsIDw9IGgpIHtcclxuICAgICAgICAgICAgbG9uZyBtaWQgPSBsICsgKGggLSBsKSAvIDI7XHJcbiAgICAgICAgICAgIGlmIChsID09IGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoaW50KSBsO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhlbHAobnVtcywgbWlkLCBtKSkge1xyXG4gICAgICAgICAgICAgICAgaCA9IG1pZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGwgPSBtaWQgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYm9vbGVhbiBoZWxwKGludFtdIG51bXMsIGxvbmcgYW5zLCBpbnQgbSkge1xyXG4gICAgICAgIGxvbmcgY250ID0gMSwgY3VyID0gMDtcclxuICAgICAgICBmb3IgKGxvbmcgbnVtIDogbnVtcykge1xyXG4gICAgICAgICAgICBpZiAoY3VyICsgbnVtID4gYW5zKSB7XHJcbiAgICAgICAgICAgICAgICBjdXIgPSBudW07XHJcbiAgICAgICAgICAgICAgICBjbnQgKz0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1ciArPSBudW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNudCA8PSBtO1xyXG4gICAgfVxyXG59XHJcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgc3BsaXRBcnJheShzZWxmLCBudW1zOiBMaXN0W2ludF0sIG06IGludCkgLT4gaW50OlxuICAgICAgICAjIOWIpOaWrSBhbnMg5piv5ZCm5Y+v6KGMXG4gICAgICAgIGRlZiBoZWxwKGFuczogaW50KSAtPiBib29sZWFuOlxuICAgICAgICAgICAgY250LCBjdXIgPSAxLCAwXG4gICAgICAgICAgICBmb3IgbnVtIGluIG51bXM6XG4gICAgICAgICAgICAgICAgaWYgKGN1ciArIG51bSkgPiBhbnM6XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IG51bVxuICAgICAgICAgICAgICAgICAgICBjbnQgKz0gMVxuICAgICAgICAgICAgICAgIGVsc2U6XG4gICAgICAgICAgICAgICAgICAgIGN1ciArPSBudW1cbiAgICAgICAgICAgIHJldHVybiBjbnQgPD0gbVxuXG4gICAgICAgIGwsIGggPSBtYXgobnVtcyksIHN1bShudW1zKVxuICAgICAgICB3aGlsZSBsIDw9IGg6XG4gICAgICAgICAgICBtaWQgPSBsICsgKGggLSBsKSAvLyAyXG4gICAgICAgICAgICBpZiBsID09IGg6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxcbiAgICAgICAgICAgIGVsaWYgaGVscChtaWQpOlxuICAgICAgICAgICAgICAgIGggPSBtaWRcbiAgICAgICAgICAgIGVsc2U6XG4gICAgICAgICAgICAgICAgbCA9IG1pZCArIDFcbiAgICAgICAgcmV0dXJuIC0xXG5cbiIKICAgIH1dCiAgfV0KfSwgewogICJpZCI6ICIwNyIsCiAgIm5hbWUiOiAi56ys5LiD56ugIiwKICAibGlzdCI6IFt7CiAgICAidGl0bGUiOiAi5Luj56CBNy4xLjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgICBpbnQgaGFtbWluZ1dlaWdodCh1aW50MzJfdCBuKSB7XG4gICAgICAgIGludCBudW0gPSAwO1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDMyOyBpKyspe1xuICAgICAgICAgICAgaWYgKG4gJiAoMSA8PCBpKSlcbiAgICAgICAgICAgICAgICBudW0rKzsgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgICAvLyB5b3UgbmVlZCB0byB0cmVhdCBuIGFzIGFuIHVuc2lnbmVkIHZhbHVlXG4gICAgcHVibGljIGludCBoYW1taW5nV2VpZ2h0KGludCBuKSB7XG4gICAgICAgIGludCByZXRWYWwgPSAwO1xuICAgICAgICBpbnQgbWFzayA9IDE7XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICAgICAgaWYgKChuICYgbWFzaykgIT0gMCkge1xuICAgICAgICAgICAgICAgIHJldFZhbCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFzayA8PD0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0VmFsO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGhhbW1pbmdXZWlnaHQoc2VsZiwgbjppbnQpLT5pbnQ6XG4gICAgICAgIHJldHZhbCA9IDBcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMzIpOlxuICAgICAgICAgICAgaWYgbiAmICgxIDw8IGkpOlxuICAgICAgICAgICAgICAgIHJldHZhbCA9IHJldHZhbCArIDFcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJldHZhbFxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIE3LjEuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGludCBoYW1taW5nV2VpZ2h0KHVpbnQzMl90IG4pIHtcbiAgICAgICAgaW50IHJldCA9IDA7XG4gICAgICAgIFxuICAgICAgICB3aGlsZSAobikge1xuICAgICAgICAgICAgcmV0ID0gcmV0ICsgMTtcbiAgICAgICAgICAgIG4gJj0gKG4gLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJwdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICAgIC8vIHlvdSBuZWVkIHRvIHRyZWF0IG4gYXMgYW4gdW5zaWduZWQgdmFsdWVcbiAgICBwdWJsaWMgaW50IGhhbW1pbmdXZWlnaHQyKGludCBuKSB7XG4gICAgICAgIGludCByZXRWYWwgPSAwO1xuICAgICAgICB3aGlsZSAobiAhPSAwKSB7XG4gICAgICAgICAgICBuID0gbiAmIChuIC0gMSk7XG4gICAgICAgICAgICByZXRWYWwrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0VmFsO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGhhbW1pbmdXZWlnaHQoc2VsZiwgbjppbnQpLT5pbnQ6XG4gICAgICAgIHJldHZhbCA9IDBcbiAgICAgICAgd2hpbGUgbjpcbiAgICAgICAgICAgIHJldHZhbCA9IHJldHZhbCArIDFcbiAgICAgICAgICAgIG4gJj0gKG4gLSAxKVxuICAgICAgICAgICAgXG4gICAgICAgIHJldHVybiByZXR2YWxcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBNy4yLjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgICBpbnQgZ2V0U3VtKGludCBhLCBpbnQgYikge1xuICAgICAgICBpbnQgYW5zID0gYSBeIGI7XG4gICAgICAgIGludCBjID0gYSAmIGI7XG4gICAgICAgIHdoaWxlKGMgIT0gMCkge1xuICAgICAgICAgICAgYyA9IChjICYgMHhmZmZmZmZmZikgPDwgMTtcbiAgICAgICAgICAgIGludCBhbnNfcHJpbSA9IGFucyBeIGM7XG4gICAgICAgICAgICBjID0gYW5zICYgYztcbiAgICAgICAgICAgIGFucyA9IGFuc19wcmltO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbnM7XG4gICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgICBwdWJsaWMgaW50IGdldFN1bShpbnQgYSwgaW50IGIpIHtcbiAgICAgICAgd2hpbGUgKGIgIT0gMCkge1xuICAgICAgICAgICAgaW50IGNhcnJ5ID0gKGEgJiBiKSA8PCAxO1xuICAgICAgICAgICAgaW50IHRlbXAgPSBhIF4gYjtcblxuICAgICAgICAgICAgYSA9IHRlbXA7XG4gICAgICAgICAgICBiID0gY2Fycnk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgZ2V0U3VtKHNlbGYsIGE6aW50LCBiOmludCktPmludDpcbiAgICAgICAgY2FycnkgPSAwXG4gICAgICAgIG1hc2sgID0gMHhGRkZGRkZGRlxuICAgICAgICBcbiAgICAgICAgd2hpbGUgYiAmIG1hc2sgIT0gMDpcbiAgICAgICAgICAgIGNhcnJ5ID0gKGEgJiBiKSA8PCAxXG4gICAgICAgICAgICBhID0gYSBeIGJcbiAgICAgICAgICAgIGIgPSBjYXJyeVxuICAgICAgICAgICAgXG4gICAgICAgIGlmIGIgPiBtYXNrOlxuICAgICAgICAgICAgcmV0dXJuIGEgJiBtYXNrXG4gICAgICAgIGVsc2U6XG4gICAgICAgICAgICByZXR1cm4gYVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIE3LjMuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHJpdmF0ZTpcbiAgICB1bm9yZGVyZWRfbWFwPGludCwgaW50PiB2aXNpdGVkO1xucHVibGljOlxuICAgIGludCBpbnRlZ2VyUmVwbGFjZW1lbnQoaW50IG4pIHtcbiAgICAgICAgaWYgKG4gPT0gMSkgcmV0dXJuIDA7XG4gICAgICAgIFxuICAgICAgICBpZiAodmlzaXRlZC5jb3VudChuKSA9PSAwKSB7XG4gICAgICAgICAgICBpZiAobiAmIDEgPT0gMSlcbiAgICAgICAgICAgICAgICB2aXNpdGVkW25dID0gMiArIG1pbihpbnRlZ2VyUmVwbGFjZW1lbnQobiA+PiAxKSwgaW50ZWdlclJlcGxhY2VtZW50KChuID4+IDEpICsgMSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHZpc2l0ZWRbbl0gPSAxICsgaW50ZWdlclJlcGxhY2VtZW50KG4gPj4gMSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB2aXNpdGVkW25dO1xuICAgIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gICAgcHVibGljIGludCBpbnRlZ2VyUmVwbGFjZW1lbnQoaW50IG4pIHtcbiAgICAgICAgaWYgKG4gPT0gMSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBpZiAobiA9PSBJbnRlZ2VyLk1BWF9WQUxVRSlcbiAgICAgICAgICAgIHJldHVybiAzMjtcbiAgICAgICAgaWYgKG4gJSAyID09IDApXG4gICAgICAgICAgICByZXR1cm4gaW50ZWdlclJlcGxhY2VtZW50KG4gLyAyKSArIDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihpbnRlZ2VyUmVwbGFjZW1lbnQobiArIDEpLCBpbnRlZ2VyUmVwbGFjZW1lbnQobiAtIDEpKSArIDE7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgaW50ZWdlclJlcGxhY2VtZW50KHNlbGYsIG46aW50KS0+aW50OlxuICAgICAgICBpZiBuID09IDE6XG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICBlbGlmIG4gJSAyID09IDA6XG4gICAgICAgICAgICByZXR1cm4gMSArIHNlbGYuaW50ZWdlclJlcGxhY2VtZW50KG4gLy8gMilcbiAgICAgICAgZWxzZTpcbiAgICAgICAgICAgIHJldHVybiBtaW4oc2VsZi5pbnRlZ2VyUmVwbGFjZW1lbnQobiArIDEpLCBzZWxmLmludGVnZXJSZXBsYWNlbWVudChuIC0gMSkpICsgMVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIE3LjMuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGludCBpbnRlZ2VyUmVwbGFjZW1lbnQoaW50IG4pIHtcbiAgICAgICAgbG9uZyBpbnQgdG1wX251bSA9IG47XG4gICAgICAgIGludCBjb3VudCA9IDA7XG4gICAgICAgIFxuICAgICAgICB3aGlsZSAodG1wX251bSA+IDEpIHtcbiAgICAgICAgICAgIGlmICh0bXBfbnVtICUgMiA9PSAwKVxuICAgICAgICAgICAgICAgIHRtcF9udW0gPj49IDE7XG4gICAgICAgICAgICBlbHNlIGlmICgoKHRtcF9udW0gKyAxKSAlIDQgPT0gMCkgJiYgKHRtcF9udW0gIT0gMykpXG4gICAgICAgICAgICAgICAgdG1wX251bSArPSAxO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRtcF9udW0gLT0gMTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gICAgcHVibGljIGludCBpbnRlZ2VyUmVwbGFjZW1lbnQoaW50IG4pIHtcbiAgICAgICAgaWYgKG4gPT0gMSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBpZiAobiA9PSBJbnRlZ2VyLk1BWF9WQUxVRSlcbiAgICAgICAgICAgIHJldHVybiAzMjtcbiAgICAgICAgaW50IGNvdW50ID0gMDtcbiAgICAgICAgd2hpbGUgKG4gPiAzKSB7XG4gICAgICAgICAgICBpZiAobiAlIDIgPT0gMClcbiAgICAgICAgICAgICAgICBuID4+PSAxO1xuICAgICAgICAgICAgZWxzZSBpZiAoKG4gKyAxKSAlIDQgPT0gMCkgXG4gICAgICAgICAgICAgICAgbiArPSAxO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG4gLT0gMTtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbiA9PSAzID8gY291bnQgKyAyIDogY291bnQgKyAxOyAvLyDlpITnkIYgbj09MyDnmoTnibnmrormg4XlhrVcbiAgICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBpbnRlZ2VyUmVwbGFjZW1lbnQoc2VsZiwgbjppbnQpLT5pbnQ6XG4gICAgICAgIGNvdW50ID0gMFxuICAgICAgICB3aGlsZSBuID4gMTpcbiAgICAgICAgICAgIGlmIG4gJiAxID09IDA6XG4gICAgICAgICAgICAgICAgbiA+Pj0gMVxuICAgICAgICAgICAgZWxpZiAobiArIDEpICUgNCA9PSAwIGFuZCBuICE9IDM6XG4gICAgICAgICAgICAgICAgbiArPSAxXG4gICAgICAgICAgICBlbHNlOlxuICAgICAgICAgICAgICAgIG4gLT0gMVxuICAgICAgICAgICAgY291bnQgKz0gMVxuXG4gICAgICAgIHJldHVybiBjb3VudFxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIE3LjMuMyIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGludCBpbnRlZ2VyUmVwbGFjZW1lbnQoaW50IG4pIHtcbiAgICAgICAgbG9uZyBpbnQgdG1wX251bSA9IG47XG4gICAgICAgIGludCBjb3VudCA9IDA7XG4gICAgICAgIFxuICAgICAgICB3aGlsZSAodG1wX251bSAhPSAxKSB7XG4gICAgICAgICAgICBpZiAodG1wX251bSAlIDIgPT0gMCkge1xuICAgICAgICAgICAgICAgIHRtcF9udW0gPj49IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgoKHRtcF9udW0gJiAyKSA9PSAwKSB8fCAodG1wX251bSA9PSAzKSlcbiAgICAgICAgICAgICAgICAgICAgdG1wX251bSAtPSAxO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdG1wX251bSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgICBwdWJsaWMgaW50IGludGVnZXJSZXBsYWNlbWVudChpbnQgbikge1xuICAgICAgICBpZiAobiA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGlmIChuID09IEludGVnZXIuTUFYX1ZBTFVFKVxuICAgICAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgICBpbnQgY291bnQgPSAwO1xuICAgICAgICB3aGlsZSAobiA+IDMpIHtcbiAgICAgICAgICAgIGlmICgobiAmIDEpID09IDApIC8v5Yik5pat5pivIDAg5oiWIDFcbiAgICAgICAgICAgICAgICBuID4+PSAxO1xuICAgICAgICAgICAgZWxzZSBpZiAoKG4gJiAyKSA9PSAwKSAvLyDlt7Lnu4/noa7lrprmnIDlkI7kuIDkvY3mmK8x77yM5Yik5pat5pivMDEg6L+Y5pivMTFcbiAgICAgICAgICAgICAgICBuIC09IDE7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbiArPSAxO1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbiA9PSAzID8gY291bnQgKyAyIDogY291bnQgKyAxOyAvLyDlpITnkIYgbj09MyDnmoTnibnmrormg4XlhrVcbiAgICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBpbnRlZ2VyUmVwbGFjZW1lbnQoc2VsZiwgbjppbnQpLT5pbnQ6XG4gICAgICAgIGNvdW50ID0gMFxuICAgICAgICB3aGlsZSBuICE9IDE6XG4gICAgICAgICAgICBpZiBuICYgMSA9PSAw77yaXG4gICAgICAgICAgICAgICAgbiA+Pj0gMVxuICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICBpZiAobiAmIDIpID09IDAgb3IgbiA9PSAzOlxuICAgICAgICAgICAgICAgICAgICBuICs9IC0xXG4gICAgICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICAgICAgbiArPSAxXG4gICAgICAgICAgICBjb3VudCArPSAxXG5cbiAgICAgICAgcmV0dXJuIGNvdW50XG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTcuNC4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgaW50IHNpbmdsZU51bWJlcih2ZWN0b3I8aW50PiYgbnVtcykge1xuICAgICAgICB1bm9yZGVyZWRfbWFwPGludCwgaW50PiBtO1xuXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtcy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgbVtudW1zW2ldXSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChhdXRvIGl0ID0gbS5iZWdpbigpOyBpdCAhPSBtLmVuZCgpOyBpdCsrKVxuICAgICAgICAgICAgaWYgKGl0LT5zZWNvbmQgPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXQtPmZpcnN0O1xuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gICAgcHVibGljIGludCBzaW5nbGVOdW1iZXIoaW50W10gbnVtcykge1xuICAgICAgICBNYXA8SW50ZWdlciwgSW50ZWdlcj4gbWFwID0gbmV3IEhhc2hNYXA8PigpO1xuICAgICAgICBmb3IgKGludCBudW0gOiBudW1zKVxuICAgICAgICAgICAgbWFwLnB1dChudW0sIG1hcC5nZXRPckRlZmF1bHQobnVtLCAwKSArIDEpO1xuICAgICAgICBmb3IgKGludCBudW0gOiBtYXAua2V5U2V0KCkpXG4gICAgICAgICAgICBpZiAobWFwLmdldChudW0pID09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgc2luZ2xlTnVtYmVyKHNlbGYsIG51bXM6TGlzdFtpbnRdKS0+aW50OlxuICAgICAgICByZXQgPSAwXG4gICAgICAgIFxuICAgICAgICBmb3IgaSBpbiByYW5nZShsZW4obnVtcykpOlxuICAgICAgICAgICAgcmV0IF49IG51bXNbaV1cbiAgICAgICAgICAgIFxuICAgICAgICByZXR1cm4gcmV0XG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTcuNC4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgaW50IHNpbmdsZU51bWJlcih2ZWN0b3I8aW50PiYgbnVtcykge1xuICAgICAgICBpbnQgcmVzdWx0ID0gMDtcbiAgICAgICAgXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtcy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0IF49IG51bXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgICBwdWJsaWMgaW50IHNpbmdsZU51bWJlcihpbnRbXSBudW1zKSB7XG4gICAgICAgIGludCByZXMgPSBudW1zWzBdO1xuICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlcyBePSBudW1zW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgc2luZ2xlTnVtYmVyKHNlbGYsIG51bXM6TGlzdFtpbnRdKS0+aW50OlxuICAgICAgICBoYXNoX3RhYiA9IGRlZmF1bHRkaWN0KGludClcbiAgICAgICAgXG4gICAgICAgIGZvciBpIGluIG51bXM6XG4gICAgICAgICAgICBoYXNoX3RhYltpXSArPSAxXG4gICAgICAgICAgICBcbiAgICAgICAgZm9yIGkgaW4gaGFzaF90YWI6XG4gICAgICAgICAgICBpZiBoYXNoX3RhYltpXSA9PSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBpXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTcuNC4zIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICAgIHB1YmxpYyBpbnQgc2luZ2xlTnVtYmVyKGludFtdIG51bXMpIHtcbiAgICAgICAgaW50IGRpc3RpbmN0U3VtID0gQXJyYXlzLnN0cmVhbShudW1zKS5kaXN0aW5jdCgpLnN1bSgpO1xuICAgICAgICBpbnQgc3VtID0gQXJyYXlzLnN0cmVhbShudW1zKS5zdW0oKTtcbiAgICAgICAgcmV0dXJuIGRpc3RpbmN0U3VtICogMiAtIHN1bTtcbiAgICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHNpbmdsZU51bWJlcihzZWxmLCBudW1zOkxpc3RbaW50XSktPmludDpcbiAgICAgICAgcmV0dXJuIDIgKiBzdW0oc2V0KG51bXMpKSAtIHN1bShudW1zKVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIE3LjQuNCIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGludCBzaW5nbGVOdW1iZXIodmVjdG9yPGludD4mIG51bXMpIHtcbiAgICAgICAgdmVjdG9yPGludD4gdCgzMik7XG4gICAgICAgIFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IG51bXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgICAgIGludCBudW0gPSBudW1zW2ldO1xuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDMxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIHRbal0gKz0gbnVtICYgMTtcbiAgICAgICAgICAgICAgICBudW0gPj49IDE7XG4gICAgICAgICAgICAgICAgaWYgKCFudW0pIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpbnQgcmVzID0gMDtcbiAgICAgICAgZm9yIChpbnQgaiA9IDMxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgaW50IG51bSA9IHRbal0gJSAzO1xuICAgICAgICAgICAgaWYgKG51bSkgcmVzICs9IDEgPDwgKDMxIC0gaik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgICBwdWJsaWMgaW50IHNpbmdsZU51bWJlcihpbnRbXSBudW1zKSB7XG4gICAgICAgIGludFtdIGNvdW50cyA9IG5ldyBpbnRbMzJdO1xuICAgICAgICBmb3IgKGludCBudW0gOiBudW1zKSB7XG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudHNbaV0gKz0gbnVtICYgMTtcbiAgICAgICAgICAgICAgICBudW0gPj49IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW50IHJlcyA9IDA7XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICAgICAgcmVzIDw8PSAxO1xuICAgICAgICAgICAgcmVzIHw9IGNvdW50c1szMSAtIGldICUgMztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHNpbmdsZU51bWJlcihzZWxmLCBudW1zOiBMaXN0W2ludF0pIC0+IGludDpcbiAgICAgICAgY291bnRzID0gWzBdICogMzJcbiAgICAgICAgIyDnu5/orqEgbnVtcyDkuK3mr4/kuKrlhYPntKDnmoTkuozov5vliLbkuK3vvIzlr7nlupTkvY3kuIrnmoQgMSDnmoTkuKrmlbBcbiAgICAgICAgZm9yIG51bSBpbiBudW1zOlxuICAgICAgICAgICAgZm9yIGogaW4gcmFuZ2UoMzIpOlxuICAgICAgICAgICAgICAgIGNvdW50c1tqXSArPSBudW0gJiAxXG4gICAgICAgICAgICAgICAgbnVtID4+PSAxXG4gICAgICAgIHJlcywgbSA9IDAsIDNcbiAgICAgICAgIyDlr7nmr4/kuIDkvY3kuIrvvIznu5/orqHnmoQgMSDnmoTkuKrmlbDlj5bkvZlcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMzIpOlxuICAgICAgICAgICAgcmVzIDw8PSAxXG4gICAgICAgICAgICByZXMgfD0gY291bnRzWzMxIC0gaV0gJSBtXG4gICAgICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlcyBpZiBjb3VudHNbMzFdICUgbSA9PSAwIGVsc2UgfihyZXMgXiAweGZmZmZmZmZmKVxuXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTcuNC41IiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICAgIHB1YmxpYyBpbnQgc2luZ2xlTnVtYmVyKGludFtdIG51bXMpIHtcbiAgICAgICAgaW50W10gY291bnRzID0gbmV3IGludFszMl07XG4gICAgICAgIGZvciAoaW50IG51bSA6IG51bXMpIHtcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvdW50c1tpXSArPSBudW0gJiAxO1xuICAgICAgICAgICAgICAgIG51bSA+Pj0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbnQgcmVzID0gMDtcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgICAgICByZXMgPDw9IDE7XG4gICAgICAgICAgICByZXMgfD0gY291bnRzWzMxIC0gaV0gJSAzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgc2luZ2xlTnVtYmVyKHNlbGYsIG51bXM6IExpc3RbaW50XSkgLT4gTGlzdFtpbnRdOlxuICAgICAgICByZXQgPSAwICAjIOaJgOacieaVsOWtl+W8guaIlueahOe7k+aenFxuICAgICAgICBhID0gMFxuICAgICAgICBiID0gMFxuICAgICAgICBmb3IgbiBpbiBudW1zOlxuICAgICAgICAgICAgcmV0IF49IG5cbiAgICAgICAgIyDmib7liLDnrKzkuIDkvY3kuI3mmK8gMCDnmoRcbiAgICAgICAgaCA9IDFcbiAgICAgICAgd2hpbGUgcmV0ICYgaCA9PSAwOlxuICAgICAgICAgICAgaCA8PD0gMVxuICAgICAgICBmb3IgbiBpbiBudW1zOlxuICAgICAgICAgICAgIyDmoLnmja7or6XkvY3mmK/lkKbkuLogMCDlsIblhbbliIbkuLrkuKTnu4RcbiAgICAgICAgICAgIGlmIGggJiBuID09IDA6XG4gICAgICAgICAgICAgICAgYSBePSBuXG4gICAgICAgICAgICBlbHNlOlxuICAgICAgICAgICAgICAgIGIgXj0gblxuXG4gICAgICAgIHJldHVybiBbYSwgYl1cblxuIgogICAgfV0KICB9XQp9LCB7CiAgImlkIjogIjA4IiwKICAibmFtZSI6ICLnrKzlhavnq6AiLAogICJsaXN0IjogW3sKICAgICJ0aXRsZSI6ICLku6PnoIE4LjEuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgTWluU3RhY2sge1xuICAgIHN0YWNrPGludD4geF9zdGFjaztcbiAgICBzdGFjazxpbnQ+IG1pbl9zdGFjaztcbnB1YmxpYzpcbiAgICBNaW5TdGFjaygpIHtcbiAgICAgICAgbWluX3N0YWNrLnB1c2goSU5UX01BWCk7XG4gICAgfVxuICAgIFxuICAgIHZvaWQgcHVzaChpbnQgeCkge1xuICAgICAgICB4X3N0YWNrLnB1c2goeCk7XG4gICAgICAgIG1pbl9zdGFjay5wdXNoKG1pbihtaW5fc3RhY2sudG9wKCksIHgpKTtcbiAgICB9XG4gICAgXG4gICAgdm9pZCBwb3AoKSB7XG4gICAgICAgIHhfc3RhY2sucG9wKCk7XG4gICAgICAgIG1pbl9zdGFjay5wb3AoKTtcbiAgICB9XG4gICAgXG4gICAgaW50IHRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHhfc3RhY2sudG9wKCk7XG4gICAgfVxuICAgIFxuICAgIGludCBnZXRNaW4oKSB7XG4gICAgICAgIHJldHVybiBtaW5fc3RhY2sudG9wKCk7XG4gICAgfVxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJpbXBvcnQgamF2YS51dGlsLlN0YWNrO1xuXG5wdWJsaWMgY2xhc3MgTWluU3RhY2sge1xuXG4gICAgLy8g5pWw5o2u5qCIXG4gICAgcHJpdmF0ZSBTdGFjazxJbnRlZ2VyPiBkYXRhO1xuICAgIC8vIOi+heWKqeagiFxuICAgIHByaXZhdGUgU3RhY2s8SW50ZWdlcj4gaGVscGVyO1xuXG4gICAgLyoqXG4gICAgICogaW5pdGlhbGl6ZSB5b3VyIGRhdGEgc3RydWN0dXJlIGhlcmUuXG4gICAgICovXG4gICAgcHVibGljIE1pblN0YWNrKCkge1xuICAgICAgICBkYXRhID0gbmV3IFN0YWNrPD4oKTtcbiAgICAgICAgaGVscGVyID0gbmV3IFN0YWNrPD4oKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdm9pZCBwdXNoKGludCB4KSB7XG4gICAgICAgIC8vIOaVsOaNruagiOWSjOi+heWKqeagiOS4gOWumuS8muWinuWKoOWFg+e0oFxuICAgICAgICBkYXRhLmFkZCh4KTtcbiAgICAgICAgaWYgKGhlbHBlci5pc0VtcHR5KCkgfHwgaGVscGVyLnBlZWsoKSA+PSB4KSB7XG4gICAgICAgICAgICBoZWxwZXIuYWRkKHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGVscGVyLmFkZChoZWxwZXIucGVlaygpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyB2b2lkIHBvcCgpIHtcbiAgICAgICAgLy8g5Lik5Liq5qCI6YO95b6XIHBvcFxuICAgICAgICBpZiAoIWRhdGEuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBoZWxwZXIucG9wKCk7XG4gICAgICAgICAgICBkYXRhLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGludCB0b3AoKSB7XG4gICAgICAgIGlmKCFkYXRhLmlzRW1wdHkoKSl7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5wZWVrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFeGNlcHRpb24oXCLmoIjkuK3lhYPntKDkuLrnqbrvvIzmraTmk43kvZzpnZ7ms5VcIik7XG4gICAgfVxuXG4gICAgcHVibGljIGludCBnZXRNaW4oKSB7XG4gICAgICAgIGlmKCFoZWxwZXIuaXNFbXB0eSgpKXtcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXIucGVlaygpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXhjZXB0aW9uKFwi5qCI5Lit5YWD57Sg5Li656m677yM5q2k5pON5L2c6Z2e5rOVXCIpO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgTWluU3RhY2s6XG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxuICAgICAgICBcIlwiXCJcbiAgICAgICAgaW5pdGlhbGl6ZSB5b3VyIGRhdGEgc3RydWN0dXJlIGhlcmUuXG4gICAgICAgIFwiXCJcIlxuICAgICAgICBzZWxmLnN0YWNrID0gW11cbiAgICAgICAgc2VsZi5oZWxwZXIgPSBbXVxuXG4gICAgZGVmIHB1c2goc2VsZiwgeDogaW50KSAtPiBOb25lOlxuICAgICAgICBzZWxmLnN0YWNrLmFwcGVuZCh4KVxuICAgICAgICBpZiBub3Qgc2VsZi5oZWxwZXIgb3IgeCA8PSBzZWxmLmhlbHBlclstMV06XG4gICAgICAgICAgICBzZWxmLmhlbHBlci5hcHBlbmQoeClcbiAgICAgICAgZWxzZTpcbiAgICAgICAgICAgIHNlbGYuaGVscGVyLmFwcGVuZChzZWxmLmhlbHBlclstMV0pXG5cbiAgICBkZWYgcG9wKHNlbGYpIC0+IE5vbmU6XG4gICAgICAgIHNlbGYuaGVscGVyLnBvcCgpXG4gICAgICAgIHJldHVybiBzZWxmLnN0YWNrLnBvcCgpXG5cbiAgICBkZWYgdG9wKHNlbGYpIC0+IGludDpcbiAgICAgICAgcmV0dXJuIHNlbGYuc3RhY2tbLTFdXG5cbiAgICBkZWYgZ2V0TWluKHNlbGYpIC0+IGludDpcbiAgICAgICAgcmV0dXJuIHNlbGYuaGVscGVyWy0xXVxuXG5cbiMgWW91ciBNaW5TdGFjayBvYmplY3Qgd2lsbCBiZSBpbnN0YW50aWF0ZWQgYW5kIGNhbGxlZCBhcyBzdWNoOlxuIyBvYmogPSBNaW5TdGFjaygpXG4jIG9iai5wdXNoKHgpXG4jIG9iai5wb3AoKVxuIyBwYXJhbV8zID0gb2JqLnRvcCgpXG4jIHBhcmFtXzQgPSBvYmouZ2V0TWluKClcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBOC4xLjIiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIE1pblN0YWNrIHtcbiAgICBzdGFjazxpbnQ+IHhfc3RhY2s7XG4gICAgc3RhY2s8aW50PiBtaW5fc3RhY2s7XG5wdWJsaWM6XG4gICAgTWluU3RhY2soKSB7XG4gICAgICAgIG1pbl9zdGFjay5wdXNoKElOVF9NQVgpO1xuICAgIH1cbiAgICBcbiAgICB2b2lkIHB1c2goaW50IHgpIHtcbiAgICAgICAgeF9zdGFjay5wdXNoKHgpO1xuICAgICAgICBtaW5fc3RhY2sucHVzaChtaW4obWluX3N0YWNrLnRvcCgpLCB4KSk7XG4gICAgfVxuICAgIFxuICAgIHZvaWQgcG9wKCkge1xuICAgICAgICB4X3N0YWNrLnBvcCgpO1xuICAgICAgICBtaW5fc3RhY2sucG9wKCk7XG4gICAgfVxuICAgIFxuICAgIGludCB0b3AoKSB7XG4gICAgICAgIHJldHVybiB4X3N0YWNrLnRvcCgpO1xuICAgIH1cbiAgICBcbiAgICBpbnQgZ2V0TWluKCkge1xuICAgICAgICByZXR1cm4gbWluX3N0YWNrLnRvcCgpO1xuICAgIH1cbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiaW1wb3J0IGphdmEudXRpbC5TdGFjaztcblxucHVibGljIGNsYXNzIE1pblN0YWNrIHtcblxuICAgIC8vIOaVsOaNruagiFxuICAgIHByaXZhdGUgU3RhY2s8SW50ZWdlcj4gZGF0YTtcbiAgICAvLyDovoXliqnmoIhcbiAgICBwcml2YXRlIFN0YWNrPEludGVnZXI+IGhlbHBlcjtcblxuICAgIC8qKlxuICAgICAqIGluaXRpYWxpemUgeW91ciBkYXRhIHN0cnVjdHVyZSBoZXJlLlxuICAgICAqL1xuICAgIHB1YmxpYyBNaW5TdGFjaygpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBTdGFjazw+KCk7XG4gICAgICAgIGhlbHBlciA9IG5ldyBTdGFjazw+KCk7XG4gICAgfVxuXG4gICAgcHVibGljIHZvaWQgcHVzaChpbnQgeCkge1xuICAgICAgICAvLyDmlbDmja7moIjlkozovoXliqnmoIjkuIDlrprkvJrlop7liqDlhYPntKBcbiAgICAgICAgZGF0YS5hZGQoeCk7XG4gICAgICAgIGlmIChoZWxwZXIuaXNFbXB0eSgpIHx8IGhlbHBlci5wZWVrKCkgPj0geCkge1xuICAgICAgICAgICAgaGVscGVyLmFkZCh4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlbHBlci5hZGQoaGVscGVyLnBlZWsoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgdm9pZCBwb3AoKSB7XG4gICAgICAgIC8vIOS4pOS4quagiOmDveW+lyBwb3BcbiAgICAgICAgaWYgKCFkYXRhLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgaGVscGVyLnBvcCgpO1xuICAgICAgICAgICAgZGF0YS5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBpbnQgdG9wKCkge1xuICAgICAgICBpZighZGF0YS5pc0VtcHR5KCkpe1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEucGVlaygpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXhjZXB0aW9uKFwi5qCI5Lit5YWD57Sg5Li656m677yM5q2k5pON5L2c6Z2e5rOVXCIpO1xuICAgIH1cblxuICAgIHB1YmxpYyBpbnQgZ2V0TWluKCkge1xuICAgICAgICBpZighaGVscGVyLmlzRW1wdHkoKSl7XG4gICAgICAgICAgICByZXR1cm4gaGVscGVyLnBlZWsoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUV4Y2VwdGlvbihcIuagiOS4reWFg+e0oOS4uuepuu+8jOatpOaTjeS9nOmdnuazlVwiKTtcbiAgICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIE1pblN0YWNrOlxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcbiAgICAgICAgXCJcIlwiXG4gICAgICAgIGluaXRpYWxpemUgeW91ciBkYXRhIHN0cnVjdHVyZSBoZXJlLlxuICAgICAgICBcIlwiXCJcbiAgICAgICAgc2VsZi5zdGFjayA9IFtdXG4gICAgICAgIHNlbGYuaGVscGVyID0gW11cblxuICAgIGRlZiBwdXNoKHNlbGYsIHg6IGludCkgLT4gTm9uZTpcbiAgICAgICAgc2VsZi5zdGFjay5hcHBlbmQoeClcbiAgICAgICAgaWYgbm90IHNlbGYuaGVscGVyIG9yIHggPCBzZWxmLmhlbHBlclstMV1bMF06XG4gICAgICAgICAgICBzZWxmLmhlbHBlci5hcHBlbmQoW3gsIDFdKVxuICAgICAgICBlbHNlOlxuICAgICAgICAgICAgc2VsZi5oZWxwZXJbLTFdID0gW3NlbGYuaGVscGVyWy0xXVswXSwgc2VsZi5oZWxwZXJbLTFdWzFdICsgMV1cblxuICAgIGRlZiBwb3Aoc2VsZikgLT4gTm9uZTpcbiAgICAgICAgaWYgc2VsZi5oZWxwZXJbLTFdWzFdID4gMTpcbiAgICAgICAgICAgIHNlbGYuaGVscGVyWy0xXSA9IFtzZWxmLmhlbHBlclstMV1bMF0sIHNlbGYuaGVscGVyWy0xXVsxXSAtIDFdXG4gICAgICAgIGVsc2U6XG4gICAgICAgICAgICBzZWxmLmhlbHBlci5wb3AoKVxuICAgICAgICByZXR1cm4gc2VsZi5zdGFjay5wb3AoKVxuXG4gICAgZGVmIHRvcChzZWxmKSAtPiBpbnQ6XG4gICAgICAgIHJldHVybiBzZWxmLnN0YWNrWy0xXVxuXG4gICAgZGVmIGdldE1pbihzZWxmKSAtPiBpbnQ6XG4gICAgICAgIHJldHVybiBzZWxmLmhlbHBlclstMV1bMF1cblxuXG4jIFlvdXIgTWluU3RhY2sgb2JqZWN0IHdpbGwgYmUgaW5zdGFudGlhdGVkIGFuZCBjYWxsZWQgYXMgc3VjaDpcbm9iaiA9IE1pblN0YWNrKClcbm9iai5wdXNoKDEpXG5vYmoucG9wKClcbnBhcmFtXzMgPSBvYmoudG9wKClcbnBhcmFtXzQgPSBvYmouZ2V0TWluKClcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBOC4xLjMiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIE1pblN0YWNrIHtcbiAgICBzdGFjazxpbnQ+IHhfc3RhY2s7XG4gICAgc3RhY2s8aW50PiBtaW5fc3RhY2s7XG5wdWJsaWM6XG4gICAgTWluU3RhY2soKSB7XG4gICAgICAgIG1pbl9zdGFjay5wdXNoKElOVF9NQVgpO1xuICAgIH1cbiAgICBcbiAgICB2b2lkIHB1c2goaW50IHgpIHtcbiAgICAgICAgeF9zdGFjay5wdXNoKHgpO1xuICAgICAgICBtaW5fc3RhY2sucHVzaChtaW4obWluX3N0YWNrLnRvcCgpLCB4KSk7XG4gICAgfVxuICAgIFxuICAgIHZvaWQgcG9wKCkge1xuICAgICAgICB4X3N0YWNrLnBvcCgpO1xuICAgICAgICBtaW5fc3RhY2sucG9wKCk7XG4gICAgfVxuICAgIFxuICAgIGludCB0b3AoKSB7XG4gICAgICAgIHJldHVybiB4X3N0YWNrLnRvcCgpO1xuICAgIH1cbiAgICBcbiAgICBpbnQgZ2V0TWluKCkge1xuICAgICAgICByZXR1cm4gbWluX3N0YWNrLnRvcCgpO1xuICAgIH1cbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiaW1wb3J0IGphdmEudXRpbC5TdGFjaztcblxucHVibGljIGNsYXNzIE1pblN0YWNrIHtcblxuICAgIC8vIOaVsOaNruagiFxuICAgIHByaXZhdGUgU3RhY2s8SW50ZWdlcj4gZGF0YTtcbiAgICAvLyDovoXliqnmoIhcbiAgICBwcml2YXRlIFN0YWNrPEludGVnZXI+IGhlbHBlcjtcblxuICAgIC8qKlxuICAgICAqIGluaXRpYWxpemUgeW91ciBkYXRhIHN0cnVjdHVyZSBoZXJlLlxuICAgICAqL1xuICAgIHB1YmxpYyBNaW5TdGFjaygpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBTdGFjazw+KCk7XG4gICAgICAgIGhlbHBlciA9IG5ldyBTdGFjazw+KCk7XG4gICAgfVxuXG4gICAgcHVibGljIHZvaWQgcHVzaChpbnQgeCkge1xuICAgICAgICBkYXRhLmFkZCh4KTtcbiAgICAgICAgaWYgKGhlbHBlci5pc0VtcHR5KCkgfHwgaGVscGVyLnBlZWsoKSA+PSB4KSB7XG4gICAgICAgICAgICBoZWxwZXIuYWRkKHgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHZvaWQgcG9wKCkge1xuICAgICAgICBpZiAoIWRhdGEuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBpbnQgdG9wID0gZGF0YS5wb3AoKTtcbiAgICAgICAgICAgIGlmKHRvcCA9PSBoZWxwZXIucGVlaygpKXtcbiAgICAgICAgICAgICAgICBoZWxwZXIucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgaW50IHRvcCgpIHtcbiAgICAgICAgaWYoIWRhdGEuaXNFbXB0eSgpKXtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLnBlZWsoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUV4Y2VwdGlvbihcIuagiOS4reWFg+e0oOS4uuepuu+8jOatpOaTjeS9nOmdnuazlVwiKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaW50IGdldE1pbigpIHtcbiAgICAgICAgaWYoIWhlbHBlci5pc0VtcHR5KCkpe1xuICAgICAgICAgICAgcmV0dXJuIGhlbHBlci5wZWVrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFeGNlcHRpb24oXCLmoIjkuK3lhYPntKDkuLrnqbrvvIzmraTmk43kvZzpnZ7ms5VcIik7XG4gICAgfVxuXG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIE1pblN0YWNrOlxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcbiAgICAgICAgXCJcIlwiXG4gICAgICAgIGluaXRpYWxpemUgeW91ciBkYXRhIHN0cnVjdHVyZSBoZXJlLlxuICAgICAgICBcIlwiXCJcbiAgICAgICAgc2VsZi5zdGFjayA9IFtdXG4gICAgICAgIHNlbGYuaGVscGVyID0gW11cblxuICAgIGRlZiBwdXNoKHNlbGYsIHg6IGludCkgLT4gTm9uZTpcbiAgICAgICAgc2VsZi5zdGFjay5hcHBlbmQoeClcbiAgICAgICAgaWYgbm90IHNlbGYuaGVscGVyIG9yIHggPD0gc2VsZi5oZWxwZXJbLTFdOlxuICAgICAgICAgICAgc2VsZi5oZWxwZXIuYXBwZW5kKHgpXG5cbiAgICBkZWYgcG9wKHNlbGYpIC0+IE5vbmU6XG4gICAgICAgIHRvcCA9IHNlbGYuc3RhY2sucG9wKClcbiAgICAgICAgaWYgc2VsZi5oZWxwZXIgYW5kIHRvcCA9PSBzZWxmLmhlbHBlclstMV06XG4gICAgICAgICAgICBzZWxmLmhlbHBlci5wb3AoKVxuICAgICAgICByZXR1cm4gdG9wXG5cbiAgICBkZWYgdG9wKHNlbGYpIC0+IGludDpcbiAgICAgICAgcmV0dXJuIHNlbGYuc3RhY2tbLTFdXG5cbiAgICBkZWYgZ2V0TWluKHNlbGYpIC0+IGludDpcbiAgICAgICAgcmV0dXJuIHNlbGYuaGVscGVyWy0xXVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIE4LjEuNCIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgTWluU3RhY2sge1xuICAgIHR5cGVkZWYgbG9uZyBsb25nIGxsO1xucHVibGljOlxuICAgIGxsIHRvcEVsZW07IFxuICAgIC8qKiBpbml0aWFsaXplIHlvdXIgZGF0YSBzdHJ1Y3R1cmUgaGVyZS4gKi9cbiAgICBNaW5TdGFjaygpIHtcbiAgICB9XG5cbiAgICB2b2lkIHB1c2goaW50IHgpIHtcbiAgICAgICAgaWYocy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBtaW5uID0geDtcbiAgICAgICAgICAgIHMucHVzaCh4LW1pbm4pOyAgLy8o5b2T5YmN5YC8eC3mnIDlsI/lgLxtaW5uKei/m+agiFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcy5wdXNoKHgtbWlubik7XG4gICAgICAgICAgICBtaW5uID0geCA8IG1pbm4gPyB4IDogbWlubjsgIC8v5YC85b6X5rOo5oSP55qE5piv5b2T5qCI6aG25YWD57SgPDAs5YiZ6K+05piO5qCI6aG25YWD57Sg5bCx5pivbWlublxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHZvaWQgcG9wKCkge1xuICAgICAgICBpZighcy5lbXB0eSgpKSB7XG4gICAgICAgICAgICB0b3BFbGVtID0gcy50b3AoKTtcbiAgICAgICAgICAgIHMucG9wKCk7XG4gICAgICAgICAgICAvL+WOn+adpeeahOWAvHgt5pyA5bCP5YC8bWlubiA9IHRvcEVsZW1cbiAgICAgICAgICAgIC8vdG9wRWxlbTwwLOivtOaYjuWOn+adpeWAvHjmm7TlsI8o5Y6f5p2l55qE5YC85bCx5piv546w5Zyo55qEbWlubinvvIzliJnnjrDlnKjnmoRtaW5u5bqU6K+l6KKr5pu05pawbWlubi10b3BFbGVtXG4gICAgICAgICAgICBpZih0b3BFbGVtIDwgMCkgbWlubiAtPSB0b3BFbGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgaW50IHRvcCgpIHtcbiAgICAgICAgaWYoIXMuZW1wdHkoKSkge1xuICAgICAgICAgICAgdG9wRWxlbSA9IHMudG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodG9wRWxlbSA8IDApIHJldHVybiBtaW5uOyAvL+ivtOaYjnRvcEVsZW0gPDAsIOivtOaYjiB4PG1pbm4sIG1pbm7lt7Lnu4/ooqvmm7TmlrDkuLrlvZPmoIjpobZ477yM5qCI6aG25YWD57Sg5bCx5pivbWlublxuICAgICAgICByZXR1cm4gdG9wRWxlbSttaW5uO1xuICAgIH1cbiAgICBcbiAgICBpbnQgZ2V0TWluKCkge1xuICAgICAgICByZXR1cm4gbWlubjtcbiAgICB9XG4gICAgcHJpdmF0ZTpcbiAgICAgICAgbGwgbWlubjtcbiAgICAgICAgc3RhY2s8bGw+cztcbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicHVibGljIGNsYXNzIE1pblN0YWNrIHtcbiAgbG9uZyBtaW47XG4gIFN0YWNrPExvbmc+IHN0YWNrO1xuXG4gIHB1YmxpYyBNaW5TdGFjaygpe1xuICAgICAgICBzdGFjaz1uZXcgU3RhY2s8PigpO1xuICAgIH1cblxuICBwdWJsaWMgdm9pZCBwdXNoKGludCB4KSB7XG4gICAgaWYgKHN0YWNrLmlzRW1wdHkoKSkge1xuICAgICAgbWluID0geDtcbiAgICAgIHN0YWNrLnB1c2goeCAtIG1pbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YWNrLnB1c2goeCAtIG1pbik7XG4gICAgICBpZiAoeCA8IG1pbil7XG4gICAgICAgIG1pbiA9IHg7IC8vIOabtOaWsOacgOWwj+WAvFxuICAgICAgfVxuICAgICAgICBcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdm9pZCBwb3AoKSB7XG4gICAgaWYgKHN0YWNrLmlzRW1wdHkoKSlcbiAgICAgIHJldHVybjtcblxuICAgIGxvbmcgcG9wID0gc3RhY2sucG9wKCk7XG4gICAgXG4gICAgLy/lvLnlh7rnmoTmmK/otJ/lgLzvvIzopoHmm7TmlrAgbWluXG4gICAgaWYgKHBvcCA8IDApIHtcbiAgICAgIG1pbiA9IG1pbiAtIHBvcDtcbiAgICB9XG5cbiAgfVxuXG4gIHB1YmxpYyBpbnQgdG9wKCkge1xuICAgIGxvbmcgdG9wID0gc3RhY2sucGVlaygpO1xuICAgIC8v6LSf5pWw55qE6K+d77yM5Ye65qCI55qE5YC85L+d5a2Y5ZyoIG1pbiDkuK1cbiAgICBpZiAodG9wIDwgMCkge1xuICAgICAgcmV0dXJuIChpbnQpIChtaW4pO1xuICAgICAgICAvL+WHuuagiOWFg+e0oOWKoOS4iuacgOWwj+WAvOWNs+WPr1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKGludCkgKHRvcCArIG1pbik7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGludCBnZXRNaW4oKSB7XG4gICAgcmV0dXJuIChpbnQpIG1pbjtcbiAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBNaW5TdGFjazpcbiAgICBkZWYgX19pbml0X18oc2VsZik6XG4gICAgICAgIFwiXCJcIlxuICAgICAgICBpbml0aWFsaXplIHlvdXIgZGF0YSBzdHJ1Y3R1cmUgaGVyZS5cbiAgICAgICAgXCJcIlwiXG4gICAgICAgIHNlbGYuc3RhY2sgPSBbXVxuICAgICAgICBzZWxmLm1pbiA9IGZsb2F0KCdpbmYnKVxuXG4gICAgZGVmIHB1c2goc2VsZiwgeDogaW50KSAtPiBOb25lOlxuICAgICAgICBpZiBub3Qgc2VsZi5zdGFjazpcbiAgICAgICAgICAgIHNlbGYubWluID0geFxuICAgICAgICAgICAgc2VsZi5zdGFjay5hcHBlbmQoMClcbiAgICAgICAgZWxzZTpcbiAgICAgICAgICAgIHNlbGYuc3RhY2suYXBwZW5kKHggLSBzZWxmLm1pbilcbiAgICAgICAgICAgIGlmIHggPCBzZWxmLm1pbjogc2VsZi5taW4gPSB4XG5cbiAgICBkZWYgcG9wKHNlbGYpIC0+IE5vbmU6XG4gICAgICAgIGlmIG5vdCBzZWxmLnN0YWNrOiByZXR1cm5cblxuICAgICAgICB0b3AgPSBzZWxmLnN0YWNrLnBvcCgpXG4gICAgICAgIGlmIHRvcCA8IDA6XG4gICAgICAgICAgICBzZWxmLm1pbiA9IHNlbGYubWluIC0gdG9wXG5cbiAgICBkZWYgdG9wKHNlbGYpIC0+IGludDpcbiAgICAgICAgdG9wID0gc2VsZi5zdGFja1stMV1cbiAgICAgICAgaWYgdG9wIDwgMDogcmV0dXJuIHNlbGYubWluXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdG9wICsgc2VsZi5taW5cblxuICAgIGRlZiBnZXRNaW4oc2VsZikgLT4gaW50OlxuICAgICAgICByZXR1cm4gc2VsZi5taW5cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBOC4yLjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFRyaWUge1xucHJpdmF0ZTpcbiAgICBib29sIGlzRW5kO1xuICAgIFRyaWUqIG5leHRbMjZdO1xucHVibGljOlxuICAgIFRyaWUoKSB7XG4gICAgICAgIGlzRW5kID0gZmFsc2U7XG4gICAgICAgIG1lbXNldChuZXh0LCAwLCBzaXplb2YobmV4dCkpO1xuICAgIH1cbiAgICBcbiAgICB2b2lkIGluc2VydChzdHJpbmcgd29yZCkge1xuICAgICAgICBUcmllKiBub2RlID0gdGhpcztcbiAgICAgICAgZm9yIChjaGFyIGMgOiB3b3JkKSB7XG4gICAgICAgICAgICBpZiAobm9kZS0+bmV4dFtjLSdhJ10gPT0gTlVMTCkge1xuICAgICAgICAgICAgICAgIG5vZGUtPm5leHRbYy0nYSddID0gbmV3IFRyaWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLT5uZXh0W2MtJ2EnXTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLT5pc0VuZCA9IHRydWU7XG4gICAgfVxuICAgIFxuICAgIGJvb2wgc2VhcmNoKHN0cmluZyB3b3JkKSB7XG4gICAgICAgIFRyaWUqIG5vZGUgPSB0aGlzO1xuICAgICAgICBmb3IgKGNoYXIgYyA6IHdvcmQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLT5uZXh0W2MgLSAnYSddO1xuICAgICAgICAgICAgaWYgKG5vZGUgPT0gTlVMTCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS0+aXNFbmQ7XG4gICAgfVxuICAgIFxuICAgIGJvb2wgc3RhcnRzV2l0aChzdHJpbmcgcHJlZml4KSB7XG4gICAgICAgIFRyaWUqIG5vZGUgPSB0aGlzO1xuICAgICAgICBmb3IgKGNoYXIgYyA6IHByZWZpeCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUtPm5leHRbYy0nYSddO1xuICAgICAgICAgICAgaWYgKG5vZGUgPT0gTlVMTCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFRyaWVOb2RlIHtcblxuICAvLyBSIGxpbmtzIHRvIG5vZGUgY2hpbGRyZW5cbiAgcHJpdmF0ZSBUcmllTm9kZVtdIGxpbmtzO1xuXG4gIHByaXZhdGUgZmluYWwgaW50IFIgPSAyNjtcblxuICBwcml2YXRlIGJvb2xlYW4gaXNFbmQ7XG5cbiAgcHVibGljIFRyaWVOb2RlKCkge1xuICAgICAgbGlua3MgPSBuZXcgVHJpZU5vZGVbUl07XG4gIH1cblxuICBwdWJsaWMgYm9vbGVhbiBjb250YWluc0tleShjaGFyIGNoKSB7XG4gICAgICByZXR1cm4gbGlua3NbY2ggLSdhJ10gIT0gbnVsbDtcbiAgfVxuICBwdWJsaWMgVHJpZU5vZGUgZ2V0KGNoYXIgY2gpIHtcbiAgICAgIHJldHVybiBsaW5rc1tjaCAtJ2EnXTtcbiAgfVxuICBwdWJsaWMgdm9pZCBwdXQoY2hhciBjaCwgVHJpZU5vZGUgbm9kZSkge1xuICAgICAgbGlua3NbY2ggLSdhJ10gPSBub2RlO1xuICB9XG4gIHB1YmxpYyB2b2lkIHNldEVuZCgpIHtcbiAgICAgIGlzRW5kID0gdHJ1ZTtcbiAgfVxuICBwdWJsaWMgYm9vbGVhbiBpc0VuZCgpIHtcbiAgICAgIHJldHVybiBpc0VuZDtcbiAgfVxufVxuXG5jbGFzcyBUcmllIHtcbiAgcHJpdmF0ZSBUcmllTm9kZSByb290O1xuXG4gIHB1YmxpYyBUcmllKCkge1xuICAgICAgcm9vdCA9IG5ldyBUcmllTm9kZSgpO1xuICB9XG5cbiAgcHVibGljIHZvaWQgaW5zZXJ0KFN0cmluZyB3b3JkKSB7XG4gICAgICBUcmllTm9kZSBub2RlID0gcm9vdDtcbiAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgd29yZC5sZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgICAgY2hhciBjdXJyZW50Q2hhciA9IHdvcmQuY2hhckF0KGkpO1xuICAgICAgICAgIGlmICghbm9kZS5jb250YWluc0tleShjdXJyZW50Q2hhcikpIHtcbiAgICAgICAgICAgICAgbm9kZS5wdXQoY3VycmVudENoYXIsIG5ldyBUcmllTm9kZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZSA9IG5vZGUuZ2V0KGN1cnJlbnRDaGFyKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2V0RW5kKCk7XG4gIH1cblxuICBwcml2YXRlIFRyaWVOb2RlIHNlYXJjaFByZWZpeChTdHJpbmcgd29yZCkge1xuICAgIFRyaWVOb2RlIG5vZGUgPSByb290O1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgd29yZC5sZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgY2hhciBjdXJMZXR0ZXIgPSB3b3JkLmNoYXJBdChpKTtcbiAgICAgICBpZiAobm9kZS5jb250YWluc0tleShjdXJMZXR0ZXIpKSB7XG4gICAgICAgICAgIG5vZGUgPSBub2RlLmdldChjdXJMZXR0ZXIpO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBwdWJsaWMgYm9vbGVhbiBzZWFyY2goU3RyaW5nIHdvcmQpIHtcbiAgICBUcmllTm9kZSBub2RlID0gc2VhcmNoUHJlZml4KHdvcmQpO1xuICAgIHJldHVybiBub2RlICE9IG51bGwgJiYgbm9kZS5pc0VuZCgpO1xuICB9XG5cbiAgcHVibGljIGJvb2xlYW4gc3RhcnRzV2l0aChTdHJpbmcgcHJlZml4KSB7XG4gICAgVHJpZU5vZGUgbm9kZSA9IHNlYXJjaFByZWZpeChwcmVmaXgpO1xuICAgIHJldHVybiBub2RlICE9IG51bGw7XG4gIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgVHJpZU5vZGU6XG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxuICAgICAgICBzZWxmLmlzRW5kID0gRmFsc2VcbiAgICAgICAgc2VsZi5jaGlsZHJlbiA9IHt9XG5cblxuY2xhc3MgVHJpZTpcbiAgICBkZWYgX19pbml0X18oc2VsZik6XG4gICAgICAgIHNlbGYucm9vdCA9IFRyaWVOb2RlKClcblxuICAgIGRlZiBpbnNlcnQoc2VsZiwgd29yZDogc3RyKSAtPiBOb25lOlxuICAgICAgICBjdXIgPSBzZWxmLnJvb3RcbiAgICAgICAgZm9yIGNoIGluIHdvcmQ6XG4gICAgICAgICAgICBpZiBjaCBub3QgaW4gY3VyLmNoaWxkcmVuOlxuICAgICAgICAgICAgICAgIG5vZGUgPSBUcmllTm9kZSgpXG4gICAgICAgICAgICAgICAgY3VyLmNoaWxkcmVuW2NoXSA9IG5vZGVcbiAgICAgICAgICAgIGN1ciA9IGN1ci5jaGlsZHJlbltjaF1cblxuICAgICAgICBjdXIuaXNFbmQgPSBUcnVlXG5cbiAgICBkZWYgc2VhcmNoKHNlbGYsIHdvcmQ6IHN0cikgLT4gYm9vbDpcbiAgICAgICAgY3VyID0gc2VsZi5yb290XG4gICAgICAgIGZvciBjaCBpbiB3b3JkOlxuICAgICAgICAgICAgaWYgY2ggbm90IGluIGN1ci5jaGlsZHJlbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gRmFsc2VcbiAgICAgICAgICAgIGN1ciA9IGN1ci5jaGlsZHJlbltjaF1cblxuICAgICAgICBpZiBjdXIuaXNFbmQ6XG4gICAgICAgICAgICByZXR1cm4gVHJ1ZVxuXG4gICAgICAgIHJldHVybiBGYWxzZVxuXG4gICAgZGVmIHN0YXJ0c1dpdGgoc2VsZiwgcHJlZml4OiBzdHIpIC0+IGJvb2w6XG4gICAgICAgIGN1ciA9IHNlbGYucm9vdFxuICAgICAgICBmb3IgY2ggaW4gcHJlZml4OlxuICAgICAgICAgICAgaWYgY2ggbm90IGluIGN1ci5jaGlsZHJlbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gRmFsc2VcbiAgICAgICAgICAgIGN1ciA9IGN1ci5jaGlsZHJlbltjaF1cblxuICAgICAgICByZXR1cm4gVHJ1ZVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIE4LjMuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAic3RydWN0IERMaW5rZWROb2RlIHtcbiAgICBpbnQga2V5LCB2YWx1ZTtcbiAgICBETGlua2VkTm9kZSogcHJldjtcbiAgICBETGlua2VkTm9kZSogbmV4dDtcbiAgICBETGlua2VkTm9kZSgpOiBrZXkoMCksIHZhbHVlKDApLCBwcmV2KG51bGxwdHIpLCBuZXh0KG51bGxwdHIpIHt9XG4gICAgRExpbmtlZE5vZGUoaW50IF9rZXksIGludCBfdmFsdWUpOiBrZXkoX2tleSksIHZhbHVlKF92YWx1ZSksIHByZXYobnVsbHB0ciksIG5leHQobnVsbHB0cikge31cbn07XG5cbmNsYXNzIExSVUNhY2hlIHtcbnByaXZhdGU6XG4gICAgdW5vcmRlcmVkX21hcDxpbnQsIERMaW5rZWROb2RlKj4gY2FjaGU7XG4gICAgRExpbmtlZE5vZGUqIGhlYWQ7XG4gICAgRExpbmtlZE5vZGUqIHRhaWw7XG4gICAgaW50IHNpemU7XG4gICAgaW50IGNhcGFjaXR5O1xuXG5wdWJsaWM6XG4gICAgTFJVQ2FjaGUoaW50IF9jYXBhY2l0eSk6IGNhcGFjaXR5KF9jYXBhY2l0eSksIHNpemUoMCkge1xuICAgICAgICAvLyDkvb/nlKjkvKrlpLTpg6jlkozkvKrlsL7pg6joioLngrlcbiAgICAgICAgaGVhZCA9IG5ldyBETGlua2VkTm9kZSgpO1xuICAgICAgICB0YWlsID0gbmV3IERMaW5rZWROb2RlKCk7XG4gICAgICAgIGhlYWQtPm5leHQgPSB0YWlsO1xuICAgICAgICB0YWlsLT5wcmV2ID0gaGVhZDtcbiAgICB9XG4gICAgXG4gICAgaW50IGdldChpbnQga2V5KSB7XG4gICAgICAgIGlmICghY2FjaGUuY291bnQoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIOWmguaenCBrZXkg5a2Y5Zyo77yM5YWI6YCa6L+H5ZOI5biM6KGo5a6a5L2N77yM5YaN56e75Yiw5aS06YOoXG4gICAgICAgIERMaW5rZWROb2RlKiBub2RlID0gY2FjaGVba2V5XTtcbiAgICAgICAgbW92ZVRvSGVhZChub2RlKTtcbiAgICAgICAgcmV0dXJuIG5vZGUtPnZhbHVlO1xuICAgIH1cbiAgICBcbiAgICB2b2lkIHB1dChpbnQga2V5LCBpbnQgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFjYWNoZS5jb3VudChrZXkpKSB7XG4gICAgICAgICAgICAvLyDlpoLmnpwga2V5IOS4jeWtmOWcqO+8jOWIm+W7uuS4gOS4quaWsOeahOiKgueCuVxuICAgICAgICAgICAgRExpbmtlZE5vZGUqIG5vZGUgPSBuZXcgRExpbmtlZE5vZGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAvLyDmt7vliqDov5vlk4jluIzooahcbiAgICAgICAgICAgIGNhY2hlW2tleV0gPSBub2RlO1xuICAgICAgICAgICAgLy8g5re75Yqg6Iez5Y+M5ZCR6ZO+6KGo55qE5aS06YOoXG4gICAgICAgICAgICBhZGRUb0hlYWQobm9kZSk7XG4gICAgICAgICAgICArK3NpemU7XG4gICAgICAgICAgICBpZiAoc2l6ZSA+IGNhcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c6LaF5Ye65a656YeP77yM5Yig6Zmk5Y+M5ZCR6ZO+6KGo55qE5bC+6YOo6IqC54K5XG4gICAgICAgICAgICAgICAgRExpbmtlZE5vZGUqIHJlbW92ZWQgPSByZW1vdmVUYWlsKCk7XG4gICAgICAgICAgICAgICAgLy8g5Yig6Zmk5ZOI5biM6KGo5Lit5a+55bqU55qE6aG5XG4gICAgICAgICAgICAgICAgY2FjaGUuZXJhc2UocmVtb3ZlZC0+a2V5KTtcbiAgICAgICAgICAgICAgICAvLyDpmLLmraLlhoXlrZjms4TmvI9cbiAgICAgICAgICAgICAgICBkZWxldGUgcmVtb3ZlZDtcbiAgICAgICAgICAgICAgICAtLXNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyDlpoLmnpwga2V5IOWtmOWcqO+8jOWFiOmAmui/h+WTiOW4jOihqOWumuS9je+8jOWGjeS/ruaUuSB2YWx1Ze+8jOW5tuenu+WIsOWktOmDqFxuICAgICAgICAgICAgRExpbmtlZE5vZGUqIG5vZGUgPSBjYWNoZVtrZXldO1xuICAgICAgICAgICAgbm9kZS0+dmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIG1vdmVUb0hlYWQobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2b2lkIGFkZFRvSGVhZChETGlua2VkTm9kZSogbm9kZSkge1xuICAgICAgICBub2RlLT5wcmV2ID0gaGVhZDtcbiAgICAgICAgbm9kZS0+bmV4dCA9IGhlYWQtPm5leHQ7XG4gICAgICAgIGhlYWQtPm5leHQtPnByZXYgPSBub2RlO1xuICAgICAgICBoZWFkLT5uZXh0ID0gbm9kZTtcbiAgICB9XG4gICAgXG4gICAgdm9pZCByZW1vdmVOb2RlKERMaW5rZWROb2RlKiBub2RlKSB7XG4gICAgICAgIG5vZGUtPnByZXYtPm5leHQgPSBub2RlLT5uZXh0O1xuICAgICAgICBub2RlLT5uZXh0LT5wcmV2ID0gbm9kZS0+cHJldjtcbiAgICB9XG5cbiAgICB2b2lkIG1vdmVUb0hlYWQoRExpbmtlZE5vZGUqIG5vZGUpIHtcbiAgICAgICAgcmVtb3ZlTm9kZShub2RlKTtcbiAgICAgICAgYWRkVG9IZWFkKG5vZGUpO1xuICAgIH1cblxuICAgIERMaW5rZWROb2RlKiByZW1vdmVUYWlsKCkge1xuICAgICAgICBETGlua2VkTm9kZSogbm9kZSA9IHRhaWwtPnByZXY7XG4gICAgICAgIHJlbW92ZU5vZGUobm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicHVibGljIGNsYXNzIExSVUNhY2hlIHtcbiAgY2xhc3MgRExpbmtlZE5vZGUge1xuICAgICAgaW50IGtleTtcbiAgICAgIGludCB2YWx1ZTtcbiAgICAgIERMaW5rZWROb2RlIHByZXY7XG4gICAgICBETGlua2VkTm9kZSBuZXh0O1xuICAgICAgcHVibGljIERMaW5rZWROb2RlKCkge31cbiAgICAgIHB1YmxpYyBETGlua2VkTm9kZShpbnQgX2tleSwgaW50IF92YWx1ZSkge2tleSA9IF9rZXk7IHZhbHVlID0gX3ZhbHVlO31cbiAgfVxuXG4gIHByaXZhdGUgTWFwPEludGVnZXIsIERMaW5rZWROb2RlPiBjYWNoZSA9IG5ldyBIYXNoTWFwPEludGVnZXIsIERMaW5rZWROb2RlPigpO1xuICBwcml2YXRlIGludCBzaXplO1xuICBwcml2YXRlIGludCBjYXBhY2l0eTtcbiAgcHJpdmF0ZSBETGlua2VkTm9kZSBoZWFkLCB0YWlsO1xuXG4gIHB1YmxpYyBMUlVDYWNoZShpbnQgY2FwYWNpdHkpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICB0aGlzLmNhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgICAvLyDkvb/nlKjkvKrlpLTpg6jlkozkvKrlsL7pg6joioLngrlcbiAgICAgIGhlYWQgPSBuZXcgRExpbmtlZE5vZGUoKTtcbiAgICAgIHRhaWwgPSBuZXcgRExpbmtlZE5vZGUoKTtcbiAgICAgIGhlYWQubmV4dCA9IHRhaWw7XG4gICAgICB0YWlsLnByZXYgPSBoZWFkO1xuICB9XG5cbiAgcHVibGljIGludCBnZXQoaW50IGtleSkge1xuICAgICAgRExpbmtlZE5vZGUgbm9kZSA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIC8vIOWmguaenCBrZXkg5a2Y5Zyo77yM5YWI6YCa6L+H5ZOI5biM6KGo5a6a5L2N77yM5YaN56e75Yiw5aS06YOoXG4gICAgICBtb3ZlVG9IZWFkKG5vZGUpO1xuICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gIH1cblxuICBwdWJsaWMgdm9pZCBwdXQoaW50IGtleSwgaW50IHZhbHVlKSB7XG4gICAgICBETGlua2VkTm9kZSBub2RlID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgLy8g5aaC5p6cIGtleSDkuI3lrZjlnKjvvIzliJvlu7rkuIDkuKrmlrDnmoToioLngrlcbiAgICAgICAgICBETGlua2VkTm9kZSBuZXdOb2RlID0gbmV3IERMaW5rZWROb2RlKGtleSwgdmFsdWUpO1xuICAgICAgICAgIC8vIOa3u+WKoOi/m+WTiOW4jOihqFxuICAgICAgICAgIGNhY2hlLnB1dChrZXksIG5ld05vZGUpO1xuICAgICAgICAgIC8vIOa3u+WKoOiHs+WPjOWQkemTvuihqOeahOWktOmDqFxuICAgICAgICAgIGFkZFRvSGVhZChuZXdOb2RlKTtcbiAgICAgICAgICArK3NpemU7XG4gICAgICAgICAgaWYgKHNpemUgPiBjYXBhY2l0eSkge1xuICAgICAgICAgICAgICAvLyDlpoLmnpzotoXlh7rlrrnph4/vvIzliKDpmaTlj4zlkJHpk77ooajnmoTlsL7pg6joioLngrlcbiAgICAgICAgICAgICAgRExpbmtlZE5vZGUgdGFpbCA9IHJlbW92ZVRhaWwoKTtcbiAgICAgICAgICAgICAgLy8g5Yig6Zmk5ZOI5biM6KGo5Lit5a+55bqU55qE6aG5XG4gICAgICAgICAgICAgIGNhY2hlLnJlbW92ZSh0YWlsLmtleSk7XG4gICAgICAgICAgICAgIC0tc2l6ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICAvLyDlpoLmnpwga2V5IOWtmOWcqO+8jOWFiOmAmui/h+WTiOW4jOihqOWumuS9je+8jOWGjeS/ruaUuSB2YWx1Ze+8jOW5tuenu+WIsOWktOmDqFxuICAgICAgICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBtb3ZlVG9IZWFkKG5vZGUpO1xuICAgICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB2b2lkIGFkZFRvSGVhZChETGlua2VkTm9kZSBub2RlKSB7XG4gICAgICBub2RlLnByZXYgPSBoZWFkO1xuICAgICAgbm9kZS5uZXh0ID0gaGVhZC5uZXh0O1xuICAgICAgaGVhZC5uZXh0LnByZXYgPSBub2RlO1xuICAgICAgaGVhZC5uZXh0ID0gbm9kZTtcbiAgfVxuXG4gIHByaXZhdGUgdm9pZCByZW1vdmVOb2RlKERMaW5rZWROb2RlIG5vZGUpIHtcbiAgICAgIG5vZGUucHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XG4gIH1cblxuICBwcml2YXRlIHZvaWQgbW92ZVRvSGVhZChETGlua2VkTm9kZSBub2RlKSB7XG4gICAgICByZW1vdmVOb2RlKG5vZGUpO1xuICAgICAgYWRkVG9IZWFkKG5vZGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBETGlua2VkTm9kZSByZW1vdmVUYWlsKCkge1xuICAgICAgRExpbmtlZE5vZGUgcmVzID0gdGFpbC5wcmV2O1xuICAgICAgcmVtb3ZlTm9kZShyZXMpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBMaXN0Tm9kZTpcbiAgICBkZWYgX19pbml0X18oc2VsZiwga2V5PU5vbmUsIHZhbHVlPU5vbmUpOlxuICAgICAgICBzZWxmLmtleSA9IGtleVxuICAgICAgICBzZWxmLnZhbHVlID0gdmFsdWVcbiAgICAgICAgc2VsZi5wcmV2ID0gTm9uZVxuICAgICAgICBzZWxmLm5leHQgPSBOb25lXG5cblxuY2xhc3MgTFJVQ2FjaGU6XG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIGNhcGFjaXR5OiBpbnQpOlxuICAgICAgICBzZWxmLmNhcGFjaXR5ID0gY2FwYWNpdHlcbiAgICAgICAgc2VsZi5oYXNobWFwID0ge31cbiAgICAgICAgIyDmlrDlu7rkuKTkuKroioLngrkgaGVhZCDlkowgdGFpbFxuICAgICAgICBzZWxmLmhlYWQgPSBMaXN0Tm9kZSgpXG4gICAgICAgIHNlbGYudGFpbCA9IExpc3ROb2RlKClcbiAgICAgICAgIyDliJ3lp4vljJbpk77ooajkuLogaGVhZCA8LT4gdGFpbFxuICAgICAgICBzZWxmLmhlYWQubmV4dCA9IHNlbGYudGFpbFxuICAgICAgICBzZWxmLnRhaWwucHJldiA9IHNlbGYuaGVhZFxuXG4gICAgIyBnZXQg5ZKMIHB1dCDmk43kvZzlj6/og73pg73kvJrosIPnlKhtb3ZlX3RvX3RhaWzmlrnms5VcbiAgICBkZWYgbW92ZV90b190YWlsKHNlbGYsIGtleTogaW50KSAtPiBpbnQ6XG4gICAgICAgIG5vZGUgPSBzZWxmLmhhc2htYXBba2V5XVxuICAgICAgICAjIOWwhiBub2RlIOe7k+eCueeahOWJjee9rue7k+eCueWSjOWQjue9rue7k+eCueebuOi/nlxuICAgICAgICBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dFxuICAgICAgICBub2RlLm5leHQucHJldiA9IG5vZGUucHJldlxuICAgICAgICAjIOWwhm5vZGXmj5LlhaXliLDlsL7oioLngrnliY1cbiAgICAgICAgbm9kZS5wcmV2ID0gc2VsZi50YWlsLnByZXZcbiAgICAgICAgbm9kZS5uZXh0ID0gc2VsZi50YWlsXG4gICAgICAgIHNlbGYudGFpbC5wcmV2Lm5leHQgPSBub2RlXG4gICAgICAgIHNlbGYudGFpbC5wcmV2ID0gbm9kZVxuXG4gICAgZGVmIGdldChzZWxmLCBrZXk6IGludCkgLT4gaW50OlxuICAgICAgICBpZiBrZXkgaW4gc2VsZi5oYXNobWFwOlxuICAgICAgICAgICAgIyDlpoLmnpzlt7Lnu4/lnKjpk77ooajkuK3kuobkuYXmiorlroPnp7vliLDmnKvlsL7vvIjlj5jmiJDmnIDmlrDorr/pl67nmoTvvIlcbiAgICAgICAgICAgIHNlbGYubW92ZV90b190YWlsKGtleSlcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmhhc2htYXAuZ2V0KGtleSkudmFsdWVcblxuICAgICAgICByZXR1cm4gLTFcblxuICAgIGRlZiBwdXQoc2VsZiwga2V5OiBpbnQsIHZhbHVlOiBpbnQpIC0+IE5vbmU6XG4gICAgICAgIGlmIGtleSBpbiBzZWxmLmhhc2htYXA6XG4gICAgICAgICAgICAjIOWmguaenGtleeacrOi6q+W3sue7j+WcqOWTiOW4jOihqOS4reS6huWwseS4jemcgOimgeWcqOmTvuihqOS4reWKoOWFpeaWsOeahOiKgueCuVxuICAgICAgICAgICAgIyDkvYbmmK/pnIDopoHmm7TmlrDlrZflhbjor6XlgLzlr7nlupToioLngrnnmoR2YWx1ZVxuICAgICAgICAgICAgc2VsZi5oYXNobWFwW2tleV0udmFsdWUgPSB2YWx1ZVxuICAgICAgICAgICAgIyDkuYvlkI7lsIbor6XoioLngrnnp7vliLDmnKvlsL5cbiAgICAgICAgICAgIHNlbGYubW92ZV90b190YWlsKGtleSlcbiAgICAgICAgZWxzZTpcbiAgICAgICAgICAgIGlmIGxlbihzZWxmLmhhc2htYXApID09IHNlbGYuY2FwYWNpdHk6XG4gICAgICAgICAgICAgICAgIyDljrvmjonlk4jluIzooajlr7nlupTpoblcbiAgICAgICAgICAgICAgICBzZWxmLmhhc2htYXAucG9wKHNlbGYuaGVhZC5uZXh0LmtleSlcbiAgICAgICAgICAgICAgICAjIOWOu+aOieacgOS5heayoeacieiiq+iuv+mXrui/h+eahOiKgueCue+8jOWNs+WktOiKgueCueS5i+WQjueahOiKgueCuVxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZC5uZXh0ID0gc2VsZi5oZWFkLm5leHQubmV4dFxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZC5uZXh0LnByZXYgPSBzZWxmLmhlYWRcbiAgICAgICAgICAgICMg5bCG5paw57uT54K55o+S5YWl5Yiw5bC+6IqC54K55YmNXG4gICAgICAgICAgICBuZXdOb2RlID0gTGlzdE5vZGUoa2V5LCB2YWx1ZSlcbiAgICAgICAgICAgIHNlbGYuaGFzaG1hcFtrZXldID0gbmV3Tm9kZVxuICAgICAgICAgICAgbmV3Tm9kZS5wcmV2ID0gc2VsZi50YWlsLnByZXZcbiAgICAgICAgICAgIG5ld05vZGUubmV4dCA9IHNlbGYudGFpbFxuICAgICAgICAgICAgc2VsZi50YWlsLnByZXYubmV4dCA9IG5ld05vZGVcbiAgICAgICAgICAgIHNlbGYudGFpbC5wcmV2ID0gbmV3Tm9kZVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIE4LjQuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiLy8g57yT5a2Y55qE6IqC54K55L+h5oGvXG5zdHJ1Y3QgTm9kZSB7XG4gICAgaW50IGtleSwgdmFsLCBmcmVxO1xuICAgIE5vZGUoaW50IF9rZXksaW50IF92YWwsaW50IF9mcmVxKToga2V5KF9rZXkpLCB2YWwoX3ZhbCksIGZyZXEoX2ZyZXEpe31cbn07XG5jbGFzcyBMRlVDYWNoZSB7XG4gICAgaW50IG1pbmZyZXEsIGNhcGFjaXR5O1xuICAgIHVub3JkZXJlZF9tYXA8aW50LCBsaXN0PE5vZGU+OjppdGVyYXRvcj4ga2V5X3RhYmxlO1xuICAgIHVub3JkZXJlZF9tYXA8aW50LCBsaXN0PE5vZGU+PiBmcmVxX3RhYmxlO1xucHVibGljOlxuICAgIExGVUNhY2hlKGludCBfY2FwYWNpdHkpIHtcbiAgICAgICAgbWluZnJlcSA9IDA7XG4gICAgICAgIGNhcGFjaXR5ID0gX2NhcGFjaXR5O1xuICAgICAgICBrZXlfdGFibGUuY2xlYXIoKTtcbiAgICAgICAgZnJlcV90YWJsZS5jbGVhcigpO1xuICAgIH1cbiAgICBcbiAgICBpbnQgZ2V0KGludCBrZXkpIHtcbiAgICAgICAgaWYgKGNhcGFjaXR5ID09IDApIHJldHVybiAtMTtcbiAgICAgICAgYXV0byBpdCA9IGtleV90YWJsZS5maW5kKGtleSk7XG4gICAgICAgIGlmIChpdCA9PSBrZXlfdGFibGUuZW5kKCkpIHJldHVybiAtMTtcbiAgICAgICAgbGlzdDxOb2RlPjo6aXRlcmF0b3Igbm9kZSA9IGl0IC0+IHNlY29uZDtcbiAgICAgICAgaW50IHZhbCA9IG5vZGUgLT4gdmFsLCBmcmVxID0gbm9kZSAtPiBmcmVxO1xuICAgICAgICBmcmVxX3RhYmxlW2ZyZXFdLmVyYXNlKG5vZGUpO1xuICAgICAgICAvLyDlpoLmnpzlvZPliY3pk77ooajkuLrnqbrvvIzmiJHku6zpnIDopoHlnKjlk4jluIzooajkuK3liKDpmaTvvIzkuJTmm7TmlrBtaW5GcmVxXG4gICAgICAgIGlmIChmcmVxX3RhYmxlW2ZyZXFdLnNpemUoKSA9PSAwKSB7XG4gICAgICAgICAgICBmcmVxX3RhYmxlLmVyYXNlKGZyZXEpO1xuICAgICAgICAgICAgaWYgKG1pbmZyZXEgPT0gZnJlcSkgbWluZnJlcSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIOaPkuWFpeWIsCBmcmVxICsgMSDkuK1cbiAgICAgICAgZnJlcV90YWJsZVtmcmVxICsgMV0ucHVzaF9mcm9udChOb2RlKGtleSwgdmFsLCBmcmVxICsgMSkpO1xuICAgICAgICBrZXlfdGFibGVba2V5XSA9IGZyZXFfdGFibGVbZnJlcSArIDFdLmJlZ2luKCk7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIFxuICAgIHZvaWQgcHV0KGludCBrZXksIGludCB2YWx1ZSkge1xuICAgICAgICBpZiAoY2FwYWNpdHkgPT0gMCkgcmV0dXJuO1xuICAgICAgICBhdXRvIGl0ID0ga2V5X3RhYmxlLmZpbmQoa2V5KTtcbiAgICAgICAgaWYgKGl0ID09IGtleV90YWJsZS5lbmQoKSkge1xuICAgICAgICAgICAgLy8g57yT5a2Y5bey5ruh77yM6ZyA6KaB6L+b6KGM5Yig6Zmk5pON5L2cXG4gICAgICAgICAgICBpZiAoa2V5X3RhYmxlLnNpemUoKSA9PSBjYXBhY2l0eSkge1xuICAgICAgICAgICAgICAgIC8vIOmAmui/hyBtaW5GcmVxIOaLv+WIsCBmcmVxX3RhYmxlW21pbkZyZXFdIOmTvuihqOeahOacq+WwvuiKgueCuVxuICAgICAgICAgICAgICAgIGF1dG8gaXQyID0gZnJlcV90YWJsZVttaW5mcmVxXS5iYWNrKCk7XG4gICAgICAgICAgICAgICAga2V5X3RhYmxlLmVyYXNlKGl0Mi5rZXkpO1xuICAgICAgICAgICAgICAgIGZyZXFfdGFibGVbbWluZnJlcV0ucG9wX2JhY2soKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJlcV90YWJsZVttaW5mcmVxXS5zaXplKCkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmcmVxX3RhYmxlLmVyYXNlKG1pbmZyZXEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBmcmVxX3RhYmxlWzFdLnB1c2hfZnJvbnQoTm9kZShrZXksIHZhbHVlLCAxKSk7XG4gICAgICAgICAgICBrZXlfdGFibGVba2V5XSA9IGZyZXFfdGFibGVbMV0uYmVnaW4oKTtcbiAgICAgICAgICAgIG1pbmZyZXEgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8g5LiOIGdldCDmk43kvZzln7rmnKzkuIDoh7TvvIzpmaTkuobpnIDopoHmm7TmlrDnvJPlrZjnmoTlgLxcbiAgICAgICAgICAgIGxpc3Q8Tm9kZT46Oml0ZXJhdG9yIG5vZGUgPSBpdCAtPiBzZWNvbmQ7XG4gICAgICAgICAgICBpbnQgZnJlcSA9IG5vZGUgLT4gZnJlcTtcbiAgICAgICAgICAgIGZyZXFfdGFibGVbZnJlcV0uZXJhc2Uobm9kZSk7XG4gICAgICAgICAgICBpZiAoZnJlcV90YWJsZVtmcmVxXS5zaXplKCkgPT0gMCkge1xuICAgICAgICAgICAgICAgIGZyZXFfdGFibGUuZXJhc2UoZnJlcSk7XG4gICAgICAgICAgICAgICAgaWYgKG1pbmZyZXEgPT0gZnJlcSkgbWluZnJlcSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJlcV90YWJsZVtmcmVxICsgMV0ucHVzaF9mcm9udChOb2RlKGtleSwgdmFsdWUsIGZyZXEgKyAxKSk7XG4gICAgICAgICAgICBrZXlfdGFibGVba2V5XSA9IGZyZXFfdGFibGVbZnJlcSArIDFdLmJlZ2luKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIExGVUNhY2hlIHtcbiAgTWFwPEludGVnZXIsIE5vZGU+IGNhY2hlOyAvLyDlrZjlgqjnvJPlrZjnmoTlhoXlrrlcbiAgTWFwPEludGVnZXIsIERvdWJseUxpbmtlZExpc3Q+IGZyZXFNYXA7IC8vIOWtmOWCqOavj+S4qumikeasoeWvueW6lOeahOWPjOWQkemTvuihqFxuICBpbnQgc2l6ZTtcbiAgaW50IGNhcGFjaXR5O1xuICBpbnQgbWluOyAvLyDlrZjlgqjlvZPliY3mnIDlsI/popHmrKFcblxuICBwdWJsaWMgTEZVQ2FjaGUoaW50IGNhcGFjaXR5KSB7XG4gICAgICBjYWNoZSA9IG5ldyBIYXNoTWFwPD4gKGNhcGFjaXR5KTtcbiAgICAgIGZyZXFNYXAgPSBuZXcgSGFzaE1hcDw+KCk7XG4gICAgICB0aGlzLmNhcGFjaXR5ID0gY2FwYWNpdHk7XG4gIH1cbiAgXG4gIHB1YmxpYyBpbnQgZ2V0KGludCBrZXkpIHtcbiAgICAgIE5vZGUgbm9kZSA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGZyZXFJbmMobm9kZSk7XG4gICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgfVxuICBcbiAgcHVibGljIHZvaWQgcHV0KGludCBrZXksIGludCB2YWx1ZSkge1xuICAgICAgaWYgKGNhcGFjaXR5ID09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBOb2RlIG5vZGUgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgIGlmIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgZnJlcUluYyhub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNpemUgPT0gY2FwYWNpdHkpIHtcbiAgICAgICAgICAgICAgRG91Ymx5TGlua2VkTGlzdCBtaW5GcmVxTGlua2VkTGlzdCA9IGZyZXFNYXAuZ2V0KG1pbik7XG4gICAgICAgICAgICAgIGNhY2hlLnJlbW92ZShtaW5GcmVxTGlua2VkTGlzdC50YWlsLnByZS5rZXkpO1xuICAgICAgICAgICAgICBtaW5GcmVxTGlua2VkTGlzdC5yZW1vdmVOb2RlKG1pbkZyZXFMaW5rZWRMaXN0LnRhaWwucHJlKTsgLy8g6L+Z6YeM5LiN6ZyA6KaB57u05oqkbWluLCDlm6DkuLrkuIvpnaJhZGTkuoZuZXdOb2Rl5ZCObWlu6IKv5a6a5pivMS5cbiAgICAgICAgICAgICAgc2l6ZS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBOb2RlIG5ld05vZGUgPSBuZXcgTm9kZShrZXksIHZhbHVlKTtcbiAgICAgICAgICBjYWNoZS5wdXQoa2V5LCBuZXdOb2RlKTtcbiAgICAgICAgICBEb3VibHlMaW5rZWRMaXN0IGxpbmtlZExpc3QgPSBmcmVxTWFwLmdldCgxKTtcbiAgICAgICAgICBpZiAobGlua2VkTGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGxpbmtlZExpc3QgPSBuZXcgRG91Ymx5TGlua2VkTGlzdCgpO1xuICAgICAgICAgICAgICBmcmVxTWFwLnB1dCgxLCBsaW5rZWRMaXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGlua2VkTGlzdC5hZGROb2RlKG5ld05vZGUpO1xuICAgICAgICAgIHNpemUrKzsgIFxuICAgICAgICAgIG1pbiA9IDE7ICAgXG4gICAgICB9XG4gIH1cblxuICB2b2lkIGZyZXFJbmMoTm9kZSBub2RlKSB7XG4gICAgICAvLyDku47ljp9mcmVx5a+55bqU55qE6ZO+6KGo6YeM56e76ZmkLCDlubbmm7TmlrBtaW5cbiAgICAgIGludCBmcmVxID0gbm9kZS5mcmVxO1xuICAgICAgRG91Ymx5TGlua2VkTGlzdCBsaW5rZWRMaXN0ID0gZnJlcU1hcC5nZXQoZnJlcSk7XG4gICAgICBsaW5rZWRMaXN0LnJlbW92ZU5vZGUobm9kZSk7XG4gICAgICBpZiAoZnJlcSA9PSBtaW4gJiYgbGlua2VkTGlzdC5oZWFkLnBvc3QgPT0gbGlua2VkTGlzdC50YWlsKSB7IFxuICAgICAgICAgIG1pbiA9IGZyZXEgKyAxO1xuICAgICAgfVxuICAgICAgLy8g5Yqg5YWl5pawZnJlceWvueW6lOeahOmTvuihqFxuICAgICAgbm9kZS5mcmVxKys7XG4gICAgICBsaW5rZWRMaXN0ID0gZnJlcU1hcC5nZXQoZnJlcSArIDEpO1xuICAgICAgaWYgKGxpbmtlZExpc3QgPT0gbnVsbCkge1xuICAgICAgICAgIGxpbmtlZExpc3QgPSBuZXcgRG91Ymx5TGlua2VkTGlzdCgpO1xuICAgICAgICAgIGZyZXFNYXAucHV0KGZyZXEgKyAxLCBsaW5rZWRMaXN0KTtcbiAgICAgIH1cbiAgICAgIGxpbmtlZExpc3QuYWRkTm9kZShub2RlKTtcbiAgfVxufVxuXG5jbGFzcyBOb2RlIHtcbiAgaW50IGtleTtcbiAgaW50IHZhbHVlO1xuICBpbnQgZnJlcSA9IDE7XG4gIE5vZGUgcHJlO1xuICBOb2RlIHBvc3Q7XG5cbiAgcHVibGljIE5vZGUoKSB7fVxuICBcbiAgcHVibGljIE5vZGUoaW50IGtleSwgaW50IHZhbHVlKSB7XG4gICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxufVxuXG5jbGFzcyBEb3VibHlMaW5rZWRMaXN0IHtcbiAgTm9kZSBoZWFkO1xuICBOb2RlIHRhaWw7XG5cbiAgcHVibGljIERvdWJseUxpbmtlZExpc3QoKSB7XG4gICAgICBoZWFkID0gbmV3IE5vZGUoKTtcbiAgICAgIHRhaWwgPSBuZXcgTm9kZSgpO1xuICAgICAgaGVhZC5wb3N0ID0gdGFpbDtcbiAgICAgIHRhaWwucHJlID0gaGVhZDtcbiAgfVxuXG4gIHZvaWQgcmVtb3ZlTm9kZShOb2RlIG5vZGUpIHtcbiAgICAgIG5vZGUucHJlLnBvc3QgPSBub2RlLnBvc3Q7XG4gICAgICBub2RlLnBvc3QucHJlID0gbm9kZS5wcmU7XG4gIH1cblxuICB2b2lkIGFkZE5vZGUoTm9kZSBub2RlKSB7XG4gICAgICBub2RlLnBvc3QgPSBoZWFkLnBvc3Q7XG4gICAgICBoZWFkLnBvc3QucHJlID0gbm9kZTtcbiAgICAgIGhlYWQucG9zdCA9IG5vZGU7XG4gICAgICBub2RlLnByZSA9IGhlYWQ7XG4gIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiaW1wb3J0IGNvbGxlY3Rpb25zXG5cblxuY2xhc3MgTm9kZTpcbiAgICBkZWYgX19pbml0X18oc2VsZiwga2V5OiBpbnQsIHZhbDogaW50KTpcbiAgICAgICAgc2VsZi5rZXkgPSBrZXlcbiAgICAgICAgc2VsZi52YWwgPSB2YWxcbiAgICAgICAgc2VsZi5mcmVxID0gMVxuICAgICAgICBzZWxmLnByZXYgPSBzZWxmLm5leHQgPSBOb25lXG5cblxuY2xhc3MgRExpbmtlZExpc3Q6XG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxuICAgICAgICBzZWxmLl9zZW50aW5lbCA9IE5vZGUoTm9uZSwgTm9uZSlcbiAgICAgICAgc2VsZi5fc2VudGluZWwubmV4dCA9IHNlbGYuX3NlbnRpbmVsLnByZXYgPSBzZWxmLl9zZW50aW5lbFxuICAgICAgICBzZWxmLl9zaXplID0gMFxuXG4gICAgZGVmIF9fbGVuX18oc2VsZik6XG4gICAgICAgIHJldHVybiBzZWxmLl9zaXplXG5cbiAgICBkZWYgYXBwZW5kKHNlbGYsIG5vZGU6IE5vZGUpOlxuICAgICAgICBub2RlLm5leHQgPSBzZWxmLl9zZW50aW5lbC5uZXh0XG4gICAgICAgIG5vZGUucHJldiA9IHNlbGYuX3NlbnRpbmVsXG4gICAgICAgIG5vZGUubmV4dC5wcmV2ID0gbm9kZVxuICAgICAgICBzZWxmLl9zZW50aW5lbC5uZXh0ID0gbm9kZVxuICAgICAgICBzZWxmLl9zaXplICs9IDFcblxuICAgIGRlZiBwb3Aoc2VsZiwgbm9kZT1Ob25lKTpcbiAgICAgICAgaWYgc2VsZi5fc2l6ZSA9PSAwOlxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgaWYgbm90IG5vZGU6XG4gICAgICAgICAgICBub2RlID0gc2VsZi5fc2VudGluZWwucHJldlxuICAgICAgICBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dFxuICAgICAgICBub2RlLm5leHQucHJldiA9IG5vZGUucHJldlxuICAgICAgICBzZWxmLl9zaXplIC09IDFcblxuICAgICAgICByZXR1cm4gbm9kZVxuXG5cbmNsYXNzIExGVUNhY2hlOlxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCBjYXBhY2l0eTogaW50KTpcbiAgICAgICAgc2VsZi5fc2l6ZSA9IDBcbiAgICAgICAgc2VsZi5fY2FwYWNpdHkgPSBjYXBhY2l0eVxuICAgICAgICBzZWxmLl9ub2RlID0gZGljdCgpXG4gICAgICAgIHNlbGYuX2ZyZXEgPSBjb2xsZWN0aW9ucy5kZWZhdWx0ZGljdChETGlua2VkTGlzdClcbiAgICAgICAgc2VsZi5fbWluZnJlcSA9IDBcblxuICAgIGRlZiBfdXBkYXRlKHNlbGYsIG5vZGU6IE5vZGUpOlxuICAgICAgICBmcmVxID0gbm9kZS5mcmVxXG5cbiAgICAgICAgc2VsZi5fZnJlcVtmcmVxXS5wb3Aobm9kZSlcblxuICAgICAgICBpZiBzZWxmLl9taW5mcmVxID09IGZyZXEgYW5kIG5vdCBzZWxmLl9mcmVxW2ZyZXFdOlxuICAgICAgICAgICAgc2VsZi5fbWluZnJlcSArPSAxXG5cbiAgICAgICAgbm9kZS5mcmVxICs9IDFcbiAgICAgICAgZnJlcSA9IG5vZGUuZnJlcVxuICAgICAgICBzZWxmLl9mcmVxW2ZyZXFdLmFwcGVuZChub2RlKVxuXG4gICAgZGVmIGdldChzZWxmLCBrZXk6IGludCkgLT4gaW50OlxuICAgICAgICBpZiBrZXkgbm90IGluIHNlbGYuX25vZGU6XG4gICAgICAgICAgICByZXR1cm4gLTFcblxuICAgICAgICBub2RlID0gc2VsZi5fbm9kZVtrZXldXG4gICAgICAgIHNlbGYuX3VwZGF0ZShub2RlKVxuICAgICAgICByZXR1cm4gbm9kZS52YWxcblxuICAgIGRlZiBwdXQoc2VsZiwga2V5OiBpbnQsIHZhbHVlOiBpbnQpIC0+IE5vbmU6XG4gICAgICAgIGlmIHNlbGYuX2NhcGFjaXR5ID09IDA6XG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICBpZiBrZXkgaW4gc2VsZi5fbm9kZTpcbiAgICAgICAgICAgIG5vZGUgPSBzZWxmLl9ub2RlW2tleV1cbiAgICAgICAgICAgIHNlbGYuX3VwZGF0ZShub2RlKVxuICAgICAgICAgICAgbm9kZS52YWwgPSB2YWx1ZVxuICAgICAgICBlbHNlOlxuICAgICAgICAgICAgaWYgc2VsZi5fc2l6ZSA9PSBzZWxmLl9jYXBhY2l0eTpcbiAgICAgICAgICAgICAgICBub2RlID0gc2VsZi5fZnJlcVtzZWxmLl9taW5mcmVxXS5wb3AoKVxuICAgICAgICAgICAgICAgIGRlbCBzZWxmLl9ub2RlW25vZGUua2V5XVxuICAgICAgICAgICAgICAgIHNlbGYuX3NpemUgLT0gMVxuXG4gICAgICAgICAgICBub2RlID0gTm9kZShrZXksIHZhbHVlKVxuICAgICAgICAgICAgc2VsZi5fbm9kZVtrZXldID0gbm9kZVxuICAgICAgICAgICAgc2VsZi5fZnJlcVsxXS5hcHBlbmQobm9kZSlcbiAgICAgICAgICAgIHNlbGYuX21pbmZyZXEgPSAxXG4gICAgICAgICAgICBzZWxmLl9zaXplICs9IDFcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBOC41LjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNvbnN0IGludCBNQVhfTEVWRUw9MTA7XG5jbGFzcyBTa2lwTm9kZXtcbnB1YmxpYzpcbiAgICBpbnQgdmFsO1xuICAgIGludCBsZXZlbDtcbiAgICBTa2lwTm9kZSoqIG5leHQ7XG4gICAgU2tpcE5vZGUoaW50IHYsaW50IGwpe1xuICAgICAgICB2YWw9djtcbiAgICAgICAgbGV2ZWw9bDtcbiAgICAgICAgbmV4dD1uZXcgU2tpcE5vZGUqW2wrMV0oKTtcbiAgICB9XG59O1xuXG5jbGFzcyBTa2lwbGlzdCB7XG5wcml2YXRlOlxuXG5wdWJsaWM6XG4gICAgU2tpcE5vZGUqIGhlYWQ7XG4gICAgaW50IExpc3RsZXZlbDtcbiAgICBTa2lwbGlzdCgpIHtcbiAgICAgICAgaGVhZD1uZXcgU2tpcE5vZGUoSU5UX01JTixNQVhfTEVWRUwpO1xuICAgICAgICBMaXN0bGV2ZWw9MDtcbiAgICB9XG4gICAgaW50IGdldGxldmVsKCl7XG4gICAgICAgIGludCBsZXY9MDtcbiAgICAgICAgd2hpbGUobGV2PE1BWF9MRVZFTCAmJiBsZXY8PUxpc3RsZXZlbCAmJiByYW5kKCk8UkFORF9NQVgvMil7XG4gICAgICAgICAgICArK2xldjsgICAgICAgICAgICAgICAgICAgICAgLy/nrYnnuqfkuLpsZXbnmoToioLngrnlh7rnjrDnmoTmpoLnjofkuLoxLzJebGV2XG4gICAgICAgIH1cbiAgICAgICAgaWYoTGlzdGxldmVsPGxldikrK0xpc3RsZXZlbDsgICAvL+WmguaenOaWsOiKgueCueetiee6p+mrmOS6jui3s+ihqOetiee6p++8jOWImei3s+ihqOetiee6p+WKoOS4gFxuICAgICAgICByZXR1cm4gbGV2O1xuICAgIH1cbiAgICBib29sIHNlYXJjaChpbnQgdGFyZ2V0KSB7XG4gICAgICAgIFNraXBOb2RlKiBzbj1oZWFkO1xuICAgICAgICBpbnQgbGw9TGlzdGxldmVsO1xuICAgICAgICB3aGlsZShsbD49MCl7XG4gICAgICAgICAgICB3aGlsZShzbi0+bmV4dFtsbF0hPW51bGxwdHIgJiYgc24tPm5leHRbbGxdLT52YWw8PXRhcmdldClzbj1zbi0+bmV4dFtsbF07XG4gICAgICAgICAgICAtLWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmKHNuLT52YWw9PXRhcmdldClyZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICB2b2lkIGFkZChpbnQgbnVtKSB7XG4gICAgICAgIC8vaWYoc2VhcmNoKG51bSkpcmV0dXJuOyAvL+S4gOW8gOWni+aIkeayoeazqOaEj+WPr+S7peWinuWIoOmHjeWkjeaVsOWtl++8jOaJgOS7peWKoOS6hui/meS4gOihjFxuICAgICAgICBTa2lwTm9kZSogc249aGVhZDtcbiAgICAgICAgaW50IGxldj1nZXRsZXZlbCgpO1xuICAgICAgICBpbnQgbGw9TGlzdGxldmVsO1xuICAgICAgICBTa2lwTm9kZSogbnNuPW5ldyBTa2lwTm9kZShudW0sbGV2KTtcbiAgICAgICAgd2hpbGUobGw+PTApe1xuICAgICAgICAgICAgd2hpbGUoc24tPm5leHRbbGxdIT1udWxscHRyICYmIHNuLT5uZXh0W2xsXS0+dmFsPG51bSlzbj1zbi0+bmV4dFtsbF07XG4gICAgICAgICAgICBpZihsbDw9bGV2KXtcbiAgICAgICAgICAgICAgICBuc24tPm5leHRbbGxdPXNuLT5uZXh0W2xsXTtcbiAgICAgICAgICAgICAgICBzbi0+bmV4dFtsbF09bnNuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLS1sbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBib29sIGVyYXNlKGludCBudW0pIHtcbiAgICAgICAgaWYoIXNlYXJjaChudW0pKXJldHVybiBmYWxzZTtcbiAgICAgICAgU2tpcE5vZGUqIHNuPWhlYWQ7XG4gICAgICAgIFNraXBOb2RlKiBkc247XG4gICAgICAgIGludCBsbD1MaXN0bGV2ZWw7XG4gICAgICAgIHdoaWxlKGxsPj0wKXtcbiAgICAgICAgICAgIHdoaWxlKHNuLT5uZXh0W2xsXSE9bnVsbHB0ciAmJiBzbi0+bmV4dFtsbF0tPnZhbDxudW0pc249c24tPm5leHRbbGxdO1xuICAgICAgICAgICAgaWYobGw9PTApZHNuPXNuLT5uZXh0W2xsXTtcbiAgICAgICAgICAgIGlmKHNuLT5uZXh0W2xsXSE9bnVsbHB0ciAmJiBzbi0+bmV4dFtsbF0tPnZhbD09bnVtKXtcbiAgICAgICAgICAgICAgICBzbi0+bmV4dFtsbF09c24tPm5leHRbbGxdLT5uZXh0W2xsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC0tbGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZHNuLT5sZXZlbD09TGlzdGxldmVsKXsgICAgICAgICAgICAgIC8v5aaC5p6c5Yig6Zmk55qE6IqC54K5562J57qn5Li65pyA6auY562J57qn6IqC54K577yMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL+WImeajgOafpeaYr+WQpuS4uuWUr+S4gOacgOmrmOetiee6p+iKgueCuSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8v5aaC5p6c5piv77yM6YKj5LmI6Lez6KGo562J57qn5YeP5LiA44CCXG4gICAgICAgICAgICBpZihoZWFkLT5uZXh0W0xpc3RsZXZlbF09PW51bGxwdHIpLS1MaXN0bGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTa2lwbGlzdCB7XG4gIGNsYXNzIFNraXBMaXN0Tm9kZSB7XG4gICAgICBpbnQgdmFsO1xuICAgICAgaW50IGNudDsgIC8vIOW9k+WJjXZhbOWHuueOsOeahOasoeaVsFxuICAgICAgU2tpcExpc3ROb2RlW10gbGV2ZWxzOyAgLy8gc3RhcnQgZnJvbSAwXG4gICAgICBTa2lwTGlzdE5vZGUoKSB7XG4gICAgICAgICAgbGV2ZWxzID0gbmV3IFNraXBMaXN0Tm9kZVtNQVhfTEVWRUxdO1xuICAgICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkb3VibGUgcCA9IDAuNTtcbiAgcHJpdmF0ZSBpbnQgTUFYX0xFVkVMID0gMTY7XG4gIHByaXZhdGUgU2tpcExpc3ROb2RlIGhlYWQ7ICAvLyDlpLTnu5PngrlcbiAgcHJpdmF0ZSBpbnQgbGV2ZWw7ICAvLyBcbiAgcHJpdmF0ZSBSYW5kb20gcmFuZG9tO1xuXG4gIHB1YmxpYyBTa2lwbGlzdCgpIHtcblxuICAgICAgbGV2ZWwgPSAwOyAgXG4gICAgICBoZWFkID0gbmV3IFNraXBMaXN0Tm9kZSgpO1xuICAgICAgcmFuZG9tID0gbmV3IFJhbmRvbSgpO1xuICB9XG5cbiAgcHVibGljIGJvb2xlYW4gc2VhcmNoKGludCB0YXJnZXQpIHtcbiAgICAgIFNraXBMaXN0Tm9kZSBjdXJOb2RlID0gaGVhZDtcbiAgICAgIGZvciAoaW50IGkgPSBsZXZlbC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHdoaWxlIChjdXJOb2RlLmxldmVsc1tpXSAhPSBudWxsICYmIGN1ck5vZGUubGV2ZWxzW2ldLnZhbCA8IHRhcmdldCkge1xuICAgICAgICAgICAgICBjdXJOb2RlID0gY3VyTm9kZS5sZXZlbHNbaV07XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3VyTm9kZSA9IGN1ck5vZGUubGV2ZWxzWzBdO1xuICAgICAgcmV0dXJuIChjdXJOb2RlICE9IG51bGwgJiYgY3VyTm9kZS52YWwgPT0gdGFyZ2V0KTtcbiAgfVxuXG4gIHB1YmxpYyB2b2lkIGFkZChpbnQgbnVtKSB7XG4gICAgICBTa2lwTGlzdE5vZGUgY3VyTm9kZSA9IGhlYWQ7XG4gICAgICAvLyDorrDlvZXmr4/lsYLog73orr/pl67nmoTmnIDlj7PoioLngrlcbiAgICAgIFNraXBMaXN0Tm9kZVtdIGxldmVsVGFpbHMgPSBuZXcgU2tpcExpc3ROb2RlW01BWF9MRVZFTF07XG4gICAgICBmb3IgKGludCBpID0gbGV2ZWwtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB3aGlsZSAoY3VyTm9kZS5sZXZlbHNbaV0gIT0gbnVsbCAmJiBjdXJOb2RlLmxldmVsc1tpXS52YWwgPCBudW0pIHtcbiAgICAgICAgICAgICAgY3VyTm9kZSA9IGN1ck5vZGUubGV2ZWxzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXZlbFRhaWxzW2ldID0gY3VyTm9kZTtcbiAgICAgIH1cbiAgICAgIGN1ck5vZGUgPSBjdXJOb2RlLmxldmVsc1swXTtcbiAgICAgIGlmIChjdXJOb2RlICE9IG51bGwgJiYgY3VyTm9kZS52YWwgPT0gbnVtKSB7XG4gICAgICAgICAgLy8g5bey5a2Y5Zyo77yMY250IOWKoDFcbiAgICAgICAgICBjdXJOb2RlLmNudCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyDmj5LlhaVcbiAgICAgICAgICBpbnQgbmV3TGV2ZWwgPSByYW5kb21MZXZlbCgpO1xuICAgICAgICAgIGlmIChuZXdMZXZlbCA+IGxldmVsKSB7XG4gICAgICAgICAgICAgIGZvciAoaW50IGkgPSBsZXZlbDsgaSA8IG5ld0xldmVsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGxldmVsVGFpbHNbaV0gPSBoZWFkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIFNraXBMaXN0Tm9kZSBuZXdOb2RlID0gbmV3IFNraXBMaXN0Tm9kZSgpO1xuICAgICAgICAgIG5ld05vZGUudmFsID0gbnVtO1xuICAgICAgICAgIG5ld05vZGUuY250ID0gMTtcbiAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGxldmVsOyBpKyspIHtcbiAgICAgICAgICAgICAgbmV3Tm9kZS5sZXZlbHNbaV0gPSBsZXZlbFRhaWxzW2ldLmxldmVsc1tpXTtcbiAgICAgICAgICAgICAgbGV2ZWxUYWlsc1tpXS5sZXZlbHNbaV0gPSBuZXdOb2RlO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICBwcml2YXRlIGludCByYW5kb21MZXZlbCgpIHtcbiAgICAgIGludCBsZXZlbCA9IDE7ICBcbiAgICAgIHdoaWxlIChyYW5kb20ubmV4dERvdWJsZSgpIDwgcCAmJiBsZXZlbCA8IE1BWF9MRVZFTCkge1xuICAgICAgICAgIGxldmVsKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGV2ZWwgPiBNQVhfTEVWRUwgPyBNQVhfTEVWRUwgOiBsZXZlbDtcbiAgfVxuICBwdWJsaWMgYm9vbGVhbiBlcmFzZShpbnQgbnVtKSB7XG4gICAgICBTa2lwTGlzdE5vZGUgY3VyTm9kZSA9IGhlYWQ7XG4gICAgICAvLyDorrDlvZXmr4/lsYLog73orr/pl67nmoTmnIDlj7PoioLngrlcbiAgICAgIFNraXBMaXN0Tm9kZVtdIGxldmVsVGFpbHMgPSBuZXcgU2tpcExpc3ROb2RlW01BWF9MRVZFTF07XG5cbiAgICAgIGZvciAoaW50IGkgPSBsZXZlbC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHdoaWxlIChjdXJOb2RlLmxldmVsc1tpXSAhPSBudWxsICYmIGN1ck5vZGUubGV2ZWxzW2ldLnZhbCA8IG51bSkge1xuICAgICAgICAgICAgICBjdXJOb2RlID0gY3VyTm9kZS5sZXZlbHNbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldmVsVGFpbHNbaV0gPSBjdXJOb2RlO1xuICAgICAgfVxuICAgICAgY3VyTm9kZSA9IGN1ck5vZGUubGV2ZWxzWzBdO1xuICAgICAgaWYgKGN1ck5vZGUgIT0gbnVsbCAmJiBjdXJOb2RlLnZhbCA9PSBudW0pIHtcbiAgICAgICAgICBpZiAoY3VyTm9kZS5jbnQgPiAxKSB7XG4gICAgICAgICAgICAgIGN1ck5vZGUuY250LS07XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGxldmVsOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGxldmVsVGFpbHNbaV0ubGV2ZWxzW2ldICE9IGN1ck5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldmVsVGFpbHNbaV0ubGV2ZWxzW2ldID0gY3VyTm9kZS5sZXZlbHNbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChsZXZlbCA+IDAgJiYgaGVhZC5sZXZlbHNbbGV2ZWwtMV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZnJvbSB0eXBpbmcgaW1wb3J0IE9wdGlvbmFsXG5pbXBvcnQgcmFuZG9tXG5cblxuY2xhc3MgTGlzdE5vZGU6XG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIGRhdGE6IE9wdGlvbmFsW2ludF0gPSBOb25lKTpcbiAgICAgICAgc2VsZi5fZGF0YSA9IGRhdGFcbiAgICAgICAgc2VsZi5fZm9yd2FyZHMgPSBbXVxuXG5cbmNsYXNzIFNraXBsaXN0OlxuXG4gICAgX01BWF9MRVZFTCA9IDE2XG5cbiAgICBkZWYgX19pbml0X18oc2VsZik6XG4gICAgICAgIHNlbGYuX2xldmVsX2NvdW50ID0gMVxuICAgICAgICBzZWxmLl9oZWFkID0gTGlzdE5vZGUoKVxuICAgICAgICBzZWxmLl9oZWFkLl9mb3J3YXJkcyA9IFtOb25lXSAqIHNlbGYuX01BWF9MRVZFTFxuXG4gICAgZGVmIHNlYXJjaChzZWxmLCB0YXJnZXQ6IGludCkgLT4gYm9vbDpcbiAgICAgICAgcCA9IHNlbGYuX2hlYWRcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2Uoc2VsZi5fbGV2ZWxfY291bnQgLSAxLCAtMSwgLTEpOlxuICAgICAgICAgICAgd2hpbGUgcC5fZm9yd2FyZHNbaV0gYW5kIHAuX2ZvcndhcmRzW2ldLl9kYXRhIDwgdGFyZ2V0OlxuICAgICAgICAgICAgICAgIHAgPSBwLl9mb3J3YXJkc1tpXVxuXG4gICAgICAgIGlmIHAuX2ZvcndhcmRzWzBdIGFuZCBwLl9mb3J3YXJkc1swXS5fZGF0YSA9PSB0YXJnZXQ6XG4gICAgICAgICAgICByZXR1cm4gVHJ1ZVxuXG4gICAgICAgIHJldHVybiBGYWxzZVxuXG4gICAgZGVmIGFkZChzZWxmLCBudW06IGludCkgLT4gTm9uZTpcbiAgICAgICAgbGV2ZWwgPSBzZWxmLl9yYW5kb21fbGV2ZWwoKVxuICAgICAgICBpZiBzZWxmLl9sZXZlbF9jb3VudCA8IGxldmVsOlxuICAgICAgICAgICAgc2VsZi5fbGV2ZWxfY291bnQgPSBsZXZlbFxuICAgICAgICBuZXdfbm9kZSA9IExpc3ROb2RlKG51bSlcbiAgICAgICAgbmV3X25vZGUuX2ZvcndhcmRzID0gW05vbmVdICogbGV2ZWxcbiAgICAgICAgdXBkYXRlID0gW3NlbGYuX2hlYWRdICogc2VsZi5fbGV2ZWxfY291bnRcblxuICAgICAgICBwID0gc2VsZi5faGVhZFxuICAgICAgICBmb3IgaSBpbiByYW5nZShzZWxmLl9sZXZlbF9jb3VudCAtIDEsIC0xLCAtMSk6XG4gICAgICAgICAgICB3aGlsZSBwLl9mb3J3YXJkc1tpXSBhbmQgcC5fZm9yd2FyZHNbaV0uX2RhdGEgPCBudW06XG4gICAgICAgICAgICAgICAgcCA9IHAuX2ZvcndhcmRzW2ldXG5cbiAgICAgICAgICAgIHVwZGF0ZVtpXSA9IHBcblxuICAgICAgICBmb3IgaSBpbiByYW5nZShsZXZlbCk6XG4gICAgICAgICAgICBuZXdfbm9kZS5fZm9yd2FyZHNbaV0gPSB1cGRhdGVbaV0uX2ZvcndhcmRzW2ldXG4gICAgICAgICAgICB1cGRhdGVbaV0uX2ZvcndhcmRzW2ldID0gbmV3X25vZGVcblxuICAgIGRlZiBlcmFzZShzZWxmLCBudW06IGludCkgLT4gYm9vbDpcbiAgICAgICAgdXBkYXRlID0gW05vbmVdICogc2VsZi5fbGV2ZWxfY291bnRcbiAgICAgICAgcCA9IHNlbGYuX2hlYWRcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2Uoc2VsZi5fbGV2ZWxfY291bnQgLSAxLCAtMSwgLTEpOlxuICAgICAgICAgICAgd2hpbGUgcC5fZm9yd2FyZHNbaV0gYW5kIHAuX2ZvcndhcmRzW2ldLl9kYXRhIDwgbnVtOlxuICAgICAgICAgICAgICAgIHAgPSBwLl9mb3J3YXJkc1tpXVxuICAgICAgICAgICAgdXBkYXRlW2ldID0gcFxuXG4gICAgICAgIGlmIHAuX2ZvcndhcmRzWzBdIGFuZCBwLl9mb3J3YXJkc1swXS5fZGF0YSA9PSBudW06XG4gICAgICAgICAgICBmb3IgaSBpbiByYW5nZShzZWxmLl9sZXZlbF9jb3VudCAtIDEsIC0xLCAtMSk6XG4gICAgICAgICAgICAgICAgaWYgdXBkYXRlW2ldLl9mb3J3YXJkc1tpXSBhbmQgdXBkYXRlW2ldLl9mb3J3YXJkc1tpXS5fZGF0YSA9PSBudW06XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVtpXS5fZm9yd2FyZHNbaV0gPSB1cGRhdGVbaV0uX2ZvcndhcmRzW2ldLl9mb3J3YXJkc1tpXVxuICAgICAgICAgICAgcmV0dXJuIFRydWVcblxuICAgICAgICB3aGlsZSBzZWxmLl9sZXZlbF9jb3VudCA+IDEgYW5kIG5vdCBzZWxmLl9oZWFkLl9mb3J3YXJkc1tzZWxmLl9sZXZlbF9jb3VudF06XG4gICAgICAgICAgICBzZWxmLl9sZXZlbF9jb3VudCAtPSAxXG5cbiAgICAgICAgcmV0dXJuIEZhbHNlXG5cbiAgICBkZWYgX3JhbmRvbV9sZXZlbChzZWxmLCBwOiBmbG9hdCA9IDAuNSkgLT4gaW50OlxuICAgICAgICBsZXZlbCA9IDFcbiAgICAgICAgd2hpbGUgcmFuZG9tLnJhbmRvbSgpIDwgcCBhbmQgbGV2ZWwgPCBzZWxmLl9NQVhfTEVWRUw6XG4gICAgICAgICAgICBsZXZlbCArPSAxXG4gICAgICAgIHJldHVybiBsZXZlbFxuXG5cbiMgWW91ciBTa2lwbGlzdCBvYmplY3Qgd2lsbCBiZSBpbnN0YW50aWF0ZWQgYW5kIGNhbGxlZCBhcyBzdWNoOlxuIyBvYmogPSBTa2lwbGlzdCgpXG4jIHBhcmFtXzEgPSBvYmouc2VhcmNoKHRhcmdldClcbiMgb2JqLmFkZChudW0pXG4jIHBhcmFtXzMgPSBvYmouZXJhc2UobnVtKVxuXG4iCiAgICB9XQogIH1dCn0sIHsKICAiaWQiOiAiMDkiLAogICJuYW1lIjogIuesrOS5neeroCIsCiAgImxpc3QiOiBbewogICAgInRpdGxlIjogIuS7o+eggTkuMS4xLjIudHdvIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgdmVjdG9yPGludD4gdHdvU3VtKHZlY3RvcjxpbnQ+JiBudW1iZXJzLCBpbnQgdGFyZ2V0KSB7XG4gICAgICAgIGZvciAoaW50IGxlZnQgPSAwLCByaWdodCA9IG51bWJlcnMuc2l6ZSgpIC0gMTsgbGVmdCA8IHJpZ2h0OyApe1xuICAgICAgICAgICAgaWYgKG51bWJlcnNbbGVmdF0gKyBudW1iZXJzW3JpZ2h0XSA9PSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlY3RvcjxpbnQ+e2xlZnQgKyAxLCByaWdodCArIDF9O1xuICAgICAgICAgICAgZWxzZSBpZiAobnVtYmVyc1tsZWZ0XSArIG51bWJlcnNbcmlnaHRdIDwgdGFyZ2V0KVxuICAgICAgICAgICAgICAgIGxlZnQrKztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByaWdodC0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2ZWN0b3I8aW50Pnt9O1xuICAgIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gICAgcHVibGljIGludFtdIHR3b1N1bShpbnRbXSBudW1zLCBpbnQgdGFyZ2V0KSB7XG4gICAgICAgIGludCBsZWZ0ID0gMCwgcmlnaHQgPSBudW1zLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChsZWZ0IDwgcmlnaHQpIHtcbiAgICAgICAgICAgIGlmIChudW1zW2xlZnRdICsgbnVtc1tyaWdodF0gPT0gdGFyZ2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW50W117bGVmdCArIDEsIHJpZ2h0ICsgMX07XG4gICAgICAgICAgICBlbHNlIGlmIChudW1zW2xlZnRdICsgbnVtc1tyaWdodF0gPCB0YXJnZXQpXG4gICAgICAgICAgICAgICAgbGVmdCsrO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJpZ2h0LS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgdHdvU3VtKHNlbGYsIG51bWJlcjpMaXN0W2ludF0sIHRhcmdldDppbnQpLT5MaXN0W2ludF06XG4gICAgICAgIGxlZnQsIHJpZ2h0ID0gMCwgbGVuKG51bWJlcnMpIC0gMVxuICAgICAgICB3aGlsZSBsZWZ0IDwgcmlnaHQ6XG4gICAgICAgICAgICBpZiAobnVtYmVyc1tsZWZ0XSArIG51bWJlcnNbcmlnaHRdID09IHRhcmdldCk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsZWZ0ICsgMSwgcmlnaHQgKyAxXVxuICAgICAgICAgICAgZWxpZiAobnVtYmVyc1tsZWZ0XSArIG51bWJlcnNbcmlnaHRdIDwgdGFyZ2V0KTpcbiAgICAgICAgICAgICAgICBsZWZ0ICs9IDFcbiAgICAgICAgICAgIGVsaWY6XG4gICAgICAgICAgICAgICAgcmlnaHQgLT0gMVxuXG4gICAgICAgIHJldHVybiBbXVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIE5LjEuMS50d28iLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgICB2ZWN0b3I8aW50PiB0d29TdW0odmVjdG9yPGludD4mIG51bWJlcnMsIGludCB0YXJnZXQpIHtcbiAgICAgICAgdmVjdG9yPGludD4gcmV0O1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8PSBudW1iZXJzLnNpemUoKSAtIDEgLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAoaW50IGogPSBpICsgMTsgaiA8PSBudW1iZXJzLnNpemUoKSAtIDE7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChudW1iZXJzW2ldICsgbnVtYmVyc1tqXSA9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2hfYmFjayhpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoX2JhY2soaiArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gICAgcHVibGljIGludFtdIHR3b1N1bShpbnRbXSBudW1zLCBpbnQgdGFyZ2V0KSB7XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChpbnQgaiA9IGkgKyAxOyBqIDwgbnVtcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChudW1zW2pdID09IHRhcmdldCAtIG51bXNbaV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW50W117aSsxLCBqKzF9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHR3b1N1bShzZWxmLCBudW1iZXJzOkxpc3RbaW50XSwgdGFyZ2V0OmludCktPkxpc3RbaW50XTpcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMCwgbGVuKG51bWJlcnMpLCAxKTpcbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKGkgKyAxLCBsZW4obnVtYmVycyksIDEpOlxuICAgICAgICAgICAgICAgIGlmIG51bWJlcnNbaV0gKyBudW1iZXJzW2pdID09IHRhcmdldDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtpICsgMSwgaiArIDFdXG5cbiAgICAgICAgcmV0dXJuIFtdXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIE5LjEuMi4xLmNvbnRhaW5lciIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGludCBtYXhBcmVhKHZlY3RvcjxpbnQ+JiBoZWlnaHQpIHtcbiAgICAgICAgaW50IHJlcyA9IDA7XG4gICAgICAgIGludCBhcmVhID0gMDtcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBoZWlnaHQuc2l6ZSgpIC0gMTsgaSsrKVxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IGkgKyAxOyBqIDwgaGVpZ2h0LnNpemUoKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgYXJlYSA9IChqIC0gaSkgKiBtaW4oaGVpZ2h0W2ldLCBoZWlnaHRbal0pO1xuICAgICAgICAgICAgICAgIGlmIChhcmVhID4gcmVzKVxuICAgICAgICAgICAgICAgICAgICByZXMgPSBhcmVhO1xuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICAgIHB1YmxpYyBpbnQgbWF4QXJlYShpbnRbXSBoZWlnaHQpIHsgIFxuICAgICAgICBpbnQgcmVzID0gMCwgYXJlYSA9IDA7XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgaGVpZ2h0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGludCBqID0gaSArIDE7IGogPCBoZWlnaHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBhcmVhID0gTWF0aC5taW4oaGVpZ2h0W2ldLCBoZWlnaHRbal0pICogKGogLSBpKTtcbiAgICAgICAgICAgICAgICByZXMgPSBNYXRoLm1heChyZXMsIGFyZWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiA6XG4gICAgZGVmIG1heEFyZWEoc2VsZiwgaGVpZ2h0Okxpc3RbaW50XSktPmludDpcbiAgICAgICAgcmVzLCBhcmVhID0gMCwgMFxuICAgICAgICBmb3IgaSBpbiByYW5nZSgwLCBsZW4oaGVpZ2h0KSwgMSk6XG4gICAgICAgICAgICBmbyBqIGluIHJhbmdlKGkgKyAxLCBsZW4oaGVpZ2h0KSwgMSk6XG4gICAgICAgICAgICAgICAgYXJlYSA9IChqIC0gaSkgKiBtaW4oaGVpZ2h0W2ldLCBoZWlnaHRbal0pXG4gICAgICAgICAgICAgICAgaWYgYXJlYSA+IHJlczpcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gYXJlYVxuXG4gICAgICAgIHJldHVybiByZXNcbiAgICBcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBOS4xLjIuMi5jb250YWluZXIiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgICBpbnQgbWF4QXJlYSh2ZWN0b3I8aW50PiYgaGVpZ2h0KSB7XG4gICAgICAgIGludCByZXMgPSAwO1xuICAgICAgICBpbnQgYXJlYSA9IDA7XG4gICAgICAgIGludCBsZWZ0ID0gMCwgcmlnaHQgPSBoZWlnaHQuc2l6ZSgpIC0gMTtcbiAgICAgICAgXG4gICAgICAgIHdoaWxlKGxlZnQgPCByaWdodCkge1xuICAgICAgICAgICAgYXJlYSA9IChyaWdodCAtIGxlZnQpICogbWluKGhlaWdodFtyaWdodF0sIGhlaWdodFtsZWZ0XSk7XG4gICAgICAgICAgICByZXMgID0gbWF4KHJlcywgYXJlYSk7XG4gICAgICAgICAgICBpZiAoaGVpZ2h0W2xlZnRdIDwgaGVpZ2h0W3JpZ2h0XSlcbiAgICAgICAgICAgICAgICBsZWZ0Kys7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmlnaHQtLTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICAgIHB1YmxpYyBpbnQgbWF4QXJlYShpbnRbXSBoZWlnaHQpIHtcbiAgICAgICAgaW50IGxlZnQgPSAwLCByaWdodCA9IGhlaWdodC5sZW5ndGggLSAxLCByZXMgPSAwLCBhcmVhID0gMDtcblxuICAgICAgICB3aGlsZSAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICAgICAgICBhcmVhID0gTWF0aC5taW4oaGVpZ2h0W2xlZnRdLCBoZWlnaHRbcmlnaHRdKSAqIChyaWdodCAtIGxlZnQpO1xuICAgICAgICAgICAgcmVzID0gTWF0aC5tYXgocmVzLCBhcmVhKTtcbiAgICAgICAgICAgIGlmIChoZWlnaHRbbGVmdF0gPCBoZWlnaHRbcmlnaHRdKVxuICAgICAgICAgICAgICAgIGxlZnQrKztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByaWdodCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgbWF4QXJlYShzZWxmLCBoZWlnaHQ6TGlzdFtpbnRdKS0+aW50OlxuICAgICAgICAjaW5pdCB0aGUgcGFyYW1cbiAgICAgICAgbGVmdCwgcmlnaHQsIHdpZHRoLCByZXMgPSAwLCBsZW4oaGVpZ2h0KSAtIDEsIGxlbihoZWlnaHQgLSAxLCAwKVxuXG4gICAgICAgIGZvciB3IGluIHJhbmdlKHdpZHRoLCAwLCAtMSk6XG4gICAgICAgICAgICBpZiBoZWlnaHRbbGVmdF0gPCBoZWlnaHRbcmlnaHRdOlxuICAgICAgICAgICAgICAgIHJlcywgbGVmdCA9IG1heChyZXMsIGhlaWdodFtsZWZ0XSAqIHcpLCBsZWZ0ICsgMVxuICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICByZXMsIHJpZ2h0ID0gbWF4KHJlcywgaGVpZ2h0W3JpZ2h0XSAqIHcpLCByaWdodCAtIDFcblxuICAgICAgICByZXR1cm4gcmVzXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTkuMi4xLjEubGlua2VkIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIvKipcbiAqIERlZmluaXRpb24gZm9yIHNpbmdseS1saW5rZWQgbGlzdC5cbiAqIHN0cnVjdCBMaXN0Tm9kZSB7XG4gKiAgICAgaW50IHZhbDtcbiAqICAgICBMaXN0Tm9kZSAqbmV4dDtcbiAqICAgICBMaXN0Tm9kZShpbnQgeCkgOiB2YWwoeCksIG5leHQoTlVMTCkge31cbiAqIH07XG4gKi9cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgICBib29sIGhhc0N5Y2xlKExpc3ROb2RlICpoZWFkKSB7XG4gICAgICAgIHVub3JkZXJlZF9zZXQ8TGlzdE5vZGUgKj4gc2Vlbk5vZGU7XG4gICAgICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICAgICAgICBpZiAoc2Vlbk5vZGUuZmluZChoZWFkKSAhPSBzZWVuTm9kZS5lbmQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHNlZW5Ob2RlLmluc2VydChoZWFkKTtcbiAgICAgICAgICAgIGhlYWQgPSBoZWFkLT5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTsgIFxuICAgIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICIvKipcbiAqIERlZmluaXRpb24gZm9yIHNpbmdseS1saW5rZWQgbGlzdC5cbiAqIGNsYXNzIExpc3ROb2RlIHtcbiAqICAgICBpbnQgdmFsO1xuICogICAgIExpc3ROb2RlIG5leHQ7XG4gKiAgICAgTGlzdE5vZGUoaW50IHgpIHtcbiAqICAgICAgICAgdmFsID0geDtcbiAqICAgICAgICAgbmV4dCA9IG51bGw7XG4gKiAgICAgfVxuICogfVxuICovXG5wdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICAgIHB1YmxpYyBib29sZWFuIGhhc0N5Y2xlKExpc3ROb2RlIGhlYWQpIHtcbiAgICAgICAgaWYgKGhlYWQgPT0gbnVsbCB8fCBoZWFkLm5leHQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgU2V0PExpc3ROb2RlPiBzZXQgPSBuZXcgSGFzaFNldDw+KCk7XG4gICAgICAgIExpc3ROb2RlIG5vZGUgPSBoZWFkO1xuICAgICAgICB3aGlsZSAobm9kZS5uZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICBpZiAoc2V0LmNvbnRhaW5zKG5vZGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNldC5hZGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGhhc0N5Y2xlKHNlbGYsIGhlYWQ6TGlzdE5vZGUpLT5ib29sOlxuICAgICAgICBpZiBoZWFkIGlzIE5vbmU6XG4gICAgICAgICAgICByZXR1cm4gRmFsc2VcblxuICAgICAgICBub2RlX3NldCA9IHt9XG4gICAgICAgIHdoaWxlIGhlYWQubmV4dDpcbiAgICAgICAgICAgIG5vZGVfc2V0W2hlYWRdID0gVHJ1ZVxuXG4gICAgICAgICAgICBpZiBoZWFkLm5leHQgaW4gbm9kZV9zZXQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRydWVcblxuICAgICAgICAgICAgaGVhZCA9IGhlYWQubmV4dFxuXG4gICAgICAgIHJldHVybiBGYWxzZVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIE5LjIuMS4yLmxpbmtlZCIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiLyoqXG4gKiBEZWZpbml0aW9uIGZvciBzaW5nbHktbGlua2VkIGxpc3QuXG4gKiBzdHJ1Y3QgTGlzdE5vZGUge1xuICogICAgIGludCB2YWw7XG4gKiAgICAgTGlzdE5vZGUgKm5leHQ7XG4gKiAgICAgTGlzdE5vZGUoaW50IHgpIDogdmFsKHgpLCBuZXh0KE5VTEwpIHt9XG4gKiB9O1xuICovXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgYm9vbCBoYXNDeWNsZShMaXN0Tm9kZSAqaGVhZCkge1xuICAgICAgICBpZihoZWFkID09IE5VTEwgfHwgaGVhZC0+bmV4dCA9PSBOVUxMKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgTGlzdE5vZGUgKnAxTGlzdCA9IGhlYWQ7XG4gICAgICAgIExpc3ROb2RlICpwMkxpc3QgPSBoZWFkO1xuICAgICAgICBcbiAgICAgICAgd2hpbGUocDJMaXN0ICE9IE5VTEwgJiYgcDJMaXN0LT5uZXh0ICE9IE5VTEwpe1xuICAgICAgICAgICAgcDFMaXN0ID0gcDFMaXN0LT5uZXh0O1xuICAgICAgICAgICAgcDJMaXN0ID0gcDJMaXN0LT5uZXh0LT5uZXh0O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocDFMaXN0ID09IHAyTGlzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICIvKipcbiAqIERlZmluaXRpb24gZm9yIHNpbmdseS1saW5rZWQgbGlzdC5cbiAqIGNsYXNzIExpc3ROb2RlIHtcbiAqICAgICBpbnQgdmFsO1xuICogICAgIExpc3ROb2RlIG5leHQ7XG4gKiAgICAgTGlzdE5vZGUoaW50IHgpIHtcbiAqICAgICAgICAgdmFsID0geDtcbiAqICAgICAgICAgbmV4dCA9IG51bGw7XG4gKiAgICAgfVxuICogfVxuICovXG5wdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICAgIHB1YmxpYyBib29sZWFuIGhhc0N5Y2xlKExpc3ROb2RlIGhlYWQpIHtcbiAgICAgICAgaWYgKGhlYWQgPT0gbnVsbCB8fCBoZWFkLm5leHQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBMaXN0Tm9kZSBmYXN0ID0gaGVhZCwgc2xvdyA9IGhlYWQ7XG4gICAgICAgIHdoaWxlIChmYXN0Lm5leHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZmFzdCA9IGZhc3QubmV4dDtcbiAgICAgICAgICAgIGlmIChmYXN0ID09IHNsb3cpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmFzdC5uZXh0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBmYXN0ID0gZmFzdC5uZXh0O1xuICAgICAgICAgICAgICAgIHNsb3cgPSBzbG93Lm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGhhc0N5Y2xlKHNlbGYsIGhlYWQ6TGlzdE5vZGUpLT5ib29sOlxuICAgICAgICBpZiBoZWFkID09IE5vbmUgb3IgaGVhZC5uZXh0ID09IE5vbmU6XG4gICAgICAgICAgICByZXR1cm4gRmFsc2VcblxuICAgICAgICBwc2xvdyA9IHBmYXN0ID0gaGVhZFxuICAgICAgICB3aGlsZSBwZmFzdCAhPSBOb25lIGFuZCBwZmFzdC5uZXh0ICE9IE5vbmU6XG4gICAgICAgICAgICBwc2xvdyA9IHBzbG93Lm5leHRcbiAgICAgICAgICAgIHBmYXN0ID0gcGZhc3QubmV4dC5uZXh0XG4gICAgICAgICAgICBpZiBwZmFzdCA9PSBwc2xvdzpcbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgIGlmIHBmYXN0ID09IE5vbmUgb3IgcGZhc3QubmV4dCA9PSBOb25lOlxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXG4gICAgICAgIGVsaWYgcGZhc3QgPT0gcHNsb3c6XG4gICAgICAgICAgICByZXR1cm4gVHJ1ZVxuXG4gICAgICAgIHJldHVybiBGYWxzZVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIE5LjIuMi4xLmxvbmciLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gICAgcHVibGljIGludCBsZW5ndGhPZkxvbmdlc3RTdWJzdHJpbmcoU3RyaW5nIHMpIHtcbiAgICAgICAgaW50IHJlcyA9IDA7XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcy5sZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGludCBqID0gaTsgaiA8IHMubGVuZ3RoKCk7IGorKykge1xuICAgICAgICAgICAgICAgIFN0cmluZyB0bXAgPSBzLnN1YnN0cmluZyhpLCBqICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGFsbFVuaXF1ZSh0bXApKVxuICAgICAgICAgICAgICAgICAgICByZXMgPSBNYXRoLm1heChyZXMsIDEgKyBqIC0gaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBwdWJsaWMgYm9vbGVhbiBhbGxVbmlxdWUoU3RyaW5nIHMpIHtcbiAgICAgICAgU2V0PENoYXJhY3Rlcj4gc2V0ID0gbmV3IEhhc2hTZXQ8PigpO1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHMubGVuZ3RoKCk7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNldC5jb250YWlucyhzLmNoYXJBdChpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNldC5hZGQocy5jaGFyQXQoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGFsbFVuaXF1ZShzZWxmLCBzOnN0ciktPmJvb2w6XG4gICAgICAgIGRpYyA9IHt9XG4gICAgICAgIGZvciBpIGluIHJhbmdlKDAsIGxlbihzKSwgMSk6XG4gICAgICAgICAgICBpZiBzW2ldIGluIGRpYzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRmFsc2VcbiAgICAgICAgICAgIGVsc2U6XG4gICAgICAgICAgICAgICAgZGljW3NbaV1dID0gMVxuXG4gICAgICAgIHJldHVybiBUcnVlXG5cbiAgICBkZWYgbGVuZ3RoT2ZMb25nZXN0U3Vic3RyaW5nKHNlbGYsIHM6c3RyKS0+aW50OlxuICAgICAgICByZXMgPSAwXG5cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMCwgbGVuKHMpLCAxKTpcbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKDAsIGxlbihzKSwgMSk6XG4gICAgICAgICAgICAgICAgaWYgc2VsZi5hbGxVbmlxdWUoc1tpIDogaiArIDFdKTpcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gbWF4KHJlcywgaiAtIGkgKyAxKVxuICAgICAgICAgICAgICAgIGVsc2U6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgcmV0dXJuIHJlc1xuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIE5LjIuMi4yLmxvbmciLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgICBpbnQgbGVuZ3RoT2ZMb25nZXN0U3Vic3RyaW5nKHN0cmluZyBzKSB7XG4gICAgICAgICAgICBpbnQgcmVzID0gMCwgbGVmdCA9IDAsIHJpZ2h0ID0gMDtcbiAgICAgICAgICAgIHVub3JkZXJlZF9zZXQ8Y2hhcj4gc2V0dGluZztcblxuICAgICAgICAgICAgZm9yIChsZWZ0ID0gMDsgbGVmdCA8IHMuc2l6ZSgpOyBsZWZ0KyspIHtcbiAgICAgICAgICAgICAgICByaWdodCA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJpZ2h0IDwgcy5zaXplKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmcuZmluZChzW3JpZ2h0XSkgIT0gc2V0dGluZy5lbmQoKSkgeyAvL2hhcyB0aGUgY2hhclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGRvbm5vdCBoYXMgdGhlIGNoYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmcuaW5zZXJ0KHNbcmlnaHRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IG1heChyZXMsIHJpZ2h0IC0gbGVmdCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXR0aW5nLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgICBwdWJsaWMgaW50IGxlbmd0aE9mTG9uZ2VzdFN1YnN0cmluZyhTdHJpbmcgcykge1xuICAgICAgICBpbnQgcmVzID0gMDtcbiAgICAgICAgZm9yIChpbnQgbGVmdCA9IDA7IGxlZnQgPCBzLmxlbmd0aCgpOyBsZWZ0KyspIHtcbiAgICAgICAgICAgIFNldDxDaGFyYWN0ZXI+IHNldCA9IG5ldyBIYXNoU2V0PD4oKTtcbiAgICAgICAgICAgIGludCByaWdodCA9IGxlZnQ7XG4gICAgICAgICAgICB3aGlsZSAocmlnaHQgPCBzLmxlbmd0aCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldC5jb250YWlucyhzLmNoYXJBdChyaWdodCkpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0LmFkZChzLmNoYXJBdChyaWdodCkpO1xuICAgICAgICAgICAgICAgICAgICByZXMgPSBNYXRoLm1heChyZXMsIHJpZ2h0IC0gbGVmdCArIDEpO1xuICAgICAgICAgICAgICAgICAgICByaWdodCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGxlbmd0aG9mTG9uZ2VzdFN1YnN0cmluZyhzZWxmLCBzOnN0ciktPmludDpcbiAgICAgICAgcmVzLCBsZWZ0LCByaWdodCA9IDAsIDAsIDBcbiAgICAgICAgc2V0dGluZ3MgPSBzZXQoKVxuXG4gICAgICAgIGZvciBsZWZ0IGluIHJhbmdlKDAsIGxlbihzKSwgMSk6XG4gICAgICAgICAgICByaWdodCA9IGxlZnRcbiAgICAgICAgICAgIHdoaWxlIChyaWdodCA8IGxlbihzKSk6XG4gICAgICAgICAgICAgICAgaWYgKHNbcmlnaHRdIGluIHNldHRpbmdzKTpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBlbHNlOlxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hZGQoc1tyaWdodF0pXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IG1heChyZXMsIHJpZ2h0IC0gbGVmdCArIDEpXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQgKyAxXG5cbiAgICAgICAgICAgIHNldHRpbmdzLmNsZWFyKClcblxuICAgICAgICByZXR1cm4gcmVzXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTkuMi4yLjMubG9uZyIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGludCBsZW5ndGhPZkxvbmdlc3RTdWJzdHJpbmcoc3RyaW5nIHMpIHtcbiAgICAgICAgICAgIGludCByZXMgPSAwLCBsZWZ0ID0gMCwgcmlnaHQgPSAwO1xuICAgICAgICAgICAgdW5vcmRlcmVkX3NldDxjaGFyPiBzZXR0aW5nO1xuXG4gICAgICAgICAgICB3aGlsZSAocmlnaHQgPCBzLnNpemUoKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nLmZpbmQoc1tyaWdodF0pICE9IHNldHRpbmcuZW5kKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUobGVmdCA8IHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc1tsZWZ0XSA9PSBzW3JpZ2h0XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmcuZXJhc2Uoc1tsZWZ0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nLmVyYXNlKHNbbGVmdF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXR0aW5nLmluc2VydChzW3JpZ2h0XSk7XG4gICAgICAgICAgICAgICAgcmVzID0gbWF4KHJlcywgcmlnaHQgLSBsZWZ0ICsgMSk7XG4gICAgICAgICAgICAgICAgcmlnaHQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgICBwdWJsaWMgaW50IGxlbmd0aE9mTG9uZ2VzdFN1YnN0cmluZyhTdHJpbmcgcykge1xuICAgICAgICBpbnQgcmVzID0gMCwgbGVmdCA9IDAsIHJpZ2h0ID0gMDtcbiAgICAgICAgU2V0PENoYXJhY3Rlcj4gc2V0ID0gbmV3IEhhc2hTZXQ8PigpO1xuICAgICAgICB3aGlsZSAocmlnaHQgPCBzLmxlbmd0aCgpKSB7XG4gICAgICAgICAgICBpZiAoc2V0LmNvbnRhaW5zKHMuY2hhckF0KHJpZ2h0KSkpXG4gICAgICAgICAgICAgICAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5jaGFyQXQobGVmdCkgPT0gcy5jaGFyQXQocmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQucmVtb3ZlKHMuY2hhckF0KGxlZnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldC5yZW1vdmUocy5jaGFyQXQobGVmdCkpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0Kys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXQuYWRkKHMuY2hhckF0KHJpZ2h0KSk7XG4gICAgICAgICAgICByZXMgPSBNYXRoLm1heChyZXMsIHJpZ2h0IC0gbGVmdCArIDEpO1xuICAgICAgICAgICAgcmlnaHQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgbGVuZ3RoT2Zsb25nZXN0U3Vic3RyaW5nKHNlbGYsIHM6c3RyKS0+aW50OlxuICAgICAgICByZXMsIGxlZnQsIHJpZ2h0ID0gMCwgMCwgMFxuICAgICAgICBzZXR0aW5ncyA9IHNldCgpXG5cbiAgICAgICAgd2hpbGUgcmlnaHQgPCBsZW4ocyk6XG4gICAgICAgICAgICBpZiBzW3JpZ2h0XSBpbiBzZXR0aW5nczpcbiAgICAgICAgICAgICAgICB3aGlsZSBsZWZ0IDwgcmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIHNbbGVmdF0gPT0gc1tyaWdodF06XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5kaXNjYXIoc1tsZWZ0XSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0ICsgMVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmRpc2NhcmQoc1tsZWZ0XSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0ICsgMVxuXG4gICAgICAgICAgICBzZXR0aW5ncy5hZGQoc1tyaWdodF0pXG4gICAgICAgICAgICByZXMgPSBtYXgocmVzLCByaWdodCAtIGxlZnQgKyAxKVxuICAgICAgICAgICAgcmlnaHQgPSByaWdodCArIDFcblxuICAgICAgICByZXR1cm4gcmVzXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTkuMi4yLjQubG9uZyIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGludCBsZW5ndGhPZkxvbmdlc3RTdWJzdHJpbmcoc3RyaW5nIHMpIHtcbiAgICAgICAgICAgIGludCByZXMgPSAwLCBsZWZ0ID0gMCwgcmlnaHQgPSAwO1xuICAgICAgICAgICAgaW50IGNoYXJzZXRbMjU2XSA9IHstMX07XG5cbiAgICAgICAgICAgIHdoaWxlIChyaWdodCA8IHMuc2l6ZSgpICYmIGxlZnQgKyByZXMgPCBzLnNpemUoKSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBtYXgobGVmdCwgY2hhcnNldFtzW3JpZ2h0XV0pO1xuICAgICAgICAgICAgICAgIHJlcyAgPSBtYXgocmVzLCByaWdodCAtIGxlZnQgKyAxKTtcbiAgICAgICAgICAgICAgICBjaGFyc2V0W3NbcmlnaHRdXSA9IHJpZ2h0ICsgMTtcbiAgICAgICAgICAgICAgICByaWdodCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICAgIHB1YmxpYyBpbnQgbGVuZ3RoT2ZMb25nZXN0U3Vic3RyaW5nKFN0cmluZyBzKSB7XG4gICAgICAgIGludCByZXMgPSAwLCBsZWZ0ID0gMCwgcmlnaHQgPSAwO1xuICAgICAgICBNYXA8Q2hhcmFjdGVyLCBJbnRlZ2VyPiBtYXAgPSBuZXcgSGFzaE1hcDw+KCk7XG4gICAgICAgIHdoaWxlIChyaWdodCA8IHMubGVuZ3RoKCkgJiYgbGVmdCA8IHMubGVuZ3RoKCkgLSByZXMpIHtcbiAgICAgICAgICAgIGlmIChtYXAuY29udGFpbnNLZXkocy5jaGFyQXQocmlnaHQpKSlcbiAgICAgICAgICAgICAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCwgbWFwLmdldChzLmNoYXJBdChyaWdodCkpICsgMSk7XG5cbiAgICAgICAgICAgIG1hcC5wdXQocy5jaGFyQXQocmlnaHQpLCByaWdodCk7XG4gICAgICAgICAgICByZXMgPSBNYXRoLm1heChyZXMsIHJpZ2h0IC0gbGVmdCArIDEpO1xuICAgICAgICAgICAgcmlnaHQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgbGVuZ3RoT2ZMb25nZXN0U3Vic3RyaW5nKHNlbGYsIHM6c3RyKS0+aW50OlxuICAgICAgICByZXMsIGxlZnQsIHJpZ2h0ID0gMCwgMCwgMFxuICAgICAgICBkaWMgPSB7fVxuXG4gICAgICAgIHdoaWxlIHJpZ2h0IDwgbGVuKHMpIGFuZCBsZWZ0ICsgcmVzIDwgbGVuKHMpOlxuICAgICAgICAgICAgaWYgc1tyaWdodF0gaW4gZGljOlxuICAgICAgICAgICAgICAgIGxlZnQgPSBtYXgobGVmdCwgZGljW3NbcmlnaHRdXSArIDEpXG5cbiAgICAgICAgICAgIGRpY1tzW3JpZ2h0XV0gPSByaWdodFxuICAgICAgICAgICAgcmVzID0gbWF4KHJlcywgcmlnaHQgLSBsZWZ0ICsgMSlcbiAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQgKyAxXG5cbiAgICAgICAgcmV0dXJuIHJlc1xuXG4iCiAgICB9XQogIH1dCn0sIHsKICAiaWQiOiAiMTAiLAogICJuYW1lIjogIuesrOWNgeeroCIsCiAgImxpc3QiOiBbewogICAgInRpdGxlIjogIuS7o+eggTEwLjEuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICAgIHB1YmxpYzpcbiAgICAgICAgaW50IGNsaW1iU3RhaXJzKGludCBuKSB7XG4gICAgICAgICAgICBpZiAobiA9PSAxKSByZXR1cm4gMTtcblxuICAgICAgICAgICAgaW50IGRwW24gKyAxXTtcbiAgICAgICAgICAgIGRwWzFdID0gMTtcbiAgICAgICAgICAgIGRwWzJdID0gMjtcblxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDM7IGkgPD0gbjsgaSsrKVxuICAgICAgICAgICAgICAgIGRwW2ldID0gZHBbaSAtIDFdICsgZHBbaSAtIDJdO1xuXG4gICAgICAgICAgICByZXR1cm4gZHBbbl07XG4gICAgICAgIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJwYWNrYWdlIGNoMTAuY29kZTtcblxucHVibGljIGNsYXNzIENsaW1iaW5nU3RhaXJzIHtcbiAgICBwdWJsaWMgaW50IGNsaW1iU3RhaXJzKGludCBuKSB7XG4gICAgICAgIGlmIChuIDwgMylcbiAgICAgICAgICAgIHJldHVybiBuO1xuXG4gICAgICAgIGludCBmaXJzdCA9IDEsc2Vjb25kID0gMjtcblxuICAgICAgICBmb3IgKGludCBpID0gMzsgaSA8IG4gKyAxOyBpKyspIHtcbiAgICAgICAgICAgIHNlY29uZCA9IGZpcnN0ICsgc2Vjb25kO1xuICAgICAgICAgICAgZmlyc3QgPSBzZWNvbmQgLSBmaXJzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2Vjb25kO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGNsaW1iU3RhaXJzKHNlbGYsIG46IGludCkgLT4gaW50OlxuICAgICAgICBpZiBuIDwgMjpcbiAgICAgICAgICAgIHJldHVybiBuXG4gICAgICAgIGRwID0gWzBdICogKG4gKyAxKVxuICAgICAgICBkcFsxXSwgZHBbMl0gPSAxLCAyXG4gICAgICAgIGZvciBpIGluIHJhbmdlKDMsIG4gKyAxKTpcbiAgICAgICAgICAgIGRwW2ldID0gZHBbaSAtIDFdICsgZHBbaSAtIDJdXG4gICAgICAgIHJldHVybiBkcFtuXVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExMC4xLjIiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgICBwdWJsaWM6XG4gICAgICAgIGludCBjbGltYlN0YWlycyhpbnQgbikge1xuICAgICAgICAgICAgaWYgKG4gPCAyKSByZXR1cm4gbjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaW50IGZpcnN0ICA9IDE7XG4gICAgICAgICAgICBpbnQgc2Vjb25kID0gMjtcblxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDM7IGkgPCBuICsgMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2Vjb25kID0gZmlyc3QgKyBzZWNvbmQ7XG4gICAgICAgICAgICAgICAgZmlyc3QgID0gc2Vjb25kIC0gZmlyc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWNvbmQ7XG4gICAgICAgIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJwYWNrYWdlIGNoMTAuY29kZTtcblxucHVibGljIGNsYXNzIENsaW1iaW5nU3RhaXJzIHtcbiAgICBwdWJsaWMgaW50IGNsaW1iU3RhaXJzKGludCBuKSB7XG4gICAgICAgIGlmIChuIDwgMylcbiAgICAgICAgICAgIHJldHVybiBuO1xuXG4gICAgICAgIGludFtdIGRwID0gbmV3IGludFtuICsgMV07XG4gICAgICAgIGRwWzFdID0gMTtcbiAgICAgICAgZHBbMl0gPSAyO1xuICAgICAgICBmb3IgKGludCBpID0gMzsgaSA8IG4rMTsgaSsrKSB7XG4gICAgICAgICAgICBkcFtpXSA9IGRwW2kgLSAxXSArIGRwW2kgLSAyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHBbbl07XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgY2xpbWJTdGFpcnMoc2VsZiwgbjogaW50KSAtPiBpbnQ6XG4gICAgICAgIGlmIG4gPCAyOlxuICAgICAgICAgICAgcmV0dXJuIG5cbiAgICAgICAgZmlyc3QsIHNlY29uZCA9IDEsIDJcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMywgbiArIDEpOlxuICAgICAgICAgICAgIyB0aGlyZCA9IGZpcnN0ICsgc2Vjb25kXG4gICAgICAgICAgICAjIGZpcnN0ID0gc2Vjb25kXG4gICAgICAgICAgICAjIHNlY29uZCA9IHRoaXJkXG4gICAgICAgICAgICBzZWNvbmQgPSBmaXJzdCArIHNlY29uZFxuICAgICAgICAgICAgZmlyc3QgPSBzZWNvbmQgLSBmaXJzdFxuICAgICAgICByZXR1cm4gc2Vjb25kXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTEwLjIuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI2luY2x1ZGU8aW9zdHJlYW0+XG4jaW5jbHVkZTx2ZWN0b3I+XG4jaW5jbHVkZTxhbGdvcml0aG0+XG5cbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgICBpbnQgaGVscGVyKHZlY3RvcjxpbnQ+JiBudW1zLCBpbnQgc3RhcnQpIHtcbiAgICAgICAgaWYoc3RhcnQgPj0gbnVtcy5zaXplKCkpIHJldHVybiAwO1xuXG4gICAgICAgIHJldHVybiBtYXgoaGVscGVyKG51bXMsIHN0YXJ0KzEpLCBudW1zW3N0YXJ0XSArIGhlbHBlcihudW1zLCBzdGFydCsyKSk7XG4gICAgfVxuICAgIGludCByb2IodmVjdG9yPGludD4mIG51bXMpIHtcbiAgICAgICAgcmV0dXJuIGhlbHBlcihudW1zLCAwKTtcbiAgICB9XG59O1xuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgICBwdWJsaWMgaW50IGhlbHBlcihpbnRbXSBudW1zLCBpbnQgc3RhcnQpIHtcbiAgICAgICAgaWYoc3RhcnQgPj0gbnVtcy5sZW5ndGgpIHJldHVybiAwO1xuXG4gICAgICAgIHJldHVybiBNYXRoLm1heChoZWxwZXIobnVtcywgc3RhcnQrMSksIG51bXNbc3RhcnRdICsgaGVscGVyKG51bXMsIHN0YXJ0KzIpKTtcbiAgICB9XG4gICAgcHVibGljIGludCByb2IoaW50W10gbnVtcykge1xuICAgICAgICByZXR1cm4gaGVscGVyKG51bXMsIDApO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZnJvbSB0eXBpbmcgaW1wb3J0IExpc3RcblxuXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgcm9iKHNlbGYsIG51bXM6IExpc3RbaW50XSkgLT4gaW50OlxuICAgICAgICBpZiBsZW4obnVtcykgPD0gMDpcbiAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIHJldHVybiBtYXgoc2VsZi5yb2IobnVtc1sxOl0pLCBudW1zWzBdICsgc2VsZi5yb2IobnVtc1syOl0pKVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExMC4yLjIiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlPGlvc3RyZWFtPlxuI2luY2x1ZGU8dmVjdG9yPlxuI2luY2x1ZGU8YWxnb3JpdGhtPlxuXG51c2luZyBuYW1lc3BhY2Ugc3RkO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgaW50IGhlbHBlcih2ZWN0b3I8aW50PiYgbnVtcywgdmVjdG9yPGludD4mbWVtbywgaW50IHN0YXJ0KSB7XG4gICAgICAgIGlmKHN0YXJ0ID49IG51bXMuc2l6ZSgpKSByZXR1cm4gMDtcbiAgICAgICAgaWYobWVtb1tzdGFydF0gIT0gLTEpIHJldHVybiBtZW1vW3N0YXJ0XTtcblxuICAgICAgICBtZW1vW3N0YXJ0XSA9IG1heChoZWxwZXIobnVtcywgbWVtbywgc3RhcnQrMSksIG51bXNbc3RhcnRdICsgaGVscGVyKG51bXMsIG1lbW8sIHN0YXJ0KzIpKTtcblxuICAgICAgICByZXR1cm4gbWVtb1tzdGFydF07XG4gICAgfVxuICAgIGludCByb2IodmVjdG9yPGludD4mIG51bXMpIHtcbiAgICAgICAgdmVjdG9yPGludD4gbWVtbyhudW1zLnNpemUoKSwgLTEpO1xuICAgICAgICByZXR1cm4gaGVscGVyKG51bXMsIG1lbW8sIDApO1xuICAgIH1cbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICAgIHB1YmxpYyBpbnQgaGVscGVyKGludFtdIG51bXMsIGludFtdIG1lbW8sIGludCBzdGFydCkge1xuICAgICAgICBpZihzdGFydCA+PSBudW1zLmxlbmd0aCkgcmV0dXJuIDA7XG4gICAgICAgIGlmKG1lbW9bc3RhcnRdICE9IC0xKSByZXR1cm4gbWVtb1tzdGFydF07XG5cbiAgICAgICAgbWVtb1tzdGFydF0gPSBNYXRoLm1heChoZWxwZXIobnVtcywgbWVtbywgc3RhcnQrMSksIG51bXNbc3RhcnRdICsgaGVscGVyKG51bXMsbWVtbywgIHN0YXJ0KzIpKTtcblxuICAgICAgICByZXR1cm4gbWVtb1tzdGFydF07XG4gICAgfVxuICAgIHB1YmxpYyBpbnQgcm9iKGludFtdIG51bXMpIHtcbiAgICAgICAgaW50W10gbWVtbyA9IG5ldyBpbnRbbnVtcy5sZW5ndGhdO1xuXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykgbWVtb1tpXSA9IC0xO1xuICAgICAgICByZXR1cm4gaGVscGVyKG51bXMsIG1lbW8sIDApO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZnJvbSB0eXBpbmcgaW1wb3J0IExpc3RcblxuXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgcm9iKHNlbGYsIG51bXM6IExpc3RbaW50XSkgLT4gaW50OlxuICAgICAgICBtZW1vID0gWy0xIGZvciB4IGluIHJhbmdlKGxlbihudW1zKSArIDEpXVxuICAgICAgICBtZW1vWy0xXSA9IDBcblxuICAgICAgICByZXR1cm4gc2VsZi5oZWxwZXIoMCwgbnVtcywgbWVtbylcblxuICAgIGRlZiBoZWxwZXIoc2VsZiwgbjogaW50LCBudW1zOiBMaXN0W2ludF0sIG1lbW86IExpc3RbaW50XSkgLT4gaW50OlxuICAgICAgICBpZiBuID49IGxlbihudW1zKTpcbiAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIGlmIG1lbW9bbl0gIT0gLTE6XG4gICAgICAgICAgICByZXR1cm4gbWVtb1tuXVxuXG4gICAgICAgIG1lbW9bbl0gPSBtYXgoXG4gICAgICAgICAgICBzZWxmLmhlbHBlcihuICsgMSwgbnVtcywgbWVtbyksIHNlbGYuaGVscGVyKG4gKyAyLCBudW1zLCBtZW1vKSArIG51bXNbbl0sXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIG1lbW9bbl1cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTAuMi4zIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZTxpb3N0cmVhbT5cbiNpbmNsdWRlPHZlY3Rvcj5cbiNpbmNsdWRlPGFsZ29yaXRobT5cblxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGludCByb2IodmVjdG9yPGludD4mIG51bXMpIHtcbiAgICAgICAgaWYobnVtcy5zaXplKCkgPD0gMCkgcmV0dXJuIDA7XG5cbiAgICAgICAgdmVjdG9yPGludD4gbWVtbyhudW1zLnNpemUoKSsxKTtcblxuICAgICAgICBtZW1vW251bXMuc2l6ZSgpLTFdID0gbnVtc1tudW1zLnNpemUoKS0xXTtcblxuICAgICAgICBmb3IoaW50IGkgPSBudW1zLnNpemUoKS0yOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbWVtb1tpXSA9IG1heChtZW1vW2krMV0sIG1lbW9baSsyXSArIG51bXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vWzBdO1xuICAgIH1cbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuXG4gICAgcHVibGljIGludCByb2IoaW50W10gbnVtcykge1xuICAgICAgICBpZihudW1zLmxlbmd0aCA8PSAwKSByZXR1cm4gMDtcblxuICAgICAgICBpbnRbXSBtZW1vID0gbmV3IGludFtudW1zLmxlbmd0aCsxXTtcbiAgICAgICAgbWVtb1tudW1zLmxlbmd0aC0xXSA9IG51bXNbbnVtcy5sZW5ndGgtMV07XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IG51bXMubGVuZ3RoLTI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBtZW1vW2ldID0gTWF0aC5tYXgobWVtb1tpKzFdLCBtZW1vW2krMl0rbnVtc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW9bMF07XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiByb2Ioc2VsZiwgbnVtczogTGlzdFtpbnRdKSAtPiBpbnQ6XG4gICAgICAgIGlmIG5vdCBudW1zOlxuICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgbWVtbyA9IFswIGZvciB4IGluIHJhbmdlKGxlbihudW1zKSArIDEpXVxuICAgICAgICBtZW1vWy0yXSA9IG51bXNbLTFdXG5cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UobGVuKG51bXMpIC0gMiwgLTEsIC0xKTpcbiAgICAgICAgICAgIG1lbW9baV0gPSBtYXgobWVtb1tpICsgMV0sIG1lbW9baSArIDJdICsgbnVtc1tpXSlcblxuICAgICAgICByZXR1cm4gbWVtb1swXVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExMC4yLjQiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlPGlvc3RyZWFtPlxuI2luY2x1ZGU8dmVjdG9yPlxuI2luY2x1ZGU8YWxnb3JpdGhtPlxuXG51c2luZyBuYW1lc3BhY2Ugc3RkO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgaW50IHJvYih2ZWN0b3I8aW50PiYgbnVtcykge1xuICAgICAgICBpZihudW1zLnNpemUoKSA8PSAwKSByZXR1cm4gMDtcblxuICAgICAgICBpbnQgcHJldiwgY3VycjtcblxuICAgICAgICBmb3IoaW50IGkgPSBudW1zLnNpemUoKS0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaW50IHRtcCA9IGN1cnI7XG4gICAgICAgICAgICBjdXJyID0gbWF4KGN1cnIsIG51bXNbaV0gKyBwcmV2KTtcbiAgICAgICAgICAgIHByZXYgPSB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnI7XG4gICAgfVxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5cbiAgICBwdWJsaWMgaW50IHJvYihpbnRbXSBudW1zKSB7XG4gICAgICAgIGlmKG51bXMubGVuZ3RoIDw9IDApIHJldHVybiAwO1xuXG4gICAgICAgIGludCBwcmV2ID0gMCwgY3VyciA9IDA7XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IG51bXMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpbnQgdG1wID0gY3VycjtcbiAgICAgICAgICAgIGN1cnIgPSBNYXRoLm1heChjdXJyLCBudW1zW2ldICsgcHJldik7XG4gICAgICAgICAgICBwcmV2ID0gdG1wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZnJvbSB0eXBpbmcgaW1wb3J0IExpc3RcblxuXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgcm9iKHNlbGYsIG51bXM6IExpc3RbaW50XSkgLT4gaW50OlxuXG4gICAgICAgIHByZXYgPSAwXG4gICAgICAgIGN1cnIgPSAwXG5cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UobGVuKG51bXMpIC0gMSwgLTEsIC0xKTpcbiAgICAgICAgICAgIHRlbXAgPSBjdXJyXG4gICAgICAgICAgICBjdXJyID0gbWF4KGN1cnIsIG51bXNbaV0gKyBwcmV2KVxuICAgICAgICAgICAgcHJldiA9IHRlbXBcblxuICAgICAgICByZXR1cm4gY3VyclxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExMC4yLjUiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlPGlvc3RyZWFtPlxuI2luY2x1ZGU8dmVjdG9yPlxuI2luY2x1ZGU8YWxnb3JpdGhtPlxuXG51c2luZyBuYW1lc3BhY2Ugc3RkO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgaW50IHJvYih2ZWN0b3I8aW50PiYgbnVtcykge1xuICAgICAgICBpZihudW1zLnNpemUoKSA9PSAxKSByZXR1cm4gbnVtc1swXTtcblxuICAgICAgICBpbnQgcHJldiA9IDAsIGN1cnIgPSAwO1xuXG4gICAgICAgIGZvcihpbnQgaSA9IDA7IGkgPCBudW1zLnNpemUoKS0xOyBpKyspIHtcbiAgICAgICAgICAgIGludCB0bXAgPSBjdXJyO1xuICAgICAgICAgICAgY3VyciA9IG1heChjdXJyLCBudW1zW2ldICsgcHJldik7XG4gICAgICAgICAgICBwcmV2ID0gdG1wO1xuICAgICAgICB9IFxuICAgICAgICBpbnQgcmVzID0gY3VycjtcblxuICAgICAgICBwcmV2ID0gMDtcbiAgICAgICAgY3VyciA9IDA7XG5cbiAgICAgICAgZm9yKGludCBpID0gMTsgaSA8IG51bXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgICAgIGludCB0bXAgPSBjdXJyO1xuICAgICAgICAgICAgY3VyciA9IG1heChjdXJyLCBudW1zW2ldICsgcHJldik7XG4gICAgICAgICAgICBwcmV2ID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1heChyZXMsIGN1cnIpO1xuICAgIH1cbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICAgIHB1YmxpYyBpbnQgcm9iKGludFtdIG51bXMpIHtcbiAgICAgICAgaWYobnVtcy5sZW5ndGggPT0gMSkgcmV0dXJuIG51bXNbMF07XG5cbiAgICAgICAgaW50IHByZXYgPSAwLCBjdXJyID0gMDtcblxuICAgICAgICBmb3IoaW50IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGludCB0bXAgPSBjdXJyO1xuICAgICAgICAgICAgY3VyciA9IE1hdGgubWF4KGN1cnIsIG51bXNbaV0gKyBwcmV2KTtcbiAgICAgICAgICAgIHByZXYgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICBpbnQgcmVzID0gY3VycjtcblxuICAgICAgICBwcmV2ID0gMDtcbiAgICAgICAgY3VyciA9IDA7XG5cbiAgICAgICAgZm9yKGludCBpID0gMTsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGludCB0bXAgPSBjdXJyO1xuICAgICAgICAgICAgY3VyciA9IE1hdGgubWF4KGN1cnIsIG51bXNbaV0gKyBwcmV2KTtcbiAgICAgICAgICAgIHByZXYgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWF0aC5tYXgocmVzLCBjdXJyKTtcbiAgICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImZyb20gdHlwaW5nIGltcG9ydCBMaXN0XG5cblxuY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHJvYihzZWxmLCBudW1zOiBMaXN0W2ludF0pIC0+IGludDpcbiAgICAgICAgaWYgbGVuKG51bXMpID09IDE6XG4gICAgICAgICAgICByZXR1cm4gbnVtc1swXVxuICAgICAgICBwcmV2ID0gMFxuICAgICAgICBjdXJyID0gMFxuXG4gICAgICAgIGZvciBpIGluIHJhbmdlKGxlbihudW1zKSAtIDEpOlxuICAgICAgICAgICAgdGVtcCA9IGN1cnJcbiAgICAgICAgICAgIGN1cnIgPSBtYXgoY3VyciwgbnVtc1tpXSArIHByZXYpXG4gICAgICAgICAgICBwcmV2ID0gdGVtcFxuXG4gICAgICAgIHJlcyA9IGN1cnJcblxuICAgICAgICBwcmV2ID0gMFxuICAgICAgICBjdXJyID0gMFxuXG4gICAgICAgIGZvciBpIGluIHJhbmdlKDEsIGxlbihudW1zKSk6XG4gICAgICAgICAgICB0ZW1wID0gY3VyclxuICAgICAgICAgICAgY3VyciA9IG1heChjdXJyLCBudW1zW2ldICsgcHJldilcbiAgICAgICAgICAgIHByZXYgPSB0ZW1wXG5cbiAgICAgICAgcmV0dXJuIG1heChyZXMsIGN1cnIpXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTEwLjMuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI2luY2x1ZGUgPGNzdGRsaWI+XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgaW50IHVuaXF1ZVBhdGhzKGludCBtLCBpbnQgbikge1xuICAgIGludCAqKmQgPSAoaW50ICoqKW1hbGxvYyhtICogc2l6ZW9mKGludCAqKSk7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgIGRbaV0gPSAoaW50ICopbWFsbG9jKG4gKiBzaXplb2YoaW50KSk7XG4gICAgICBmb3IgKGludCBqID0gMDsgaiA8IG47IGorKykgZFtpXVtqXSA9IDE7XG4gICAgfVxuICAgIGZvciAoaW50IGNvbCA9IDE7IGNvbCA8IG07IGNvbCsrKVxuICAgICAgZm9yIChpbnQgcm93ID0gMTsgcm93IDwgbjsgcm93KyspXG4gICAgICAgIGRbY29sXVtyb3ddID0gZFtjb2wgLSAxXVtyb3ddICsgZFtjb2xdW3JvdyAtIDFdO1xuICAgIGludCBhbnMgPSBkW20gLSAxXVtuIC0gMV07XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBtOyBpKyspIGZyZWUoZFtpXSk7XG4gICAgZnJlZShkKTtcbiAgICByZXR1cm4gYW5zO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGludCB1bmlxdWVQYXRocyhpbnQgbSwgaW50IG4pIHtcbiAgICBpbnRbXVtdIGQgPSBuZXcgaW50W21dW25dO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbTsgaSsrKVxuICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBuOyBqKyspIGRbaV1bal0gPSAxO1xuICAgIGZvciAoaW50IGNvbCA9IDE7IGNvbCA8IG07IGNvbCsrKVxuICAgICAgZm9yIChpbnQgcm93ID0gMTsgcm93IDwgbjsgcm93KyspXG4gICAgICAgIGRbY29sXVtyb3ddID0gZFtjb2wgLSAxXVtyb3ddICsgZFtjb2xdW3JvdyAtIDFdO1xuICAgIHJldHVybiBkW20gLSAxXVtuIC0gMV07XG4gIH1cbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgdW5pcXVlUGF0aHMoc2VsZiwgbTogaW50LCBuOiBpbnQpIC0+IGludDpcbiAgICAgICAgZCA9IFtbMV0gKiBuIGZvciBfIGluIHJhbmdlKG0pXVxuXG4gICAgICAgIGZvciBjb2wgaW4gcmFuZ2UoMSwgbSk6XG4gICAgICAgICAgICBmb3Igcm93IGluIHJhbmdlKDEsIG4pOlxuICAgICAgICAgICAgICAgIGRbY29sXVtyb3ddID0gZFtjb2wgLSAxXVtyb3ddICsgZFtjb2xdW3JvdyAtIDFdXG5cbiAgICAgICAgcmV0dXJuIGRbbSAtIDFdW24gLSAxXVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExMC4zLjIiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDxjc3RkbGliPlxuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIGludCB1bmlxdWVQYXRocyhpbnQgbSwgaW50IG4pIHtcbiAgICBpbnQgKmRwID0gKGludCAqKW1hbGxvYyhuICogc2l6ZW9mKGludCkpO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKSBkcFtpXSA9IDE7XG4gICAgZm9yIChpbnQgaSA9IDE7IGkgPCBtOyBpKyspXG4gICAgICBmb3IgKGludCBqID0gMTsgaiA8IG47IGorKylcbiAgICAgICAgZHBbal0gKz0gZHBbaiAtIDFdO1xuICAgIGludCBhbnMgPSBkcFtuIC0gMV07XG4gICAgZnJlZShkcCk7XG4gICAgcmV0dXJuIGFucztcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogInB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBpbnQgdW5pcXVlUGF0aHMoaW50IG0sIGludCBuKSB7XG4gICAgaW50W10gZHAgPSBuZXcgaW50W25dO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKSBkcFtpXSA9IDE7XG4gICAgZm9yIChpbnQgaSA9IDE7IGkgPCBtOyBpKyspXG4gICAgICBmb3IgKGludCBqID0gMTsgaiA8IG47IGorKylcbiAgICAgICAgZHBbal0gKz0gZHBbaiAtIDFdO1xuICAgIHJldHVybiBkcFtuIC0gMV07XG4gIH1cbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgdW5pcXVlUGF0aHMoc2VsZiwgbTogaW50LCBuOiBpbnQpIC0+IGludDpcbiAgICAgICAgZHAgPSBbMV0gKiBuXG4gICAgICAgIGZvciBfIGluIHJhbmdlKDEsIG0pOlxuICAgICAgICAgICAgZm9yIGogaW4gcmFuZ2UoMSwgbik6XG4gICAgICAgICAgICAgICAgZHBbal0gKz0gZHBbaiAtIDFdXG4gICAgICAgIHJldHVybiBkcFtuIC0gMV1cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTAuMy4zIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8dXRpbGl0eT5cbiNpbmNsdWRlIDxtYXA+XG51c2luZyBuYW1lc3BhY2Ugc3RkO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIG1hcDxwYWlyPGludCwgaW50PiwgaW50PiB2aXNpdGVkO1xuICBpbnQgdW5pcXVlUGF0aHMoaW50IG0sIGludCBuKSB7XG4gICAgaWYgKHZpc2l0ZWQuY291bnQobWFrZV9wYWlyKG0sIG4pKSlcbiAgICAgIHJldHVybiB2aXNpdGVkW21ha2VfcGFpcihtLCBuKV07XG4gICAgaWYgKG0gPT0gMSB8fCBuID09IDEpIHJldHVybiAxO1xuICAgIGludCBjbnQgPSB1bmlxdWVQYXRocyhtIC0gMSwgbikgKyBcXFxuICAgICAgICAgICAgICB1bmlxdWVQYXRocyhtLCBuIC0gMSk7XG4gICAgcmV0dXJuIHZpc2l0ZWRbbWFrZV9wYWlyKG0sIG4pXSA9IGNudDtcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBqYXZhLnV0aWwuKjtcblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGNsYXNzIFBhaXIge1xuICAgIHB1YmxpYyBmaW5hbCBpbnQgZmlyc3Q7XG4gICAgcHVibGljIGZpbmFsIGludCBzZWNvbmQ7XG4gICAgcHVibGljIFBhaXIoaW50IHgsIGludCB5KSB7XG4gICAgICB0aGlzLmZpcnN0ID0geDtcbiAgICAgIHRoaXMuc2Vjb25kID0geTtcbiAgICB9XG4gIH1cbiAgcHVibGljIFBhaXIgbWFrZV9wYWlyKGludCB4LCBpbnQgeSkge1xuICAgIFBhaXIgYnVmID0gbmV3IFBhaXIoeCwgeSk7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuICBwdWJsaWMgTWFwPFBhaXIsIEludGVnZXI+IHZpc2l0ZWQ7XG4gIHB1YmxpYyBTb2x1dGlvbigpIHtcbiAgICB0aGlzLnZpc2l0ZWQgPSBuZXcgSGFzaE1hcDxQYWlyLCBJbnRlZ2VyPigpO1xuICB9XG4gIGludCB1bmlxdWVQYXRocyhpbnQgbSwgaW50IG4pIHtcbiAgICBpZiAodmlzaXRlZC5nZXQobWFrZV9wYWlyKG0sIG4pKSAhPSBudWxsKVxuICAgICAgcmV0dXJuIHZpc2l0ZWQuZ2V0KG1ha2VfcGFpcihtLCBuKSk7XG4gICAgaWYgKG0gPT0gMSB8fCBuID09IDEpIHJldHVybiAxO1xuICAgIGludCBjbnQgPSB1bmlxdWVQYXRocyhtIC0gMSwgbikgK1xuICAgICAgdW5pcXVlUGF0aHMobSwgbiAtIDEpO1xuICAgIHZpc2l0ZWQucHV0KG1ha2VfcGFpcihtLCBuKSwgY250KTtcbiAgICByZXR1cm4gY250O1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgdmlzaXRlZCA9IGRpY3QoKVxuXG4gICAgZGVmIHVuaXF1ZVBhdGhzKHNlbGYsIG06IGludCwgbjogaW50KSAtPiBpbnQ6XG4gICAgICAgIGlmIChtLCBuKSBpbiBzZWxmLnZpc2l0ZWQ6XG4gICAgICAgICAgICByZXR1cm4gc2VsZi52aXNpdGVkWyhtLCBuKV1cbiAgICAgICAgaWYgbSA9PSAxIG9yIG4gPT0gMTpcbiAgICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIGNudCA9IHNlbGYudW5pcXVlUGF0aHMobSAtIDEsIG4pICsgc2VsZi51bmlxdWVQYXRocyhtLCBuIC0gMSlcbiAgICAgICAgc2VsZi52aXNpdGVkWyhtLCBuKV0gPSBjbnRcbiAgICAgICAgcmV0dXJuIGNudFxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExMC40LjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgICBpbnQgY29pbkNoYW5nZSh2ZWN0b3I8aW50PiYgY29pbnMsIGludCBhbW91bnQpIHtcbiAgICAgICAgaW50IE1heCA9IGFtb3VudCArIDE7XG4gICAgICAgIHZlY3RvcjxpbnQ+IGRwKGFtb3VudCArIDEsIE1heCk7XG4gICAgICAgIGRwWzBdID0gMDtcbiAgICAgICAgXG4gICAgICAgIGZvciAoaW50IGkgPSAxOyBpIDw9IGFtb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IGNvaW5zLnNpemUoKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvaW5zW2pdIDw9IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZHBbaV0gPSBtaW4oZHBbaV0sIGRwW2kgLSBjb2luc1tqXV0gKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBkcFthbW91bnRdID4gYW1vdW50ID8gLTEgOiBkcFthbW91bnRdO1xuICAgIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJpbXBvcnQgamF2YS51dGlsLkFycmF5cztcbnB1YmxpYyBjbGFzcyBDb2luQ2hhbmdlIHtcbiAgICBwdWJsaWMgaW50IGNvaW5DaGFuZ2UoaW50W10gY29pbnMsIGludCBhbW91bnQpIHtcbiAgICAgICAgaWYgKGFtb3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgaW50W10gZHAgPSBuZXcgaW50W2Ftb3VudCArIDFdO1xuICAgICAgICBBcnJheXMuZmlsbChkcCwgYW1vdW50ICsgMSk7XG4gICAgICAgIGRwWzBdID0gMDtcblxuICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IGFtb3VudCArIDE7IGkrKykge1xuICAgICAgICAgICAgZm9yIChpbnQgY29pbiA6IGNvaW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvaW4gPD0gaSkge1xuICAgICAgICAgICAgICAgICAgICBkcFtpXSA9IE1hdGgubWluKGRwW2ldLCBkcFtpIC0gY29pbl0gKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRwW2Ftb3VudF0gPT0gYW1vdW50ICsgMSA/IC0xIDogZHBbYW1vdW50XTtcbiAgICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImZyb20gdHlwaW5nIGltcG9ydCBMaXN0XG5cblxuY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGNvaW5DaGFuZ2Uoc2VsZiwgY29pbnM6IExpc3RbaW50XSwgYW1vdW50OiBpbnQpIC0+IGludDpcbiAgICAgICAgaWYgYW1vdW50ID09IDA6XG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICAjIHVzZSBhbW91bnQgKyAxIHRvIGluZGljYXRlIGJpZ2dlciB0aGFuIGFueVxuICAgICAgICBkcCA9IFthbW91bnQgKyAxXSAqIChhbW91bnQgKyAxKVxuICAgICAgICBkcFswXSA9IDBcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMSwgYW1vdW50ICsgMSk6XG4gICAgICAgICAgICBmb3IgY29pbiBpbiBjb2luczpcbiAgICAgICAgICAgICAgICBpZiBjb2luIDw9IGk6XG4gICAgICAgICAgICAgICAgICAgIGRwW2ldID0gbWluKGRwW2ldLCBkcFtpIC0gY29pbl0gKyAxKVxuICAgICAgICByZXR1cm4gLTEgaWYgZHBbYW1vdW50XSA9PSAoYW1vdW50ICsgMSkgZWxzZSBkcFthbW91bnRdXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTEwLjQuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGludCBjaGFuZ2UoaW50IGFtb3VudCwgdmVjdG9yPGludD4mIGNvaW5zKSB7XG4gICAgICAgIHZlY3RvcjxpbnQ+IGRwKGFtb3VudCArIDEsIDApO1xuICAgICAgICBkcFswXSAgPSAxO1xuICAgICAgICBcbiAgICAgICAgZm9yIChpbnQgY29pbjogY29pbnMpIHtcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSBjb2luOyBpIDwgYW1vdW50ICsgMTsgaSsrKVxuICAgICAgICAgICAgICAgIGRwW2ldICs9IGRwW2kgLSBjb2luXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGRwW2Ftb3VudF07XG4gICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBqYXZhLnV0aWwuQXJyYXlzO1xuXG5wdWJsaWMgY2xhc3MgQ29pbkNoYW5nZTIge1xuICAgIHB1YmxpYyBpbnQgY2hhbmdlKGludCBhbW91bnQsIGludFtdIGNvaW5zKSB7XG4gICAgICAgIGludFtdIGRwID0gbmV3IGludFthbW91bnQgKyAxXTtcbiAgICAgICAgZHBbMF0gPSAxO1xuICAgICAgICBmb3IgKGludCBjb2luIDogY29pbnMpIHtcbiAgICAgICAgICAgIGlmIChjb2luID4gYW1vdW50KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChpbnQgaSA9IGNvaW47IGkgPCBhbW91bnQgKyAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkcFtpXSArPSBkcFtpIC0gY29pbl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRwW2Ftb3VudF07XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBjaGFuZ2Uoc2VsZiwgYW1vdW50OiBpbnQsIGNvaW5zOiBMaXN0W2ludF0pIC0+IGludDpcbiAgICAgICAgZHAgPSBbMF0gKiAoYW1vdW50ICsgMSlcbiAgICAgICAgZHBbMF0gPSAxXG4gICAgICAgIGZvciBjb2luIGluIGNvaW5zOlxuICAgICAgICAgICAgZm9yIHggaW4gcmFuZ2UoY29pbiwgYW1vdW50ICsgMSk6XG4gICAgICAgICAgICAgICAgZHBbeF0gKz0gZHBbeCAtIGNvaW5dXG4gICAgICAgIHJldHVybiBkcFthbW91bnRdXG5cbiIKICAgIH1dCiAgfV0KfSwgewogICJpZCI6ICIxMSIsCiAgIm5hbWUiOiAi56ys5Y2B5LiA56ugIiwKICAibGlzdCI6IFt7CiAgICAidGl0bGUiOiAi5Luj56CBMTEuMS4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgdmVjdG9yPGludD4gbWF4U2xpZGluZ1dpbmRvdyh2ZWN0b3I8aW50PiYgbnVtcywgaW50IGspIHtcbiAgICAgICAgdmVjdG9yPGludD4gcmVzID0ge307XG4gICAgICAgIFxuICAgICAgICBpbnQgbGVuZ3RoID0gbnVtcy5zaXplKCk7XG4gICAgICAgIGlmIChsZW5ndGggKiBrID09IDApXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICBcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBsZW5ndGggLSBrICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBpbnQgbWF4X3ZhbCA9IElOVF9NSU47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAoaW50IGogPSBpOyBqIDwgaSArIGs7IGorKykge1xuICAgICAgICAgICAgICAgIG1heF92YWwgPSBtYXgobWF4X3ZhbCwgbnVtc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJlcy5wdXNoX2JhY2sobWF4X3ZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgICBwdWJsaWMgaW50W10gbWF4U2xpZGluZ1dpbmRvdyhpbnRbXSBudW1zLCBpbnQgaykge1xuICAgICAgICBpZiAoayA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG51bXM7XG4gICAgICAgIGludCB0dXJuID0gbnVtcy5sZW5ndGggLSBrICsgMTtcbiAgICAgICAgaW50W10gcmVzID0gbmV3IGludFt0dXJuXTtcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB0dXJuOyBpKyspIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IGdldE1heChudW1zLCBpLCBrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIHByaXZhdGUgaW50IGdldE1heChpbnRbXSBudW1zLCBpbnQgbGVmdCwgaW50IGspIHtcbiAgICAgICAgaW50IG1heCA9IG51bXNbbGVmdF07XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgay0xOyBpKyspIHtcbiAgICAgICAgICAgIGxlZnQrKztcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgbnVtc1tsZWZ0XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBtYXhTbGlkaW5nV2luZG93KHNlbGYsIG51bXM6TGlzdFtpbnRdLCBrOmludCktPkxpc3RbaW50XTpcbiAgICAgICAgbGVuZ3RoID0gbGVuKG51bXMpXG4gICAgICAgIGlmIGxlbmd0aCAqIGsgPT0gMDpcbiAgICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICAgICAgXG4gICAgICAgIG91dHB1dCA9IFtdXG4gICAgICAgICMg6YGN5Y6G5omA5pyJ5Y+v6IO955qE56qX5Y+jXG4gICAgICAgIGZvciBpIGluIHJhbmdlKGxlbmd0aCAtIGsgKyAxKTpcbiAgICAgICAgICAgIG1heF92YWwgPSAtc3lzLm1heHNpemUgLSAxXG4gICAgICAgICAgICAjIOaJvuWIsOS4gOS4queql+WPo+S4reeahOacgOWkp+WAvFxuICAgICAgICAgICAgZm9yIGogaW4gcmFuZ2UoaSwgaSArIGspOlxuICAgICAgICAgICAgICAgIG1heF92YWwgPSBtYXgobWF4X3ZhbCwgbnVtc1tqXSlcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICMg5bCG5pyA5aSn5YC85pS+5Yiw5pWw57uE5YiX6KGo6YeMXG4gICAgICAgICAgICBvdXRwdXQuYXBwZW5kKG1heF92YWwpXG4gICAgICAgICAgICBcbiAgICAgICAgcmV0dXJuIG91dHB1dFxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExMS4xLjIiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgICB2ZWN0b3I8aW50PiBtYXhTbGlkaW5nV2luZG93KHZlY3RvcjxpbnQ+JiBudW1zLCBpbnQgaykge1xuICAgICAgICB2ZWN0b3I8aW50PiByZXM7XG4gICAgICAgIG11bHRpc2V0PGludD4gbXlzZXR0aW5nO1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IG51bXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgICAgIG15c2V0dGluZy5pbnNlcnQobnVtc1tpXSk7XG4gICAgICAgICAgICBpZiAoaSA+PSBrIC0gMSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoX2JhY2soKm15c2V0dGluZy5yYmVnaW4oKSk7XG4gICAgICAgICAgICAgICAgbXlzZXR0aW5nLmVyYXNlKG15c2V0dGluZy5maW5kKG51bXNbaSAtIGsgKyAxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgICBwdWJsaWMgaW50W10gbWF4U2xpZGluZ1dpbmRvdyhpbnRbXSBudW1zLCBpbnQgaykge1xuICAgICAgICBpZiAoayA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG51bXM7XG4gICAgICAgIGludFtdIHJlcyA9IG5ldyBpbnRbbnVtcy5sZW5ndGggLSBrICsgMV07XG5cbiAgICAgICAgRGVxdWU8SW50ZWdlcj4gcXVldWUgPSBuZXcgTGlua2VkTGlzdDw+KCk7XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyDku47lsL7pg6jlvIDlp4vnp7vpmaTmr5TmlrDliqDlhaXlhYPntKDlsI/nmoTlhYPntKBcbiAgICAgICAgICAgIHdoaWxlICghcXVldWUuaXNFbXB0eSgpICYmIG51bXNbcXVldWUuZ2V0TGFzdCgpXSA8IG51bXNbaV0pXG4gICAgICAgICAgICAgICAgcXVldWUucmVtb3ZlTGFzdCgpO1xuICAgICAgICAgICAgLy8g5bCG5paw5Yqg5YWl5YWD57Sg5re75Yqg5Yiw5Y+M56uv6Zif5YiX55qE5bC+6YOoXG4gICAgICAgICAgICBxdWV1ZS5hZGRMYXN0KGkpO1xuICAgICAgICAgICAgLy8g5aaC6L+H56qX5Y+j5aSW55qE5YWD57Sg5LuN54S25Zyo5Y+M56uv6Zif5YiX5Lit77yM5bCG5YW256e76ZmkXG4gICAgICAgICAgICBpZiAocXVldWUuZ2V0Rmlyc3QoKSA9PSBpIC0gaylcbiAgICAgICAgICAgICAgICBxdWV1ZS5yZW1vdmVGaXJzdCgpO1xuICAgICAgICAgICAgLy8g5bCG5aS06YOo5YWD57Sg5Y2z5b2T5YmN5pyA5aSn5YWD57Sg5a+55bqU55qE5pWw5a2X5pS+5YWl57uT5p6c5pWw57uEXG4gICAgICAgICAgICBpZiAoaSAtIGsgKyAxID49IDApXG4gICAgICAgICAgICAgICAgcmVzW2kgLSBrICsgMV0gPSBudW1zW3F1ZXVlLmdldEZpcnN0KCldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBtYXhTbGlkaW5nV2luZG93KHNlbGYsIG51bXM6IExpc3RbaW50XSwgazogaW50KSAtPiBMaXN0W2ludF06XG4gICAgICAgIGQgPSBjb2xsZWN0aW9ucy5kZXF1ZSgpXG4gICAgICAgIG91dCA9IFtdXG4gICAgICAgIFxuICAgICAgICBmb3IgaSwgbiBpbiBlbnVtZXJhdGUobnVtcyk6XG4gICAgICAgICAgICAjIOenu+mZpOaJgOacieavlOW9k+WJjeWFg+e0oOWwj+eahOWFg+e0oFxuICAgICAgICAgICAgd2hpbGUgZCBhbmQgbnVtc1tkWy0xXV0gPCBuOlxuICAgICAgICAgICAgICAgIGQucG9wKClcbiAgICAgICAgICAgIGQgKz0gaSxcbiAgICAgICAgICAgIGlmIGRbMF0gPT0gaSAtIGs6XG4gICAgICAgICAgICAgICAgZC5wb3BsZWZ0KClcbiAgICAgICAgICAgIGlmIGkgPj0gayAtIDE6XG4gICAgICAgICAgICAgICAgb3V0LmFwcGVuZChudW1zW2RbMF1dKVxuXG4gICAgICAgIHJldHVybiBvdXRcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTEuMi4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICAgIHB1YmxpYyBTdHJpbmcgbWluV2luZG93KFN0cmluZyBzLCBTdHJpbmcgdCkge1xuICAgICAgICBpZiAocy5sZW5ndGgoKSA9PSAwIHx8IHQubGVuZ3RoKCkgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICBpbnQgbGVmdCA9IDAsIHJpZ2h0ID0gMDtcbiAgICAgICAgTWFwPENoYXJhY3RlciwgSW50ZWdlcj4gdE1hcCA9IG5ldyBIYXNoTWFwPD4oKTtcbiAgICAgICAgZm9yIChjaGFyIGMgOiB0LnRvQ2hhckFycmF5KCkpIHtcbiAgICAgICAgICAgIHRNYXAucHV0KGMsIHRNYXAuZ2V0T3JEZWZhdWx0KGMsIDApICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnQgcmVxdWlyZWQgPSB0TWFwLmtleVNldCgpLnNpemUoKSwgZm9ybWVkID0gMDtcbiAgICAgICAgTWFwPENoYXJhY3RlciwgSW50ZWdlcj4gd2luZG93TWFwID0gbmV3IEhhc2hNYXA8PigpO1xuXG4gICAgICAgIC8vIGFuc1swXSDlrZjmlL7lrZfnrKbplb/luqbvvIxhbnNbMV3lkoxhbnNbMl3liIbliKvlrZjmlL7lt6blj7PntKLlvJVcbiAgICAgICAgaW50W10gYW5zID0gbmV3IGludFszXTtcbiAgICAgICAgYW5zWzBdID0gSW50ZWdlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgd2hpbGUgKHJpZ2h0IDwgcy5sZW5ndGgoKSkge1xuICAgICAgICAgICAgY2hhciBjaGFyYWN0ZXIgPSBzLmNoYXJBdChyaWdodCk7XG4gICAgICAgICAgICB3aW5kb3dNYXAucHV0KGNoYXJhY3Rlciwgd2luZG93TWFwLmdldE9yRGVmYXVsdChjaGFyYWN0ZXIsIDApICsgMSk7XG5cbiAgICAgICAgICAgIGlmICh0TWFwLmNvbnRhaW5zS2V5KGNoYXJhY3RlcikgJiYgd2luZG93TWFwLmdldChjaGFyYWN0ZXIpLmludFZhbHVlKCkgPT0gdE1hcC5nZXQoY2hhcmFjdGVyKS5pbnRWYWx1ZSgpKVxuICAgICAgICAgICAgICAgIGZvcm1lZCsrO1xuXG4gICAgICAgICAgICB3aGlsZSAobGVmdCA8PSByaWdodCAmJiAoZm9ybWVkID09IHJlcXVpcmVkKSkge1xuICAgICAgICAgICAgICAgIGNoYXJhY3RlciA9IHMuY2hhckF0KGxlZnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCArIDEgPCBhbnNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgYW5zID0gbmV3IGludFtde3JpZ2h0IC0gbGVmdCArIDEsIGxlZnQsIHJpZ2h0fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2luZG93TWFwLnB1dChjaGFyYWN0ZXIsIHdpbmRvd01hcC5nZXRPckRlZmF1bHQoY2hhcmFjdGVyLCAxKSAtIDEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRNYXAuY29udGFpbnNLZXkoY2hhcmFjdGVyKSAmJiB3aW5kb3dNYXAuZ2V0KGNoYXJhY3RlcikgPCB0TWFwLmdldChjaGFyYWN0ZXIpKVxuICAgICAgICAgICAgICAgICAgICBmb3JtZWQgLT0gMTtcblxuICAgICAgICAgICAgICAgIGxlZnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJpZ2h0Kys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYW5zWzBdID09IEludGVnZXIuTUFYX1ZBTFVFID8gXCJcIiA6IHMuc3Vic3RyaW5nKGFuc1sxXSwgYW5zWzJdICsgMSk7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgbWluV2luZG93KHNlbGYsIHM6c3RyLCB0OnN0ciktPnN0cjpcbiAgICAgICAgaWYgbm90IHQgb3Igbm90IHM6XG4gICAgICAgICAgICByZXR1cm4gXCJcIlxuICAgICAgICAgICAgXG4gICAgICAgIGRpY3RfdCA9IENvdW50ZXIodClcbiAgICAgICAgXG4gICAgICAgIHJlcXVpcmVkID0gbGVuKGRpY3RfdClcbiAgICAgICAgXG4gICAgICAgICPliJ3lp4vljJbmu5Hliqjnqpflj6NcbiAgICAgICAgbGVmdCwgcmlnaHQgPSAwLCAwXG4gICAgICAgIFxuICAgICAgICBmb3JtZWQgPSAwXG4gICAgICAgIFxuICAgICAgICB3aW5kb3dfY291bnRzID0ge31cbiAgICAgICAgXG4gICAgICAgIGFucyA9IGZsb2F0KFwiaW5mXCIpLCBOb25lLCBOb25lXG4gICAgICAgIFxuICAgICAgICB3aGlsZSByaWdodCA8IGxlbihzKTpcbiAgICAgICAgICAgIGNoYXJhY3RlciA9IHNbcmlnaHRdXG4gICAgICAgICAgICB3aW5kb3dfY291bnRzW2NoYXJhY3Rlcl0gPSB3aW5kb3dfY291bnRzLmdldChjaGFyYWN0ZXIsIDApICsgMVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiBjaGFyYWN0ZXIgaW4gZGljdF90IGFuZCB3aW5kb3dfY291bnRzW2NoYXJhY3Rlcl0gPT0gZGljdF90W2NoYXJhY3Rlcl06XG4gICAgICAgICAgICAgICAgZm9ybWVkICs9IDFcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHdoaWxlIGxlZnQgPD0gcmlnaHQgYW5kIGZvcm1lZCA9PSByZXF1aXJlZDpcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXIgPSBzW2xlZnRdXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgcmlnaHQgLSBsZWZ0ICsgMSA8IGFuc1swXTpcbiAgICAgICAgICAgICAgICAgICAgYW5zID0gKHJpZ2h0IC0gbGVmdCArIDEsIGxlZnQsIHJpZ2h0KVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB3aW5kb3dfY291bnRzW2NoYXJhY3Rlcl0gLT0gMVxuICAgICAgICAgICAgICAgIGlmIGNoYXJhY3RlciBpbiBkaWN0X3QgYW5kIHdpbmRvd19jb3VudHNbY2hhcmFjdGVyXSA8IGRpY3RfdFtjaGFyYWN0ZXJdOlxuICAgICAgICAgICAgICAgICAgICBmb3JtZWQgLT0gMVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsZWZ0ICs9IDFcbiAgICAgICAgICAgIHJpZ2h0ICs9IDFcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgaWYgYW5zWzBdID09IGZsb2F0KFwiaW5mXCIpOlxuICAgICAgICAgICAgcmV0dXJuIFwiXCJcbiAgICAgICAgZWxzZTpcbiAgICAgICAgICAgIHJldHVybiBzW2Fuc1sxXTogYW5zWzJdICsgMV1cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTEuMi4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gICAgcHVibGljOlxuICAgICAgICBzdHJpbmcgbWluV2luZG93KHN0cmluZyBzLCBzdHJpbmcgdCkge1xuICAgICAgICAgICAgaWYgKHMuc2l6ZSgpID09IDAgfHwgdC5zaXplKCkgPT0gMCB8fCB0LnNpemUoKSA+IHMuc2l6ZSgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuXG4gICAgICAgICAgICB2ZWN0b3I8aW50PiByZW1haW5pbmcoMTI4LCAwKTtcbiAgICAgICAgICAgIGludCByZXF1aXJlZCA9IHQuc2l6ZSgpO1xuXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHJlcXVpcmVkOyBpKyspXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nW3RbaV1dKys7XG5cbiAgICAgICAgICAgIGludCBtaW4gPSBJTlRfTUFYLCBzdGFydCA9IDAsIGxlZnQgPSAwLCBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDw9IHMuc2l6ZSgpICYmIHN0YXJ0IDwgcy5zaXplKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gcy5zaXplKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nW3NbaV1dLS07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdbc1tpXV0gPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkLS07XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAtIHN0YXJ0IDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSBpIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nW3Nbc3RhcnRdXSsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nW3Nbc3RhcnRdXSA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZCsrO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1pbiA9PSBJTlRfTUFYID8gXCJcIiA6IHMuc3Vic3RyKGxlZnQsIG1pbik7XG4gICAgICAgIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIG1pbldpbmRvdyhzZWxmLCBzLCB0KTpcbiAgICAgICAgaWYgbm90IHQgb3Igbm90IHM6XG4gICAgICAgICAgICByZXR1cm4gXCJcIlxuICAgICAgICAgICAgXG4gICAgICAgIGRpY3RfdCA9IENvdW50ZXIodClcbiAgICAgICAgXG4gICAgICAgIHJlcXVpcmVkID0gbGVuKGRpY3RfdClcbiAgICAgICAgXG4gICAgICAgIGZvciBpLCBjaGFyIGluIGVudW1lcmF0ZShzKTpcbiAgICAgICAgICAgIGlmIGNoYXIgaW4gZGljdF90OlxuICAgICAgICAgICAgICAgIGZpbHRlcmVkX3MuYXBwZW5kKChpLCBjaGFyKSlcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgbGVmdCwgcmlnaHQgPSAwLCAwXG4gICAgICAgIGZvcm1lZCA9IDBcbiAgICAgICAgd2luZG93X2NvdW50cyA9IHt9XG4gICAgICAgIFxuICAgICAgICBhbnMgPSBmbG9hdChcImluZlwiKSwgTm9uZSwgTm9uZVxuICAgICAgICBcbiAgICAgICAgd2hpbGUgcmlnaHQgPCBsZW4oZmlsdGVyZWRfcyk6XG4gICAgICAgICAgICBjaGFyYWN0ZXIgPSBmaWx0ZXJlZF9zW3JdWzFdXG4gICAgICAgICAgICB3aW5kb3dfY291bnRzW2NoYXJhY3Rlcl0gPSB3aW5kb3dfY291bnRzLmdldChjaGFyYWN0ZXIsIDApICsgMVxuXG4gICAgICAgICAgICBpZiB3aW5kb3dfY291bnRzW2NoYXJhY3Rlcl0gPT0gZGljdF90W2NoYXJhY3Rlcl06XG4gICAgICAgICAgICAgICAgZm9ybWVkICs9IDFcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHdoaWxlIGxlZnQgPD0gcmlnaHQgYW5kIGZvcm1lZCA9PSByZXF1aXJlZDpcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXIgPSBmaWx0ZXJlZF9zW2xdWzFdXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZW5kICAgPSBmaWx0ZXJlZF9zW3JpZ2h0XVswXVxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZmlsdGVyZWRfc1tsZWZ0XVswXVxuICAgICAgICAgICAgICAgIGlmIGVuZCAtIHN0YXJ0ICsgMSA8IGFuc1swXTpcbiAgICAgICAgICAgICAgICAgICAgYW5zID0gKGVuZCAtIHN0YXJ0ICsgMSwgc3RhcnQsIGVuZClcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgd2luZG93X2NvdW50c1tjaGFyYWN0ZXJdIC09IDFcbiAgICAgICAgICAgICAgICBpZiB3aW5kb3dfY291bnRzW2NoYXJhY3Rlcl0gPCBkaWN0X3RbY2hhcmFjdGVyXTpcbiAgICAgICAgICAgICAgICAgICAgZm9ybWVkIC09IDFcbiAgICAgICAgICAgICAgICBsZWZ0ICs9IDFcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHJpZ2h0ICs9IDFcbiAgICAgICAgICAgIFxuICAgICAgICBpZiBhbnNbMF0gPT0gZmxvYXQoXCJpbmZcIik6XG4gICAgICAgICAgICByZXR1cm4gXCJcIlxuICAgICAgICBlbHNlOlxuICAgICAgICAgICAgcmV0dXJuIHNbYW5zWzFdOmFuc1syXSArIDFdXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTExLjMuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICAgIHB1YmxpYzpcbiAgICAgICAgaW50IGNoYXJhY3RlclJlcGxhY2VtZW50KHN0cmluZyBzLCBpbnQgaykge1xuICAgICAgICAgICAgaW50IHJlcyA9IDAsIGxlZnQgPSAwLCByaWdodCA9IDAsIHNpemUgPSBzLnNpemUoKSwgbG9jYWxNYXhGcmVxID0gMDtcblxuICAgICAgICAgICAgdmVjdG9yPGludD4gY291bnQoMjYsIDApO1xuICAgICAgICAgICAgZm9yICg7IHJpZ2h0IDwgc2l6ZTsgcmlnaHQrKykge1xuICAgICAgICAgICAgICAgIGNvdW50W3NbcmlnaHRdIC0gJ0EnXSArPSAxO1xuICAgICAgICAgICAgICAgIGxvY2FsTWF4RnJlcSA9IG1heChsb2NhbE1heEZyZXEsIGNvdW50W3NbcmlnaHRdIC0gJ0EnXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKHJpZ2h0IC0gbGVmdCArIDEpIC0gbG9jYWxNYXhGcmVxID4gaykge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSBtYXgocmVzLCAocmlnaHQgLSBsZWZ0KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50W3NbbGVmdF0gLSAnQSddIC09IDE7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxNYXhGcmVxID0gKihtYXhfZWxlbWVudChjb3VudC5iZWdpbigpLCBjb3VudC5lbmQoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1heChyZXMsIHJpZ2h0IC0gbGVmdCk7XG4gICAgICAgIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gICAgcHVibGljIGludCBjaGFyYWN0ZXJSZXBsYWNlbWVudChTdHJpbmcgcywgaW50IGspIHtcbiAgICAgICAgaW50IHJlcyA9IDAsIGxlZnQgPSAwLCByaWdodCA9IDA7XG4gICAgICAgIGludFtdIGNvdW50cyA9IG5ldyBpbnRbMjZdO1xuXG4gICAgICAgIHdoaWxlKCByaWdodCA8IHMubGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIGNvdW50c1tzLmNoYXJBdChyaWdodCkgLSAnQSddKys7XG4gICAgICAgICAgICBpbnQgbWF4Q2hhckNvdW50ID0gZ2V0TW9zdENoYXJDb3VudChjb3VudHMpO1xuICAgICAgICAgICAgcmlnaHQrKztcbiAgICAgICAgICAgIGlmIChyaWdodCAtIGxlZnQgLSBtYXhDaGFyQ291bnQgPiBrKSB7XG4gICAgICAgICAgICAgICAgY291bnRzW3MuY2hhckF0KGxlZnQpIC0gJ0EnXS0tO1xuICAgICAgICAgICAgICAgIGxlZnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmlnaHQgLSBsZWZ0O1xuICAgIH1cblxuICAgIHByaXZhdGUgaW50IGdldE1vc3RDaGFyQ291bnQoaW50W10gY291bnRzKSB7XG4gICAgICAgIGludCBhbnMgPSAwO1xuICAgICAgICBmb3IgKGludCBuIDogY291bnRzKVxuICAgICAgICAgICAgYW5zID0gTWF0aC5tYXgoYW5zLCBuKTtcbiAgICAgICAgcmV0dXJuIGFucztcbiAgICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBjaGFyYWN0ZXJSZXBsYWNlbWVudChzZWxmLCBzOiBzdHIsIGs6IGludCkgLT4gaW50OlxuICAgICAgICByZXMgPSBsb3cgPSBoaWdoID0gMFxuICAgICAgICBjb3VudHMgPSBjb2xsZWN0aW9ucy5Db3VudGVyKClcbiAgICAgICAgXG4gICAgICAgIGZvciBoaWdoIGluIHJhbmdlKDEsIGxlbihzKSArIDEpOlxuICAgICAgICAgICAgY291bnRzW3NbaGlnaCAtIDFdXSArPSAxXG4gICAgICAgICAgICBtYXhfY2hhcl9uID0gY291bnRzLm1vc3RfY29tbW9uKDEpWzBdWzFdXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIGhpZ2ggLSBsb3cgLSBtYXhfY2hhcl9uID4gazpcbiAgICAgICAgICAgICAgICBjb3VudHNbc1tsb3ddXSAtPSAxXG4gICAgICAgICAgICAgICAgbG93ICs9IDFcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBoaWdoIC1sb3dcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTEuMy4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gICAgcHVibGljOlxuICAgICAgICBpbnQgY2hhcmFjdGVyUmVwbGFjZW1lbnQoc3RyaW5nIHMsIGludCBrKSB7XG4gICAgICAgICAgICBpbnQgcmVzID0gMDtcbiAgICAgICAgICAgIGludCBtYXhmID0gMDtcbiAgICAgICAgICAgIHZlY3RvcjxpbnQ+IGNvdW50KDI2LCAwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBzLnNpemUoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRbc1tpXSAtICdBJ10gKz0gMTtcbiAgICAgICAgICAgICAgICBtYXhmID0gbWF4KG1heGYsIGNvdW50W3NbaV0gLSAnQSddKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAocmVzIC0gbWF4ZiA8IGspXG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSAxO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY291bnRbc1tpIC0gcmVzXSAtICdBJ10gLT0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgICBwdWJsaWMgaW50IGNoYXJhY3RlclJlcGxhY2VtZW50KFN0cmluZyBzLCBpbnQgaykge1xuICAgICAgICBpbnQgcmVzID0gMCwgdG1wTWF4ID0gMDtcbiAgICAgICAgaW50W10gY291bnRzID0gbmV3IGludFsyNl07XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBzLmxlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50c1tzLmNoYXJBdChpKSAtICdBJ10rKztcbiAgICAgICAgICAgIHRtcE1heCA9IE1hdGgubWF4KHRtcE1heCwgY291bnRzW3MuY2hhckF0KGkpIC0gJ0EnXSk7XG5cbiAgICAgICAgICAgIGlmIChyZXMgLSB0bXBNYXggPCBrKVxuICAgICAgICAgICAgICAgIHJlcysrO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvdW50c1tzLmNoYXJBdChpIC0gcmVzKSAtICdBJ10tLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGNoYXJhY3RlclJlcGxhY2VtZW50KHNlbGYsIHM6IHN0ciwgazogaW50KSAtPiBpbnQ6XG4gICAgICAgIG1heF9jaGFyX24gPSByZXMgPSAwXG4gICAgICAgIGNvdW50ID0gY29sbGVjdGlvbnMuQ291bnRlcigpXG4gICAgICAgIGZvciBpIGluIHJhbmdlKGxlbihzKSk6XG4gICAgICAgICAgICBjb3VudFtzW2ldXSArPSAxXG4gICAgICAgICAgICBtYXhfY2hhcl9uID0gbWF4KG1heF9jaGFyX24sIGNvdW50W3NbaV1dKVxuXG4gICAgICAgICAgICBpZiByZXMgLSBtYXhfY2hhcl9uIDwgazpcbiAgICAgICAgICAgICAgICByZXMgKz0gMVxuICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICBjb3VudFtzW2kgLSByZXNdXSAtPSAxXG5cbiAgICAgICAgcmV0dXJuIHJlc1xuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExMS40LjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgI+eUn+aIkOWPr+iDveeahOWtkOWtl+espuS4slxuICAgIGRlZiBwZXJtKHNlbGYsIHM6c3RyKS0+c3RyOlxuICAgICAgICBpZiBsZW4ocykgPD0gMTpcbiAgICAgICAgICAgIHJldHVybiBbc11cbiAgICAgICAgXG4gICAgICAgIHMxID0gW11cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UobGVuKHMpKTpcbiAgICAgICAgICAgIGZvciBqIGluIHNlbGYucGVybShzWzA6aV0gKyBzW2kgKyAxOl0pOlxuICAgICAgICAgICAgICAgIHMxLmFwcGVuZChzW2ldICsgailcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgcmV0dXJuIHMxXG5cbiAgICBkZWYgY2hlY2tJbmNsdXNpb24oc2VsZiwgczE6IHN0ciwgczI6IHN0cikgLT4gYm9vbDpcbiAgICAgICAgaWYgKGxlbihzMSkgPiBsZW4oczIpKTpcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxuICAgICAgICBcbiAgICAgICAgczFfcGVybSA9IGxpc3Qoc2V0KHNlbGYucGVybShzMSkpKVxuICAgICAgICAj5qOA5rWL5a2X56ym5LiyUzHnmoTmjpLliJfmmK/lkKbmmK/lrZfnrKbkuLJTMueahOWtkOS4slxuICAgICAgICBmb3IgaSBpbiBzMV9wZXJtOlxuICAgICAgICAgICAgaWR4ID0gczIuZmluZChpKVxuICAgICAgICAgICAgaWYgaWR4ICE9IC0xOlxuICAgICAgICAgICAgICAgIHJldHVybiBUcnVlXG4gICAgICAgICAgICBcbiAgICAgICAgcmV0dXJuIEZhbHNlXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTExLjQuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICAgIHB1YmxpYzpcbiAgICAgICAgYm9vbCBjaGVja0luY2x1c2lvbihzdHJpbmcgczEsIHN0cmluZyBzMikge1xuICAgICAgICAgICAgdmVjdG9yPGludD4gY250cygyNTYsIDApO1xuICAgICAgICAgICAgZm9yIChjaGFyIGNoOiBzMSlcbiAgICAgICAgICAgICAgICBjbnRzW2NoXSsrO1xuXG4gICAgICAgICAgICBpbnQgbGVmdCA9IHMxLnNpemUoKTtcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwLCBqID0gMDsgaiA8IHMyLnNpemUoKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNudHNbczJbal1dLS0gPiAwKVxuICAgICAgICAgICAgICAgICAgICBsZWZ0LS07XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAobGVmdCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqICsgMSAtIGkgPT0gczEuc2l6ZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK2NudHNbczJbaSsrXV0gPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICAgIHB1YmxpYyBib29sZWFuIGNoZWNrSW5jbHVzaW9uKFN0cmluZyBzMSwgU3RyaW5nIHMyKSB7XG4gICAgICAgIGlmIChzMS5sZW5ndGgoKSA+IHMyLmxlbmd0aCgpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpbnRbXSBhcnJheVMxID0gbmV3IGludFsyNl0sIGFycmF5UzIgPSBuZXcgaW50WzI2XTtcbiAgICAgICAgaW50IGNvdW50ID0gMDtcblxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHMxLmxlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5UzFbczEuY2hhckF0KGkpIC0gJ2EnXSsrO1xuICAgICAgICAgICAgYXJyYXlTMltzMi5jaGFyQXQoaSkgLSAnYSddKys7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDI2OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJheVMxW2ldID09IGFycmF5UzJbaV0pXG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgczIubGVuZ3RoKCkgLSBzMS5sZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY291bnQgPT0gMjYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpbnQgbGVmdCA9IHMyLmNoYXJBdChpKSAtICdhJywgcmlnaHQgPSBzMi5jaGFyQXQoaSArIHMxLmxlbmd0aCgpKSAtICdhJztcblxuICAgICAgICAgICAgYXJyYXlTMltyaWdodF0rKztcbiAgICAgICAgICAgIGlmIChhcnJheVMyW3JpZ2h0XSA9PSBhcnJheVMxW3JpZ2h0XSlcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgZWxzZSBpZiAoYXJyYXlTMltyaWdodF0gPT0gYXJyYXlTMVtyaWdodF0gKyAxKVxuICAgICAgICAgICAgICAgIGNvdW50LS07XG5cbiAgICAgICAgICAgIGFycmF5UzJbbGVmdF0tLTtcbiAgICAgICAgICAgIGlmIChhcnJheVMyW2xlZnRdID09IGFycmF5UzFbbGVmdF0pXG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIGVsc2UgaWYgKGFycmF5UzJbbGVmdF0gPT0gYXJyYXlTMVtsZWZ0XSAtIDEpXG4gICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb3VudCA9PSAyNjtcbiAgICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBjaGVja0luY2x1c2lvbihzZWxmLCBzMTogc3RyLCBzMjogc3RyKSAtPiBib29sOlxuICAgICAgICBpZiAobGVuKHMxKSA+IGxlbihzMikpOlxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXG4gICAgICAgIFxuICAgICAgICBsaXN0MSA9IFswIGZvciBpIGluIHJhbmdlKDI2KV1cbiAgICAgICAgbGlzdDIgPSBbMCBmb3IgaSBpbiByYW5nZSgyNildXG4gICAgICAgIFxuICAgICAgICBmb3IgaSBpbiByYW5nZShsZW4oczEpKTpcbiAgICAgICAgICAgIGxpc3QxW29yZChzMVtpXSkgLSBvcmQoJ2EnKV0gKz0gMVxuICAgICAgICAgICAgbGlzdDJbb3JkKHMyW2ldKSAtIG9yZCgnYScpXSArPSAxXG4gICAgICAgICAgICBcbiAgICAgICAgY291bnQgPSAwXG4gICAgICAgIGZvciBpIGluIHJhbmdlKDI2KTpcbiAgICAgICAgICAgIGlmIGxpc3QxW2ldID09IGxpc3QyW2ldOlxuICAgICAgICAgICAgICAgIGNvdW50ICs9IDFcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UobGVuKHMyKSAtIGxlbihzMSkpOlxuICAgICAgICAgICAgcmlnaHQgPSBvcmQoczJbaSArIGxlbihzMSldKSAtIG9yZCgnYScpXG4gICAgICAgICAgICBsZWZ0ID0gb3JkKHMyW2ldKSAtIG9yZCgnYScpXG4gICAgICAgICAgICBpZiBjb3VudCA9PSAyNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJ1ZVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBsaXN0MltyaWdodF0gKz0gMVxuICAgICAgICAgICAgaWYgbGlzdDJbcmlnaHRdID09IGxpc3QxW3JpZ2h0XTpcbiAgICAgICAgICAgICAgICBjb3VudCArPSAxXG4gICAgICAgICAgICBlbGlmIGxpc3QyW3JpZ2h0XSA9PSBsaXN0MVtyaWdodF0gKyAxOlxuICAgICAgICAgICAgICAgIGNvdW50IC09IDFcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGxpc3QyW2xlZnRdIC09IDFcbiAgICAgICAgICAgIGlmIGxpc3QyW2xlZnRdID09IGxpc3QxW2xlZnRdOlxuICAgICAgICAgICAgICAgIGNvdW50ICs9IDFcbiAgICAgICAgICAgIGVsaWYgbGlzdDJbbGVmdF0gPT0gbGlzdDFbbGVmdF0gLSAxOlxuICAgICAgICAgICAgICAgIGNvdW50IC09IDFcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgcmV0dXJuIGNvdW50ID09IDI2XG5cbiIKICAgIH1dCiAgfV0KfSwgewogICJpZCI6ICIxMiIsCiAgIm5hbWUiOiAi56ys5Y2B5LqM56ugIiwKICAibGlzdCI6IFt7CiAgICAidGl0bGUiOiAi5Luj56CBMTIuMS4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gICAgcGx1YmxpYzpcbiAgICAgICAgYm9vbCBzdG9uZUdhbWUodmVjdG9yPGludD4mIHBpbGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogInBhY2thZ2UgY2gxMi5jb2RlO1xuXG5wdWJsaWMgY2xhc3MgMTIuMS4xLlN0b25lR2FtZSB7XG4gICAgcHVibGljIGJvb2xlYW4gc3RvbmVHYW1lKGludFtdIHBpbGVzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZnJvbSB0eXBpbmcgaW1wb3J0IExpc3RcblxuXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgc3RvbmVHYW1lKHNlbGYsIHBpbGVzOiBMaXN0W2ludF0pIC0+IGJvb2w6XG4gICAgICAgIHJldHVybiBUcnVlXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTEyLjEuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHJpdmF0ZTpcbiAgICBpbnQgZmluZF9tYXgoaW50IGxlZnQsIGludCByaWdodCwgdmVjdG9yPGludD4mIHBpbGVzLCB2ZWN0b3I8dmVjdG9yPGludD4+JiBtZW0pIHtcbiAgICAgICAgaWYgKGxlZnQgPCAwIHx8IHJpZ2h0IDwgMCB8fCBsZWZ0ID4gcmlnaHQpIHJldHVybiAwO1xuXG4gICAgICAgIGlmIChtZW1bbGVmdF1bcmlnaHRdICE9IDApXG4gICAgICAgICAgICByZXR1cm4gbWVtW2xlZnRdW3JpZ2h0XTtcbiAgICAgICAgXG4gICAgICAgIGlmIChsZWZ0ID09IHJpZ2h0KSB7XG4gICAgICAgICAgICBtZW1bbGVmdF1bcmlnaHRdID0gcGlsZXNbbGVmdF07XG4gICAgICAgICAgICByZXR1cm4gcGlsZXNbbGVmdF07XG4gICAgICAgIH1cblxuICAgICAgICBpbnQgbWF4X3N0b25lID0gbWF4KHBpbGVzW2xlZnRdICArIG1pbihmaW5kX21heChsZWZ0ICsgMiwgcmlnaHQsIHBpbGVzLCBtZW0pLCBmaW5kX21heChsZWZ0ICsgMSwgcmlnaHQgLSAxLCBwaWxlcywgbWVtKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGlsZXNbcmlnaHRdICsgbWluKGZpbmRfbWF4KGxlZnQgKyAxLCByaWdodCAtIDEsIHBpbGVzLCBtZW0pLCBmaW5kX21heChsZWZ0LCByaWdodCAtIDIsIHBpbGVzLCBtZW0pKSk7XG4gICAgICAgIG1lbVtsZWZ0XVtyaWdodF0gPSBtYXhfc3RvbmU7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbWF4X3N0b25lO1xuICAgIH1cbnB1YmxpYzpcbiAgICBib29sIHN0b25lR2FtZSh2ZWN0b3I8aW50PiYgcGlsZXMpIHtcbiAgICAgICAgaW50IHN1bSA9IDA7XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBwaWxlcy5zaXplKCk7IGkrKylcbiAgICAgICAgICAgIHN1bSArPSBwaWxlc1tpXTtcbiAgICAgICAgXG4gICAgICAgIHZlY3Rvcjx2ZWN0b3I8aW50Pj4gbWVtO1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHBpbGVzLnNpemUoKTsgaSsrKVxuICAgICAgICAgICAgbWVtLnB1c2hfYmFjayh2ZWN0b3I8aW50PihwaWxlcy5zaXplKCksIDApKTtcblxuICAgICAgICByZXR1cm4gMiAqIGZpbmRfbWF4KDAsIHBpbGVzLnNpemUoKSAtIDEsIHBpbGVzLCBtZW0pID4gc3VtO1xuICAgIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJwYWNrYWdlIGNoMTIuY29kZTtcblxucHVibGljIGNsYXNzIDEyLjEuMi5TdG9uZUdhbWUge1xuICAgIHB1YmxpYyBib29sZWFuIHN0b25lR2FtZShpbnRbXSBwaWxlcykge1xuICAgICAgICBpbnQgc3VtID0gMDtcbiAgICAgICAgZm9yIChpbnQgaSA6IHBpbGVzKSB7XG4gICAgICAgICAgICBzdW0gKz0gaTtcbiAgICAgICAgfVxuICAgICAgICBpbnRbXVtdIG1lbSA9IG5ldyBpbnRbcGlsZXMubGVuZ3RoXVtwaWxlcy5sZW5ndGhdO1xuICAgICAgICByZXR1cm4gMiAqIGZpbmRNYXgoMCwgcGlsZXMubGVuZ3RoIC0gMSwgcGlsZXMsIG1lbSkgPj0gc3VtO1xuICAgIH1cblxuICAgIHByaXZhdGUgaW50IGZpbmRNYXgoaW50IGxlZnQsIGludCByaWdodCwgaW50W10gcGlsZXMsIGludFtdW10gbWVtKSB7XG4gICAgICAgIGlmIChsZWZ0IDwgMCB8fCBsZWZ0ID4gcmlnaHQpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgaWYgKG1lbVtsZWZ0XVtyaWdodF0gIT0gMClcbiAgICAgICAgICAgIHJldHVybiBtZW1bbGVmdF1bcmlnaHRdO1xuICAgICAgICBpZiAobGVmdCA9PSByaWdodCkge1xuICAgICAgICAgICAgbWVtW2xlZnRdW3JpZ2h0XSA9IHBpbGVzW2xlZnRdO1xuICAgICAgICAgICAgcmV0dXJuIHBpbGVzW2xlZnRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaW50IG1heCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgIHBpbGVzW2xlZnRdICtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGZpbmRNYXgobGVmdCArIDIsIHJpZ2h0LCBwaWxlcywgbWVtKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluZE1heChsZWZ0ICsgMSwgcmlnaHQgLSAxLCBwaWxlcywgbWVtKSksXG4gICAgICAgICAgICAgICAgcGlsZXNbcmlnaHRdICtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGZpbmRNYXgobGVmdCArIDEsIHJpZ2h0IC0gMSwgcGlsZXMsIG1lbSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmRNYXgobGVmdCwgcmlnaHQgLSAyLCBwaWxlcywgbWVtKSkpO1xuXG4gICAgICAgIG1lbVtsZWZ0XVtyaWdodF0gPSBtYXg7XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBzdG9uZUdhbWUoc2VsZiwgcGlsZXM6IExpc3RbaW50XSkgLT4gYm9vbDpcbiAgICAgICAgc3VtID0gMFxuICAgICAgICBmb3IgaSBpbiBwaWxlczpcbiAgICAgICAgICAgIHN1bSArPSBpXG4gICAgICAgIG1lbSA9IFtdXG4gICAgICAgIGZvciBpIGluIHJhbmdlKGxlbihwaWxlcykpOlxuICAgICAgICAgICAgbWVtLmFwcGVuZChbMF0gKiBsZW4ocGlsZXMpKVxuXG4gICAgICAgIHJldHVybiAyICogc2VsZi5maW5kX21heCgwLCBsZW4ocGlsZXMpIC0gMSwgcGlsZXMsIG1lbSkgPiBzdW1cblxuICAgIGRlZiBmaW5kX21heChcbiAgICAgICAgc2VsZiwgbGVmdDogaW50LCByaWdodDogaW50LCBwaWxlczogTGlzdFtpbnRdLCBtZW06IExpc3RbTGlzdFtpbnRdXVxuICAgICkgLT4gaW50OlxuICAgICAgICBpZiBsZWZ0IDwgMCBvciByaWdodCA8IDAgb3IgbGVmdCA+IHJpZ2h0OlxuICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgaWYgbWVtW2xlZnRdW3JpZ2h0XSAhPSAwOlxuICAgICAgICAgICAgcmV0dXJuIG1lbVtsZWZ0XVtyaWdodF1cbiAgICAgICAgaWYgbGVmdCA9PSByaWdodDpcbiAgICAgICAgICAgIG1lbVtsZWZ0XVtyaWdodF0gPSBwaWxlc1tsZWZ0XVxuICAgICAgICAgICAgcmV0dXJuIHBpbGVzW2xlZnRdXG4gICAgICAgIG1heF9zdG9uZSA9IG1heChcbiAgICAgICAgICAgIHBpbGVzW2xlZnRdICsgbWluKFxuICAgICAgICAgICAgICAgIHNlbGYuZmluZF9tYXgobGVmdCArIDIsIHJpZ2h0LCBwaWxlcywgbWVtKSxcbiAgICAgICAgICAgICAgICBzZWxmLmZpbmRfbWF4KGxlZnQgKyAxLCByaWdodCAtIDEsIHBpbGVzLCBtZW0pLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHBpbGVzW3JpZ2h0XSArIG1pbihcbiAgICAgICAgICAgICAgICBzZWxmLmZpbmRfbWF4KGxlZnQgKyAxLCByaWdodCAtIDEsIHBpbGVzLCBtZW0pLFxuICAgICAgICAgICAgICAgIHNlbGYuZmluZF9tYXgobGVmdCwgcmlnaHQgLSAyLCBwaWxlcywgbWVtKSxcbiAgICAgICAgICAgICksICAjIGJsYWNrIGZvcm1hdHRlciBhZGRlZCB0cmFpbGluZyBjb21tYVxuICAgICAgICApXG4gICAgICAgIG1lbVtsZWZ0XVtyaWdodF0gPSBtYXhfc3RvbmVcbiAgICAgICAgcmV0dXJuIG1heF9zdG9uZVxuXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTEyLjIuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHJpdmF0ZTpcbiAgICBpbnQgZmluZF9tYXgoaW50IGxlZnQsIGludCByaWdodCwgdmVjdG9yPGludD4mIG51bXMsIHZlY3Rvcjx2ZWN0b3I8aW50Pj4mIG1lbSkge1xuICAgICAgICBpZiAobGVmdCA8IDAgfHwgcmlnaHQgPCAwIHx8IGxlZnQgPiByaWdodClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBcbiAgICAgICAgaWYgKG1lbVtsZWZ0XVtyaWdodF0gIT0gMClcbiAgICAgICAgICAgIHJldHVybiBtZW1bbGVmdF1bcmlnaHRdO1xuICAgICAgICBcbiAgICAgICAgaWYgKGxlZnQgPT0gcmlnaHQpIHtcbiAgICAgICAgICAgIG1lbVtsZWZ0XVtyaWdodF0gPSBudW1zW2xlZnRdO1xuICAgICAgICAgICAgcmV0dXJuIG51bXNbbGVmdF07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGludCBtYXhfbnVtID0gbWF4KG51bXNbbGVmdF0gICsgbWluKGZpbmRfbWF4KGxlZnQgKyAyLCByaWdodCwgbnVtcywgbWVtKSwgZmluZF9tYXgobGVmdCArIDEsIHJpZ2h0IC0gMSwgbnVtcywgbWVtKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG51bXNbcmlnaHRdICsgbWluKGZpbmRfbWF4KGxlZnQgKyAxLCByaWdodCAtIDEsIG51bXMsIG1lbSksIGZpbmRfbWF4KGxlZnQsIHJpZ2h0IC0gMiwgbnVtcywgbWVtKSkpO1xuICAgICAgICBtZW1bbGVmdF1bcmlnaHRdID0gbWF4X251bTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBtYXhfbnVtO1xuICAgIH1cbnB1YmxpYzpcbiAgICBib29sIFByZWRpY3RUaGVXaW5uZXIodmVjdG9yPGludD4mIG51bXMpIHtcbiAgICAgICAgaW50IHN1bSA9IDA7XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtcy5zaXplKCk7IGkrKylcbiAgICAgICAgICAgIHN1bSArPSBudW1zW2ldO1xuICAgICAgICBcbiAgICAgICAgdmVjdG9yPHZlY3RvcjxpbnQ+PiBtZW07XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtcy5zaXplKCk7IGkrKylcbiAgICAgICAgICAgIG1lbS5wdXNoX2JhY2sodmVjdG9yPGludD4obnVtcy5zaXplKCksIDApKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiAyICogZmluZF9tYXgoMCwgbnVtcy5zaXplKCkgLSAxLCBudW1zLCBtZW0pID49IHN1bTtcbiAgICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicGFja2FnZSBjaDEyLmNvZGU7XG5cbnB1YmxpYyBjbGFzcyAxMi4yLjEuUHJlZGljdFRoZVdpbm5lciB7XG4gICAgcHVibGljIGJvb2xlYW4gUHJlZGljdFRoZVdpbm5lcihpbnRbXSBudW1zKSB7XG4gICAgICAgIGludCBzdW0gPSAwO1xuICAgICAgICBmb3IgKGludCBpIDogbnVtcylcbiAgICAgICAgICAgIHN1bSArPSBpO1xuICAgICAgICBpbnRbXVtdIG1lbSA9IG5ldyBpbnRbbnVtcy5sZW5ndGhdW251bXMubGVuZ3RoXTtcbiAgICAgICAgcmV0dXJuIHN1bSA8PSBmaW5kTWF4KDAsIG51bXMubGVuZ3RoIC0gMSwgbnVtcywgbWVtKSAqIDI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbnQgZmluZE1heChpbnQgbCwgaW50IHIsIGludFtdIG51bXMsIGludFtdW10gbWVtKSB7XG4gICAgICAgIGlmIChsIDwgMCB8fCBsID4gcilcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBpZiAobWVtW2xdW3JdICE9IDApXG4gICAgICAgICAgICByZXR1cm4gbWVtW2xdW3JdO1xuXG4gICAgICAgIGlmIChsID09IHIpIHtcbiAgICAgICAgICAgIG1lbVtsXVtyXSA9IG51bXNbbF07XG4gICAgICAgICAgICByZXR1cm4gbnVtc1tsXTtcbiAgICAgICAgfVxuICAgICAgICBtZW1bbF1bcl0gPSBNYXRoLm1heChudW1zW2xdICsgTWF0aC5taW4oZmluZE1heChsICsgMSwgciAtIDEsIG51bXMsIG1lbSksIGZpbmRNYXgobCArIDIsIHIsIG51bXMsIG1lbSkpLFxuICAgICAgICAgICAgICAgIG51bXNbcl0gKyBNYXRoLm1pbihmaW5kTWF4KGwgKyAxLCByIC0gMSwgbnVtcywgbWVtKSwgZmluZE1heChsLCByIC0gMiwgbnVtcywgbWVtKSkpO1xuICAgICAgICByZXR1cm4gbWVtW2xdW3JdO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZnJvbSB0eXBpbmcgaW1wb3J0IExpc3RcblxuXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgUHJlZGljdFRoZVdpbm5lcihzZWxmLCBudW1zOiBMaXN0W2ludF0pIC0+IGJvb2w6XG4gICAgICAgIHN1bSA9IDBcbiAgICAgICAgZm9yIGkgaW4gbnVtczpcbiAgICAgICAgICAgIHN1bSArPSBpXG4gICAgICAgIG1lbSA9IFtdXG4gICAgICAgIGZvciBpIGluIHJhbmdlKGxlbihudW1zKSk6XG4gICAgICAgICAgICBtZW0uYXBwZW5kKFswXSAqIGxlbihudW1zKSlcblxuICAgICAgICByZXR1cm4gMiAqIHNlbGYuZmluZF9tYXgoMCwgbGVuKG51bXMpIC0gMSwgbnVtcywgbWVtKSA+PSBzdW1cblxuICAgIGRlZiBmaW5kX21heChcbiAgICAgICAgc2VsZiwgbGVmdDogaW50LCByaWdodDogaW50LCBudW1zOiBMaXN0W2ludF0sIG1lbTogTGlzdFtMaXN0W2ludF1dXG4gICAgKSAtPiBpbnQ6XG4gICAgICAgIGlmIGxlZnQgPCAwIG9yIHJpZ2h0IDwgMCBvciBsZWZ0ID4gcmlnaHQ6XG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICBpZiBtZW1bbGVmdF1bcmlnaHRdICE9IDA6XG4gICAgICAgICAgICByZXR1cm4gbWVtW2xlZnRdW3JpZ2h0XVxuICAgICAgICBpZiBsZWZ0ID09IHJpZ2h0OlxuICAgICAgICAgICAgbWVtW2xlZnRdW3JpZ2h0XSA9IG51bXNbbGVmdF1cbiAgICAgICAgICAgIHJldHVybiBudW1zW2xlZnRdXG4gICAgICAgIG1heF9udW0gPSBtYXgoXG4gICAgICAgICAgICBudW1zW2xlZnRdXG4gICAgICAgICAgICArIG1pbihcbiAgICAgICAgICAgICAgICBzZWxmLmZpbmRfbWF4KGxlZnQgKyAyLCByaWdodCwgbnVtcywgbWVtKSxcbiAgICAgICAgICAgICAgICBzZWxmLmZpbmRfbWF4KGxlZnQgKyAxLCByaWdodCAtIDEsIG51bXMsIG1lbSksXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbnVtc1tyaWdodF1cbiAgICAgICAgICAgICsgbWluKFxuICAgICAgICAgICAgICAgIHNlbGYuZmluZF9tYXgobGVmdCArIDEsIHJpZ2h0IC0gMSwgbnVtcywgbWVtKSxcbiAgICAgICAgICAgICAgICBzZWxmLmZpbmRfbWF4KGxlZnQsIHJpZ2h0IC0gMiwgbnVtcywgbWVtKSxcbiAgICAgICAgICAgICksICAjIGJsYWNrIGZvcm1hdHRlciBhZGRlZCB0cmFpbGluZyBjb21tYVxuICAgICAgICApXG4gICAgICAgIG1lbVtsZWZ0XVtyaWdodF0gPSBtYXhfbnVtXG4gICAgICAgIHJldHVybiBtYXhfbnVtXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTEyLjIuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGJvb2wgUHJlZGljdFRoZVdpbm5lcih2ZWN0b3I8aW50PiYgbnVtcykge1xuICAgICAgICBpbnQgbGVuID0gbnVtcy5zaXplKCk7XG4gICAgICAgIFxuICAgICAgICB2ZWN0b3I8dmVjdG9yPGludD4+IGRwO1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IG51bXMuc2l6ZSgpOyBpKyspXG4gICAgICAgICAgICBkcC5wdXNoX2JhY2sodmVjdG9yPGludD4obnVtcy5zaXplKCksIDApKTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoaW50IGkgPSAwO2kgPCBudW1zLnNpemUoKTsgaSsrKVxuICAgICAgICAgICAgZHBbaV1baV0gPSBudW1zW2ldO1xuICAgICAgICBcbiAgICAgICAgZm9yIChpbnQgaSA9IGxlbiAtIDE7IGkgPiAtMTsgaS0tKVxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IGkgKyAxOyBqIDwgbGVuOyBqKyspXG4gICAgICAgICAgICAgICAgZHBbaV1bal0gPSBtYXgobnVtc1tpXSAtIGRwW2kgKyAxXVtqXSwgbnVtc1tqXSAtIGRwW2ldW2ogLSAxXSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZHBbMF1bbGVuIC0gMV0gPj0gMDtcbiAgICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicGFja2FnZSBjaDEyLmNvZGU7XG5cbnB1YmxpYyBjbGFzcyAxMi4yLjIuUHJlZGljdFRoZVdpbm5lciB7XG4gICAgcHVibGljIGJvb2xlYW4gUHJlZGljdFRoZVdpbm5lcihpbnRbXSBudW1zKSB7XG4gICAgICAgIGludFtdW10gZHAgPSBuZXcgaW50W251bXMubGVuZ3RoXVtudW1zLmxlbmd0aF07XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZHBbaV1baV0gPSBudW1zW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IG51bXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGZvciAoaW50IGogPSBpICsgMTsgaiA8IG51bXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgZHBbaV1bal0gPSBNYXRoLm1heChudW1zW2ldIC0gZHBbaSArIDFdW2pdLCBudW1zW2pdIC0gZHBbaV1baiAtIDFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHBbMF1bbnVtcy5sZW5ndGggLSAxXSA+PSAwO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZnJvbSB0eXBpbmcgaW1wb3J0IExpc3RcblxuXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgUHJlZGljdFRoZVdpbm5lcihzZWxmLCBudW1zOiBMaXN0W2ludF0pIC0+IGJvb2w6XG4gICAgICAgIG4gPSBsZW4obnVtcylcblxuICAgICAgICBkcCA9IFtbMF0gKiBuIGZvciBfIGluIHJhbmdlKG4pXVxuXG4gICAgICAgIGZvciBpIGluIHJhbmdlKG4pOlxuICAgICAgICAgICAgZHBbaV1baV0gPSBudW1zW2ldXG5cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UobiAtIDEsIC0xLCAtMSk6XG4gICAgICAgICAgICBmb3IgaiBpbiByYW5nZShpICsgMSwgbik6XG4gICAgICAgICAgICAgICAgZHBbaV1bal0gPSBtYXgobnVtc1tpXSAtIGRwW2kgKyAxXVtqXSwgbnVtc1tqXSAtIGRwW2ldW2ogLSAxXSlcbiAgICAgICAgcmV0dXJuIGRwWzBdW24gLSAxXSA+PSAwXG5cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTIuMi4zIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgYm9vbCBQcmVkaWN0VGhlV2lubmVyKHZlY3RvcjxpbnQ+JiBudW1zKSB7XG4gICAgICAgIGludCBsZW4gPSBudW1zLnNpemUoKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChsZW4gJSAyID09IDAgfHwgbGVuID09IDEpIHJldHVybiB0cnVlO1xuICAgICAgICBcbiAgICAgICAgdmVjdG9yPGludD4gZHAobGVuLCAwKTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoaW50IGkgPSBsZW4gLSAxOyBpID4gLTE7IGktLSkge1xuICAgICAgICAgICAgZHBbaV0gPSBudW1zW2ldO1xuICAgICAgICAgICAgZm9yIChpbnQgaiA9IGkgKyAxOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBkcFtqXSA9IG1heChudW1zW2ldIC0gZHBbal0sIG51bXNbal0gLSBkcFtqIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZHBbbGVuIC0gMV0gPj0gMDsgXG4gICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogInBhY2thZ2UgY2gxMi5jb2RlO1xuXG5wdWJsaWMgY2xhc3MgMTIuMi4zLlByZWRpY3RUaGVXaW5uZXIge1xuICAgIHB1YmxpYyBib29sZWFuIFByZWRpY3RUaGVXaW5uZXIoaW50W10gbnVtcykge1xuICAgICAgICBpZiAobnVtcy5sZW5ndGggPT0gMSB8fCBudW1zLmxlbmd0aCAlIDIgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGludFtdIGRwID0gbmV3IGludFtudW1zLmxlbmd0aF07XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IG51bXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGRwW2ldID0gbnVtc1tpXTtcbiAgICAgICAgICAgIGZvciAoaW50IGogPSBpICsgMTsgaiA8IG51bXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgZHBbal0gPSBNYXRoLm1heChudW1zW2ldIC0gZHBbal0sIG51bXNbal0gLSBkcFtqIC0gMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkcFtudW1zLmxlbmd0aCAtIDFdID49IDA7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBQcmVkaWN0VGhlV2lubmVyKHNlbGYsIG51bXM6IExpc3RbaW50XSkgLT4gYm9vbDpcbiAgICAgICAgbiA9IGxlbihudW1zKVxuICAgICAgICBpZiBuICUgMiA9PSAwIG9yIG4gPT0gMTpcbiAgICAgICAgICAgIHJldHVybiBUcnVlXG4gICAgICAgIGRwID0gWzBdICogblxuXG4gICAgICAgIGZvciBpIGluIHJhbmdlKG4gLSAxLCAtMSwgLTEpOlxuICAgICAgICAgICAgZHBbaV0gPSBudW1zW2ldXG4gICAgICAgICAgICBmb3IgaiBpbiByYW5nZShpICsgMSwgbik6XG4gICAgICAgICAgICAgICAgZHBbal0gPSBtYXgobnVtc1tpXSAtIGRwW2pdLCBudW1zW2pdIC0gZHBbaiAtIDFdKVxuICAgICAgICByZXR1cm4gZHBbLTFdID49IDBcblxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExMi4zLjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIi8vVExFXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgYm9vbCBjYW5XaW5OaW0oaW50IG4pIHtcblx0Ym9vbCByZXMgPSBmYWxzZTtcbiAgICAgICAgYm9vbCAqbWVtID0gKGJvb2wgKiltYWxsb2MoKG4gKyAxKSAqIHNpemVvZihib29sKSk7XG4gICAgICAgIG1lbXNldChtZW0sIHRydWUsIChuICsgMSkgKiBzaXplb2YoYm9vbCkpO1xuICAgICAgICBcbiAgICAgICAgZm9yIChpbnQgaSA9IDQ7IGkgPCBuICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIShtZW1baSAtIDFdICYmIG1lbVtpIC0gMl0gJiYgbWVtW2kgLSAzXSkpXG4gICAgICAgICAgICAgICAgbWVtW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZW1baV0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBcblx0cmVzID0gbWVtW25dO1xuXHRmcmVlKG1lbSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogInBhY2thZ2UgY2gxMi5jb2RlO1xuXG5wdWJsaWMgY2xhc3MgTmltR2FtZSB7XG4gICAgcHVibGljIGJvb2xlYW4gY2FuV2luTmltKGludCBuKSB7XG4gICAgICAgIGJvb2xlYW5bXSBtZW0gPSBuZXcgYm9vbGVhbltuICsgMV07XG4gICAgICAgIG1lbVsxXSA9IHRydWU7XG4gICAgICAgIG1lbVsyXSA9IHRydWU7XG4gICAgICAgIG1lbVszXSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IDQ7IGkgPCBuICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIShtZW1baSAtIDFdICYmIG1lbVtpIC0gMl0gJiYgbWVtW2kgLSAzXSkpXG4gICAgICAgICAgICAgICAgbWVtW2ldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtW25dO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGNhbldpbk5pbShzZWxmLCBuOiBpbnQpIC0+IGJvb2w6XG4gICAgICAgIG1lbSA9IFtUcnVlXSAqIChuICsgMSlcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoNCwgbiArIDEpOlxuICAgICAgICAgICAgaWYgbm90IChtZW1baSAtIDFdIGFuZCBtZW1baSAtIDJdIGFuZCBtZW1baSAtIDNdKTpcbiAgICAgICAgICAgICAgICBtZW1baV0gPSBUcnVlXG4gICAgICAgICAgICBlbHNlOlxuICAgICAgICAgICAgICAgIG1lbVtpXSA9IEZhbHNlXG4gICAgICAgIHJldHVybiBtZW1bbl1cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTEyLjMuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGJvb2wgY2FuV2luTmltKGludCBuKSB7XG4gICAgICAgIGlmIChuIDwgNCkgcmV0dXJuIHRydWU7XG4gICAgICAgIFxuICAgICAgICBpbnQgYSA9IHRydWUsIGIgPSB0cnVlLCBjID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoaW50IGkgPSA0OyBpIDwgbiArIDE7IGkrKykge1xuICAgICAgICAgICAgaW50IGN1cnJlbnQgPSAhKGEgJiYgYiAmJiBjKTtcbiAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgICAgYiA9IGM7XG4gICAgICAgICAgICBjID0gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogInBhY2thZ2UgY2gxMi5jb2RlO1xuXG5wdWJsaWMgY2xhc3MgTmltR2FtZSB7XG4gICAgcHVibGljIGJvb2xlYW4gY2FuV2luTmltKGludCBuKSB7XG4gICAgICAgIGlmIChuIDwgNClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGJvb2xlYW4gYSA9IHRydWUsIGIgPSB0cnVlLCBjID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGludCBpID0gNDsgaSA8IG4gKyAxOyBpKyspIHtcbiAgICAgICAgICAgIGJvb2xlYW4gY3VycmVudCA9IGEgJiYgYiAmJiBjID8gZmFsc2UgOiB0cnVlO1xuICAgICAgICAgICAgYSA9IGI7XG4gICAgICAgICAgICBiID0gYztcbiAgICAgICAgICAgIGMgPSBjdXJyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgY2FuV2luTmltKHNlbGYsIG46IGludCkgLT4gYm9vbDpcbiAgICAgICAgaWYgbiA8IDQ6XG4gICAgICAgICAgICByZXR1cm4gVHJ1ZVxuICAgICAgICBhLCBiLCBjID0gVHJ1ZSwgVHJ1ZSwgVHJ1ZVxuICAgICAgICBmb3IgaSBpbiByYW5nZSg0LCBuICsgMSk6XG4gICAgICAgICAgICBjdXJyZW50ID0gbm90IChhIGFuZCBiIGFuZCBjKVxuICAgICAgICAgICAgYSwgYiwgYyA9IGIsIGMsIGN1cnJlbnRcbiAgICAgICAgcmV0dXJuIGNcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTIuMy4zIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgYm9vbCBjYW5XaW5OaW0oaW50IG4pIHtcbiAgICAgICByZXR1cm4gbiAlIDQgIT0gMDtcbiAgICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicGFja2FnZSBjaDEyLmNvZGU7XG5cbnB1YmxpYyBjbGFzcyBOaW1HYW1lIHtcbiAgICBwdWJsaWMgYm9vbGVhbiBjYW5XaW5OaW0oaW50IG4pIHtcbiAgICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwICE9IG4gJSA0O1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGNhbldpbk5pbTMoc2VsZiwgbjogaW50KSAtPiBib29sOlxuICAgICAgICByZXR1cm4gbiAlIDQgIT0gMFxuXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTEyLjQuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHJpdmF0ZTpcbiAgICBpbnQgY29zdChpbnQgbG93LCBpbnQgaGlnaCkge1xuICAgICAgICBpZiAobG93ID49IGhpZ2gpIHJldHVybiAwO1xuICAgICAgICBcbiAgICAgICAgaW50IHJlcyA9IElOVF9NQVg7XG4gICAgICAgIGZvciAoaW50IGkgPSBsb3c7IGkgPCBoaWdoICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBpbnQgdG1wID0gaSArIG1heChjb3N0KGxvdywgaSAtIDEpLCBjb3N0KGkgKyAxLCBoaWdoKSk7XG4gICAgICAgICAgICByZXMgPSBtaW4ocmVzLCB0bXApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbnB1YmxpYzpcbiAgICBpbnQgZ2V0TW9uZXlBbW91bnQoaW50IG4pIHtcbiAgICAgICAgcmV0dXJuIGNvc3QoMSwgbik7XG4gICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogInB1YmxpYyBjbGFzcyBHZXRNb25leUFtb3VudCB7XG5cbiAgICBwdWJsaWMgaW50IGNvc3QoaW50IGxvdywgaW50IGhpZ2gpIHtcbiAgICAgICAgaWYgKGxvdyA+PSBoaWdoKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGludCByZXMgPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICAgICAgZm9yIChpbnQgaSA9IGxvdzsgaSA8PSBoaWdoOyBpKyspIHtcbiAgICAgICAgICAgIGludCB0bXAgPSBpICsgTWF0aC5tYXgoY29zdChpICsgMSwgaGlnaCksIGNvc3QobG93LCBpIC0gMSkpO1xuICAgICAgICAgICAgcmVzID0gTWF0aC5taW4odG1wLCByZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgcHVibGljIGludCBnZXRNb25leUFtb3VudChpbnQgbikge1xuICAgICAgICByZXR1cm4gY29zdCgxLCBuKTtcbiAgICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBzeXNcblxuXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgZ2V0TW9uZXlBbW91bnQoc2VsZiwgbjogaW50KSAtPiBpbnQ6XG4gICAgICAgIGRlZiBjb3N0KGxvdzogaW50LCBoaWdoOiBpbnQpIC0+IGludDpcbiAgICAgICAgICAgIGlmIGxvdyA+PSBoaWdoOlxuICAgICAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgICAgICByZXMgPSBzeXMubWF4c2l6ZVxuICAgICAgICAgICAgZm9yIGkgaW4gcmFuZ2UobG93LCBoaWdoICsgMSk6XG4gICAgICAgICAgICAgICAgdG1wID0gaSArIG1heChcbiAgICAgICAgICAgICAgICAgICAgY29zdChsb3csIGkgLSAxKSwgY29zdChpICsgMSwgaGlnaClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgcmVzID0gbWluKHJlcywgdG1wKVxuICAgICAgICAgICAgcmV0dXJuIHJlc1xuXG4gICAgICAgIHJldHVybiBjb3N0KDEsIG4pXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTEyLjQuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHJpdmF0ZTpcbiAgICBpbnQgY29zdChpbnQgbG93LCBpbnQgaGlnaCwgdmVjdG9yPHZlY3RvcjxpbnQ+PiBtZW0pIHtcbiAgICAgICAgaWYgKGxvdyA+PSBoaWdoKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIFxuICAgICAgICBpZiAobWVtW2xvd11baGlnaF0pXG4gICAgICAgICAgICByZXR1cm4gbWVtW2xvd11baGlnaF07XG4gICAgICAgIFxuICAgICAgICBpbnQgcmVzID0gSU5UX01BWDtcbiAgICAgICAgZm9yIChpbnQgaSA9IChsb3cgKyBoaWdoKSAvIDI7IGkgPCBoaWdoICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBpbnQgdG1wID0gaSArIG1heChjb3N0KGxvdywgaSAtIDEsIG1lbSksIGNvc3QoaSArIDEsIGhpZ2gsIG1lbSkpO1xuICAgICAgICAgICAgcmVzID0gbWluKHJlcywgdG1wKTtcbiAgICAgICAgfVxuICAgICAgICBtZW1bbG93XVtoaWdoXSA9IHJlcztcbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxucHVibGljOlxuICAgIGludCBnZXRNb25leUFtb3VudChpbnQgbikge1xuICAgICAgICBpZiAobiA9PSAxKSByZXR1cm4gMDtcblxuICAgICAgICB2ZWN0b3I8dmVjdG9yPGludD4+IG1lbShuICsgMSwgdmVjdG9yPGludD4obiArIDEsIDApKTtcbiAgICAgICAgcmV0dXJuIGNvc3QoMSwgbiwgbWVtKTtcbiAgICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicHVibGljIGNsYXNzIEdldE1vbmV5QW1vdW50IHtcblxuICAgIHB1YmxpYyBpbnQgZ2V0TW9uZXlBbW91bnQgKGludCBuKXtcbiAgICAgICAgaWYgKG4gPT0gMSkgcmV0dXJuIDA7XG4gICAgICAgIGludFtdW10gbWVtID0gbmV3IGludFtuICsgMV1bbiArIDFdO1xuICAgICAgICByZXR1cm4gY29zdCgxLCBuLCBtZW0pO1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbnQgY29zdChpbnQgbG93LCBpbnQgaGlnaCwgaW50W11bXSBtZW0pIHtcbiAgICAgICAgaWYgKGxvdyA+PSBoaWdoKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGlmIChtZW1bbG93XVtoaWdoXSAhPSAwKVxuICAgICAgICAgICAgcmV0dXJuIG1lbVtsb3ddW2hpZ2hdO1xuICAgICAgICBpbnQgbWluUmVzID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgIGZvciAoaW50IGkgPSAobG93ICsgaGlnaCkgLyAyOyBpIDw9IGhpZ2g7IGkrKykge1xuICAgICAgICAgICAgaW50IHJlcyA9IGkgKyBNYXRoLm1heChjb3N0KGkgKyAxLCBoaWdoLCBtZW0pLCBjb3N0KGxvdywgaSAtIDEsIG1lbSkpO1xuICAgICAgICAgICAgbWluUmVzID0gTWF0aC5taW4ocmVzLCBtaW5SZXMpO1xuICAgICAgICB9XG4gICAgICAgIG1lbVtsb3ddW2hpZ2hdID0gbWluUmVzO1xuICAgICAgICByZXR1cm4gbWluUmVzO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiaW1wb3J0IHN5c1xuZnJvbSB0eXBpbmcgaW1wb3J0IExpc3RcblxuXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgZ2V0TW9uZXlBbW91bnQoc2VsZiwgbjogaW50KSAtPiBpbnQ6XG4gICAgICAgIGRlZiBjb3N0KGxvdzogaW50LCBoaWdoOiBpbnQsIG1lbTogTGlzdFtMaXN0W2ludF1dKSAtPiBpbnQ6XG5cbiAgICAgICAgICAgIGlmIGxvdyA+PSBoaWdoOlxuICAgICAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgICAgICBpZiBtZW1bbG93XVtoaWdoXSAhPSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBtZW1bbG93XVtoaWdoXVxuXG4gICAgICAgICAgICByZXMgPSBzeXMubWF4c2l6ZVxuICAgICAgICAgICAgZm9yIGkgaW4gcmFuZ2UoKGxvdyArIGhpZ2gpIC8vIDIsIGhpZ2ggKyAxKTpcbiAgICAgICAgICAgICAgICB0bXAgPSBpICsgbWF4KFxuICAgICAgICAgICAgICAgICAgICBjb3N0KGxvdywgaSAtIDEsIG1lbSksXG4gICAgICAgICAgICAgICAgICAgIGNvc3QoaSArIDEsIGhpZ2gsIG1lbSksXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHJlcyA9IG1pbihyZXMsIHRtcClcbiAgICAgICAgICAgIG1lbVtsb3ddW2hpZ2hdID0gcmVzXG4gICAgICAgICAgICByZXR1cm4gcmVzXG5cbiAgICAgICAgaWYgbiA9PSAxOlxuICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgbWVtID0gW1swXSAqIChuICsgMSkgZm9yIF8gaW4gcmFuZ2UobiArIDEpXVxuXG4gICAgICAgIHJldHVybiBjb3N0KDEsIG4sIG1lbSlcblxuIgogICAgfV0KICB9XQp9LCB7CiAgImlkIjogIjEzIiwKICAibmFtZSI6ICLnrKzljYHkuInnq6AiLAogICJsaXN0IjogW3sKICAgICJ0aXRsZSI6ICLku6PnoIExMy4xLjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJwYWNrYWdlIGNoMTMuY29kZTtcbnB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG5cbiAgICBwdWJsaWMgaW50IG1heFByb2ZpdE9yaWdpbihpbnRbXSBwcmljZXMpIHtcbiAgICAgICAgaW50IG1heCA9IDA7XG4gICAgICAgIGZvciAoaW50IGkgPSBwcmljZXMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgZm9yIChpbnQgaiA9IGkgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmljZXNbaV0gLSBwcmljZXNbal0gPiBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IHByaWNlc1tpXSAtIHByaWNlc1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbn1cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTEzLjEuMS5iZXN0IiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gICAgcHVibGljOlxuICAgICAgICBpbnQgbWF4UHJvZml0KHZlY3RvcjxpbnQ+JiBwcmljZXMpIHtcbiAgICAgICAgICAgIGludCBtYXhwcm9maXQgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHByaWNlcy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSBpICsgMTsgaiA8IHByaWNlcy5zaXplKCk7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJpY2VzW2pdIC0gcHJpY2VzW2ldID4gbWF4cHJvZml0KVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4cHJvZml0ID0gcHJpY2VzW2pdIC0gcHJpY2VzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1heHByb2ZpdDtcbiAgICAgICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBtYXhQcm9maXQoc2VsZiwgcHJpY2VzOiBMaXN0W2ludF0pIC0+IGludDpcbiAgICAgICAgbWF4X2RpZmYgPSAwXG4gICAgICAgIGZvciBpIGluIHJhbmdlKDEsIGxlbihwcmljZXMpKTpcbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKDAsIGkpOlxuICAgICAgICAgICAgICAgIGlmIHByaWNlc1tpXSAtIHByaWNlc1tqXSA+IG1heF9kaWZmOlxuICAgICAgICAgICAgICAgICAgICBtYXhfZGlmZiA9IHByaWNlc1tpXSAtIHByaWNlc1tqXVxuICAgICAgICByZXR1cm4gbWF4X2RpZmZcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTMuMS4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicGFja2FnZSBjaDEzLmNvZGU7XG5wdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICAgIHB1YmxpYyBpbnQgbWF4UHJvZml0KGludFtdIHByaWNlcykge1xuICAgICAgICBpZiAocHJpY2VzID09IG51bGwgfHwgcHJpY2VzLmxlbmd0aCA8PSAxKSBcbiAgICAgICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGludCBtaW4gPSBwcmljZXNbMF07XG4gICAgICAgIGludCBtYXggPSAwO1xuXG4gICAgICAgIGZvciAoaW50IGkgPSAxOyBpIDwgcHJpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heChwcmljZXNbaV0gLSBtaW4sIG1heCk7XG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHByaWNlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExMy4xLjIuYmVzdCIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGludCBtYXhQcm9maXQodmVjdG9yPGludD4mIHByaWNlcykge1xuICAgICAgICBpZiAocHJpY2VzLnNpemUoKSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgaW50IG1heF9kaWZmID0gMDtcbiAgICAgICAgaW50IG1pbl9wcmljZSA9IHByaWNlc1swXTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoaW50IGkgPSAxOyBpIDwgcHJpY2VzLnNpemUoKTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobWluX3ByaWNlID4gcHJpY2VzW2ldKVxuICAgICAgICAgICAgICAgIG1pbl9wcmljZSA9IHByaWNlc1tpXTtcbiAgICAgICAgICAgIG1heF9kaWZmID0gbWF4KG1heF9kaWZmLCBwcmljZXNbaV0gLSBtaW5fcHJpY2UpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbWF4X2RpZmY7XG4gICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuaW1wb3J0IHN5c1xuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBtYXhQcm9maXQoc2VsZiwgcHJpY2VzOiBMaXN0W2ludF0pIC0+IGludDpcbiAgICAgICAgbWF4X2RpZmYgPSAwXG4gICAgICAgIG1pbl9wcmljZSA9IHN5cy5tYXhzaXplXG4gICAgICAgIGZvciBpIGluIHJhbmdlKGxlbihwcmljZXMpKTpcbiAgICAgICAgICAgIGlmIG1pbl9wcmljZSA+IHByaWNlc1tpXTpcbiAgICAgICAgICAgICAgICBtaW5fcHJpY2UgPSBwcmljZXNbaV1cbiAgICAgICAgICAgIG1heF9kaWZmID0gbWF4KG1heF9kaWZmLCBwcmljZXNbaV0gLSBtaW5fcHJpY2UpXG4gICAgICAgIHJldHVybiBtYXhfZGlmZlxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExMy4yLjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJwYWNrYWdlIGNoMTMuY29kZTtcbnB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gICAgcHVibGljIGludCBtYXhQcm9maXQoaW50W10gcHJpY2VzKSB7XG4gICAgICAgIGlmIChwcmljZXMgPT0gbnVsbCB8fCBwcmljZXMubGVuZ3RoIDwgMilcbiAgICAgICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGludCBhbnMgPSAwO1xuICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IHByaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHByaWNlc1tpXSAtIHByaWNlc1tpIC0gMV0gPiAwKVxuICAgICAgICAgICAgICAgIGFucyArPSBwcmljZXNbaV0gLSBwcmljZXNbaSAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbnM7XG4gICAgfVxufVxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTMuMi5iZXN0IiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgaW50IG1heFByb2ZpdCh2ZWN0b3I8aW50PiYgcHJpY2VzKSB7XG4gICAgICAgIGludCBtYXhwcm9maXQgPSAwO1xuICAgICAgICBpbnQgc2l6ZSA9IHByaWNlcy5zaXplKCk7XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IDE7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwcmljZXNbaV0gPiBwcmljZXNbaSAtIDFdKVxuICAgICAgICAgICAgICAgIG1heHByb2ZpdCArPSBwcmljZXNbaV0gLSBwcmljZXNbaSAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbWF4cHJvZml0O1xuICAgIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZnJvbSB0eXBpbmcgaW1wb3J0IExpc3RcblxuXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgbWF4UHJvZml0KHNlbGYsIHByaWNlczogTGlzdFtpbnRdKSAtPiBpbnQ6XG4gICAgICAgIGlmIGxlbihwcmljZXMpIDw9IDE6XG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICBtYXhfcHJvZml0ID0gMFxuICAgICAgICBmb3IgaSBpbiByYW5nZSgxLCBsZW4ocHJpY2VzKSk6XG4gICAgICAgICAgICBpZiBwcmljZXNbaV0gLSBwcmljZXNbaSAtIDFdID4gMDpcbiAgICAgICAgICAgICAgICBtYXhfcHJvZml0ICs9IHByaWNlc1tpXSAtIHByaWNlc1tpIC0gMV1cbiAgICAgICAgcmV0dXJuIG1heF9wcm9maXRcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTMuMy4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicGFja2FnZSBjaDEzLmNvZGU7XG5cbnB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gICAgcHVibGljIGludCBtYXhQcm9maXRPcmlnaW4oaW50W10gcHJpY2VzLCBpbnQgZmVlKSB7XG4gICAgICAgIGlmIChwcmljZXMgPT0gbnVsbCB8fCBwcmljZXMubGVuZ3RoIDwgMilcbiAgICAgICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGludFtdIGJ1eSA9IG5ldyBpbnRbcHJpY2VzLmxlbmd0aF0sIHNlbGwgPSBuZXcgaW50W3ByaWNlcy5sZW5ndGhdO1xuICAgICAgICBidXlbMF0gPSAtcHJpY2VzWzBdO1xuICAgICAgICBzZWxsWzBdID0gMDtcblxuICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IHByaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYnV5W2ldID0gTWF0aC5tYXgoYnV5W2kgLSAxXSwgc2VsbFtpIC0gMV0gLSBwcmljZXNbaV0pO1xuICAgICAgICAgICAgc2VsbFtpXSA9IE1hdGgubWF4KGJ1eVtpIC0gMV0gKyBwcmljZXNbaV0gLSBmZWUsIHNlbGxbaSAtIDFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxsW3ByaWNlcy5sZW5ndGggLSAxXTtcbiAgICB9XG59XG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExMy4zLjEuYmVzdCIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGludCBtYXhQcm9maXQodmVjdG9yPGludD4mIHByaWNlcywgaW50IGZlZSkge1xuICAgICAgICBpZiAocHJpY2VzLnNpemUoKSA8PSAxKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIFxuXHRpbnQgcmVzID0gMDtcbiAgICAgICAgaW50ICpidXkgID0gbmV3IGludFtwcmljZXMuc2l6ZSgpICsgMV0oKTtcbiAgICAgICAgaW50ICpzZWxsID0gbmV3IGludFtwcmljZXMuc2l6ZSgpICsgMV0oKTtcbiAgICAgICAgXG4gICAgICAgIGJ1eVswXSA9IC1wcmljZXNbMF07XG4gICAgICAgIFxuICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IHByaWNlcy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgYnV5W2ldICA9IG1heChidXlbaSAtIDFdLCBzZWxsW2kgLSAxXSAtIHByaWNlc1tpXSk7XG4gICAgICAgICAgICBzZWxsW2ldID0gbWF4KGJ1eVtpIC0gMV0gKyBwcmljZXNbaV0gLSBmZWUsIHNlbGxbaSAtIDFdKTtcbiAgICAgICAgfVxuXG5cdHJlcyA9IHNlbGxbcHJpY2VzLnNpemUoKSAtIDFdO1xuXHRkZWxldGUgW10gYnV5O1xuXHRkZWxldGUgW10gc2VsbDtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBtYXhQcm9maXQoc2VsZiwgcHJpY2VzOiBMaXN0W2ludF0sIGZlZTogaW50KSAtPiBpbnQ6XG4gICAgICAgIGlmIGxlbihwcmljZXMpIDw9IDE6XG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICAjIGJ1eSA9IFswIGZvciBpIGluIHJhbmdlKGxlbihwcmljZXMpKV1cbiAgICAgICAgIyBzZWxsID0gWzAgZm9yIGkgaW4gcmFuZ2UobGVuKHByaWNlcykpXVxuICAgICAgICBidXksIHNlbGwgPSBbMF0gKiBsZW4ocHJpY2VzKSwgWzBdICogbGVuKHByaWNlcylcbiAgICAgICAgYnV5WzBdID0gLXByaWNlc1swXVxuICAgICAgICBmb3IgaSBpbiByYW5nZSgxLCBsZW4ocHJpY2VzKSk6XG4gICAgICAgICAgICBidXlbaV0gPSBtYXgoYnV5W2kgLSAxXSwgc2VsbFtpIC0gMV0gLSBwcmljZXNbaV0pXG4gICAgICAgICAgICBzZWxsW2ldID0gbWF4KGJ1eVtpIC0gMV0gKyBwcmljZXNbaV0gLSBmZWUsIHNlbGxbaSAtIDFdKVxuICAgICAgICByZXR1cm4gc2VsbFstMV1cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTMuMy4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicGFja2FnZSBjaDEzLmNvZGU7XG5cbnB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gICAgcHVibGljIGludCBtYXhQcm9maXQoaW50W10gcHJpY2VzLCBpbnQgZmVlKSB7XG4gICAgICAgIGlmIChwcmljZXMgPT0gbnVsbCB8fCBwcmljZXMubGVuZ3RoIDwgMilcbiAgICAgICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGludCBwcmVCdXkgPSAtcHJpY2VzWzBdO1xuICAgICAgICBpbnQgcHJlU2VsbCA9IDA7XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IDE7IGkgPCBwcmljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGludCBidXkgPSBNYXRoLm1heChwcmVCdXksIHByZVNlbGwgLSBwcmljZXNbaV0pO1xuICAgICAgICAgICAgaW50IHNlbGwgPSBNYXRoLm1heChwcmVCdXkgKyBwcmljZXNbaV0gLSBmZWUsIHByZVNlbGwpO1xuXG4gICAgICAgICAgICBwcmVCdXkgPSBidXk7XG4gICAgICAgICAgICBwcmVTZWxsID0gc2VsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJlU2VsbDtcbiAgICB9XG59XG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExMy4zLjIuYmVzdCIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGludCBtYXhQcm9maXQodmVjdG9yPGludD4mIHByaWNlcywgaW50IGZlZSkge1xuICAgICAgICBpZiAocHJpY2VzLnNpemUoKSA8PSAxKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIFxuICAgICAgICBpbnQgcHJlX2J1eSAgPSAtcHJpY2VzWzBdO1xuICAgICAgICBpbnQgcHJlX3NlbGwgPSAwO1xuICAgICAgICBcbiAgICAgICAgZm9yIChpbnQgaSA9IDE7IGkgPCBwcmljZXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgICAgIGludCBidXkgID0gbWF4KHByZV9idXksIHByZV9zZWxsIC0gcHJpY2VzW2ldKTtcbiAgICAgICAgICAgIGludCBzZWxsID0gbWF4KHByZV9idXkgKyBwcmljZXNbaV0gLSBmZWUsIHByZV9zZWxsKTtcbiAgICAgICAgICAgIHByZV9idXkgID0gYnV5O1xuICAgICAgICAgICAgcHJlX3NlbGwgPSBzZWxsO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcHJlX3NlbGw7XG4gICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBtYXhQcm9maXQoc2VsZiwgcHJpY2VzOiBMaXN0W2ludF0sIGZlZTogaW50KSAtPiBpbnQ6XG4gICAgICAgIGlmIGxlbihwcmljZXMpIDw9IDE6XG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICBwcmVfYnV5ID0gLXByaWNlc1swXVxuICAgICAgICBwcmVfc2VsbCA9IDBcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMSwgbGVuKHByaWNlcykpOlxuICAgICAgICAgICAgYnV5ID0gbWF4KHByZV9idXksIHByZV9zZWxsIC0gcHJpY2VzW2ldKVxuICAgICAgICAgICAgc2VsbCA9IG1heChwcmVfYnV5ICsgcHJpY2VzW2ldIC0gZmVlLCBwcmVfc2VsbClcbiAgICAgICAgICAgIHByZV9idXkgPSBidXlcbiAgICAgICAgICAgIHByZV9zZWxsID0gc2VsbFxuICAgICAgICByZXR1cm4gcHJlX3NlbGxcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTMuNC4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicGFja2FnZSBjaDEzLmNvZGU7XG5wdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICAgIHB1YmxpYyBpbnQgbWF4UHJvZml0T3JpZ2luKGludFtdIHByaWNlcykge1xuICAgICAgICBpZiAocHJpY2VzID09IG51bGwgfHwgcHJpY2VzLmxlbmd0aCA8IDIpXG4gICAgICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICBpbnRbXSBidXkgPSBuZXcgaW50W3ByaWNlcy5sZW5ndGhdLCBzZWxsID0gbmV3IGludFtwcmljZXMubGVuZ3RoXTtcbiAgICAgICAgYnV5WzBdID0gLXByaWNlc1swXTtcbiAgICAgICAgc2VsbFswXSA9IDA7XG5cbiAgICAgICAgYnV5WzFdID0gTWF0aC5tYXgoKDAgLSBwcmljZXNbMV0pLCBidXlbMF0pO1xuICAgICAgICBzZWxsWzFdID0gTWF0aC5tYXgoKGJ1eVswXSArIHByaWNlc1sxXSksIHNlbGxbMF0pO1xuXG4gICAgICAgIGZvciAoaW50IGkgPSAyOyBpIDwgcHJpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBidXlbaV0gPSBNYXRoLm1heCgoc2VsbFtpIC0gMl0gLSBwcmljZXNbaV0pLCBidXlbaSAtIDFdKTtcbiAgICAgICAgICAgIHNlbGxbaV0gPSBNYXRoLm1heCgoYnV5W2kgLSAxXSArIHByaWNlc1tpXSksIHNlbGxbaSAtIDFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxsW3ByaWNlcy5sZW5ndGggLSAxXTtcbiAgICB9XG59XG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExMy40LjEuYmVzdCIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGludCBtYXhQcm9maXQodmVjdG9yPGludD4mIHByaWNlcykge1xuICAgICAgICBpZiAocHJpY2VzLnNpemUoKSA8PSAxKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIFxuICAgICAgICBpbnQgcmVzID0gMDtcbiAgICAgICAgaW50ICpidXkgID0gbmV3IGludFtwcmljZXMuc2l6ZSgpXSgpO1xuICAgICAgICBpbnQgKnNlbGwgPSBuZXcgaW50W3ByaWNlcy5zaXplKCldKCk7XG4gICAgICAgIGJ1eVswXSAgPSAtcHJpY2VzWzBdO1xuICAgICAgICBidXlbMV0gID0gbWF4KCgwIC0gcHJpY2VzWzFdKSwgYnV5WzBdKTtcbiAgICAgICAgc2VsbFsxXSA9IG1heCgoYnV5WzBdICsgcHJpY2VzWzFdKSwgc2VsbFswXSk7XG4gICAgICAgIFxuICAgICAgICBmb3IgKGludCBpID0gMjsgaSA8IHByaWNlcy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgYnV5W2ldICA9IG1heCgoc2VsbFtpIC0gMl0gLSBwcmljZXNbaV0pLCBidXlbaSAtIDFdKTtcbiAgICAgICAgICAgIHNlbGxbaV0gPSBtYXgoKGJ1eVtpIC0gMV0gKyBwcmljZXNbaV0pLCBzZWxsW2kgLSAxXSk7IFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXMgPSBzZWxsW3ByaWNlcy5zaXplKCkgLSAxXTtcbiAgICAgICAgXG4gICAgICAgIGRlbGV0ZSBbXSBidXk7XG4gICAgICAgIGRlbGV0ZSBbXSBzZWxsO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImZyb20gdHlwaW5nIGltcG9ydCBMaXN0XG5cblxuY2xhc3MgU29sdXRpb246XG4gICAgZGVmIG1heFByb2ZpdChzZWxmLCBwcmljZXM6IExpc3RbaW50XSkgLT4gaW50OlxuICAgICAgICBpZiBsZW4ocHJpY2VzKSA8PSAxOlxuICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgYnV5LCBzZWxsID0gWzBdICogbGVuKHByaWNlcyksIFswXSAqIGxlbihwcmljZXMpXG4gICAgICAgIGJ1eVswXSA9IC1wcmljZXNbMF1cbiAgICAgICAgYnV5WzFdID0gbWF4KCgwIC0gcHJpY2VzWzFdKSwgYnV5WzBdKVxuICAgICAgICBzZWxsWzFdID0gbWF4KChidXlbMF0gKyBwcmljZXNbMV0pLCBzZWxsWzBdKVxuICAgICAgICBmb3IgaSBpbiByYW5nZSgyLCBsZW4ocHJpY2VzKSk6XG4gICAgICAgICAgICBidXlbaV0gPSBtYXgoKHNlbGxbaSAtIDJdIC0gcHJpY2VzW2ldKSwgYnV5W2kgLSAxXSlcbiAgICAgICAgICAgIHNlbGxbaV0gPSBtYXgoKGJ1eVtpIC0gMV0gKyBwcmljZXNbaV0pLCBzZWxsW2kgLSAxXSlcbiAgICAgICAgcmV0dXJuIHNlbGxbLTFdXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTEzLjQuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogInBhY2thZ2UgY2gxMy5jb2RlO1xuXG5pbXBvcnQgamF2YS51dGlsLkFycmF5cztcblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgICBwdWJsaWMgaW50IG1heFByb2ZpdChpbnRbXSBwcmljZXMpIHtcbiAgICAgICAgaWYgKHByaWNlcyA9PSBudWxsIHx8IHByaWNlcy5sZW5ndGggPCAyKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgaW50IGIwID0gLXByaWNlc1swXTtcbiAgICAgICAgaW50IGIxID0gYjA7XG5cbiAgICAgICAgaW50IHMwID0gMDtcbiAgICAgICAgaW50IHMxID0gMDtcbiAgICAgICAgaW50IHMyID0gMDtcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBwcmljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGIwID0gTWF0aC5tYXgoYjEsIHMyIC0gcHJpY2VzW2ldKTtcbiAgICAgICAgICAgIHMwID0gTWF0aC5tYXgoczEsIGIwICsgcHJpY2VzW2ldKTtcblxuICAgICAgICAgICAgczIgPSBzMTtcbiAgICAgICAgICAgIHMxID0gczA7XG4gICAgICAgICAgICBiMSA9IGIwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzMDtcbiAgICB9XG59XG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExMy40LjIuYmVzdCIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGludCBtYXhQcm9maXQodmVjdG9yPGludD4mIHByaWNlcykge1xuICAgICAgICBpZiAocHJpY2VzLnNpemUoKSA8PSAxKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIFxuICAgICAgICBpbnQgYjAgPSAtcHJpY2VzWzBdO1xuICAgICAgICBpbnQgYjEgPSBiMDtcbiAgICAgICAgaW50IHMwID0gMCwgczEgPSAwLCBzMiA9IDA7XG4gICAgICAgIFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHByaWNlcy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgYjAgPSBtYXgoYjEsIHMyIC0gcHJpY2VzW2ldKTtcbiAgICAgICAgICAgIHMwID0gbWF4KHMxLCBiMCArIHByaWNlc1tpXSk7XG4gICAgICAgICAgICBzMiA9IHMxO1xuICAgICAgICAgICAgczEgPSBzMDtcbiAgICAgICAgICAgIGIxID0gYjA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzMDtcbiAgICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImZyb20gdHlwaW5nIGltcG9ydCBMaXN0XG5cblxuY2xhc3MgU29sdXRpb246XG5cbiAgICBkZWYgbWF4UHJvZml0KHNlbGYsIHByaWNlczogTGlzdFtpbnRdKSAtPiBpbnQ6XG4gICAgICAgIGlmIGxlbihwcmljZXMpIDw9IDE6XG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICBiMCA9IC1wcmljZXNbMF1cbiAgICAgICAgYjEgPSBiMFxuICAgICAgICBzMCwgczEsIHMyID0gMCwgMCwgMFxuICAgICAgICBmb3IgaSBpbiByYW5nZSgwLCBsZW4ocHJpY2VzKSk6XG4gICAgICAgICAgICBiMCA9IG1heChiMSwgczIgLSBwcmljZXNbaV0pXG4gICAgICAgICAgICBzMCA9IG1heChzMSwgYjAgKyBwcmljZXNbaV0pXG4gICAgICAgICAgICBzMiA9IHMxXG4gICAgICAgICAgICBzMSA9IHMwXG4gICAgICAgICAgICBiMSA9IGIwXG4gICAgICAgIHJldHVybiBzMFxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExMy41LjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJwYWNrYWdlIGNoMTMuY29kZTtcbnB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gICAgcHVibGljIGludCBtYXhQcm9maXQoaW50IGssIGludFtdIHByaWNlcykge1xuICAgICAgICBpZiAocHJpY2VzID09IG51bGwgfHwgcHJpY2VzLmxlbmd0aCA8IDIpXG4gICAgICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICBpbnRbXVtdIGRwID0gbmV3IGludFtrICsgMV1bcHJpY2VzLmxlbmd0aF07XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IDE7IGkgPD0gazsgaSsrKSB7XG4gICAgICAgICAgICBpbnQgbWluUHJpY2UgPSBwcmljZXNbMF07XG4gICAgICAgICAgICBmb3IgKGludCBqID0gMTsgaiA8IHByaWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIG1pblByaWNlID0gTWF0aC5taW4obWluUHJpY2UsIHByaWNlc1tqXSAtIGRwW2kgLSAxXVtqIC0gMV0pO1xuICAgICAgICAgICAgICAgIGRwW2ldW2pdID0gTWF0aC5tYXgoZHBbaV1baiAtIDFdLCBwcmljZXNbal0gLSBtaW5QcmljZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRwW2tdW3ByaWNlcy5sZW5ndGggLSAxXTtcbiAgICB9XG59XG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExMy41LjEuYmVzdCIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiLy9UaGlzIHNvbHV0aW9uIG1heWJlIFJ1bnRpbWUgRXJyb3JcbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgICBpbnQgbWF4UHJvZml0KGludCBrLCB2ZWN0b3I8aW50PiYgcHJpY2VzKSB7XG4gICAgICAgIGlmIChwcmljZXMuc2l6ZSgpIDw9IDEpIHJldHVybiAwO1xuICAgICAgICBcbiAgICAgICAgdmVjdG9yPHZlY3RvcjxpbnQ+PiBkcChrICsgMSwgdmVjdG9yPGludD4ocHJpY2VzLnNpemUoKSArIDEsIDApKTtcblxuICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IGsgKyAxOyBpKyspIHtcbiAgICAgICAgICAgIGludCBtaW5fcHJpY2UgPSBwcmljZXNbMF07XG4gICAgICAgICAgICBmb3IgKGludCBqID0gMTsgaiA8IHByaWNlcy5zaXplKCk7IGorKykge1xuICAgICAgICAgICAgICAgIG1pbl9wcmljZSA9IG1pbihtaW5fcHJpY2UsIHByaWNlc1tqXSAtIGRwW2kgLSAxXVtqIC0gMV0pO1xuICAgICAgICAgICAgICAgIGRwW2ldW2pdICA9IG1heChkcFtpXVtqIC0gMV0sIHByaWNlc1tqXSAtIG1pbl9wcmljZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBkcFtrXVtwcmljZXMuc2l6ZSgpIC0gMV07XG4gICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBtYXhQcm9maXQoc2VsZiwgazogaW50LCBwcmljZXM6IExpc3RbaW50XSkgLT4gaW50OlxuICAgICAgICBpZiBsZW4ocHJpY2VzKSA8PSAxOlxuICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgaWYgayA+IGxlbihwcmljZXMpIC8gMiArIDE6XG4gICAgICAgICAgICBtYXhfcHJvZml0ID0gMFxuICAgICAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMSwgbGVuKHByaWNlcykpOlxuICAgICAgICAgICAgICAgIGlmIHByaWNlc1tpXSAtIHByaWNlc1tpIC0gMV0gPiAwOlxuICAgICAgICAgICAgICAgICAgICBtYXhfcHJvZml0ICs9IHByaWNlc1tpXSAtIHByaWNlc1tpIC0gMV1cbiAgICAgICAgICAgIHJldHVybiBtYXhfcHJvZml0XG4gICAgICAgIGRwID0gW11cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMCwgayArIDEpOlxuICAgICAgICAgICAgZHAuYXBwZW5kKFswXSAqIGxlbihwcmljZXMpKVxuICAgICAgICBmb3IgaSBpbiByYW5nZSgxLCBrICsgMSk6XG4gICAgICAgICAgICBtaW5fcHJpY2UgPSBwcmljZXNbMF1cbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKDEsIGxlbihwcmljZXMpKTpcbiAgICAgICAgICAgICAgICBtaW5fcHJpY2UgPSBtaW4obWluX3ByaWNlLCBwcmljZXNbal0gLSBkcFtpIC0gMV1baiAtIDFdKVxuICAgICAgICAgICAgICAgIGRwW2ldW2pdID0gbWF4KGRwW2ldW2ogLSAxXSwgcHJpY2VzW2pdIC0gbWluX3ByaWNlKVxuICAgICAgICByZXR1cm4gZHBbLTFdWy0xXVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExMy41LjIiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJwYWNrYWdlIGNoMTMuY29kZTtcblxuaW1wb3J0IGphdmEudXRpbC5BcnJheXM7XG5cbnB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gICAgcHVibGljIGludCBtYXhQcm9maXQoaW50IGssIGludFtdIHByaWNlcykge1xuICAgICAgICBpZiAocHJpY2VzID09IG51bGwgfHwgcHJpY2VzLmxlbmd0aCA8IDIpXG4gICAgICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICBpZiAoayA+IHByaWNlcy5sZW5ndGggLyAyICsgMSkge1xuICAgICAgICAgICAgaW50IGFucyA9IDA7XG4gICAgICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IHByaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwcmljZXNbaV0gLSBwcmljZXNbaSAtIDFdID4gMClcbiAgICAgICAgICAgICAgICAgICAgYW5zICs9IHByaWNlc1tpXSAtIHByaWNlc1tpIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYW5zO1xuICAgICAgICB9XG5cbiAgICAgICAgaW50W10gbWluUHJpY2UgPSBuZXcgaW50W2sgKyAxXTtcbiAgICAgICAgQXJyYXlzLmZpbGwobWluUHJpY2UsIHByaWNlc1swXSk7XG5cbiAgICAgICAgaW50W10gZHAgPSBuZXcgaW50W2sgKyAxXTtcblxuICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IHByaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDE7IGogPD0gazsgaisrKSB7XG4gICAgICAgICAgICAgICAgbWluUHJpY2Vbal0gPSBNYXRoLm1pbihtaW5QcmljZVtqXSwgcHJpY2VzW2ldIC0gZHBbaiAtIDFdKTtcbiAgICAgICAgICAgICAgICBkcFtqXSA9IE1hdGgubWF4KGRwW2pdLCBwcmljZXNbaV0gLSBtaW5QcmljZVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRwW2tdO1xuICAgIH1cbn1cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTEzLjUuMi5iZXN0IiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgaW50IG1heFByb2ZpdChpbnQgaywgdmVjdG9yPGludD4mIHByaWNlcykge1xuICAgICAgICBpZiAocHJpY2VzLnNpemUoKSA8PSAxKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIFxuICAgICAgICBpZiAoayA+IChwcmljZXMuc2l6ZSgpIC8gMiArIDEpKSB7XG4gICAgICAgICAgICBpbnQgbWF4X3Byb2ZpdCA9IDA7XG4gICAgICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IHByaWNlcy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwcmljZXNbaV0gLSBwcmljZXNbaSAtIDFdID4gMClcbiAgICAgICAgICAgICAgICAgICAgbWF4X3Byb2ZpdCArPSBwcmljZXNbaV0gLSBwcmljZXNbaSAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gbWF4X3Byb2ZpdDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaW50ICptaW5fcHJpY2UgPSBuZXcgaW50W2sgKyAxXSgpO1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGsgKyAxOyBpKyspXG4gICAgICAgICAgICBtaW5fcHJpY2VbaV0gPSBwcmljZXNbMF07XG4gICAgICAgIFxuICAgICAgICBpbnQgKmRwICAgICAgICA9IG5ldyBpbnRbayArIDFdKCk7XG4gICAgICAgIFxuICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IHByaWNlcy5zaXplKCk7IGkrKykge1xuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDE7IGogPCBrICsgMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgbWluX3ByaWNlW2pdID0gbWluKG1pbl9wcmljZVtqXSwgcHJpY2VzW2ldIC0gZHBbaiAtIDFdKTtcbiAgICAgICAgICAgICAgICBkcFtqXSA9IG1heChkcFtqXSwgcHJpY2VzW2ldIC0gbWluX3ByaWNlW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaW50IHJlcyA9IGRwW2tdO1xuICAgICAgICBkZWxldGUgW10gbWluX3ByaWNlO1xuICAgICAgICBkZWxldGUgW10gZHA7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBtYXhQcm9maXQoc2VsZiwgazogaW50LCBwcmljZXM6IExpc3RbaW50XSkgLT4gaW50OlxuICAgICAgICBpZiBsZW4ocHJpY2VzKSA8PSAxOlxuICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgaWYgayA+IGxlbihwcmljZXMpIC8gMiArIDE6XG4gICAgICAgICAgICBtYXhfcHJvZml0ID0gMFxuICAgICAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMSwgbGVuKHByaWNlcykpOlxuICAgICAgICAgICAgICAgIGlmIHByaWNlc1tpXSAtIHByaWNlc1tpIC0gMV0gPiAwOlxuICAgICAgICAgICAgICAgICAgICBtYXhfcHJvZml0ICs9IHByaWNlc1tpXSAtIHByaWNlc1tpIC0gMV1cbiAgICAgICAgICAgIHJldHVybiBtYXhfcHJvZml0XG4gICAgICAgIG1pbl9wcmljZSwgZHAgPSBbcHJpY2VzWzBdXSAqIChrICsgMSksIFswXSAqIChrICsgMSlcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMSwgbGVuKHByaWNlcykpOlxuICAgICAgICAgICAgZm9yIGogaW4gcmFuZ2UoMSwgayArIDEpOlxuICAgICAgICAgICAgICAgIG1pbl9wcmljZVtqXSA9IG1pbihtaW5fcHJpY2Vbal0sIHByaWNlc1tpXSAtIGRwW2ogLSAxXSlcbiAgICAgICAgICAgICAgICBkcFtqXSA9IG1heChkcFtqXSwgcHJpY2VzW2ldIC0gbWluX3ByaWNlW2pdKVxuICAgICAgICByZXR1cm4gZHBba11cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTMuNi4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJpbnQgbWF4UHJvZml0KGludCBrLCB2ZWN0b3I8aW50PiYgcHJpY2VzKSB7XG4gICAgaWYgKHByaWNlcy5zaXplKCkgPD0gMSlcbiAgICAgICAgcmV0dXJuIDA7XG5cbiAgICBpbnQgKmRwID0gbmV3IGludFtwcmljZXMuc2l6ZSgpICsgMV0oKTtcbiAgICBtaW5fcHJpY2VzID0gcHJpY2VzWzBdO1xuXG4gICAgZm9yIChpbnQgaSA9IDE7IGkgPCBwcmljZXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgbWluX3ByaWNlID0gbWluKG1pbl9wcmljZSwgcHJpY2VzW2ldIC0gZHBbaSAtIDFdKTtcbiAgICAgICAgZHBbaSArIDFdID0gbWF4KGRwW2ldLCBwcmljZXNbaV0gLSBtaW5fcHJpY2UpO1xuICAgIH1cblxuICAgIGludCByZXMgPSBkcFtwcmljZXMuc2l6ZSgpIC0gMV07XG5cbiAgICBkZWxldGUgW10gZHA7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicGFja2FnZSBjaDEzLmNvZGU7XG5cbnB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gICAgcHVibGljIGludCBtYXhQcm9maXQoaW50W10gcHJpY2VzKSB7XG4gICAgICAgIGlmIChwcmljZXMgPT0gbnVsbCB8fCBwcmljZXMubGVuZ3RoIDwgMilcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBpbnRbXSBkcCA9IG5ldyBpbnRbcHJpY2VzLmxlbmd0aCArIDFdO1xuICAgICAgICBpbnQgbWluID0gcHJpY2VzWzBdO1xuXG4gICAgICAgIGZvciAoaW50IGkgPSAxOyBpIDwgcHJpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHByaWNlc1tpXSAtIGRwW2kgLSAxXSk7XG4gICAgICAgICAgICBkcFtpICsgMV0gPSBNYXRoLm1heChkcFtpXSwgcHJpY2VzW2ldIC0gbWluKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHBbZHAubGVuZ3RoIC0gMV07XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBtYXhQcm9maXQoc2VsZiwgcHJpY2VzOiBMaXN0W2ludF0pIC0+IGludDpcbiAgICAgICAgaWYgbGVuKHByaWNlcykgPD0gMTpcbiAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIGRwID0gWzBdICogKGxlbihwcmljZXMpKzEpXG4gICAgICAgIG1pbl9wcmljZSA9IHByaWNlc1swXVxuXG4gICAgICAgIGZvciBpIGluIHJhbmdlKDEsIGxlbihwcmljZXMpKTpcbiAgICAgICAgICAgIG1pbl9wcmljZSA9IG1pbihtaW5fcHJpY2UsIHByaWNlc1tpXSAtIGRwW2kgLSAxXSlcbiAgICAgICAgICAgIGRwW2kgKyAxXSA9IG1heChkcFtpXSwgcHJpY2VzW2ldIC0gbWluX3ByaWNlKVxuICAgICAgICByZXR1cm4gZHBbLTFdXG4iCiAgICB9XQogIH1dCn0sIHsKICAiaWQiOiAiMTQiLAogICJuYW1lIjogIuesrOWNgeWbm+eroCIsCiAgImxpc3QiOiBbewogICAgInRpdGxlIjogIuS7o+eggTE0LjEuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIExpc3ROb2RlKiBtZXJnZVR3b0xpc3RzKExpc3ROb2RlKiBsMSwgTGlzdE5vZGUqIGwyKSB7XG4gICAgICAgIGlmIChsMSA9PSBudWxscHRyKSB7XG4gICAgICAgICAgICByZXR1cm4gbDI7XG4gICAgICAgIH0gZWxzZSBpZiAobDIgPT0gbnVsbHB0cikge1xuICAgICAgICAgICAgcmV0dXJuIGwxO1xuICAgICAgICB9IGVsc2UgaWYgKGwxLT52YWwgPCBsMi0+dmFsKSB7XG4gICAgICAgICAgICBsMS0+bmV4dCA9IG1lcmdlVHdvTGlzdHMobDEtPm5leHQsIGwyKTtcbiAgICAgICAgICAgIHJldHVybiBsMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwyLT5uZXh0ID0gbWVyZ2VUd29MaXN0cyhsMSwgbDItPm5leHQpO1xuICAgICAgICAgICAgcmV0dXJuIGwyO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gICAgcHVibGljIExpc3ROb2RlIG1lcmdlVHdvTGlzdHMoTGlzdE5vZGUgbDEsIExpc3ROb2RlIGwyKSB7XG4gICAgICAgIGlmIChsMSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobDIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGwxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGwxLnZhbCA8IGwyLnZhbCkge1xuICAgICAgICAgICAgbDEubmV4dCA9IG1lcmdlVHdvTGlzdHMobDEubmV4dCwgbDIpO1xuICAgICAgICAgICAgcmV0dXJuIGwxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbDIubmV4dCA9IG1lcmdlVHdvTGlzdHMobDEsIGwyLm5leHQpO1xuICAgICAgICAgICAgcmV0dXJuIGwyO1xuICAgICAgICB9XG5cbiAgICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImZyb20gdHlwaW5nIGltcG9ydCBMaXN0XG4jIERlZmluaXRpb24gZm9yIHNpbmdseS1saW5rZWQgbGlzdC5cbmNsYXNzIExpc3ROb2RlOlxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCB4KTpcbiAgICAgICAgc2VsZi52YWwgPSB4XG4gICAgICAgIHNlbGYubmV4dCA9IE5vbmVcblxuXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgbWVyZ2VUd29MaXN0cyhzZWxmLCBsMTogTGlzdE5vZGUsIGwyOiBMaXN0Tm9kZSkgLT4gTGlzdE5vZGU6XG4gICAgICAgIGlmIGwxIGlzIE5vbmU6XG4gICAgICAgICAgICByZXR1cm4gbDJcbiAgICAgICAgaWYgbDIgaXMgTm9uZTpcbiAgICAgICAgICAgIHJldHVybiBsMVxuICAgICAgICBpZiBsMS52YWwgPCBsMi52YWw6XG4gICAgICAgICAgICBsMS5uZXh0ID0gc2VsZi5tZXJnZVR3b0xpc3RzKGwxLm5leHQsIGwyKVxuICAgICAgICAgICAgcmV0dXJuIGwxXG4gICAgICAgIGwyLm5leHQgPSBzZWxmLm1lcmdlVHdvTGlzdHMobDEsIGwyLm5leHQpXG4gICAgICAgIHJldHVybiBsMlxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTQuMS4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgTGlzdE5vZGUqIG1lcmdlVHdvTGlzdHMoTGlzdE5vZGUqIGwxLCBMaXN0Tm9kZSogbDIpIHtcbiAgICAgICAgTGlzdE5vZGUqIHByZUhlYWQgPSBuZXcgTGlzdE5vZGUoLTEpO1xuXG4gICAgICAgIExpc3ROb2RlKiBwcmV2ID0gcHJlSGVhZDtcbiAgICAgICAgd2hpbGUgKGwxICE9IG51bGxwdHIgJiYgbDIgIT0gbnVsbHB0cikge1xuICAgICAgICAgICAgaWYgKGwxLT52YWwgPCBsMi0+dmFsKSB7XG4gICAgICAgICAgICAgICAgcHJldi0+bmV4dCA9IGwxO1xuICAgICAgICAgICAgICAgIGwxID0gbDEtPm5leHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXYtPm5leHQgPSBsMjtcbiAgICAgICAgICAgICAgICBsMiA9IGwyLT5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IHByZXYtPm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDlkIjlubblkI4gbDEg5ZKMIGwyIOacgOWkmuWPquacieS4gOS4qui/mOacquiiq+WQiOW5tuWujO+8jOaIkeS7rOebtOaOpeWwhumTvuihqOacq+WwvuaMh+WQkeacquWQiOW5tuWujOeahOmTvuihqOWNs+WPr1xuICAgICAgICBwcmV2LT5uZXh0ID0gbDEgPT0gbnVsbHB0ciA/IGwyIDogbDE7XG5cbiAgICAgICAgcmV0dXJuIHByZUhlYWQtPm5leHQ7XG4gICAgfVxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gICAgcHVibGljIExpc3ROb2RlIG1lcmdlVHdvTGlzdHMoTGlzdE5vZGUgbDEsIExpc3ROb2RlIGwyKSB7XG4gICAgICAgIExpc3ROb2RlIHByZWhlYWQgPSBuZXcgTGlzdE5vZGUoLTEpO1xuXG4gICAgICAgIExpc3ROb2RlIHByZXYgPSBwcmVoZWFkO1xuICAgICAgICB3aGlsZSAobDEgIT0gbnVsbCAmJiBsMiAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobDEudmFsIDw9IGwyLnZhbCkge1xuICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IGwxO1xuICAgICAgICAgICAgICAgIGwxID0gbDEubmV4dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbDI7XG4gICAgICAgICAgICAgICAgbDIgPSBsMi5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IHByZXYubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOWQiOW5tuWQjiBsMSDlkowgbDIg5pyA5aSa5Y+q5pyJ5LiA5Liq6L+Y5pyq6KKr5ZCI5bm25a6M77yM5oiR5Lus55u05o6l5bCG6ZO+6KGo5pyr5bC+5oyH5ZCR5pyq5ZCI5bm25a6M55qE6ZO+6KGo5Y2z5Y+vXG4gICAgICAgIHByZXYubmV4dCA9IGwxID09IG51bGwgPyBsMiA6IGwxO1xuXG4gICAgICAgIHJldHVybiBwcmVoZWFkLm5leHQ7XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuIyBEZWZpbml0aW9uIGZvciBzaW5nbHktbGlua2VkIGxpc3QuXG5jbGFzcyBMaXN0Tm9kZTpcbiAgICBkZWYgX19pbml0X18oc2VsZiwgeCk6XG4gICAgICAgIHNlbGYudmFsID0geFxuICAgICAgICBzZWxmLm5leHQgPSBOb25lXG5cblxuY2xhc3MgU29sdXRpb246XG4gICAgZGVmIG1lcmdlVHdvTGlzdHMoc2VsZiwgbDE6IExpc3ROb2RlLCBsMjogTGlzdE5vZGUpIC0+IExpc3ROb2RlOlxuICAgICAgICBcbiAgICAgICAgc2VudGluZWwgPSBMaXN0Tm9kZSgtMSkgIyDlk6jlhbXnu5PngrlcblxuICAgICAgICBjdXJyID0gc2VudGluZWxcbiAgICAgICAgd2hpbGUgbDEgYW5kIGwyOlxuICAgICAgICAgICAgaWYgbDEudmFsIDw9IGwyLnZhbDpcbiAgICAgICAgICAgICAgICBjdXJyLm5leHQgPSBsMVxuICAgICAgICAgICAgICAgIGwxID0gbDEubmV4dFxuICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICBjdXJyLm5leHQgPSBsMlxuICAgICAgICAgICAgICAgIGwyID0gbDIubmV4dCAgICAgICAgICAgIFxuICAgICAgICAgICAgY3VyciA9IGN1cnIubmV4dFxuXG4gICAgICAgIGN1cnIubmV4dCA9IGwxIGlmIGwxIGlzIG5vdCBOb25lIGVsc2UgbDJcblxuICAgICAgICByZXR1cm4gc2VudGluZWwubmV4dFxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTQuMS4zIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgTGlzdE5vZGUqIG1lcmdlVHdvTGlzdHMoTGlzdE5vZGUgKmEsIExpc3ROb2RlICpiKSB7XG4gICAgICAgIGlmICgoIWEpIHx8ICghYikpIHJldHVybiBhID8gYSA6IGI7XG4gICAgICAgIExpc3ROb2RlIGhlYWQsICp0YWlsID0gJmhlYWQsICphUHRyID0gYSwgKmJQdHIgPSBiO1xuICAgICAgICB3aGlsZSAoYVB0ciAmJiBiUHRyKSB7XG4gICAgICAgICAgICBpZiAoYVB0ci0+dmFsIDwgYlB0ci0+dmFsKSB7XG4gICAgICAgICAgICAgICAgdGFpbC0+bmV4dCA9IGFQdHI7IGFQdHIgPSBhUHRyLT5uZXh0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YWlsLT5uZXh0ID0gYlB0cjsgYlB0ciA9IGJQdHItPm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWlsID0gdGFpbC0+bmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0YWlsLT5uZXh0ID0gKGFQdHIgPyBhUHRyIDogYlB0cik7XG4gICAgICAgIHJldHVybiBoZWFkLm5leHQ7XG4gICAgfVxuXG4gICAgTGlzdE5vZGUqIG1lcmdlS0xpc3RzKHZlY3RvcjxMaXN0Tm9kZSo+JiBsaXN0cykge1xuICAgICAgICBMaXN0Tm9kZSAqYW5zID0gbnVsbHB0cjtcbiAgICAgICAgZm9yIChzaXplX3QgaSA9IDA7IGkgPCBsaXN0cy5zaXplKCk7ICsraSkge1xuICAgICAgICAgICAgYW5zID0gbWVyZ2VUd29MaXN0cyhhbnMsIGxpc3RzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5zO1xuICAgIH1cbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICAgIHB1YmxpYyBMaXN0Tm9kZSBtZXJnZVR3b0xpc3RzKExpc3ROb2RlIGwxLCBMaXN0Tm9kZSBsMikge1xuICAgICAgICBpZiAobDEgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGwyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGwyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsMS52YWwgPCBsMi52YWwpIHtcbiAgICAgICAgICAgIGwxLm5leHQgPSBtZXJnZVR3b0xpc3RzKGwxLm5leHQsIGwyKTtcbiAgICAgICAgICAgIHJldHVybiBsMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGwyLm5leHQgPSBtZXJnZVR3b0xpc3RzKGwxLCBsMi5uZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBsMjtcbiAgICAgICAgfVxuXG4gICAgfVxuICAgIFxuICAgIHB1YmxpYyBMaXN0Tm9kZSBtZXJnZUtMaXN0cyhMaXN0Tm9kZVtdIGxpc3RzKSB7XG4gICAgICAgIExpc3ROb2RlIHJlcyA9IG51bGw7XG4gICAgICAgIGZvciAoTGlzdE5vZGUgbGlzdDogbGlzdHMpIHtcbiAgICAgICAgICAgIHJlcyA9IG1lcmdlVHdvTGlzdHMocmVzLCBsaXN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZnJvbSB0eXBpbmcgaW1wb3J0IExpc3RcbiMgRGVmaW5pdGlvbiBmb3Igc2luZ2x5LWxpbmtlZCBsaXN0LlxuY2xhc3MgTGlzdE5vZGU6XG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIHgpOlxuICAgICAgICBzZWxmLnZhbCA9IHhcbiAgICAgICAgc2VsZi5uZXh0ID0gTm9uZVxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBtZXJnZUtMaXN0cyhzZWxmLCBsaXN0czogTGlzdFtMaXN0Tm9kZV0pIC0+IExpc3ROb2RlOlxuICAgICAgICBkZWYgbWVyZ2VUd29MaXN0cyhsMTogTGlzdE5vZGUsIGwyOiBMaXN0Tm9kZSkgLT4gTGlzdE5vZGU6XG5cbiAgICAgICAgICAgIHNlbnRpbmVsID0gTGlzdE5vZGUoLTEpICAjIOWTqOWFtee7k+eCuVxuXG4gICAgICAgICAgICBjdXJyID0gc2VudGluZWxcbiAgICAgICAgICAgIHdoaWxlIGwxIGFuZCBsMjpcbiAgICAgICAgICAgICAgICBpZiBsMS52YWwgPD0gbDIudmFsOlxuICAgICAgICAgICAgICAgICAgICBjdXJyLm5leHQgPSBsMVxuICAgICAgICAgICAgICAgICAgICBsMSA9IGwxLm5leHRcbiAgICAgICAgICAgICAgICBlbHNlOlxuICAgICAgICAgICAgICAgICAgICBjdXJyLm5leHQgPSBsMlxuICAgICAgICAgICAgICAgICAgICBsMiA9IGwyLm5leHRcbiAgICAgICAgICAgICAgICBjdXJyID0gY3Vyci5uZXh0XG5cbiAgICAgICAgICAgIGN1cnIubmV4dCA9IGwxIGlmIGwxIGlzIG5vdCBOb25lIGVsc2UgbDJcblxuICAgICAgICAgICAgcmV0dXJuIHNlbnRpbmVsLm5leHRcblxuICAgICAgICBpZiBub3QgbGlzdHM6XG4gICAgICAgICAgICByZXR1cm4gTm9uZVxuICAgICAgICBsID0gbGlzdHNbMF1cblxuICAgICAgICBmb3IgaSBpbiByYW5nZSgxLCBsZW4obGlzdHMpKTpcbiAgICAgICAgICAgIGwgPSBtZXJnZVR3b0xpc3RzKGwsIGxpc3RzW2ldKVxuXG4gICAgICAgIHJldHVybiBsXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE0LjEuNCIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIExpc3ROb2RlKiBtZXJnZVR3b0xpc3RzKExpc3ROb2RlICphLCBMaXN0Tm9kZSAqYikge1xuICAgICAgICBpZiAoKCFhKSB8fCAoIWIpKSByZXR1cm4gYSA/IGEgOiBiO1xuICAgICAgICBMaXN0Tm9kZSBoZWFkLCAqdGFpbCA9ICZoZWFkLCAqYVB0ciA9IGEsICpiUHRyID0gYjtcbiAgICAgICAgd2hpbGUgKGFQdHIgJiYgYlB0cikge1xuICAgICAgICAgICAgaWYgKGFQdHItPnZhbCA8IGJQdHItPnZhbCkge1xuICAgICAgICAgICAgICAgIHRhaWwtPm5leHQgPSBhUHRyOyBhUHRyID0gYVB0ci0+bmV4dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFpbC0+bmV4dCA9IGJQdHI7IGJQdHIgPSBiUHRyLT5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFpbCA9IHRhaWwtPm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGFpbC0+bmV4dCA9IChhUHRyID8gYVB0ciA6IGJQdHIpO1xuICAgICAgICByZXR1cm4gaGVhZC5uZXh0O1xuICAgIH1cblxuICAgIExpc3ROb2RlKiBtZXJnZSh2ZWN0b3IgPExpc3ROb2RlKj4gJmxpc3RzLCBpbnQgbCwgaW50IHIpIHtcbiAgICAgICAgaWYgKGwgPT0gcikgcmV0dXJuIGxpc3RzW2xdO1xuICAgICAgICBpZiAobCA+IHIpIHJldHVybiBudWxscHRyO1xuICAgICAgICBpbnQgbWlkID0gKGwgKyByKSA+PiAxO1xuICAgICAgICByZXR1cm4gbWVyZ2VUd29MaXN0cyhtZXJnZShsaXN0cywgbCwgbWlkKSwgbWVyZ2UobGlzdHMsIG1pZCArIDEsIHIpKTtcbiAgICB9XG5cbiAgICBMaXN0Tm9kZSogbWVyZ2VLTGlzdHModmVjdG9yPExpc3ROb2RlKj4mIGxpc3RzKSB7XG4gICAgICAgIHJldHVybiBtZXJnZShsaXN0cywgMCwgbGlzdHMuc2l6ZSgpIC0gMSk7XG4gICAgfVxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICIvKipcbiAqIERlZmluaXRpb24gZm9yIHNpbmdseS1saW5rZWQgbGlzdC5cbiAqIHB1YmxpYyBjbGFzcyBMaXN0Tm9kZSB7XG4gKiAgICAgaW50IHZhbDtcbiAqICAgICBMaXN0Tm9kZSBuZXh0O1xuICogICAgIExpc3ROb2RlKGludCB4KSB7IHZhbCA9IHg7IH1cbiAqIH1cbiAqL1xuY2xhc3MgU29sdXRpb24ge1xuICAgcHVibGljIExpc3ROb2RlIG1lcmdlS0xpc3RzKExpc3ROb2RlW10gbGlzdHMpIHtcbiAgICAgICAgaWYgKGxpc3RzID09IG51bGwgfHwgbGlzdHMubGVuZ3RoID09IDApIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbWVyZ2UobGlzdHMsIDAsIGxpc3RzLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIHByaXZhdGUgTGlzdE5vZGUgbWVyZ2UoTGlzdE5vZGVbXSBsaXN0cywgaW50IGxlZnQsIGludCByaWdodCkge1xuICAgICAgICBpZiAobGVmdCA9PSByaWdodCkgcmV0dXJuIGxpc3RzW2xlZnRdO1xuICAgICAgICBpbnQgbWlkID0gbGVmdCArIChyaWdodCAtIGxlZnQpIC8gMjtcbiAgICAgICAgTGlzdE5vZGUgbDEgPSBtZXJnZShsaXN0cywgbGVmdCwgbWlkKTtcbiAgICAgICAgTGlzdE5vZGUgbDIgPSBtZXJnZShsaXN0cywgbWlkICsgMSwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gbWVyZ2VUd29MaXN0cyhsMSwgbDIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgTGlzdE5vZGUgbWVyZ2VUd29MaXN0cyhMaXN0Tm9kZSBsMSwgTGlzdE5vZGUgbDIpIHtcbiAgICAgICAgaWYgKGwxID09IG51bGwpIHJldHVybiBsMjtcbiAgICAgICAgaWYgKGwyID09IG51bGwpIHJldHVybiBsMTtcbiAgICAgICAgaWYgKGwxLnZhbCA8IGwyLnZhbCkge1xuICAgICAgICAgICAgbDEubmV4dCA9IG1lcmdlVHdvTGlzdHMobDEubmV4dCwgbDIpO1xuICAgICAgICAgICAgcmV0dXJuIGwxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbDIubmV4dCA9IG1lcmdlVHdvTGlzdHMobDEsbDIubmV4dCk7XG4gICAgICAgICAgICByZXR1cm4gbDI7XG4gICAgICAgIH1cbiAgICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImZyb20gdHlwaW5nIGltcG9ydCBMaXN0XG4jIERlZmluaXRpb24gZm9yIHNpbmdseS1saW5rZWQgbGlzdC5cbmNsYXNzIExpc3ROb2RlOlxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCB4KTpcbiAgICAgICAgc2VsZi52YWwgPSB4XG4gICAgICAgIHNlbGYubmV4dCA9IE5vbmVcblxuXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgbWVyZ2VLTGlzdHMoc2VsZiwgbGlzdHM6IExpc3RbTGlzdE5vZGVdKSAtPiBMaXN0Tm9kZTpcbiAgICAgICAgZGVmIG1lcmdlVHdvTGlzdHMobDE6IExpc3ROb2RlLCBsMjogTGlzdE5vZGUpIC0+IExpc3ROb2RlOlxuXG4gICAgICAgICAgICBzZW50aW5lbCA9IExpc3ROb2RlKC0xKSAgIyDlk6jlhbXnu5PngrlcblxuICAgICAgICAgICAgY3VyciA9IHNlbnRpbmVsXG4gICAgICAgICAgICB3aGlsZSBsMSBhbmQgbDI6XG4gICAgICAgICAgICAgICAgaWYgbDEudmFsIDw9IGwyLnZhbDpcbiAgICAgICAgICAgICAgICAgICAgY3Vyci5uZXh0ID0gbDFcbiAgICAgICAgICAgICAgICAgICAgbDEgPSBsMS5uZXh0XG4gICAgICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICAgICAgY3Vyci5uZXh0ID0gbDJcbiAgICAgICAgICAgICAgICAgICAgbDIgPSBsMi5uZXh0XG4gICAgICAgICAgICAgICAgY3VyciA9IGN1cnIubmV4dFxuXG4gICAgICAgICAgICBjdXJyLm5leHQgPSBsMSBpZiBsMSBpcyBub3QgTm9uZSBlbHNlIGwyXG5cbiAgICAgICAgICAgIHJldHVybiBzZW50aW5lbC5uZXh0XG5cbiAgICAgICAgYW1vdW50ID0gbGVuKGxpc3RzKVxuICAgICAgICBpbnRlcnZhbCA9IDFcbiAgICAgICAgd2hpbGUgaW50ZXJ2YWwgPCBhbW91bnQ6XG4gICAgICAgICAgICBmb3IgaSBpbiByYW5nZSgwLCBhbW91bnQgLSBpbnRlcnZhbCwgaW50ZXJ2YWwgKiAyKTpcbiAgICAgICAgICAgICAgICBsaXN0c1tpXSA9IG1lcmdlVHdvTGlzdHMobGlzdHNbaV0sIGxpc3RzW2kgKyBpbnRlcnZhbF0pXG4gICAgICAgICAgICBpbnRlcnZhbCAqPSAyXG4gICAgICAgIHJldHVybiBsaXN0c1swXSBpZiBhbW91bnQgPiAwIGVsc2UgbGlzdHNcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTQuMS41IiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgc3RydWN0IFN0YXR1cyB7XG4gICAgICAgIGludCB2YWw7XG4gICAgICAgIExpc3ROb2RlICpwdHI7XG4gICAgICAgIGJvb2wgb3BlcmF0b3IgPCAoY29uc3QgU3RhdHVzICZyaHMpIGNvbnN0IHtcbiAgICAgICAgICAgIHJldHVybiB2YWwgPiByaHMudmFsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaW9yaXR5X3F1ZXVlIDxTdGF0dXM+IHE7XG5cbiAgICBMaXN0Tm9kZSogbWVyZ2VLTGlzdHModmVjdG9yPExpc3ROb2RlKj4mIGxpc3RzKSB7XG4gICAgICAgIGZvciAoYXV0byBub2RlOiBsaXN0cykge1xuICAgICAgICAgICAgaWYgKG5vZGUpIHEucHVzaCh7bm9kZS0+dmFsLCBub2RlfSk7XG4gICAgICAgIH1cbiAgICAgICAgTGlzdE5vZGUgaGVhZCwgKnRhaWwgPSAmaGVhZDtcbiAgICAgICAgd2hpbGUgKCFxLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIGF1dG8gZiA9IHEudG9wKCk7IHEucG9wKCk7XG4gICAgICAgICAgICB0YWlsLT5uZXh0ID0gZi5wdHI7IFxuICAgICAgICAgICAgdGFpbCA9IHRhaWwtPm5leHQ7XG4gICAgICAgICAgICBpZiAoZi5wdHItPm5leHQpIHEucHVzaCh7Zi5wdHItPm5leHQtPnZhbCwgZi5wdHItPm5leHR9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZC5uZXh0O1xuICAgIH1cbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiLyoqXG4gKiBEZWZpbml0aW9uIGZvciBzaW5nbHktbGlua2VkIGxpc3QuXG4gKiBwdWJsaWMgY2xhc3MgTGlzdE5vZGUge1xuICogICAgIGludCB2YWw7XG4gKiAgICAgTGlzdE5vZGUgbmV4dDtcbiAqICAgICBMaXN0Tm9kZShpbnQgeCkgeyB2YWwgPSB4OyB9XG4gKiB9XG4gKi9cbmNsYXNzIFNvbHV0aW9uIHtcbiAgIHB1YmxpYyBMaXN0Tm9kZSBtZXJnZUtMaXN0cyhMaXN0Tm9kZVtdIGxpc3RzKSB7XG4gICAgICAgIGlmIChsaXN0cyA9PSBudWxsIHx8IGxpc3RzLmxlbmd0aCA9PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgICAgUHJpb3JpdHlRdWV1ZTxMaXN0Tm9kZT4gcXVldWUgPSBuZXcgUHJpb3JpdHlRdWV1ZTw+KGxpc3RzLmxlbmd0aCwgbmV3IENvbXBhcmF0b3I8TGlzdE5vZGU+KCkge1xuICAgICAgICAgICAgQE92ZXJyaWRlXG4gICAgICAgICAgICBwdWJsaWMgaW50IGNvbXBhcmUoTGlzdE5vZGUgbzEsIExpc3ROb2RlIG8yKSB7XG4gICAgICAgICAgICAgICAgaWYgKG8xLnZhbCA8IG8yLnZhbCkgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG8xLnZhbCA9PSBvMi52YWwpIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBMaXN0Tm9kZSBkdW1teSA9IG5ldyBMaXN0Tm9kZSgwKTtcbiAgICAgICAgTGlzdE5vZGUgcCA9IGR1bW15O1xuICAgICAgICBmb3IgKExpc3ROb2RlIG5vZGUgOiBsaXN0cykge1xuICAgICAgICAgICAgaWYgKG5vZGUgIT0gbnVsbCkgcXVldWUuYWRkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICghcXVldWUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBwLm5leHQgPSBxdWV1ZS5wb2xsKCk7XG4gICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICAgICAgaWYgKHAubmV4dCAhPSBudWxsKSBxdWV1ZS5hZGQocC5uZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHVtbXkubmV4dDtcbiAgICB9XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImZyb20gdHlwaW5nIGltcG9ydCBMaXN0XG4jIERlZmluaXRpb24gZm9yIHNpbmdseS1saW5rZWQgbGlzdC5cbmNsYXNzIExpc3ROb2RlKG9iamVjdCk6XG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIHgpOlxuICAgICAgICBzZWxmLnZhbCA9IHhcbiAgICAgICAgc2VsZi5uZXh0ID0gTm9uZVxuXG5cbmNsYXNzIFNvbHV0aW9uKG9iamVjdCk6XG4gICAgZGVmIG1lcmdlS0xpc3RzKHNlbGYsIGxpc3RzOiBMaXN0W0xpc3ROb2RlXSkgLT4gTGlzdE5vZGU6XG4gICAgICAgIGltcG9ydCBoZWFwcVxuXG4gICAgICAgIGwgPSBbXVxuXG4gICAgICAgIGZvciBoZWFkIGluIGxpc3RzOlxuICAgICAgICAgICAgaWYgaGVhZDpcbiAgICAgICAgICAgICAgICBoZWFwcS5oZWFwcHVzaChsLCAoaGVhZC52YWwsIGhlYWQpKVxuXG4gICAgICAgIGR1bW15ID0gTGlzdE5vZGUoLTEpXG4gICAgICAgIGN1ciA9IGR1bW15XG5cbiAgICAgICAgd2hpbGUgbDpcbiAgICAgICAgICAgIF8sIG5vZGUgPSBoZWFwcS5oZWFwcG9wKGwpXG4gICAgICAgICAgICBjdXIubmV4dCA9IG5vZGVcbiAgICAgICAgICAgIGN1ciA9IGN1ci5uZXh0XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0XG4gICAgICAgICAgICBpZiBub2RlOlxuICAgICAgICAgICAgICAgIGhlYXBxLmhlYXBwdXNoKGwsIChub2RlLnZhbCwgbm9kZSkpXG5cbiAgICAgICAgcmV0dXJuIGR1bW15Lm5leHRcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTQuMi4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8aW9zdHJlYW0+XG4jaW5jbHVkZSA8dmVjdG9yPlxuXG51c2luZyBuYW1lc3BhY2Ugc3RkO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgaW50IGZpbmRLdGhMYXJnZXN0KHZlY3RvcjxpbnQ+ICZudW1zLCBpbnQgaykge1xuICAgICAgICBpbnQgc2l6ZSA9IG51bXMuc2l6ZSgpO1xuICAgICAgICBzb3J0KGJlZ2luKG51bXMpLCBlbmQobnVtcykpO1xuICAgICAgICByZXR1cm4gbnVtc1tzaXplIC0ga107XG4gICAgfVxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJpbXBvcnQgamF2YS51dGlsLkFycmF5cztcblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcblxuICAgIHB1YmxpYyBpbnQgZmluZEt0aExhcmdlc3QoaW50W10gbnVtcywgaW50IGspIHtcbiAgICAgICAgaW50IGxlbiA9IG51bXMubGVuZ3RoO1xuICAgICAgICBBcnJheXMuc29ydChudW1zKTtcbiAgICAgICAgcmV0dXJuIG51bXNbbGVuIC0ga107XG4gICAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBmaW5kS3RoTGFyZ2VzdChzZWxmLCBudW1zOiBMaXN0W2ludF0sIGs6IGludCkgLT4gaW50OlxuICAgICAgICBudW1zLnNvcnQoKVxuICAgICAgICByZXR1cm4gbnVtc1sta11cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTQuMi4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgdm9pZCBtYXhIZWFwaWZ5KHZlY3RvcjxpbnQ+JiBhLCBpbnQgaSwgaW50IGhlYXBTaXplKSB7XG4gICAgICAgIGludCBsID0gaSAqIDIgKyAxLCByID0gaSAqIDIgKyAyLCBsYXJnZXN0ID0gaTtcbiAgICAgICAgaWYgKGwgPCBoZWFwU2l6ZSAmJiBhW2xdID4gYVtsYXJnZXN0XSkge1xuICAgICAgICAgICAgbGFyZ2VzdCA9IGw7XG4gICAgICAgIH0gXG4gICAgICAgIGlmIChyIDwgaGVhcFNpemUgJiYgYVtyXSA+IGFbbGFyZ2VzdF0pIHtcbiAgICAgICAgICAgIGxhcmdlc3QgPSByO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXJnZXN0ICE9IGkpIHtcbiAgICAgICAgICAgIHN3YXAoYVtpXSwgYVtsYXJnZXN0XSk7XG4gICAgICAgICAgICBtYXhIZWFwaWZ5KGEsIGxhcmdlc3QsIGhlYXBTaXplKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZvaWQgYnVpbGRNYXhIZWFwKHZlY3RvcjxpbnQ+JiBhLCBpbnQgaGVhcFNpemUpIHtcbiAgICAgICAgZm9yIChpbnQgaSA9IGhlYXBTaXplIC8gMjsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIG1heEhlYXBpZnkoYSwgaSwgaGVhcFNpemUpO1xuICAgICAgICB9IFxuICAgIH1cblxuICAgIGludCBmaW5kS3RoTGFyZ2VzdCh2ZWN0b3I8aW50PiYgbnVtcywgaW50IGspIHtcbiAgICAgICAgaW50IGhlYXBTaXplID0gbnVtcy5zaXplKCk7XG4gICAgICAgIGJ1aWxkTWF4SGVhcChudW1zLCBoZWFwU2l6ZSk7XG4gICAgICAgIGZvciAoaW50IGkgPSBudW1zLnNpemUoKSAtIDE7IGkgPj0gbnVtcy5zaXplKCkgLSBrICsgMTsgLS1pKSB7XG4gICAgICAgICAgICBzd2FwKG51bXNbMF0sIG51bXNbaV0pO1xuICAgICAgICAgICAgLS1oZWFwU2l6ZTtcbiAgICAgICAgICAgIG1heEhlYXBpZnkobnVtcywgMCwgaGVhcFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW1zWzBdO1xuICAgIH1cbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICBwdWJsaWMgaW50IGZpbmRLdGhMYXJnZXN0KGludFtdIG51bXMsIGludCBrKSB7XG4gICAgICBpbnQgaGVhcFNpemUgPSBudW1zLmxlbmd0aDtcbiAgICAgIGJ1aWxkTWF4SGVhcChudW1zLCBoZWFwU2l6ZSk7XG4gICAgICBmb3IgKGludCBpID0gbnVtcy5sZW5ndGggLSAxOyBpID49IG51bXMubGVuZ3RoIC0gayArIDE7IC0taSkge1xuICAgICAgICAgIHN3YXAobnVtcywgMCwgaSk7XG4gICAgICAgICAgLS1oZWFwU2l6ZTtcbiAgICAgICAgICBtYXhIZWFwaWZ5KG51bXMsIDAsIGhlYXBTaXplKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudW1zWzBdO1xuICB9XG5cbiAgcHVibGljIHZvaWQgYnVpbGRNYXhIZWFwKGludFtdIGEsIGludCBoZWFwU2l6ZSkge1xuICAgICAgZm9yIChpbnQgaSA9IGhlYXBTaXplIC8gMjsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICBtYXhIZWFwaWZ5KGEsIGksIGhlYXBTaXplKTtcbiAgICAgIH0gXG4gIH1cblxuICBwdWJsaWMgdm9pZCBtYXhIZWFwaWZ5KGludFtdIGEsIGludCBpLCBpbnQgaGVhcFNpemUpIHtcbiAgICAgIGludCBsID0gaSAqIDIgKyAxLCByID0gaSAqIDIgKyAyLCBsYXJnZXN0ID0gaTtcbiAgICAgIGlmIChsIDwgaGVhcFNpemUgJiYgYVtsXSA+IGFbbGFyZ2VzdF0pIHtcbiAgICAgICAgICBsYXJnZXN0ID0gbDtcbiAgICAgIH0gXG4gICAgICBpZiAociA8IGhlYXBTaXplICYmIGFbcl0gPiBhW2xhcmdlc3RdKSB7XG4gICAgICAgICAgbGFyZ2VzdCA9IHI7XG4gICAgICB9XG4gICAgICBpZiAobGFyZ2VzdCAhPSBpKSB7XG4gICAgICAgICAgc3dhcChhLCBpLCBsYXJnZXN0KTtcbiAgICAgICAgICBtYXhIZWFwaWZ5KGEsIGxhcmdlc3QsIGhlYXBTaXplKTtcbiAgICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB2b2lkIHN3YXAoaW50W10gYSwgaW50IGksIGludCBqKSB7XG4gICAgICBpbnQgdGVtcCA9IGFbaV07XG4gICAgICBhW2ldID0gYVtqXTtcbiAgICAgIGFbal0gPSB0ZW1wO1xuICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImZyb20gdHlwaW5nIGltcG9ydCBMaXN0XG5cblxuY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGZpbmRLdGhMYXJnZXN0KHNlbGYsIG51bXM6IExpc3RbaW50XSwgazogaW50KSAtPiBpbnQ6XG4gICAgICAgIGltcG9ydCBoZWFwcVxuXG4gICAgICAgIGhlYXAgPSBbXVxuXG4gICAgICAgIGZvciBpIGluIHJhbmdlKGspOlxuICAgICAgICAgICAgaGVhcC5hcHBlbmQobnVtc1tpXSlcblxuICAgICAgICBoZWFwcS5oZWFwaWZ5KGhlYXApXG5cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoaywgbGVuKG51bXMpKTpcbiAgICAgICAgICAgIGlmIG51bXNbaV0gPiBoZWFwWzBdOlxuICAgICAgICAgICAgICAgIGhlYXBxLmhlYXBwb3AoaGVhcClcbiAgICAgICAgICAgICAgICBoZWFwcS5oZWFwcHVzaChoZWFwLCBudW1zW2ldKVxuXG4gICAgICAgIHJldHVybiBoZWFwWzBdXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE0LjIuMyIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIHZvaWQgbWF4SGVhcGlmeSh2ZWN0b3I8aW50PiYgYSwgaW50IGksIGludCBoZWFwU2l6ZSkge1xuICAgICAgICBpbnQgbCA9IGkgKiAyICsgMSwgciA9IGkgKiAyICsgMiwgbGFyZ2VzdCA9IGk7XG4gICAgICAgIGlmIChsIDwgaGVhcFNpemUgJiYgYVtsXSA+IGFbbGFyZ2VzdF0pIHtcbiAgICAgICAgICAgIGxhcmdlc3QgPSBsO1xuICAgICAgICB9IFxuICAgICAgICBpZiAociA8IGhlYXBTaXplICYmIGFbcl0gPiBhW2xhcmdlc3RdKSB7XG4gICAgICAgICAgICBsYXJnZXN0ID0gcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFyZ2VzdCAhPSBpKSB7XG4gICAgICAgICAgICBzd2FwKGFbaV0sIGFbbGFyZ2VzdF0pO1xuICAgICAgICAgICAgbWF4SGVhcGlmeShhLCBsYXJnZXN0LCBoZWFwU2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2b2lkIGJ1aWxkTWF4SGVhcCh2ZWN0b3I8aW50PiYgYSwgaW50IGhlYXBTaXplKSB7XG4gICAgICAgIGZvciAoaW50IGkgPSBoZWFwU2l6ZSAvIDI7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBtYXhIZWFwaWZ5KGEsIGksIGhlYXBTaXplKTtcbiAgICAgICAgfSBcbiAgICB9XG5cbiAgICBpbnQgZmluZEt0aExhcmdlc3QodmVjdG9yPGludD4mIG51bXMsIGludCBrKSB7XG4gICAgICAgIGludCBoZWFwU2l6ZSA9IG51bXMuc2l6ZSgpO1xuICAgICAgICBidWlsZE1heEhlYXAobnVtcywgaGVhcFNpemUpO1xuICAgICAgICBmb3IgKGludCBpID0gbnVtcy5zaXplKCkgLSAxOyBpID49IG51bXMuc2l6ZSgpIC0gayArIDE7IC0taSkge1xuICAgICAgICAgICAgc3dhcChudW1zWzBdLCBudW1zW2ldKTtcbiAgICAgICAgICAgIC0taGVhcFNpemU7XG4gICAgICAgICAgICBtYXhIZWFwaWZ5KG51bXMsIDAsIGhlYXBTaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtc1swXTtcbiAgICB9XG59O1xuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGludCBmaW5kS3RoTGFyZ2VzdChpbnRbXSBudW1zLCBpbnQgaykge1xuICAgICAgaW50IGhlYXBTaXplID0gbnVtcy5sZW5ndGg7XG4gICAgICBidWlsZE1heEhlYXAobnVtcywgaGVhcFNpemUpO1xuICAgICAgZm9yIChpbnQgaSA9IG51bXMubGVuZ3RoIC0gMTsgaSA+PSBudW1zLmxlbmd0aCAtIGsgKyAxOyAtLWkpIHtcbiAgICAgICAgICBzd2FwKG51bXMsIDAsIGkpO1xuICAgICAgICAgIC0taGVhcFNpemU7XG4gICAgICAgICAgbWF4SGVhcGlmeShudW1zLCAwLCBoZWFwU2l6ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVtc1swXTtcbiAgfVxuXG4gIHB1YmxpYyB2b2lkIGJ1aWxkTWF4SGVhcChpbnRbXSBhLCBpbnQgaGVhcFNpemUpIHtcbiAgICAgIGZvciAoaW50IGkgPSBoZWFwU2l6ZSAvIDI7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgbWF4SGVhcGlmeShhLCBpLCBoZWFwU2l6ZSk7XG4gICAgICB9IFxuICB9XG5cbiAgcHVibGljIHZvaWQgbWF4SGVhcGlmeShpbnRbXSBhLCBpbnQgaSwgaW50IGhlYXBTaXplKSB7XG4gICAgICBpbnQgbCA9IGkgKiAyICsgMSwgciA9IGkgKiAyICsgMiwgbGFyZ2VzdCA9IGk7XG4gICAgICBpZiAobCA8IGhlYXBTaXplICYmIGFbbF0gPiBhW2xhcmdlc3RdKSB7XG4gICAgICAgICAgbGFyZ2VzdCA9IGw7XG4gICAgICB9IFxuICAgICAgaWYgKHIgPCBoZWFwU2l6ZSAmJiBhW3JdID4gYVtsYXJnZXN0XSkge1xuICAgICAgICAgIGxhcmdlc3QgPSByO1xuICAgICAgfVxuICAgICAgaWYgKGxhcmdlc3QgIT0gaSkge1xuICAgICAgICAgIHN3YXAoYSwgaSwgbGFyZ2VzdCk7XG4gICAgICAgICAgbWF4SGVhcGlmeShhLCBsYXJnZXN0LCBoZWFwU2l6ZSk7XG4gICAgICB9XG4gIH1cblxuICBwdWJsaWMgdm9pZCBzd2FwKGludFtdIGEsIGludCBpLCBpbnQgaikge1xuICAgICAgaW50IHRlbXAgPSBhW2ldO1xuICAgICAgYVtpXSA9IGFbal07XG4gICAgICBhW2pdID0gdGVtcDtcbiAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBmaW5kS3RoTGFyZ2VzdChzZWxmLCBudW1zOiBMaXN0W2ludF0sIGs6IGludCkgLT4gaW50OlxuICAgICAgICBpbXBvcnQgaGVhcHFcblxuICAgICAgICByZXR1cm4gaGVhcHEubmxhcmdlc3QoaywgbnVtcylbLTFdXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE0LjIuNCIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGludCBxdWlja1NlbGVjdCh2ZWN0b3I8aW50PiYgYSwgaW50IGwsIGludCByLCBpbnQgaW5kZXgpIHtcbiAgICAgICAgaW50IHEgPSByYW5kb21QYXJ0aXRpb24oYSwgbCwgcik7XG4gICAgICAgIGlmIChxID09IGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gYVtxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBxIDwgaW5kZXggPyBxdWlja1NlbGVjdChhLCBxICsgMSwgciwgaW5kZXgpIDogcXVpY2tTZWxlY3QoYSwgbCwgcSAtIDEsIGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlubGluZSBpbnQgcmFuZG9tUGFydGl0aW9uKHZlY3RvcjxpbnQ+JiBhLCBpbnQgbCwgaW50IHIpIHtcbiAgICAgICAgaW50IGkgPSByYW5kKCkgJSAociAtIGwgKyAxKSArIGw7XG4gICAgICAgIHN3YXAoYVtpXSwgYVtyXSk7XG4gICAgICAgIHJldHVybiBwYXJ0aXRpb24oYSwgbCwgcik7XG4gICAgfVxuXG4gICAgaW5saW5lIGludCBwYXJ0aXRpb24odmVjdG9yPGludD4mIGEsIGludCBsLCBpbnQgcikge1xuICAgICAgICBpbnQgeCA9IGFbcl0sIGkgPSBsIC0gMTtcbiAgICAgICAgZm9yIChpbnQgaiA9IGw7IGogPCByOyArK2opIHtcbiAgICAgICAgICAgIGlmIChhW2pdIDw9IHgpIHtcbiAgICAgICAgICAgICAgICBzd2FwKGFbKytpXSwgYVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dhcChhW2kgKyAxXSwgYVtyXSk7XG4gICAgICAgIHJldHVybiBpICsgMTtcbiAgICB9XG5cbiAgICBpbnQgZmluZEt0aExhcmdlc3QodmVjdG9yPGludD4mIG51bXMsIGludCBrKSB7XG4gICAgICAgIHNyYW5kKHRpbWUoMCkpO1xuICAgICAgICByZXR1cm4gcXVpY2tTZWxlY3QobnVtcywgMCwgbnVtcy5zaXplKCkgLSAxLCBudW1zLnNpemUoKSAtIGspO1xuICAgIH1cbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICBSYW5kb20gcmFuZG9tID0gbmV3IFJhbmRvbSgpO1xuXG4gIHB1YmxpYyBpbnQgZmluZEt0aExhcmdlc3QoaW50W10gbnVtcywgaW50IGspIHtcbiAgICAgIHJldHVybiBxdWlja1NlbGVjdChudW1zLCAwLCBudW1zLmxlbmd0aCAtIDEsIG51bXMubGVuZ3RoIC0gayk7XG4gIH1cblxuICBwdWJsaWMgaW50IHF1aWNrU2VsZWN0KGludFtdIGEsIGludCBsLCBpbnQgciwgaW50IGluZGV4KSB7XG4gICAgICBpbnQgcSA9IHJhbmRvbVBhcnRpdGlvbihhLCBsLCByKTtcbiAgICAgIGlmIChxID09IGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIGFbcV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBxIDwgaW5kZXggPyBxdWlja1NlbGVjdChhLCBxICsgMSwgciwgaW5kZXgpIDogcXVpY2tTZWxlY3QoYSwgbCwgcSAtIDEsIGluZGV4KTtcbiAgICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBpbnQgcmFuZG9tUGFydGl0aW9uKGludFtdIGEsIGludCBsLCBpbnQgcikge1xuICAgICAgaW50IGkgPSByYW5kb20ubmV4dEludChyIC0gbCArIDEpICsgbDtcbiAgICAgIHN3YXAoYSwgaSwgcik7XG4gICAgICByZXR1cm4gcGFydGl0aW9uKGEsIGwsIHIpO1xuICB9XG5cbiAgcHVibGljIGludCBwYXJ0aXRpb24oaW50W10gYSwgaW50IGwsIGludCByKSB7XG4gICAgICBpbnQgeCA9IGFbcl0sIGkgPSBsIC0gMTtcbiAgICAgIGZvciAoaW50IGogPSBsOyBqIDwgcjsgKytqKSB7XG4gICAgICAgICAgaWYgKGFbal0gPD0geCkge1xuICAgICAgICAgICAgICBzd2FwKGEsICsraSwgaik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3dhcChhLCBpICsgMSwgcik7XG4gICAgICByZXR1cm4gaSArIDE7XG4gIH1cblxuICBwdWJsaWMgdm9pZCBzd2FwKGludFtdIGEsIGludCBpLCBpbnQgaikge1xuICAgICAgaW50IHRlbXAgPSBhW2ldO1xuICAgICAgYVtpXSA9IGFbal07XG4gICAgICBhW2pdID0gdGVtcDtcbiAgfVxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIHR5cGluZyBpbXBvcnQgTGlzdFxuaW1wb3J0IHJhbmRvbVxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBmaW5kS3RoTGFyZ2VzdChzZWxmLCBudW1zOiBMaXN0W2ludF0sIGs6IGludCkgLT4gaW50OlxuICAgICAgICByZXR1cm4gc2VsZi5zZWxlY3QobnVtcywgMCwgbGVuKG51bXMpIC0gMSwgbGVuKG51bXMpIC0gaylcblxuICAgIGRlZiBzZWxlY3Qoc2VsZiwgbnVtczogTGlzdFtpbnRdLCBsZWZ0OiBpbnQsIHJpZ2h0OiBpbnQsIGtfc21hbGxlc3Q6IGludCkgLT4gaW50OlxuICAgICAgICBpZiBsZWZ0ID09IHJpZ2h0OlxuICAgICAgICAgICAgIyDlpoLmnpzlj6rmnInkuIDkuKrlhYPntKDvvIzliJnmnIDlt6bovrnnmoTlhYPntKDljbPmmK/nrZTmoYhcbiAgICAgICAgICAgIHJldHVybiBudW1zW2xlZnRdXG4gICAgICAgICMg6ZqP5py66I635Y+W5LiA5LiqIFtsZWZ0LCByaWdodF0g6IyD5Zu055qE5pW05pWwXG4gICAgICAgIHBpdm90X2luZGV4ID0gcmFuZG9tLnJhbmRpbnQobGVmdCwgcmlnaHQpXG4gICAgICAgICMg5qC55o2uIHBpdm90ID0gbnVtc1twaXZvdF9pbmRleF0g6L+b6KGM5YiS5YiG77yM5b6X5Yiw5paw55qEIHBpdm90X2luZGV477yM5q2k5pe2IHBpdm90X2luZGV4IOW3pui+ueeahOmDveWwj+S6juetieS6jiBwaXZvdO+8jOWPs+i+ueeahOmDveWkp+S6juetieS6jiBwaXZvdFxuICAgICAgICBwaXZvdF9pbmRleCA9IHNlbGYucGFydGl0aW9uKG51bXMsIGxlZnQsIHJpZ2h0LCBwaXZvdF9pbmRleClcbiAgICAgICAgaWYga19zbWFsbGVzdCA9PSBwaXZvdF9pbmRleDpcbiAgICAgICAgICAgICMg5aaC5p6c5q2k5pe2IE4gLSBLID09IHBpdm90X2luZGV477yM6KGo56S65oiR5Lus5bey57uP5om+5Yiw56ysIE4tSysxIOWwj+WFg+e0oO+8jOWNs+esrCBLIOWkp+WFg+e0oOOAgui/meS5n+WwseaYr+aIkeS7rOWJjemdouaJgOivtOeahOWPr+S7peebtOaOpeino+WGs+eahOWtkOmXrumimFxuICAgICAgICAgICAgcmV0dXJuIG51bXNba19zbWFsbGVzdF1cbiAgICAgICAgZWxpZiBrX3NtYWxsZXN0IDwgcGl2b3RfaW5kZXg6XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zZWxlY3QobnVtcywgbGVmdCwgcGl2b3RfaW5kZXggLSAxLCBrX3NtYWxsZXN0KVxuICAgICAgICBlbHNlOlxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2VsZWN0KG51bXMsIHBpdm90X2luZGV4ICsgMSwgcmlnaHQsIGtfc21hbGxlc3QpXG5cbiAgICBkZWYgcGFydGl0aW9uKHNlbGYsIG51bXM6IExpc3RbaW50XSwgbGVmdDogaW50LCByaWdodDogaW50LCBwaXZvdF9pbmRleDogaW50KTpcbiAgICAgICAgaSA9IGxlZnRcbiAgICAgICAgaiA9IHJpZ2h0ICsgMVxuICAgICAgICBwaXZvdCA9IG51bXNbcGl2b3RfaW5kZXhdXG4gICAgICAgIG51bXNbcGl2b3RfaW5kZXhdLCBudW1zW2xlZnRdID0gbnVtc1tsZWZ0XSwgbnVtc1twaXZvdF9pbmRleF1cblxuICAgICAgICB3aGlsZSBUcnVlOlxuICAgICAgICAgICAgd2hpbGUgVHJ1ZTpcbiAgICAgICAgICAgICAgICBpICs9IDFcbiAgICAgICAgICAgICAgICBpZiBpID09IHJpZ2h0IG9yIG51bXNbaV0gPj0gcGl2b3Q6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB3aGlsZSBUcnVlOlxuICAgICAgICAgICAgICAgIGogLT0gMVxuICAgICAgICAgICAgICAgIGlmIGogPT0gbGVmdCBvciBudW1zW2pdIDw9IHBpdm90OlxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgaWYgaSA+PSBqOlxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBudW1zW2ldLCBudW1zW2pdID0gbnVtc1tqXSwgbnVtc1tpXVxuICAgICAgICBudW1zW2xlZnRdLCBudW1zW2pdID0gbnVtc1tqXSwgbnVtc1tsZWZ0XVxuICAgICAgICByZXR1cm4galxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExNC4yLjUiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgICBpbnQgcXVpY2tTZWxlY3QodmVjdG9yPGludD4mIGEsIGludCBsLCBpbnQgciwgaW50IGluZGV4KSB7XG4gICAgICAgIGludCBxID0gcmFuZG9tUGFydGl0aW9uKGEsIGwsIHIpO1xuICAgICAgICBpZiAocSA9PSBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGFbcV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcSA8IGluZGV4ID8gcXVpY2tTZWxlY3QoYSwgcSArIDEsIHIsIGluZGV4KSA6IHF1aWNrU2VsZWN0KGEsIGwsIHEgLSAxLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbmxpbmUgaW50IHJhbmRvbVBhcnRpdGlvbih2ZWN0b3I8aW50PiYgYSwgaW50IGwsIGludCByKSB7XG4gICAgICAgIGludCBpID0gcmFuZCgpICUgKHIgLSBsICsgMSkgKyBsO1xuICAgICAgICBzd2FwKGFbaV0sIGFbcl0pO1xuICAgICAgICByZXR1cm4gcGFydGl0aW9uKGEsIGwsIHIpO1xuICAgIH1cblxuICAgIGlubGluZSBpbnQgcGFydGl0aW9uKHZlY3RvcjxpbnQ+JiBhLCBpbnQgbCwgaW50IHIpIHtcbiAgICAgICAgaW50IHggPSBhW3JdLCBpID0gbCAtIDE7XG4gICAgICAgIGZvciAoaW50IGogPSBsOyBqIDwgcjsgKytqKSB7XG4gICAgICAgICAgICBpZiAoYVtqXSA8PSB4KSB7XG4gICAgICAgICAgICAgICAgc3dhcChhWysraV0sIGFbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3YXAoYVtpICsgMV0sIGFbcl0pO1xuICAgICAgICByZXR1cm4gaSArIDE7XG4gICAgfVxuXG4gICAgaW50IGZpbmRLdGhMYXJnZXN0KHZlY3RvcjxpbnQ+JiBudW1zLCBpbnQgaykge1xuICAgICAgICBzcmFuZCh0aW1lKDApKTtcbiAgICAgICAgcmV0dXJuIHF1aWNrU2VsZWN0KG51bXMsIDAsIG51bXMuc2l6ZSgpIC0gMSwgbnVtcy5zaXplKCkgLSBrKTtcbiAgICB9XG59O1xuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgUmFuZG9tIHJhbmRvbSA9IG5ldyBSYW5kb20oKTtcblxuICBwdWJsaWMgaW50IGZpbmRLdGhMYXJnZXN0KGludFtdIG51bXMsIGludCBrKSB7XG4gICAgICByZXR1cm4gcXVpY2tTZWxlY3QobnVtcywgMCwgbnVtcy5sZW5ndGggLSAxLCBudW1zLmxlbmd0aCAtIGspO1xuICB9XG5cbiAgcHVibGljIGludCBxdWlja1NlbGVjdChpbnRbXSBhLCBpbnQgbCwgaW50IHIsIGludCBpbmRleCkge1xuICAgICAgaW50IHEgPSByYW5kb21QYXJ0aXRpb24oYSwgbCwgcik7XG4gICAgICBpZiAocSA9PSBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBhW3FdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcSA8IGluZGV4ID8gcXVpY2tTZWxlY3QoYSwgcSArIDEsIHIsIGluZGV4KSA6IHF1aWNrU2VsZWN0KGEsIGwsIHEgLSAxLCBpbmRleCk7XG4gICAgICB9XG4gIH1cblxuICBwdWJsaWMgaW50IHJhbmRvbVBhcnRpdGlvbihpbnRbXSBhLCBpbnQgbCwgaW50IHIpIHtcbiAgICAgIGludCBpID0gcmFuZG9tLm5leHRJbnQociAtIGwgKyAxKSArIGw7XG4gICAgICBzd2FwKGEsIGksIHIpO1xuICAgICAgcmV0dXJuIHBhcnRpdGlvbihhLCBsLCByKTtcbiAgfVxuXG4gIHB1YmxpYyBpbnQgcGFydGl0aW9uKGludFtdIGEsIGludCBsLCBpbnQgcikge1xuICAgICAgaW50IHggPSBhW3JdLCBpID0gbCAtIDE7XG4gICAgICBmb3IgKGludCBqID0gbDsgaiA8IHI7ICsraikge1xuICAgICAgICAgIGlmIChhW2pdIDw9IHgpIHtcbiAgICAgICAgICAgICAgc3dhcChhLCArK2ksIGopO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN3YXAoYSwgaSArIDEsIHIpO1xuICAgICAgcmV0dXJuIGkgKyAxO1xuICB9XG5cbiAgcHVibGljIHZvaWQgc3dhcChpbnRbXSBhLCBpbnQgaSwgaW50IGopIHtcbiAgICAgIGludCB0ZW1wID0gYVtpXTtcbiAgICAgIGFbaV0gPSBhW2pdO1xuICAgICAgYVtqXSA9IHRlbXA7XG4gIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZnJvbSB0eXBpbmcgaW1wb3J0IExpc3RcbmltcG9ydCByYW5kb21cblxuXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgZmluZEt0aExhcmdlc3Qoc2VsZiwgbnVtczogTGlzdFtpbnRdLCBrOiBpbnQpIC0+IGludDpcbiAgICAgICAgcmV0dXJuIHNlbGYuc2VsZWN0KG51bXMsIDAsIGxlbihudW1zKSAtIDEsIGxlbihudW1zKSAtIGspXG5cbiAgICBkZWYgc2VsZWN0KHNlbGYsIG51bXM6IExpc3RbaW50XSwgbGVmdDogaW50LCByaWdodDogaW50LCBrX3NtYWxsZXN0OiBpbnQpIC0+IGludDpcbiAgICAgICAgd2hpbGUgbGVmdCA8IHJpZ2h0OlxuICAgICAgICAgICAgcGl2b3RfaW5kZXggPSByYW5kb20ucmFuZGludChsZWZ0LCByaWdodClcbiAgICAgICAgICAgIHBpdm90X2luZGV4ID0gc2VsZi5wYXJ0aXRpb24obnVtcywgbGVmdCwgcmlnaHQsIHBpdm90X2luZGV4KVxuICAgICAgICAgICAgaWYga19zbWFsbGVzdCA9PSBwaXZvdF9pbmRleDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtc1trX3NtYWxsZXN0XVxuICAgICAgICAgICAgZWxpZiBrX3NtYWxsZXN0IDwgcGl2b3RfaW5kZXg6XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBwaXZvdF9pbmRleCAtIDFcbiAgICAgICAgICAgIGVsc2U6XG4gICAgICAgICAgICAgICAgbGVmdCA9IHBpdm90X2luZGV4ICsgMVxuXG4gICAgICAgIGlmIGxlZnQgPT0gcmlnaHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVtc1tsZWZ0XVxuXG4gICAgZGVmIHBhcnRpdGlvbihzZWxmLCBudW1zOiBMaXN0W2ludF0sIGxlZnQ6IGludCwgcmlnaHQ6IGludCwgcGl2b3RfaW5kZXg6IGludCk6XG4gICAgICAgIGkgPSBsZWZ0XG4gICAgICAgIGogPSByaWdodCArIDFcbiAgICAgICAgcGl2b3QgPSBudW1zW3Bpdm90X2luZGV4XVxuICAgICAgICBudW1zW3Bpdm90X2luZGV4XSwgbnVtc1tsZWZ0XSA9IG51bXNbbGVmdF0sIG51bXNbcGl2b3RfaW5kZXhdXG5cbiAgICAgICAgd2hpbGUgVHJ1ZTpcbiAgICAgICAgICAgIHdoaWxlIFRydWU6XG4gICAgICAgICAgICAgICAgaSArPSAxXG4gICAgICAgICAgICAgICAgaWYgaSA9PSByaWdodCBvciBudW1zW2ldID49IHBpdm90OlxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgd2hpbGUgVHJ1ZTpcbiAgICAgICAgICAgICAgICBqIC09IDFcbiAgICAgICAgICAgICAgICBpZiBqID09IGxlZnQgb3IgbnVtc1tqXSA8PSBwaXZvdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGlmIGkgPj0gajpcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgbnVtc1tpXSwgbnVtc1tqXSA9IG51bXNbal0sIG51bXNbaV1cbiAgICAgICAgbnVtc1tsZWZ0XSwgbnVtc1tqXSA9IG51bXNbal0sIG51bXNbbGVmdF1cbiAgICAgICAgcmV0dXJuIGpcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTQuMy4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgYm9vbCBzZWFyY2hNYXRyaXgodmVjdG9yPHZlY3RvcjxpbnQ+PiYgbWF0cml4LCBpbnQgdGFyZ2V0KSB7XG4gICAgICAgIGZvcihpbnQgaSA9IDA7IGkgPCBtYXRyaXguc2l6ZSgpOyBpKyspXG4gICAgICAgICAgICBmb3IoaW50IGogPSAwOyBqIDwgbWF0cml4WzBdLnNpemUoKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYobWF0cml4W2ldW2pdID09IHRhcmdldCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGJvb2xlYW4gc2VhcmNoTWF0cml4KGludFtdW10gbWF0cml4LCBpbnQgdGFyZ2V0KSB7XG4gICAgICBmb3IgKGludCBpID0gMDsgaSA8IG1hdHJpeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgbWF0cml4WzBdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChtYXRyaXhbaV1bal0gPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImZyb20gdHlwaW5nIGltcG9ydCBMaXN0XG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgc2VhcmNoTWF0cml4KHNlbGYsIG1hdHJpeDogTGlzdFtMaXN0W2ludF1dLCB0YXJnZXQ6IGludCkgLT4gYm9vbDpcbiAgICAgICAgXCJcIlwiXG4gICAgICAgIDp0eXBlIG1hdHJpeDogTGlzdFtMaXN0W2ludF1dXG4gICAgICAgIDp0eXBlIHRhcmdldDogaW50XG4gICAgICAgIDpydHlwZTogYm9vbFxuICAgICAgICBcIlwiXCJcbiAgICAgICAgaWYgbm90IG1hdHJpeCBvciBub3QgbWF0cml4WzBdOlxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXG5cbiAgICAgICAgbSA9IGxlbihtYXRyaXgpXG4gICAgICAgIG4gPSBsZW4obWF0cml4WzBdKVxuXG4gICAgICAgIGZvciBpIGluIHJhbmdlKG0pOlxuICAgICAgICAgICAgZm9yIGogaW4gcmFuZ2Uobik6XG4gICAgICAgICAgICAgICAgaWYgbWF0cml4W2ldW2pdID09IHRhcmdldDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRydWVcblxuICAgICAgICByZXR1cm4gRmFsc2VcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTQuMy4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gICAgYm9vbCBzZWFyY2hNYXRyaXgodmVjdG9yPHZlY3RvcjxpbnQ+PiYgbWF0cml4LCBpbnQgdGFyZ2V0KSB7XG4gICAgICAgIGZvcihpbnQgaSA9IDA7IGkgPCBtYXRyaXguc2l6ZSgpOyBpKyspXG4gICAgICAgICAgICBmb3IoaW50IGogPSAwOyBqIDwgbWF0cml4WzBdLnNpemUoKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYobWF0cml4W2ldW2pdID09IHRhcmdldCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGJvb2xlYW4gc2VhcmNoTWF0cml4KGludFtdW10gbWF0cml4LCBpbnQgdGFyZ2V0KSB7XG4gICAgICBmb3IgKGludCBpID0gMDsgaSA8IG1hdHJpeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgbWF0cml4WzBdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChtYXRyaXhbaV1bal0gPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImZyb20gdHlwaW5nIGltcG9ydCBMaXN0XG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgc2VhcmNoTWF0cml4KHNlbGYsIG1hdHJpeDogTGlzdFtMaXN0W2ludF1dLCB0YXJnZXQ6IGludCkgLT4gYm9vbDpcbiAgICAgICAgXCJcIlwiXG4gICAgICAgIDp0eXBlIG1hdHJpeDogTGlzdFtMaXN0W2ludF1dXG4gICAgICAgIDp0eXBlIHRhcmdldDogaW50XG4gICAgICAgIDpydHlwZTogYm9vbFxuICAgICAgICBcIlwiXCJcblxuICAgICAgICBkZWYgYmluYXJ5U2VhcmNoKGFycjogTGlzdFtMaXN0W2ludF1dLCB0YXJnZXQ6IGludCkgLT4gYm9vbDpcbiAgICAgICAgICAgIGxvID0gMFxuICAgICAgICAgICAgaGkgPSBsZW4oYXJyKSAtIDFcbiAgICAgICAgICAgIHdoaWxlIGxvIDw9IGhpOlxuICAgICAgICAgICAgICAgIG1pZCA9IGxvICsgKGhpIC0gbG8pIC8vIDJcbiAgICAgICAgICAgICAgICBpZiBhcnJbbWlkXSA9PSB0YXJnZXQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUcnVlXG4gICAgICAgICAgICAgICAgZWxpZiBhcnJbbWlkXSA8IHRhcmdldDpcbiAgICAgICAgICAgICAgICAgICAgbG8gPSBtaWQgKyAxXG4gICAgICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICAgICAgaGkgPSBtaWQgLSAxXG5cbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxuXG4gICAgICAgIGlmIG5vdCBtYXRyaXggb3Igbm90IG1hdHJpeFswXTpcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxuXG4gICAgICAgIG0gPSBsZW4obWF0cml4KVxuXG4gICAgICAgIGZvciBpIGluIHJhbmdlKG0pOlxuICAgICAgICAgICAgaWYgYmluYXJ5U2VhcmNoKG1hdHJpeFtpXSwgdGFyZ2V0KTpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJ1ZVxuXG4gICAgICAgIHJldHVybiBGYWxzZVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExNC4zLjMiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgICBib29sIHNlYXJjaE1hdHJpeCh2ZWN0b3I8dmVjdG9yPGludD4+JiBtYXRyaXgsIGludCB0YXJnZXQpIHtcbiAgICAgICAgaWYobWF0cml4LnNpemUoKSA9PSAwIHx8IG1hdHJpeFswXS5zaXplKCkgPT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpbnQgaSA9IG1hdHJpeC5zaXplKCkgLSAxO1xuICAgICAgICBpbnQgaiA9IDA7XG4gICAgICAgIHdoaWxlKGkgPj0gMCAmJiBqIDwgbWF0cml4WzBdLnNpemUoKSl7XG4gICAgICAgICAgICBpZihtYXRyaXhbaV1bal0gPiB0YXJnZXQpXG4gICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgZWxzZSBpZihtYXRyaXhbaV1bal0gPCB0YXJnZXQpXG4gICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gIHByaXZhdGUgYm9vbGVhbiBiaW5hcnlTZWFyY2goaW50W11bXSBtYXRyaXgsIGludCB0YXJnZXQsIGludCBzdGFydCwgYm9vbGVhbiB2ZXJ0aWNhbCkge1xuICAgICAgaW50IGxvID0gc3RhcnQ7XG4gICAgICBpbnQgaGkgPSB2ZXJ0aWNhbCA/IG1hdHJpeFswXS5sZW5ndGgtMSA6IG1hdHJpeC5sZW5ndGgtMTtcblxuICAgICAgd2hpbGUgKGhpID49IGxvKSB7XG4gICAgICAgICAgaW50IG1pZCA9IChsbyArIGhpKS8yO1xuICAgICAgICAgIGlmICh2ZXJ0aWNhbCkgeyAvLyBzZWFyY2hpbmcgYSBjb2x1bW5cbiAgICAgICAgICAgICAgaWYgKG1hdHJpeFtzdGFydF1bbWlkXSA8IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdHJpeFtzdGFydF1bbWlkXSA+IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgaGkgPSBtaWQgLSAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgeyAvLyBzZWFyY2hpbmcgYSByb3dcbiAgICAgICAgICAgICAgaWYgKG1hdHJpeFttaWRdW3N0YXJ0XSA8IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdHJpeFttaWRdW3N0YXJ0XSA+IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgaGkgPSBtaWQgLSAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBib29sZWFuIHNlYXJjaE1hdHJpeChpbnRbXVtdIG1hdHJpeCwgaW50IHRhcmdldCkge1xuICAgICAgLy8gYW4gZW1wdHkgbWF0cml4IG9idmlvdXNseSBkb2VzIG5vdCBjb250YWluIGB0YXJnZXRgXG4gICAgICBpZiAobWF0cml4ID09IG51bGwgfHwgbWF0cml4Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBpdGVyYXRlIG92ZXIgbWF0cml4IGRpYWdvbmFsc1xuICAgICAgaW50IHNob3J0ZXJEaW0gPSBNYXRoLm1pbihtYXRyaXgubGVuZ3RoLCBtYXRyaXhbMF0ubGVuZ3RoKTtcbiAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgc2hvcnRlckRpbTsgaSsrKSB7XG4gICAgICAgICAgYm9vbGVhbiB2ZXJ0aWNhbEZvdW5kID0gYmluYXJ5U2VhcmNoKG1hdHJpeCwgdGFyZ2V0LCBpLCB0cnVlKTtcbiAgICAgICAgICBib29sZWFuIGhvcml6b250YWxGb3VuZCA9IGJpbmFyeVNlYXJjaChtYXRyaXgsIHRhcmdldCwgaSwgZmFsc2UpO1xuICAgICAgICAgIGlmICh2ZXJ0aWNhbEZvdW5kIHx8IGhvcml6b250YWxGb3VuZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBmYWxzZTsgXG4gIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZnJvbSB0eXBpbmcgaW1wb3J0IExpc3RcbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBiaW5hcnlfc2VhcmNoKHNlbGYsIG1hdHJpeDogTGlzdFtMaXN0W2ludF1dLCB0YXJnZXQ6IGludCwgc3RhcnQ6IGludCwgdmVydGljYWw6IGJvb2wpIC0+IGJvb2w6XG4gICAgICAgIGxvID0gc3RhcnRcbiAgICAgICAgaGkgPSBsZW4obWF0cml4WzBdKSAtIDEgaWYgdmVydGljYWwgZWxzZSBsZW4obWF0cml4KSAtIDFcblxuICAgICAgICB3aGlsZSBsbyA8PSBoaTpcbiAgICAgICAgICAgIG1pZCA9IGxvICsgKGhpIC0gbG8pIC8vIDJcbiAgICAgICAgICAgIGlmIHZlcnRpY2FsOlxuICAgICAgICAgICAgICAgIGlmIG1hdHJpeFtzdGFydF1bbWlkXSA8IHRhcmdldDpcbiAgICAgICAgICAgICAgICAgICAgbG8gPSBtaWQgKyAxXG4gICAgICAgICAgICAgICAgZWxpZiBtYXRyaXhbc3RhcnRdW21pZF0gPiB0YXJnZXQ6XG4gICAgICAgICAgICAgICAgICAgIGhpID0gbWlkIC0gMVxuICAgICAgICAgICAgICAgIGVsc2U6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUcnVlXG4gICAgICAgICAgICBlbHNlOlxuICAgICAgICAgICAgICAgIGlmIG1hdHJpeFttaWRdW3N0YXJ0XSA8IHRhcmdldDpcbiAgICAgICAgICAgICAgICAgICAgbG8gPSBtaWQgKyAxXG4gICAgICAgICAgICAgICAgZWxpZiBtYXRyaXhbbWlkXVtzdGFydF0gPiB0YXJnZXQ6XG4gICAgICAgICAgICAgICAgICAgIGhpID0gbWlkIC0gMVxuICAgICAgICAgICAgICAgIGVsc2U6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUcnVlXG5cbiAgICAgICAgcmV0dXJuIEZhbHNlXG5cbiAgICBkZWYgc2VhcmNoTWF0cml4KHNlbGYsIG1hdHJpeDogTGlzdFtMaXN0W2ludF1dLCB0YXJnZXQ6IGludCkgLT4gYm9vbDpcbiAgICAgICAgaWYgbm90IG1hdHJpeDpcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxuXG4gICAgICAgIG1pbkxlbiA9IG1pbihsZW4obWF0cml4KSwgbGVuKG1hdHJpeFswXSkpXG4gICAgICAgIGZvciBpIGluIHJhbmdlKG1pbkxlbik6XG4gICAgICAgICAgICB2ZXJ0aWNhbF9mb3VuZCA9IHNlbGYuYmluYXJ5X3NlYXJjaChtYXRyaXgsIHRhcmdldCwgaSwgVHJ1ZSlcbiAgICAgICAgICAgIGhvcml6b250YWxfZm91bmQgPSBzZWxmLmJpbmFyeV9zZWFyY2gobWF0cml4LCB0YXJnZXQsIGksIEZhbHNlKVxuICAgICAgICAgICAgaWYgdmVydGljYWxfZm91bmQgb3IgaG9yaXpvbnRhbF9mb3VuZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJ1ZVxuXG4gICAgICAgIHJldHVybiBGYWxzZVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExNC4zLjQiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgICBib29sIHNlYXJjaE1hdHJpeCh2ZWN0b3I8dmVjdG9yPGludD4+JiBtYXRyaXgsIGludCB0YXJnZXQpIHtcbiAgICAgICAgaWYobWF0cml4LnNpemUoKSA9PSAwIHx8IG1hdHJpeFswXS5zaXplKCkgPT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpbnQgaSA9IG1hdHJpeC5zaXplKCkgLSAxO1xuICAgICAgICBpbnQgaiA9IDA7XG4gICAgICAgIHdoaWxlKGkgPj0gMCAmJiBqIDwgbWF0cml4WzBdLnNpemUoKSl7XG4gICAgICAgICAgICBpZihtYXRyaXhbaV1bal0gPiB0YXJnZXQpXG4gICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgZWxzZSBpZihtYXRyaXhbaV1bal0gPCB0YXJnZXQpXG4gICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XG4gIHByaXZhdGUgaW50W11bXSBtYXRyaXg7XG4gIHByaXZhdGUgaW50IHRhcmdldDtcblxuICBwcml2YXRlIGJvb2xlYW4gc2VhcmNoUmVjKGludCBsZWZ0LCBpbnQgdXAsIGludCByaWdodCwgaW50IGRvd24pIHtcbiAgICAgIC8vIHRoaXMgc3VibWF0cml4IGhhcyBubyBoZWlnaHQgb3Igbm8gd2lkdGguXG4gICAgICBpZiAobGVmdCA+IHJpZ2h0IHx8IHVwID4gZG93bikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIGB0YXJnZXRgIGlzIGFscmVhZHkgbGFyZ2VyIHRoYW4gdGhlIGxhcmdlc3QgZWxlbWVudCBvciBzbWFsbGVyXG4gICAgICAvLyB0aGFuIHRoZSBzbWFsbGVzdCBlbGVtZW50IGluIHRoaXMgc3VibWF0cml4LlxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQgPCBtYXRyaXhbdXBdW2xlZnRdIHx8IHRhcmdldCA+IG1hdHJpeFtkb3duXVtyaWdodF0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGludCBtaWQgPSBsZWZ0ICsgKHJpZ2h0LWxlZnQpLzI7XG5cbiAgICAgIC8vIExvY2F0ZSBgcm93YCBzdWNoIHRoYXQgbWF0cml4W3Jvdy0xXVttaWRdIDwgdGFyZ2V0IDwgbWF0cml4W3Jvd11bbWlkXVxuICAgICAgaW50IHJvdyA9IHVwO1xuICAgICAgd2hpbGUgKHJvdyA8PSBkb3duICYmIG1hdHJpeFtyb3ddW21pZF0gPD0gdGFyZ2V0KSB7XG4gICAgICAgICAgaWYgKG1hdHJpeFtyb3ddW21pZF0gPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByb3crKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlYXJjaFJlYyhsZWZ0LCByb3csIG1pZC0xLCBkb3duKSB8fCBzZWFyY2hSZWMobWlkKzEsIHVwLCByaWdodCwgcm93LTEpO1xuICB9XG5cbiAgcHVibGljIGJvb2xlYW4gc2VhcmNoTWF0cml4KGludFtdW10gbWF0LCBpbnQgdGFyZykge1xuICAgICAgLy8gY2FjaGUgaW5wdXQgdmFsdWVzIGluIG9iamVjdCB0byBhdm9pZCBwYXNzaW5nIHRoZW0gdW5uZWNlc3NhcmlseVxuICAgICAgLy8gdG8gYHNlYXJjaFJlY2BcbiAgICAgIG1hdHJpeCA9IG1hdDtcbiAgICAgIHRhcmdldCA9IHRhcmc7XG5cbiAgICAgIC8vIGFuIGVtcHR5IG1hdHJpeCBvYnZpb3VzbHkgZG9lcyBub3QgY29udGFpbiBgdGFyZ2V0YFxuICAgICAgaWYgKG1hdHJpeCA9PSBudWxsIHx8IG1hdHJpeC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlYXJjaFJlYygwLCAwLCBtYXRyaXhbMF0ubGVuZ3RoLTEsIG1hdHJpeC5sZW5ndGgtMSk7XG4gIH1cbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZnJvbSB0eXBpbmcgaW1wb3J0IExpc3RcbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBzZWFyY2hNYXRyaXgoc2VsZiwgbWF0cml4OiBMaXN0W0xpc3RbaW50XV0sIHRhcmdldDogaW50KSAtPiBib29sOlxuICAgICAgICBpZiBub3QgbWF0cml4OlxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXG5cbiAgICAgICAgZGVmIHNlYXJjaF9yZWMobGVmdCwgdXAsIHJpZ2h0LCBkb3duKTpcbiAgICAgICAgICAgICMg56m655+p6Zi1XG4gICAgICAgICAgICBpZiBsZWZ0ID4gcmlnaHQgb3IgdXAgPiBkb3duOlxuICAgICAgICAgICAgICAgIHJldHVybiBGYWxzZVxuICAgICAgICAgICAgIyDnm67moIflgLzlpKfkuo7nn6npmLXlj7PkuIvop5LlhYPntKDmiJbogIXlsI/kuo7lt6bkuIrop5LlhYPntKBcbiAgICAgICAgICAgIGVsaWYgdGFyZ2V0IDwgbWF0cml4W3VwXVtsZWZ0XSBvciB0YXJnZXQgPiBtYXRyaXhbZG93bl1bcmlnaHRdOlxuICAgICAgICAgICAgICAgIHJldHVybiBGYWxzZVxuXG4gICAgICAgICAgICBtaWQgPSBsZWZ0ICsgKHJpZ2h0IC0gbGVmdCkgLy8gMlxuXG4gICAgICAgICAgICAjIOWumuS9jSByb3fvvIzmnaXkvb8gbWF0cml4W3Jvdy0xXVttaWRdIDwgdGFyZ2V0IDwgbWF0cml4W3Jvd11bbWlkXVxuICAgICAgICAgICAgcm93ID0gdXBcbiAgICAgICAgICAgIHdoaWxlIHJvdyA8PSBkb3duIGFuZCBtYXRyaXhbcm93XVttaWRdIDw9IHRhcmdldDpcbiAgICAgICAgICAgICAgICBpZiBtYXRyaXhbcm93XVttaWRdID09IHRhcmdldDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRydWVcbiAgICAgICAgICAgICAgICByb3cgKz0gMVxuXG4gICAgICAgICAgICByZXR1cm4gc2VhcmNoX3JlYyhsZWZ0LCByb3csIG1pZCAtIDEsIGRvd24pIG9yIHNlYXJjaF9yZWMoXG4gICAgICAgICAgICAgICAgbWlkICsgMSwgdXAsIHJpZ2h0LCByb3cgLSAxXG4gICAgICAgICAgICApXG5cbiAgICAgICAgcmV0dXJuIHNlYXJjaF9yZWMoMCwgMCwgbGVuKG1hdHJpeFswXSkgLSAxLCBsZW4obWF0cml4KSAtIDEpXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE0LjMuNSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGJvb2wgc2VhcmNoTWF0cml4KHZlY3Rvcjx2ZWN0b3I8aW50Pj4mIG1hdHJpeCwgaW50IHRhcmdldCkge1xuICAgICAgICBpZihtYXRyaXguc2l6ZSgpID09IDAgfHwgbWF0cml4WzBdLnNpemUoKSA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGludCBpID0gbWF0cml4LnNpemUoKSAtIDE7XG4gICAgICAgIGludCBqID0gMDtcbiAgICAgICAgd2hpbGUoaSA+PSAwICYmIGogPCBtYXRyaXhbMF0uc2l6ZSgpKXtcbiAgICAgICAgICAgIGlmKG1hdHJpeFtpXVtqXSA+IHRhcmdldClcbiAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICBlbHNlIGlmKG1hdHJpeFtpXVtqXSA8IHRhcmdldClcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICBlbHNlIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGJvb2xlYW4gc2VhcmNoTWF0cml4KGludFtdW10gbWF0cml4LCBpbnQgdGFyZ2V0KSB7XG4gICAgICAvLyBzdGFydCBvdXIgXCJwb2ludGVyXCIgaW4gdGhlIGJvdHRvbS1sZWZ0XG4gICAgICBpbnQgcm93ID0gbWF0cml4Lmxlbmd0aC0xO1xuICAgICAgaW50IGNvbCA9IDA7XG5cbiAgICAgIHdoaWxlIChyb3cgPj0gMCAmJiBjb2wgPCBtYXRyaXhbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG1hdHJpeFtyb3ddW2NvbF0gPiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgcm93LS07XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRyaXhbcm93XVtjb2xdIDwgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgIGNvbCsrO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIGZvdW5kIGl0XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImZyb20gdHlwaW5nIGltcG9ydCBMaXN0XG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgc2VhcmNoTWF0cml4KHNlbGYsIG1hdHJpeDogTGlzdFtMaXN0W2ludF1dLCB0YXJnZXQ6IGludCkgLT4gYm9vbDpcbiAgICAgICAgaWYgbm90IG1hdHJpeDpcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxuXG4gICAgICAgICMg5Lmf5bCx5piv5om+5Yiw56ys5LiA5Liq5aSn5LqOdGFyZ2V055qE5L2N572uXG4gICAgICAgIGRlZiBiaW5hcnlTZWFyY2gobWF0cml4OiBMaXN0W0xpc3RbaW50XV0sIHVwOiBpbnQsIGRvd246IGludCwgY29sOiBpbnQsIHRhcmdldDogaW50KSAtPiBMaXN0OlxuICAgICAgICAgICAgbG8gPSB1cFxuICAgICAgICAgICAgaGkgPSBkb3duICsgMVxuICAgICAgICAgICAgd2hpbGUgbG8gPCBoaTpcbiAgICAgICAgICAgICAgICBtaWQgPSBsbyArIChoaSAtIGxvKSAvLyAyXG4gICAgICAgICAgICAgICAgaWYgbWF0cml4W21pZF1bY29sXSA9PSB0YXJnZXQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbVHJ1ZSwgbWlkXVxuICAgICAgICAgICAgICAgIGVsaWYgbWF0cml4W21pZF1bY29sXSA8IHRhcmdldDpcbiAgICAgICAgICAgICAgICAgICAgbG8gPSBtaWQgKyAxXG4gICAgICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICAgICAgaGkgPSBtaWRcblxuICAgICAgICAgICAgcmV0dXJuIFtGYWxzZSwgbG9dXG5cbiAgICAgICAgZGVmIHNlYXJjaF9yZWMobGVmdDogaW50LCB1cDogaW50LCByaWdodDogaW50LCBkb3duOiBpbnQpIC0+IGJvb2w6XG4gICAgICAgICAgICAjIOepuuefqemYtVxuICAgICAgICAgICAgaWYgbGVmdCA+IHJpZ2h0IG9yIHVwID4gZG93bjpcbiAgICAgICAgICAgICAgICByZXR1cm4gRmFsc2VcbiAgICAgICAgICAgICMg55uu5qCH5YC85aSn5LqO55+p6Zi15Y+z5LiL6KeS5YWD57Sg5oiW6ICF5bCP5LqO5bem5LiK6KeS5YWD57SgXG4gICAgICAgICAgICBlbGlmIHRhcmdldCA8IG1hdHJpeFt1cF1bbGVmdF0gb3IgdGFyZ2V0ID4gbWF0cml4W2Rvd25dW3JpZ2h0XTpcbiAgICAgICAgICAgICAgICByZXR1cm4gRmFsc2VcblxuICAgICAgICAgICAgbWlkID0gbGVmdCArIChyaWdodCAtIGxlZnQpIC8vIDJcblxuICAgICAgICAgICAgIyDlrprkvY0gcm9377yM5p2l5L2/IG1hdHJpeFtyb3ctMV1bbWlkXSA8IHRhcmdldCA8IG1hdHJpeFtyb3ddW21pZF1cbiAgICAgICAgICAgIGZpbmQsIHJvdyA9IGJpbmFyeVNlYXJjaChtYXRyaXgsIHVwLCBkb3duLCBtaWQsIHRhcmdldClcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBmaW5kXG4gICAgICAgICAgICAgICAgb3Igc2VhcmNoX3JlYyhsZWZ0LCByb3csIG1pZCAtIDEsIGRvd24pXG4gICAgICAgICAgICAgICAgb3Igc2VhcmNoX3JlYyhtaWQgKyAxLCB1cCwgcmlnaHQsIHJvdyAtIDEpXG4gICAgICAgICAgICApXG5cbiAgICAgICAgcmV0dXJuIHNlYXJjaF9yZWMoMCwgMCwgbGVuKG1hdHJpeFswXSkgLSAxLCBsZW4obWF0cml4KSAtIDEpXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE0LjMuNiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGJvb2wgc2VhcmNoTWF0cml4KHZlY3Rvcjx2ZWN0b3I8aW50Pj4mIG1hdHJpeCwgaW50IHRhcmdldCkge1xuICAgICAgICBpZihtYXRyaXguc2l6ZSgpID09IDAgfHwgbWF0cml4WzBdLnNpemUoKSA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGludCBpID0gbWF0cml4LnNpemUoKSAtIDE7XG4gICAgICAgIGludCBqID0gMDtcbiAgICAgICAgd2hpbGUoaSA+PSAwICYmIGogPCBtYXRyaXhbMF0uc2l6ZSgpKXtcbiAgICAgICAgICAgIGlmKG1hdHJpeFtpXVtqXSA+IHRhcmdldClcbiAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICBlbHNlIGlmKG1hdHJpeFtpXVtqXSA8IHRhcmdldClcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICBlbHNlIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGJvb2xlYW4gc2VhcmNoTWF0cml4KGludFtdW10gbWF0cml4LCBpbnQgdGFyZ2V0KSB7XG4gICAgICAvLyBzdGFydCBvdXIgXCJwb2ludGVyXCIgaW4gdGhlIGJvdHRvbS1sZWZ0XG4gICAgICBpbnQgcm93ID0gbWF0cml4Lmxlbmd0aC0xO1xuICAgICAgaW50IGNvbCA9IDA7XG5cbiAgICAgIHdoaWxlIChyb3cgPj0gMCAmJiBjb2wgPCBtYXRyaXhbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG1hdHJpeFtyb3ddW2NvbF0gPiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgcm93LS07XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRyaXhbcm93XVtjb2xdIDwgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgIGNvbCsrO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIGZvdW5kIGl0XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImZyb20gdHlwaW5nIGltcG9ydCBMaXN0XG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgc2VhcmNoTWF0cml4KHNlbGYsIG1hdHJpeDogTGlzdFtMaXN0W2ludF1dLCB0YXJnZXQ6IGludCk6XG4gICAgICAgIGlmIGxlbihtYXRyaXgpID09IDAgb3IgbGVuKG1hdHJpeFswXSkgPT0gMDpcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxuXG4gICAgICAgIG0gPSBsZW4obWF0cml4KVxuICAgICAgICBuID0gbGVuKG1hdHJpeFswXSlcblxuICAgICAgICByb3cgPSBtIC0gMVxuICAgICAgICBjb2wgPSAwXG5cbiAgICAgICAgd2hpbGUgY29sIDwgbiBhbmQgcm93ID49IDA6XG4gICAgICAgICAgICBpZiBtYXRyaXhbcm93XVtjb2xdID4gdGFyZ2V0OlxuICAgICAgICAgICAgICAgIHJvdyAtPSAxXG4gICAgICAgICAgICBlbGlmIG1hdHJpeFtyb3ddW2NvbF0gPCB0YXJnZXQ6XG4gICAgICAgICAgICAgICAgY29sICs9IDFcbiAgICAgICAgICAgIGVsc2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRydWVcblxuICAgICAgICByZXR1cm4gRmFsc2VcblxuIgogICAgfV0KICB9XQp9LCB7CiAgImlkIjogIjE1IiwKICAibmFtZSI6ICLnrKzljYHkupTnq6AiLAogICJsaXN0IjogW3sKICAgICJ0aXRsZSI6ICLku6PnoIExNS4xLjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcclxucHVibGljOlxyXG4gICAgaW50IGZpbmRDb250ZW50Q2hpbGRyZW4odmVjdG9yPGludD4mIGcsIHZlY3RvcjxpbnQ+JiBzKSB7XHJcbiAgICAgICAgLy8g5a+55a2p5a2Q6IOD5Y+j5Lul5Y+K6aW85bmy5o6S5bqPXHJcbiAgICAgICAgc29ydChnLmJlZ2luKCksIGcuZW5kKCkpO1xyXG4gICAgICAgIHNvcnQocy5iZWdpbigpLCBzLmVuZCgpKTtcclxuICAgICAgICBpbnQgYW5zID0gMDtcclxuICAgICAgICAvLyDppbzlubLkuIvmoIdcclxuICAgICAgICBpbnQgaWR4ID0gMDtcclxuICAgICAgICAvLyDpgY3ljobmr4/kuKrlranlrZBcclxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGcuc2l6ZSgpOyBpKyspIHtcclxuICAgICAgICAgICAgLy8g6YGN5Y6G5Ymp5L2Z55qE6aW85bmyXHJcbiAgICAgICAgICAgIHdoaWxlIChpZHggPCBzLnNpemUoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNbaWR4XSA+PSBnW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5zICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWR4ICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkeCArPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhbnM7XHJcbiAgICB9XHJcbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xyXG4gICAgcHVibGljIGludCBmaW5kQ29udGVudENoaWxkcmVuKGludFtdIGcsIGludFtdIHMpIHtcclxuICAgICAgICAvLyDlr7nlranlrZDog4Plj6Pku6Xlj4rppbzlubLmjpLluo9cclxuICAgICAgICBBcnJheXMuc29ydChnKTtcclxuICAgICAgICBBcnJheXMuc29ydChzKTtcclxuICAgICAgICBpbnQgYW5zID0gMDtcclxuICAgICAgICAvLyDppbzlubLkuIvmoIdcclxuICAgICAgICBpbnQgaWR4ID0gMDtcclxuICAgICAgICAvLyDpgY3ljobmr4/kuKrlranlrZBcclxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8g6YGN5Y6G5Ymp5L2Z55qE6aW85bmyXHJcbiAgICAgICAgICAgIHdoaWxlIChpZHggPCBzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNbaWR4XSA+PSBnW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5zICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWR4ICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkeCArPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhbnM7XHJcbiAgICB9XHJcbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGZpbmRDb250ZW50Q2hpbGRyZW4oc2VsZiwgZzogTGlzdFtpbnRdLCBzOiBMaXN0W2ludF0pIC0+IGludDpcbiAgICAgICAgIyDlr7nlranlrZDog4Plj6Pku6Xlj4rppbzlubLmjpLluo9cbiAgICAgICAgZy5zb3J0KClcbiAgICAgICAgcy5zb3J0KClcbiAgICAgICAgYW5zID0gMFxuICAgICAgICAjIOmlvOW5suS4i+agh1xuICAgICAgICBpZHggPSAwXG4gICAgICAgICMg6YGN5Y6G5q+P5Liq5a2p5a2QXG4gICAgICAgIGZvciBpIGluIHJhbmdlKGxlbihnKSk6XG4gICAgICAgICAgICAjIOmBjeWOhuWJqeS9meeahOmlvOW5slxuICAgICAgICAgICAgd2hpbGUgaWR4IDwgbGVuKHMpOlxuICAgICAgICAgICAgICAgIGlmIHNbaWR4XSA+PSBnW2ldOlxuICAgICAgICAgICAgICAgICAgICBhbnMgKz0gMVxuICAgICAgICAgICAgICAgICAgICBpZHggKz0gMVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGVsc2U6XG4gICAgICAgICAgICAgICAgICAgIGlkeCArPSAxXG4gICAgICAgIHJldHVybiBhbnNcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTUuMi4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XHJcbnB1YmxpYzpcclxuICAgIGJvb2wgY2FuSnVtcCh2ZWN0b3I8aW50PiYgbnVtcykge1xyXG4gICAgICAgIGJvb2wgZHBbbnVtcy5zaXplKCldO1xyXG4gICAgICAgIG1lbXNldChkcCwgZmFsc2UsIHNpemVvZihkcCkpO1xyXG4gICAgICAgIGRwWzBdID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IG51bXMuc2l6ZSgpOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBpOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChqICsgbnVtc1tqXSA+PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHBbaV0gPSBkcFtpXSB8IGRwW2pdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkcFtudW1zLnNpemUoKSAtIDFdO1xyXG4gICAgfVxyXG59O1xuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcclxuICAgIHB1YmxpYyBib29sZWFuIGNhbkp1bXAoaW50W10gbnVtcykge1xyXG4gICAgICAgIGJvb2xlYW5bXSBkcCA9IG5ldyBib29sZWFuW251bXMubGVuZ3RoXTtcclxuICAgICAgICBkcFswXSA9IHRydWU7XHJcbiAgICAgICAgZm9yIChpbnQgaSA9IDE7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgaTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaiArIG51bXNbal0gPj0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRwW2ldID0gZHBbaV0gfCBkcFtqXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZHBbbnVtcy5sZW5ndGggLSAxXTtcclxuICAgIH1cclxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgY2FuSnVtcChzZWxmLCBudW1zOiBMaXN0W2ludF0pIC0+IGJvb2w6XG4gICAgICAgIGRwID0gW0ZhbHNlXSAqIGxlbihudW1zKVxuICAgICAgICBkcFswXSA9IFRydWVcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMSwgbGVuKG51bXMpKTpcbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKDAsIGkpOlxuICAgICAgICAgICAgICAgIGlmIGogKyBudW1zW2pdID49IGk6XG4gICAgICAgICAgICAgICAgICAgIGRwW2ldID0gZHBbaV0gfCBkcFtqXVxuICAgICAgICByZXR1cm4gZHBbbGVuKG51bXMpIC0gMV1cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTUuMi4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XHJcbnB1YmxpYzpcclxuICAgIGJvb2wgY2FuSnVtcCh2ZWN0b3I8aW50PiYgbnVtcykge1xyXG4gICAgICAgIGludCBuID0gbnVtcy5zaXplKCk7XHJcbiAgICAgICAgaW50IGRwW25dO1xyXG4gICAgICAgIG1lbXNldChkcCwgMCwgc2l6ZW9mKGRwKSk7XHJcbiAgICAgICAgZHBbMF0gPSBudW1zWzBdO1xyXG4gICAgICAgIGZvciAoaW50IGkgPSAxOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChkcFtpIC0gMV0gPCBpKSB7XHJcbiAgICAgICAgICAgICAgICBkcFtpXSA9IGRwW2kgLSAxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChkcFtpIC0gMV0gPiBpICsgbnVtc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRwW2ldID0gZHBbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkcFtpXSA9IGkgKyBudW1zW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkcFtuIC0gMV0gPj0gbiAtIDE7XHJcbiAgICB9XHJcbn07XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xyXG4gICAgcHVibGljIGJvb2xlYW4gY2FuSnVtcChpbnRbXSBudW1zKSB7XHJcbiAgICAgICAgaW50IG4gPSBudW1zLmxlbmd0aDtcclxuICAgICAgICBpbnRbXSBkcCA9IG5ldyBpbnRbbl07XHJcbiAgICAgICAgZHBbMF0gPSBudW1zWzBdO1xyXG4gICAgICAgIGZvciAoaW50IGkgPSAxOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChkcFtpIC0gMV0gPCBpKSB7XHJcbiAgICAgICAgICAgICAgICBkcFtpXSA9IGRwW2kgLSAxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRwW2ldID0gTWF0aC5tYXgoZHBbaSAtIDFdLCBpICsgbnVtc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRwW24gLSAxXSA+PSBuIC0gMTtcclxuICAgIH1cclxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcclxuICAgIGRlZiBjYW5KdW1wKHNlbGYsIG51bXM6IExpc3RbaW50XSkgLT4gYm9vbDpcclxuICAgICAgICBuID0gbGVuKG51bXMpXHJcbiAgICAgICAgZHAgPSBbMF0gKiBuXHJcbiAgICAgICAgZHBbMF0gPSBudW1zWzBdXHJcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMSwgbik6XHJcbiAgICAgICAgICAgIGlmIGRwW2kgLSAxXSA8IGk6XHJcbiAgICAgICAgICAgICAgICBkcFtpXSA9IGRwW2kgLSAxXVxyXG4gICAgICAgICAgICBlbHNlOlxyXG4gICAgICAgICAgICAgICAgZHBbaV0gPSBtYXgoZHBbaSAtIDFdLCBpICsgbnVtc1tpXSlcclxuICAgICAgICByZXR1cm4gZHBbbiAtIDFdID49IG4gLSAxXHJcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTUuMi4zIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XHJcbnB1YmxpYzpcclxuICAgIGJvb2wgY2FuSnVtcCh2ZWN0b3I8aW50PiYgbnVtcykge1xyXG4gICAgICAgIGludCBiZWdpbiA9IDAsIGVuZCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgLy8g5LiL5qyh6ICD6JmR55qE5pyA6L+c5L2N572uXHJcbiAgICAgICAgICAgIGludCBuZXh0X2VuZCA9IGVuZDtcclxuICAgICAgICAgICAgLy8gbWluKGVuZCArIDEsIGxlbihudW1zKSkg6Ziy5q2i6LaK55WMXHJcbiAgICAgICAgICAgIGludCBsaW1pdCA9IGVuZCArIDE7XHJcbiAgICAgICAgICAgIGlmIChudW1zLnNpemUoKSA8IGxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICBsaW1pdCA9IG51bXMuc2l6ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSBiZWdpbjsgaSA8IGxpbWl0OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0X2VuZCA+IGkgKyBudW1zW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dF9lbmQgPSBuZXh0X2VuZDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dF9lbmQgPSBpICsgbnVtc1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV4dF9lbmQgPT0gZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiZWdpbiA9IGVuZCArIDE7XHJcbiAgICAgICAgICAgIGVuZCA9IG5leHRfZW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW5kID49IG51bXMuc2l6ZSgpIC0gMTtcclxuICAgIH1cclxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XHJcbiAgICBwdWJsaWMgYm9vbGVhbiBjYW5KdW1wKGludFtdIG51bXMpIHtcclxuICAgICAgICBpbnQgYmVnaW4gPSAwLCBlbmQgPSAwO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIC8vIOS4i+asoeiAg+iZkeeahOacgOi/nOS9jee9rlxyXG4gICAgICAgICAgICBpbnQgbmV4dF9lbmQgPSBlbmQ7XHJcbiAgICAgICAgICAgIC8vIG1pbihlbmQgKyAxLCBsZW4obnVtcykpIOmYsuatoui2iueVjFxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gYmVnaW47IGkgPCBNYXRoLm1pbihlbmQgKyAxLCBudW1zLmxlbmd0aCk7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbmV4dF9lbmQgPSBNYXRoLm1heChuZXh0X2VuZCwgaSArIG51bXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXh0X2VuZCA9PSBlbmQpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJlZ2luID0gZW5kICsgMTtcclxuICAgICAgICAgICAgZW5kID0gbmV4dF9lbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbmQgPj0gbnVtcy5sZW5ndGggLSAxO1xyXG4gICAgfVxyXG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBjYW5KdW1wKHNlbGYsIG51bXM6IExpc3RbaW50XSkgLT4gYm9vbDpcbiAgICAgICAgIyDlj6/ot7Pot4PojIPlm7RcbiAgICAgICAgYmVnaW4sIGVuZCA9IDAsIDBcbiAgICAgICAgIyDkuIvmrKHogIPomZHnmoTmnIDov5zkvY3nva7vvIznu4jngrnkvY3nva5cbiAgICAgICAgbmV4dF9lbmQgPSBlbmQsIHRhcmdldCA9IGxlbihudW1zKSAtIDFcbiAgICAgICAgd2hpbGUgbmV4dF9lbmQgPCB0YXJnZXQ6XG4gICAgICAgICAgICAjIG1pbihlbmQgKyAxLCBsZW4obnVtcykpIOmYsuatoui2iueVjFxuICAgICAgICAgICAgZm9yIGkgaW4gcmFuZ2UoYmVnaW4sIG1pbihlbmQgKyAxLCBsZW4obnVtcykpKTpcbiAgICAgICAgICAgICAgICBuZXh0X2VuZCA9IG1heChuZXh0X2VuZCwgaSArIG51bXNbaV0pXG4gICAgICAgICAgICAjIOiMg+WbtOS4jeWPkeeUn+WPmOWMlu+8jOe7iOeCueS4jeWPr+i+vlxuICAgICAgICAgICAgaWYgbmV4dF9lbmQgPT0gZW5kOlxuICAgICAgICAgICAgICAgIHJldHVybiBGYWxzZVxuICAgICAgICAgICAgYmVnaW4sIGVuZCA9IGVuZCArIDEsIG5leHRfZW5kXG4gICAgICAgIHJldHVybiBUcnVlXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE1LjMuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xyXG5wdWJsaWNcclxuICAgIGludCBjYW5keShpbnRbXSByYXRpbmdzKSB7XHJcbiAgICAgICAgaW50IG4gPSByYXRpbmdzLmxlbmd0aDtcclxuICAgICAgICBpbnRbXSBsZWZ0X2FucyA9IG5ldyBpbnRbbl07XHJcbiAgICAgICAgaW50W10gcmlnaHRfYW5zID0gbmV3IGludFtuXTtcclxuICAgICAgICBBcnJheXMuZmlsbChsZWZ0X2FucywgMSk7XHJcbiAgICAgICAgQXJyYXlzLmZpbGwocmlnaHRfYW5zLCAxKTtcclxuICAgICAgICBpbnQgYW5zID0gMDtcclxuICAgICAgICAvLyDogIPomZHlt6bnm7jpgrvlranlrZDmnaHku7ZcclxuICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocmF0aW5nc1tpXSA+IHJhdGluZ3NbaSAtIDFdKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0X2Fuc1tpXSA9IGxlZnRfYW5zW2kgLSAxXSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g6ICD6JmR5Y+z55u46YK75a2p5a2Q5p2h5Lu2XHJcbiAgICAgICAgZm9yIChpbnQgaSA9IG4gLSAyOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBpZiAocmF0aW5nc1tpXSA+IHJhdGluZ3NbaSArIDFdKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodF9hbnNbaV0gPSByaWdodF9hbnNbaSArIDFdICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDlkIjlubbkuKTkuKrmnaHku7bnu5PmnpxcclxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBhbnMgKz0gTWF0aC5tYXgobGVmdF9hbnNbaV0sIHJpZ2h0X2Fuc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhbnM7XHJcbiAgICB9XHJcbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XHJcbiAgICBwdWJsaWMgaW50IGNhbmR5KGludFtdIHJhdGluZ3MpIHtcclxuICAgICAgICBpbnQgbiA9IHJhdGluZ3MubGVuZ3RoO1xyXG4gICAgICAgIGludFtdIGxlZnRfYW5zID0gbmV3IGludFtuXTtcclxuICAgICAgICBpbnRbXSByaWdodF9hbnMgPSBuZXcgaW50W25dO1xyXG4gICAgICAgIEFycmF5cy5maWxsKGxlZnRfYW5zLCAxKTtcclxuICAgICAgICBBcnJheXMuZmlsbChyaWdodF9hbnMsIDEpO1xyXG4gICAgICAgIGludCBhbnMgPSAwO1xyXG4gICAgICAgIC8vIOiAg+iZkeW3puebuOmCu+WtqeWtkOadoeS7tlxyXG4gICAgICAgIGZvciAoaW50IGkgPSAxOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChyYXRpbmdzW2ldID4gcmF0aW5nc1tpIC0gMV0pIHtcclxuICAgICAgICAgICAgICAgIGxlZnRfYW5zW2ldID0gbGVmdF9hbnNbaSAtIDFdICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDogIPomZHlj7Pnm7jpgrvlranlrZDmnaHku7ZcclxuICAgICAgICBmb3IgKGludCBpID0gbiAtIDI7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmIChyYXRpbmdzW2ldID4gcmF0aW5nc1tpICsgMV0pIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0X2Fuc1tpXSA9IHJpZ2h0X2Fuc1tpICsgMV0gKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOWQiOW5tuS4pOS4quadoeS7tue7k+aenFxyXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFucyArPSBNYXRoLm1heChsZWZ0X2Fuc1tpXSwgcmlnaHRfYW5zW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFucztcclxuICAgIH1cclxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgbGVhc3RJbnRlcnZhbChzZWxmLCB0YXNrczogTGlzdFtzdHJdLCBuOiBpbnQpIC0+IGludDpcbiAgICAgICAgdF9tYXAgPSBbMF0gKiAyNlxuICAgICAgICBmb3IgdCBpbiB0YXNrczpcbiAgICAgICAgICAgIHRfbWFwW29yZCh0KSAtIG9yZChcIkFcIildICs9IDFcbiAgICAgICAgdF9tYXAuc29ydCgpXG4gICAgICAgICMgbWF4X251bSDkuLrmnIDpq5jmrKHmlbDvvIxjbnQg5Li65pyA6auY5qyh5pWw55qE5Lu75Yqh56eN57G7XG4gICAgICAgIG1heF9udW0sIGNudCA9IHRfbWFwWzI1XSwgMFxuICAgICAgICBmb3IgaSBpbiByYW5nZSgyNik6XG4gICAgICAgICAgICBpZiB0X21hcFtpXSA9PSBtYXhfbnVtOlxuICAgICAgICAgICAgICAgIGNudCArPSAxXG4gICAgICAgIHJldHVybiBtYXgoKG1heF9udW0gLSAxKSAqIChuICsgMSkgKyBjbnQsIGxlbih0YXNrcykpXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE1LjQuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAgIGludCBjYW5keSh2ZWN0b3I8aW50PiYgcmF0aW5ncykge1xuICAgICAgICBpbnQgbiA9IHJhdGluZ3Muc2l6ZSgpO1xuICAgICAgICB2ZWN0b3I8aW50PiBsZWZ0X2FucyhuLCAxKTtcbiAgICAgICAgdmVjdG9yPGludD4gcmlnaHRfYW5zKG4sIDEpO1xuICAgICAgICBpbnQgYW5zID0gMDtcbiAgICAgICAgLy8g6ICD6JmR5bem55u46YK75a2p5a2Q5p2h5Lu2XG4gICAgICAgIGZvciAoaW50IGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmF0aW5nc1tpXSA+IHJhdGluZ3NbaSAtIDFdKSB7XG4gICAgICAgICAgICAgICAgbGVmdF9hbnNbaV0gPSBsZWZ0X2Fuc1tpIC0gMV0gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIOiAg+iZkeWPs+ebuOmCu+WtqeWtkOadoeS7tlxuICAgICAgICBmb3IgKGludCBpID0gbiAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAocmF0aW5nc1tpXSA+IHJhdGluZ3NbaSArIDFdKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRfYW5zW2ldID0gcmlnaHRfYW5zW2kgKyAxXSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8g5ZCI5bm25Lik5Liq5p2h5Lu257uT5p6cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb3V0IDw8IGxlZnRfYW5zW2ldIDw8IFwiOlwiIDw8IHJpZ2h0X2Fuc1tpXSA8PCBlbmRsO1xuICAgICAgICAgICAgaWYgKGxlZnRfYW5zW2ldID4gcmlnaHRfYW5zW2ldKSB7XG4gICAgICAgICAgICAgICAgYW5zICs9IGxlZnRfYW5zW2ldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbnMgKz0gcmlnaHRfYW5zW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbnM7XG4gICAgfVxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XHJcbiAgICBwdWJsaWMgaW50IGNhbmR5KGludFtdIHJhdGluZ3MpIHtcclxuICAgICAgICBpbnQgbiA9IHJhdGluZ3MubGVuZ3RoO1xyXG4gICAgICAgIGludFtdIGxlZnRfYW5zID0gbmV3IGludFtuXTtcclxuICAgICAgICBpbnRbXSByaWdodF9hbnMgPSBuZXcgaW50W25dO1xyXG4gICAgICAgIEFycmF5cy5maWxsKGxlZnRfYW5zLCAxKTtcclxuICAgICAgICBBcnJheXMuZmlsbChyaWdodF9hbnMsIDEpO1xyXG4gICAgICAgIGludCBhbnMgPSAwO1xyXG4gICAgICAgIC8vIOiAg+iZkeW3puebuOmCu+WtqeWtkOadoeS7tlxyXG4gICAgICAgIGZvciAoaW50IGkgPSAxOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChyYXRpbmdzW2ldID4gcmF0aW5nc1tpIC0gMV0pIHtcclxuICAgICAgICAgICAgICAgIGxlZnRfYW5zW2ldID0gbGVmdF9hbnNbaSAtIDFdICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDogIPomZHlj7Pnm7jpgrvlranlrZDmnaHku7ZcclxuICAgICAgICBmb3IgKGludCBpID0gbiAtIDI7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmIChyYXRpbmdzW2ldID4gcmF0aW5nc1tpICsgMV0pIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0X2Fuc1tpXSA9IHJpZ2h0X2Fuc1tpICsgMV0gKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOWQiOW5tuS4pOS4quadoeS7tue7k+aenFxyXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFucyArPSBNYXRoLm1heChsZWZ0X2Fuc1tpXSwgcmlnaHRfYW5zW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFucztcclxuICAgIH1cclxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgY2FuZHkoc2VsZiwgcmF0aW5nczogTGlzdFtpbnRdKSAtPiBpbnQ6XG4gICAgICAgIGxlZnRfYW5zLCByaWdodF9hbnMgPSBbMV0gKiBsZW4ocmF0aW5ncyksIFsxXSAqIGxlbihyYXRpbmdzKVxuICAgICAgICBhbnMgPSAwXG4gICAgICAgICMg6ICD6JmR5bem55u46YK75a2p5a2Q5p2h5Lu2XG4gICAgICAgIGZvciBpIGluIHJhbmdlKDEsIGxlbihyYXRpbmdzKSk6XG4gICAgICAgICAgICBpZiByYXRpbmdzW2ldID4gcmF0aW5nc1tpIC0gMV06XG4gICAgICAgICAgICAgICAgbGVmdF9hbnNbaV0gPSBsZWZ0X2Fuc1tpIC0gMV0gKyAxXG4gICAgICAgICMg6ICD6JmR5Y+z55u46YK75a2p5a2Q5p2h5Lu2XG4gICAgICAgIGZvciBpIGluIHJhbmdlKGxlbihyYXRpbmdzKSAtIDIsIC0xLCAtMSk6XG4gICAgICAgICAgICBpZiByYXRpbmdzW2ldID4gcmF0aW5nc1tpICsgMV06XG4gICAgICAgICAgICAgICAgcmlnaHRfYW5zW2ldID0gcmlnaHRfYW5zW2kgKyAxXSArIDFcbiAgICAgICAgIyDlkIjlubbkuKTkuKrmnaHku7bnu5PmnpxcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMCwgbGVuKHJhdGluZ3MpKTpcbiAgICAgICAgICAgIGFucyArPSBtYXgobGVmdF9hbnNbaV0sIHJpZ2h0X2Fuc1tpXSlcbiAgICAgICAgcmV0dXJuIGFuc1xuXG4iCiAgICB9XQogIH1dCn0sIHsKICAiaWQiOiAiMTYiLAogICJuYW1lIjogIuesrOWNgeWFreeroCIsCiAgImxpc3QiOiBbewogICAgInRpdGxlIjogIuS7o+eggTE2LjEuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xyXG5wdWJsaWM6XHJcbiAgICB2ZWN0b3I8dmVjdG9yPGludD4+IGFucztcclxuICAgIHZlY3RvcjxpbnQ+IHBhdGg7XHJcbiAgICB2ZWN0b3I8dmVjdG9yPGludD4+IGNvbWJpbmF0aW9uU3VtKHZlY3RvcjxpbnQ+JiBjYW5kaWRhdGVzLCBpbnQgdGFyZ2V0KSB7XHJcbiAgICAgICAgZGZzKGNhbmRpZGF0ZXMsIDAsIHRhcmdldCk7XHJcbiAgICAgICAgcmV0dXJuIGFucztcclxuICAgIH1cclxuICAgIHZvaWQgZGZzKHZlY3RvcjxpbnQ+JiBjYW5kaWRhdGVzLCBpbnQgaWR4LCBpbnQgY3VyKSB7XHJcbiAgICAgICAgLy8g6YCS5b2S57uT5p2fXHJcbiAgICAgICAgaWYgKGN1ciA9PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIOWFi+mahiBwYXRoIOW5tua3u+WKoOWIsCBhbnNcclxuICAgICAgICAgICAgYW5zLnB1c2hfYmFjayh2ZWN0b3I8aW50PihwYXRoKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9IGVsc2UgaWYgKGlkeCA9PSBjYW5kaWRhdGVzLnNpemUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDEu5Yqg5YWl6L+Z5Liq5pWw5a2XXHJcbiAgICAgICAgaWYgKGNhbmRpZGF0ZXNbaWR4XSA8PSBjdXIpIHtcclxuICAgICAgICAgICAgcGF0aC5wdXNoX2JhY2soY2FuZGlkYXRlc1tpZHhdKTtcclxuICAgICAgICAgICAgLy8gaWR4IOS4jeWPmO+8jOe7p+e7reiAg+iZkeW9k+WJjeaVsOWtl1xyXG4gICAgICAgICAgICBkZnMoY2FuZGlkYXRlcywgaWR4LCBjdXIgLSBjYW5kaWRhdGVzW2lkeF0pO1xyXG4gICAgICAgICAgICAvLyDmtojpmaTlvbHlk41cclxuICAgICAgICAgICAgcGF0aC5wb3BfYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAyLuS4jeWKoOWFpei/meS4quaVsOWtl++8jOiAg+iZkeS4i+S4gOS4quaVsOWtl1xyXG4gICAgICAgIGRmcyhjYW5kaWRhdGVzLCBpZHggKyAxLCBjdXIpO1xyXG4gICAgfVxyXG59O1xuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcclxuICAgIExpc3Q8TGlzdDxJbnRlZ2VyPj4gYW5zID0gbmV3IEFycmF5TGlzdDw+KCk7XHJcbiAgICBwdWJsaWMgTGlzdDxMaXN0PEludGVnZXI+PiBjb21iaW5hdGlvblN1bShpbnRbXSBjYW5kaWRhdGVzLCBpbnQgdGFyZ2V0KSB7XHJcbiAgICAgICAgZGZzKGNhbmRpZGF0ZXMsIDAsIHRhcmdldCwgbmV3IEFycmF5TGlzdDw+KCkpO1xyXG4gICAgICAgIHJldHVybiBhbnM7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgdm9pZCBkZnMoaW50W10gY2FuZGlkYXRlcywgaW50IGlkeCwgaW50IGN1ciwgTGlzdDxJbnRlZ2VyPiBwYXRoKSB7XHJcbiAgICAgICAgLy8g6YCS5b2S57uT5p2fXHJcbiAgICAgICAgaWYgKGN1ciA9PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIOWFi+mahiBwYXRoIOW5tua3u+WKoOWIsCBhbnNcclxuICAgICAgICAgICAgYW5zLmFkZChuZXcgQXJyYXlMaXN0PD4ocGF0aCkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfSBlbHNlIGlmIChpZHggPT0gY2FuZGlkYXRlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAxLuWKoOWFpei/meS4quaVsOWtl1xyXG4gICAgICAgIGlmIChjYW5kaWRhdGVzW2lkeF0gPD0gY3VyKSB7XHJcbiAgICAgICAgICAgIHBhdGguYWRkKGNhbmRpZGF0ZXNbaWR4XSk7XHJcbiAgICAgICAgICAgIC8vIGlkeCDkuI3lj5jvvIznu6fnu63ogIPomZHlvZPliY3mlbDlrZdcclxuICAgICAgICAgICAgZGZzKGNhbmRpZGF0ZXMsIGlkeCwgY3VyIC0gY2FuZGlkYXRlc1tpZHhdLCBwYXRoKTtcclxuICAgICAgICAgICAgLy8g5raI6Zmk5b2x5ZONXHJcbiAgICAgICAgICAgIHBhdGgucmVtb3ZlKHBhdGguc2l6ZSgpIC0gMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDIu5LiN5Yqg5YWl6L+Z5Liq5pWw5a2X77yM6ICD6JmR5LiL5LiA5Liq5pWw5a2XXHJcbiAgICAgICAgZGZzKGNhbmRpZGF0ZXMsIGlkeCArIDEsIGN1ciwgcGF0aCk7XHJcbiAgICB9XHJcbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGNvbWJpbmF0aW9uU3VtKHNlbGYsIGNhbmRpZGF0ZXM6IExpc3RbaW50XSwgdGFyZ2V0OiBpbnQpIC0+IExpc3RbTGlzdFtpbnRdXTpcbiAgICAgICAgYW5zID0gW11cbiAgICAgICAgbiA9IGxlbihjYW5kaWRhdGVzKVxuXG4gICAgICAgIGRlZiBkZnMoaWR4OiBpbnQsIGN1cjogaW50LCBwYXRoOiBMaXN0W2ludF0pOlxuICAgICAgICAgICAgIyDpgJLlvZLnu5PmnZ9cbiAgICAgICAgICAgIGlmIGN1ciA9PSAwOlxuICAgICAgICAgICAgICAgICMg5YWL6ZqGIHBhdGgg5bm25re75Yqg5YiwIGFuc1xuICAgICAgICAgICAgICAgIGFucy5hcHBlbmQocGF0aFs6XSlcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIGVsaWYgaWR4ID09IG46XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAjIDEu5Yqg5YWl6L+Z5Liq5pWw5a2XXG4gICAgICAgICAgICBpZiBjYW5kaWRhdGVzW2lkeF0gPD0gY3VyOlxuICAgICAgICAgICAgICAgIHBhdGguYXBwZW5kKGNhbmRpZGF0ZXNbaWR4XSlcbiAgICAgICAgICAgICAgICAjIGlkeCDkuI3lj5jvvIznu6fnu63ogIPomZHlvZPliY3mlbDlrZdcbiAgICAgICAgICAgICAgICBkZnMoaWR4LCBjdXIgLSBjYW5kaWRhdGVzW2lkeF0sIHBhdGgpXG4gICAgICAgICAgICAgICAgIyDmtojpmaTlvbHlk41cbiAgICAgICAgICAgICAgICBwYXRoLnBvcCgpXG4gICAgICAgICAgICAjIDIu5LiN5Yqg5YWl6L+Z5Liq5pWw5a2X77yM6ICD6JmR5LiL5LiA5Liq5pWw5a2XXG4gICAgICAgICAgICBkZnMoaWR4ICsgMSwgY3VyLCBwYXRoKVxuXG4gICAgICAgIGRmcygwLCB0YXJnZXQsIFtdKVxuICAgICAgICByZXR1cm4gYW5zXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE2LjIuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xyXG5wdWJsaWM6XHJcbiAgICB2ZWN0b3I8dmVjdG9yPGludD4+IGFucztcclxuICAgIHNldDxpbnQ+IHZpc2l0ZWQ7XHJcbiAgICB2ZWN0b3I8aW50PiBwYXRoO1xyXG4gICAgdmVjdG9yPHZlY3RvcjxpbnQ+PiBjb21iaW5hdGlvblN1bTIodmVjdG9yPGludD4mIGNhbmRpZGF0ZXMsIGludCB0YXJnZXQpIHtcclxuICAgICAgICBzb3J0KGNhbmRpZGF0ZXMuYmVnaW4oKSwgY2FuZGlkYXRlcy5lbmQoKSk7XHJcbiAgICAgICAgZGZzKGNhbmRpZGF0ZXMsIDAsIHRhcmdldCk7XHJcbiAgICAgICAgcmV0dXJuIGFucztcclxuICAgIH1cclxuICAgIHZvaWQgZGZzKHZlY3RvcjxpbnQ+JiBjYW5kaWRhdGVzLCBpbnQgaWR4LCBpbnQgY3VyKSB7XHJcbiAgICAgICAgaWYgKGN1ciA9PSAwKSB7XHJcbiAgICAgICAgICAgIGFucy5wdXNoX2JhY2sodmVjdG9yPGludD4ocGF0aCkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfSBlbHNlIGlmIChpZHggPT0gY2FuZGlkYXRlcy5zaXplKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDlvZPliY3mlbDlrZfkuI7liY3pnaLmlbDlrZfnm7jlkIzlubbkuJTliY3pnaLmlbDlrZfmsqHmnInlnKjot6/lvoTkuK3vvIzliJnlv73nlaXov5nkuKrmlbDlrZdcclxuICAgICAgICBpZiAoaWR4ICE9IDAgJiYgY2FuZGlkYXRlc1tpZHhdID09IGNhbmRpZGF0ZXNbaWR4IC0gMV0gJiYgIXZpc2l0ZWQuY291bnQoaWR4IC0gMSkpIHtcclxuICAgICAgICAgICAgZGZzKGNhbmRpZGF0ZXMsIGlkeCArIDEsIGN1cik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMS7liqDlhaXov5nkuKrmlbDlrZdcclxuICAgICAgICBpZiAoY2FuZGlkYXRlc1tpZHhdIDw9IGN1cikge1xyXG4gICAgICAgICAgICBwYXRoLnB1c2hfYmFjayhjYW5kaWRhdGVzW2lkeF0pO1xyXG4gICAgICAgICAgICB2aXNpdGVkLmluc2VydChpZHgpO1xyXG4gICAgICAgICAgICAvLyDlkJHkuIvpgJLlvZLml7bogIPomZHkuIvkuIDkuKrmlbDlrZdcclxuICAgICAgICAgICAgZGZzKGNhbmRpZGF0ZXMsIGlkeCArIDEsIGN1ciAtIGNhbmRpZGF0ZXNbaWR4XSk7XHJcbiAgICAgICAgICAgIC8vIOa2iOmZpOW9seWTjVxyXG4gICAgICAgICAgICBwYXRoLnBvcF9iYWNrKCk7XHJcbiAgICAgICAgICAgIHZpc2l0ZWQuZXJhc2UoaWR4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMi7kuI3liqDlhaXov5nkuKrmlbDlrZdcclxuICAgICAgICBkZnMoY2FuZGlkYXRlcywgaWR4ICsgMSwgY3VyKTtcclxuICAgIH1cclxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XHJcbiAgICBMaXN0PExpc3Q8SW50ZWdlcj4+IGFucyA9IG5ldyBBcnJheUxpc3Q8PigpO1xyXG4gICAgU2V0PEludGVnZXI+IHZpc2l0ZWQgPSBuZXcgSGFzaFNldDw+KCk7XHJcbiAgICBMaXN0PEludGVnZXI+IHBhdGggPSBuZXcgQXJyYXlMaXN0PD4oKTtcclxuICAgIHB1YmxpYyBMaXN0PExpc3Q8SW50ZWdlcj4+IGNvbWJpbmF0aW9uU3VtMihpbnRbXSBjYW5kaWRhdGVzLCBpbnQgdGFyZ2V0KSB7XHJcbiAgICAgICAgQXJyYXlzLnNvcnQoY2FuZGlkYXRlcyk7XHJcbiAgICAgICAgZGZzKGNhbmRpZGF0ZXMsIDAsIHRhcmdldCk7XHJcbiAgICAgICAgcmV0dXJuIGFucztcclxuICAgIH1cclxuICAgIHB1YmxpYyB2b2lkIGRmcyhpbnRbXSBjYW5kaWRhdGVzLCBpbnQgaWR4LCBpbnQgY3VyKSB7XHJcbiAgICAgICAgaWYgKGN1ciA9PSAwKSB7XHJcbiAgICAgICAgICAgIGFucy5hZGQobmV3IEFycmF5TGlzdDw+KHBhdGgpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaWR4ID09IGNhbmRpZGF0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5b2T5YmN5pWw5a2X5LiO5YmN6Z2i5pWw5a2X55u45ZCM5bm25LiU5YmN6Z2i5pWw5a2X5rKh5pyJ5Zyo6Lev5b6E5Lit77yM5YiZ5b+955Wl6L+Z5Liq5pWw5a2XXHJcbiAgICAgICAgaWYgKGlkeCAhPSAwICYmIGNhbmRpZGF0ZXNbaWR4XSA9PSBjYW5kaWRhdGVzW2lkeCAtIDFdICYmICF2aXNpdGVkLmNvbnRhaW5zKGlkeCAtIDEpKSB7XHJcbiAgICAgICAgICAgIGRmcyhjYW5kaWRhdGVzLCBpZHggKyAxLCBjdXIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDEu5Yqg5YWl6L+Z5Liq5pWw5a2XXHJcbiAgICAgICAgaWYgKGNhbmRpZGF0ZXNbaWR4XSA8PSBjdXIpIHtcclxuICAgICAgICAgICAgcGF0aC5hZGQoY2FuZGlkYXRlc1tpZHhdKTtcclxuICAgICAgICAgICAgdmlzaXRlZC5hZGQoaWR4KTtcclxuICAgICAgICAgICAgLy8g5ZCR5LiL6YCS5b2S5pe26ICD6JmR5LiL5LiA5Liq5pWw5a2XXHJcbiAgICAgICAgICAgIGRmcyhjYW5kaWRhdGVzLCBpZHggKyAxLCBjdXIgLSBjYW5kaWRhdGVzW2lkeF0pO1xyXG4gICAgICAgICAgICAvLyDmtojpmaTlvbHlk41cclxuICAgICAgICAgICAgcGF0aC5yZW1vdmUocGF0aC5zaXplKCkgLSAxKTtcclxuICAgICAgICAgICAgdmlzaXRlZC5yZW1vdmUoaWR4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMi7kuI3liqDlhaXov5nkuKrmlbDlrZdcclxuICAgICAgICBkZnMoY2FuZGlkYXRlcywgaWR4ICsgMSwgY3VyKTtcclxuICAgIH1cclxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgY29tYmluYXRpb25TdW0yKHNlbGYsIGNhbmRpZGF0ZXM6IExpc3RbaW50XSwgdGFyZ2V0OiBpbnQpIC0+IExpc3RbTGlzdFtpbnRdXTpcbiAgICAgICAgYW5zID0gW11cbiAgICAgICAgbiA9IGxlbihjYW5kaWRhdGVzKVxuICAgICAgICB2aXNpdGVkID0gc2V0KClcbiAgICAgICAgY2FuZGlkYXRlcy5zb3J0KClcblxuICAgICAgICBkZWYgZGZzKGlkeDogaW50LCBjdXI6IGludCwgcGF0aDogTGlzdFtpbnRdKTpcbiAgICAgICAgICAgIGlmIGN1ciA9PSAwOlxuICAgICAgICAgICAgICAgIGFucy5hcHBlbmQocGF0aFs6XSlcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIGVsaWYgaWR4ID09IG46XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAjIOW9k+WJjeaVsOWtl+S4juWJjemdouaVsOWtl+ebuOWQjOW5tuS4lOWJjemdouaVsOWtl+ayoeacieWcqOi3r+W+hOS4re+8jOWImeW/veeVpei/meS4quaVsOWtl1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGlkeCAhPSAwXG4gICAgICAgICAgICAgICAgYW5kIGNhbmRpZGF0ZXNbaWR4XSA9PSBjYW5kaWRhdGVzW2lkeCAtIDFdXG4gICAgICAgICAgICAgICAgYW5kIChpZHggLSAxKSBub3QgaW4gdmlzaXRlZFxuICAgICAgICAgICAgKTpcbiAgICAgICAgICAgICAgICBkZnMoaWR4ICsgMSwgY3VyLCBwYXRoKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgIyAxLuWKoOWFpei/meS4quaVsOWtl1xuICAgICAgICAgICAgaWYgY2FuZGlkYXRlc1tpZHhdIDw9IGN1cjpcbiAgICAgICAgICAgICAgICBwYXRoLmFwcGVuZChjYW5kaWRhdGVzW2lkeF0pXG4gICAgICAgICAgICAgICAgdmlzaXRlZC5hZGQoaWR4KVxuICAgICAgICAgICAgICAgICMg5ZCR5LiL6YCS5b2S5pe26ICD6JmR5LiL5LiA5Liq5pWw5a2XXG4gICAgICAgICAgICAgICAgZGZzKGlkeCArIDEsIGN1ciAtIGNhbmRpZGF0ZXNbaWR4XSwgcGF0aClcbiAgICAgICAgICAgICAgICAjIOa2iOmZpOW9seWTjVxuICAgICAgICAgICAgICAgIHBhdGgucG9wKClcbiAgICAgICAgICAgICAgICB2aXNpdGVkLnJlbW92ZShpZHgpXG4gICAgICAgICAgICAjIDIu5LiN5Yqg5YWl6L+Z5Liq5pWw5a2XXG4gICAgICAgICAgICBkZnMoaWR4ICsgMSwgY3VyLCBwYXRoKVxuXG4gICAgICAgIGRmcygwLCB0YXJnZXQsIFtdKVxuICAgICAgICByZXR1cm4gYW5zXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE2LjMuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xyXG5wdWJsaWM6XHJcbiAgICB2ZWN0b3I8dmVjdG9yPGludD4+IGFucztcclxuICAgIHZlY3RvcjxpbnQ+IHBhdGg7XHJcbiAgICB2ZWN0b3I8dmVjdG9yPGludD4+IHN1YnNldHModmVjdG9yPGludD4mIG51bXMpIHtcclxuICAgICAgICBkZnMobnVtcywgMCk7XHJcbiAgICAgICAgcmV0dXJuIGFucztcclxuICAgIH1cclxuICAgIHZvaWQgZGZzKHZlY3RvcjxpbnQ+JiBudW1zLCBpbnQgaWR4KSB7XHJcbiAgICAgICAgaWYgKGlkeCA9PSBudW1zLnNpemUoKSkge1xyXG4gICAgICAgICAgICBhbnMucHVzaF9iYWNrKHZlY3RvcjxpbnQ+KHBhdGgpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXRoLnB1c2hfYmFjayhudW1zW2lkeF0pO1xyXG4gICAgICAgIGRmcyhudW1zLCBpZHggKyAxKTtcclxuICAgICAgICBwYXRoLnBvcF9iYWNrKCk7XHJcbiAgICAgICAgZGZzKG51bXMsIGlkeCArIDEpO1xyXG4gICAgfVxyXG59O1xuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcclxuICAgIExpc3Q8TGlzdDxJbnRlZ2VyPj4gYW5zID0gbmV3IEFycmF5TGlzdDw+KCk7XHJcbiAgICBwdWJsaWMgTGlzdDxMaXN0PEludGVnZXI+PiBzdWJzZXRzKGludFtdIG51bXMpIHtcclxuICAgICAgICBkZnMobnVtcywgMCwgbmV3IEFycmF5TGlzdDw+KCkpO1xyXG4gICAgICAgIHJldHVybiBhbnM7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgdm9pZCBkZnMoaW50W10gbnVtcywgaW50IGlkeCwgTGlzdDxJbnRlZ2VyPiBwYXRoKSB7XHJcbiAgICAgICAgaWYgKGlkeCA9PSBudW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBhbnMuYWRkKG5ldyBBcnJheUxpc3Q8PihwYXRoKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGF0aC5hZGQobnVtc1tpZHhdKTtcclxuICAgICAgICBkZnMobnVtcywgaWR4ICsgMSwgcGF0aCk7XHJcbiAgICAgICAgcGF0aC5yZW1vdmUocGF0aC5zaXplKCkgLSAxKTtcclxuICAgICAgICBkZnMobnVtcywgaWR4ICsgMSwgcGF0aCk7XHJcbiAgICB9XHJcbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHN1YnNldHMoc2VsZiwgbnVtczogTGlzdFtpbnRdKSAtPiBMaXN0W0xpc3RbaW50XV06XG4gICAgICAgIGFucyA9IFtdXG4gICAgICAgIG4gPSBsZW4obnVtcylcblxuICAgICAgICBkZWYgZGZzKGlkeDogaW50LCBwYXRoOiBMaXN0W2ludF0pOlxuICAgICAgICAgICAgaWYgaWR4ID09IG46XG4gICAgICAgICAgICAgICAgYW5zLmFwcGVuZChwYXRoWzpdKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgcGF0aC5hcHBlbmQobnVtc1tpZHhdKVxuICAgICAgICAgICAgZGZzKGlkeCArIDEsIHBhdGgpXG4gICAgICAgICAgICBwYXRoLnBvcCgpXG4gICAgICAgICAgICBkZnMoaWR4ICsgMSwgcGF0aClcblxuICAgICAgICBkZnMoMCwgW10pXG4gICAgICAgIHJldHVybiBhbnNcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTYuNC4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XHJcbnB1YmxpYzpcclxuICAgIHZlY3Rvcjx2ZWN0b3I8aW50Pj4gYW5zO1xyXG4gICAgdmVjdG9yPGludD4gcGF0aDtcclxuICAgIHNldDxpbnQ+IHZpc2l0ZWQ7XHJcbiAgICB2ZWN0b3I8dmVjdG9yPGludD4+IHBlcm11dGUodmVjdG9yPGludD4mIG51bXMpIHtcclxuICAgICAgICBkZnMobnVtcyk7XHJcbiAgICAgICAgcmV0dXJuIGFucztcclxuICAgIH1cclxuICAgIHZvaWQgZGZzKHZlY3RvcjxpbnQ+JiBudW1zKSB7XHJcbiAgICAgICAgaWYgKHBhdGguc2l6ZSgpID09IG51bXMuc2l6ZSgpKSB7XHJcbiAgICAgICAgICAgIGFucy5wdXNoX2JhY2sodmVjdG9yPGludD4ocGF0aCkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtcy5zaXplKCk7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWQuY291bnQoaSkpIHtcclxuICAgICAgICAgICAgICAgIHZpc2l0ZWQuaW5zZXJ0KGkpO1xyXG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoX2JhY2sobnVtc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBkZnMobnVtcyk7XHJcbiAgICAgICAgICAgICAgICBwYXRoLnBvcF9iYWNrKCk7XHJcbiAgICAgICAgICAgICAgICB2aXNpdGVkLmVyYXNlKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uIHtcclxuICAgIExpc3Q8TGlzdDxJbnRlZ2VyPj4gYW5zID0gbmV3IEFycmF5TGlzdDw+KCk7XHJcbiAgICBTZXQ8SW50ZWdlcj4gdmlzaXRlZCA9IG5ldyBIYXNoU2V0PD4oKTtcclxuICAgIHB1YmxpYyBMaXN0PExpc3Q8SW50ZWdlcj4+IHBlcm11dGUoaW50W10gbnVtcykge1xyXG4gICAgICAgIGRmcyhuZXcgQXJyYXlMaXN0PD4oKSwgbnVtcyk7XHJcbiAgICAgICAgcmV0dXJuIGFucztcclxuICAgIH1cclxuICAgIHB1YmxpYyB2b2lkIGRmcyhMaXN0PEludGVnZXI+IHBhdGgsIGludFtdIG51bXMpIHtcclxuICAgICAgICBpZiAocGF0aC5zaXplKCkgPT0gbnVtcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgYW5zLmFkZChuZXcgQXJyYXlMaXN0PD4ocGF0aCkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWQuY29udGFpbnMoaSkpIHtcclxuICAgICAgICAgICAgICAgIHZpc2l0ZWQuYWRkKGkpO1xyXG4gICAgICAgICAgICAgICAgcGF0aC5hZGQobnVtc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBkZnMocGF0aCwgbnVtcyk7XHJcbiAgICAgICAgICAgICAgICBwYXRoLnJlbW92ZShwYXRoLnNpemUoKSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgdmlzaXRlZC5yZW1vdmUoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHBlcm11dGUoc2VsZiwgbnVtczogTGlzdFtpbnRdKSAtPiBMaXN0W0xpc3RbaW50XV06XG4gICAgICAgIGFucyA9IFtdXG4gICAgICAgIG4gPSBsZW4obnVtcylcbiAgICAgICAgdmlzaXRlZCA9IHNldCgpXG5cbiAgICAgICAgZGVmIGRmcyhwYXRoOiBMaXN0W2ludF0pOlxuICAgICAgICAgICAgaWYgbGVuKHBhdGgpID09IG46XG4gICAgICAgICAgICAgICAgYW5zLmFwcGVuZChwYXRoWzpdKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgZm9yIGkgaW4gcmFuZ2Uobik6XG4gICAgICAgICAgICAgICAgaWYgaSBub3QgaW4gdmlzaXRlZDpcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRlZC5hZGQoaSlcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5hcHBlbmQobnVtc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgZGZzKHBhdGgpXG4gICAgICAgICAgICAgICAgICAgIHBhdGgucG9wKClcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRlZC5yZW1vdmUoaSlcblxuICAgICAgICBkZnMoW10pXG4gICAgICAgIHJldHVybiBhbnNcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTYuNS4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XHJcbnB1YmxpYzpcclxuICAgIGJvb2wgY29sWzldWzldO1xyXG4gICAgYm9vbCByb3dbOV1bOV07XHJcbiAgICBib29sIHBsYWNlWzldWzldO1xyXG5cclxuICAgIHZvaWQgc29sdmVTdWRva3UodmVjdG9yPHZlY3RvcjxjaGFyPj4mIGJvYXJkKSB7XHJcbiAgICAgICAgbWVtc2V0KGNvbCwgZmFsc2UsIHNpemVvZihjb2wpKTtcclxuICAgICAgICBtZW1zZXQocm93LCBmYWxzZSwgc2l6ZW9mKHJvdykpO1xyXG4gICAgICAgIG1lbXNldChwbGFjZSwgZmFsc2UsIHNpemVvZihwbGFjZSkpO1xyXG5cclxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDk7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IDk7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvYXJkW2ldW2pdID09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW50IG51bSA9IGJvYXJkW2ldW2pdIC0gJzEnO1xyXG4gICAgICAgICAgICAgICAgcm93W2ldW251bV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY29sW2pdW251bV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcGxhY2VbaSAvIDMgKiAzICsgaiAvIDNdW251bV0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkZnMoYm9hcmQsIDAsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIGJvb2wgZGZzKHZlY3Rvcjx2ZWN0b3I8Y2hhcj4+JiBib2FyZCwgaW50IGksIGludCBqKSB7XHJcbiAgICAgICAgaWYgKGogPT0gOSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGZzKGJvYXJkLCBpICsgMSwgMCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpID09IDkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChib2FyZFtpXVtqXSAhPSAnLicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRmcyhib2FyZCwgaSwgaiArIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChpbnQgayA9IDA7IGsgPCA5OyBrKyspIHtcclxuICAgICAgICAgICAgaWYgKGNvbFtqXVtrXSB8fCByb3dbaV1ba10gfHwgcGxhY2VbaSAvIDMgKiAzICsgaiAvIDNdW2tdKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBib2FyZFtpXVtqXSA9ICcxJyArIGs7XHJcbiAgICAgICAgICAgIGNvbFtqXVtrXSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJvd1tpXVtrXSA9IHRydWU7XHJcbiAgICAgICAgICAgIHBsYWNlW2kgLyAzICogMyArIGogLyAzXVtrXSA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChkZnMoYm9hcmQsIGksIGogKyAxKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYm9hcmRbaV1bal0gPSAnLic7XHJcbiAgICAgICAgICAgIGNvbFtqXVtrXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICByb3dbaV1ba10gPSBmYWxzZTtcclxuICAgICAgICAgICAgcGxhY2VbaSAvIDMgKiAzICsgaiAvIDNdW2tdID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufTtcbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbiB7XHJcbiAgICBcclxuICAgIGJvb2xlYW5bXVtdIGNvbCA9IG5ldyBib29sZWFuWzldWzldO1xyXG4gICAgYm9vbGVhbltdW10gcm93ID0gbmV3IGJvb2xlYW5bOV1bOV07XHJcbiAgICBib29sZWFuW11bXSBwbGFjZSA9IG5ldyBib29sZWFuWzldWzldO1xyXG4gICAgXHJcbiAgICBwdWJsaWMgdm9pZCBzb2x2ZVN1ZG9rdShjaGFyW11bXSBib2FyZCkge1xyXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgOTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgOTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9hcmRbaV1bal0gPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnQgbnVtID0gYm9hcmRbaV1bal0gLSAnMSc7XHJcbiAgICAgICAgICAgICAgICByb3dbaV1bbnVtXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb2xbal1bbnVtXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBwbGFjZVtpIC8gMyAqIDMgKyBqIC8gM11bbnVtXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZGZzKGJvYXJkLCAwLCAwKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcHVibGljIGJvb2xlYW4gZGZzKGNoYXJbXVtdIGJvYXJkLCBpbnQgaSwgaW50IGopIHtcclxuICAgICAgICBpZiAoaiA9PSA5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZnMoYm9hcmQsIGkgKyAxLCAwKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGkgPT0gOSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKGJvYXJkW2ldW2pdICE9ICcuJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZGZzKGJvYXJkLCBpLCBqICsgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGludCBrID0gMDsgayA8IDk7IGsrKykge1xyXG4gICAgICAgICAgICBpZiAoY29sW2pdW2tdIHx8IHJvd1tpXVtrXSB8fCBwbGFjZVtpIC8gMyAqIDMgKyBqIC8gM11ba10pIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJvYXJkW2ldW2pdID0gKGNoYXIpKCcxJyArIGspO1xyXG4gICAgICAgICAgICBjb2xbal1ba10gPSB0cnVlO1xyXG4gICAgICAgICAgICByb3dbaV1ba10gPSB0cnVlO1xyXG4gICAgICAgICAgICBwbGFjZVtpIC8gMyAqIDMgKyBqIC8gM11ba10gPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoZGZzKGJvYXJkLCBpLCBqICsgMSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJvYXJkW2ldW2pdID0gJy4nO1xyXG4gICAgICAgICAgICBjb2xbal1ba10gPSBmYWxzZTtcclxuICAgICAgICAgICAgcm93W2ldW2tdID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHBsYWNlW2kgLyAzICogMyArIGogLyAzXVtrXSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgXHJcbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHNvbHZlU3Vkb2t1KHNlbGYsIGJvYXJkOiBMaXN0W0xpc3Rbc3RyXV0pIC0+IE5vbmU6XG4gICAgICAgIGNvbCA9IFtbRmFsc2VdICogOSBmb3IgaSBpbiByYW5nZSg5KV1cbiAgICAgICAgcm93ID0gW1tGYWxzZV0gKiA5IGZvciBpIGluIHJhbmdlKDkpXVxuICAgICAgICBwbGFjZSA9IFtbRmFsc2VdICogOSBmb3IgaSBpbiByYW5nZSg5KV1cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoOSk6XG4gICAgICAgICAgICBmb3IgaiBpbiByYW5nZSg5KTpcbiAgICAgICAgICAgICAgICBpZiBib2FyZFtpXVtqXSAhPSBcIi5cIjpcbiAgICAgICAgICAgICAgICAgICAgbnVtID0gaW50KGJvYXJkW2ldW2pdKSAtIDFcbiAgICAgICAgICAgICAgICAgICAgY29sW2pdW251bV0gPSBUcnVlXG4gICAgICAgICAgICAgICAgICAgIHJvd1tpXVtudW1dID0gVHJ1ZVxuICAgICAgICAgICAgICAgICAgICBwbGFjZVtpIC8vIDMgKiAzICsgaiAvLyAzXVtudW1dID0gVHJ1ZVxuXG4gICAgICAgIGRlZiBkZnMoaTogaW50LCBqOiBpbnQpIC0+IGJvb2xlYW46XG4gICAgICAgICAgICBpZiBqID09IDk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRmcyhpICsgMSwgMClcbiAgICAgICAgICAgIGlmIGkgPT0gOTpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJ1ZVxuICAgICAgICAgICAgaWYgYm9hcmRbaV1bal0gIT0gXCIuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRmcyhpLCBqICsgMSlcbiAgICAgICAgICAgIGZvciBrIGluIHJhbmdlKDkpOlxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgY29sW2pdW2tdID09IFRydWVcbiAgICAgICAgICAgICAgICAgICAgb3Igcm93W2ldW2tdID09IFRydWVcbiAgICAgICAgICAgICAgICAgICAgb3IgcGxhY2VbaSAvLyAzICogMyArIGogLy8gM11ba10gPT0gVHJ1ZVxuICAgICAgICAgICAgICAgICk6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgYm9hcmRbaV1bal0gPSBzdHIoayArIDEpXG4gICAgICAgICAgICAgICAgY29sW2pdW2tdID0gVHJ1ZVxuICAgICAgICAgICAgICAgIHJvd1tpXVtrXSA9IFRydWVcbiAgICAgICAgICAgICAgICBwbGFjZVtpIC8vIDMgKiAzICsgaiAvLyAzXVtrXSA9IFRydWVcbiAgICAgICAgICAgICAgICBpZiBkZnMoaSwgaiArIDEpID09IFRydWU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUcnVlXG4gICAgICAgICAgICAgICAgYm9hcmRbaV1bal0gPSBcIi5cIlxuICAgICAgICAgICAgICAgIGNvbFtqXVtrXSA9IEZhbHNlXG4gICAgICAgICAgICAgICAgcm93W2ldW2tdID0gRmFsc2VcbiAgICAgICAgICAgICAgICBwbGFjZVtpIC8vIDMgKiAzICsgaiAvLyAzXVtrXSA9IEZhbHNlXG4gICAgICAgICAgICByZXR1cm4gRmFsc2VcblxuICAgICAgICBkZnMoMCwgMClcblxuIgogICAgfV0KICB9XQp9LCB7CiAgImlkIjogIjE3IiwKICAibmFtZSI6ICLnrKzljYHkuIPnq6AiLAogICJsaXN0IjogW3sKICAgICJ0aXRsZSI6ICLku6PnoIExNy4xLjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDx2ZWN0b3I+XG51c2luZyBuYW1lc3BhY2Ugc3RkO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIHZlY3RvcjxpbnQ+IG1ham9yaXR5RWxlbWVudCh2ZWN0b3I8aW50PiYgbnVtcykge1xuICAgIGludCBuID0gbnVtcy5zaXplKCk7XG4gICAgdmVjdG9yPGludD4gcmVzO1xuICAgIGludCBjbnQxID0gMCwgY250MiA9IDAsIG4xLCBuMjtcbiAgICBib29sIG4xX2luaXQgPSBmYWxzZSwgbjJfaW5pdCA9IGZhbHNlO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtcy5zaXplKCk7IGkrKykge1xuICAgICAgaWYgKCFuMV9pbml0KSB7XG4gICAgICAgIG4xID0gbnVtc1tpXTtcbiAgICAgICAgbjFfaW5pdCA9IHRydWU7XG4gICAgICAgIGNudDEgKz0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bXNbaV0gPT0gbjEpIGNudDEgKz0gMTtcbiAgICAgIGVsc2UgaWYgKCFuMl9pbml0KSB7XG4gICAgICAgIG4yID0gbnVtc1tpXTtcbiAgICAgICAgbjJfaW5pdCA9IHRydWU7XG4gICAgICAgIGNudDIgKz0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bXNbaV0gPT0gbjIpIGNudDIgKz0gMTtcbiAgICAgIGVsc2UgaWYgKGNudDEgPT0gMCkge1xuICAgICAgICBuMSA9IG51bXNbaV07XG4gICAgICAgIGNudDEgKz0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNudDIgPT0gMCkge1xuICAgICAgICBuMiA9IG51bXNbaV07XG4gICAgICAgIGNudDIgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNudDEgLT0gMTtcbiAgICAgICAgY250MiAtPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBjbnQxID0gMDtcbiAgICBjbnQyID0gMDtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG51bXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgIGlmIChudW1zW2ldID09IG4xKSBjbnQxICs9IDE7XG4gICAgICBpZiAobnVtc1tpXSA9PSBuMikgY250MiArPSAxO1xuICAgIH1cbiAgICBpZiAoY250MSA+IG4gLyAzKSByZXMucHVzaF9iYWNrKG4xKTtcbiAgICBpZiAoY250MiA+IG4gLyAzKSByZXMucHVzaF9iYWNrKG4yKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiaW1wb3J0IGphdmEudXRpbC4qO1xuXG5wdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICBwdWJsaWMgTGlzdDxJbnRlZ2VyPiBtYWphb3JpdHlFbGVtZW50KGludFtdIG51bXMpIHtcbiAgICBpbnQgbiA9IG51bXMubGVuZ3RoO1xuICAgIExpc3Q8SW50ZWdlcj4gcmVzID0gbmV3IEFycmF5TGlzdDw+KCk7XG4gICAgaW50IGNudDEgPSAwLCBjbnQyID0gMCwgbjEsIG4yO1xuICAgIGJvb2xlYW4gbjFfaW5pdCA9IGZhbHNlLCBuMl9pbml0ID0gZmFsc2U7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW4xX2luaXQpIHtcbiAgICAgICAgbjEgPSBudW1zW2ldO1xuICAgICAgICBuMV9pbml0ID0gdHJ1ZTtcbiAgICAgICAgY250MSArPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtc1tpXSA9PSBuMSkgY250MSArPSAxO1xuICAgICAgZWxzZSBpZiAoIW4yX2luaXQpIHtcbiAgICAgICAgbjIgPSBudW1zW2ldO1xuICAgICAgICBuMl9pbml0ID0gdHJ1ZTtcbiAgICAgICAgY250MiArPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtc1tpXSA9PSBuMikgY250MiArPSAxO1xuICAgICAgZWxzZSBpZiAoY250MSA9PSAwKSB7XG4gICAgICAgIG4xID0gbnVtc1tpXTtcbiAgICAgICAgY250MSArPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY250MiA9PSAwKSB7XG4gICAgICAgIG4yID0gbnVtc1tpXTtcbiAgICAgICAgY250MiArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY250MSAtPSAxO1xuICAgICAgICBjbnQyIC09IDE7XG4gICAgICB9XG4gICAgfVxuICAgIGNudDEgPSAwO1xuICAgIGNudDIgPSAwO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG51bXNbaV0gPT0gbjEpIGNudDEgKz0gMTtcbiAgICAgIGlmIChudW1zW2ldID09IG4yKSBjbnQyICs9IDE7XG4gICAgfVxuICAgIGlmIChjbnQxID4gbiAvIDMpIHJlcy5hZGQobjEpO1xuICAgIGlmIChjbnQyID4gbiAvIDMpIHJlcy5hZGQobjIpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgbWFqb3JpdHlFbGVtZW50KHNlbGYsIG51bXM6IExpc3RbaW50XSkgLT4gTGlzdFtpbnRdOlxuICAgICAgICBuID0gbGVuKG51bXMpXG4gICAgICAgIHJlcyA9IFtdXG4gICAgICAgIGNudDEgPSAwXG4gICAgICAgIGNudDIgPSAwXG4gICAgICAgIG4xID0gTm9uZVxuICAgICAgICBuMiA9IE5vbmVcblxuICAgICAgICAjIOetm+mAieWHuueOsOasoeaVsOacgOWkmueahOWJjeS4pOS4qlxuICAgICAgICBmb3IgbnVtIGluIG51bXM6XG4gICAgICAgICAgICBpZiBudW0gPT0gbjE6XG4gICAgICAgICAgICAgICAgY250MSArPSAxXG4gICAgICAgICAgICBlbGlmIG51bSA9PSBuMjpcbiAgICAgICAgICAgICAgICBjbnQyICs9IDFcbiAgICAgICAgICAgIGVsaWYgY250MSA9PSAwOlxuICAgICAgICAgICAgICAgIG4xID0gbnVtXG4gICAgICAgICAgICAgICAgY250MSArPSAxXG4gICAgICAgICAgICBlbGlmIGNudDIgPT0gMDpcbiAgICAgICAgICAgICAgICBuMiA9IG51bVxuICAgICAgICAgICAgICAgIGNudDIgKz0gMVxuICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICBjbnQxIC09IDFcbiAgICAgICAgICAgICAgICBjbnQyIC09IDFcbiAgICAgICAgIyDnrZvpgInlh7rnjrDmrKHmlbDotoXov4fkuInliIbkuYvkuIDnmoRcbiAgICAgICAgIyDov5nph4znmoRjbnQx5ZKMY250MueahOWQq+S5ieW3sue7j+WPmOS6hlxuICAgICAgICAjIOi/memHjOeahGNudDHlkoxjbnQy6KGo56S655qE5piv5Ye6546w5qyh5pWw77yMIOiAjOS4iumdoueahOWImeS4jeaYr1xuICAgICAgICBjbnQxID0gMFxuICAgICAgICBjbnQyID0gMFxuICAgICAgICBmb3IgbnVtIGluIG51bXM6XG4gICAgICAgICAgICBpZiBudW0gPT0gbjE6XG4gICAgICAgICAgICAgICAgY250MSArPSAxXG4gICAgICAgICAgICBpZiBudW0gPT0gbjI6XG4gICAgICAgICAgICAgICAgY250MiArPSAxXG4gICAgICAgIGlmIGNudDEgPiBuIC8vIDM6XG4gICAgICAgICAgICByZXMuYXBwZW5kKG4xKVxuICAgICAgICBpZiBjbnQyID4gbiAvLyAzOlxuICAgICAgICAgICAgcmVzLmFwcGVuZChuMilcbiAgICAgICAgcmV0dXJuIHJlc1xuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExNy4yLjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDx2ZWN0b3I+XG4jaW5jbHVkZSA8YWxnb3JpdGhtPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICBpbnQgbGFyZ2VzdFJlY3RhbmdsZUFyZWEodmVjdG9yPGludD4mIGhlaWdodHMpIHtcbiAgICBpbnQgbiA9IGhlaWdodHMuc2l6ZSgpLCBhbnMgPSAwO1xuICAgIGlmIChuICE9IDApIGFucyA9IGhlaWdodHNbMF07XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGludCBoZWlnaHQgPSBoZWlnaHRzW2ldO1xuICAgICAgZm9yIChpbnQgaiA9IGk7IGogPCBuOyBqKyspIHtcbiAgICAgICAgaGVpZ2h0ID0gbWluKGhlaWdodCwgaGVpZ2h0c1tqXSk7XG4gICAgICAgIGFucyA9IG1heChhbnMsIChqIC0gaSArIDEpICogaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFucztcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBqYXZhLnV0aWwuKjtcbmltcG9ydCBqYXZhLmxhbmcuTWF0aDtcblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGludCBsYXJnZXN0UmVjdGFuZ2xlQXJlYShpbnRbXSBoZWlnaHRzKSB7XG4gICAgaW50IG4gPSBoZWlnaHRzLmxlbmd0aCwgYW5zID0gMDtcbiAgICBpZiAobiAhPSAwKSBhbnMgPSBoZWlnaHRzWzBdO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBpbnQgaGVpZ2h0ID0gaGVpZ2h0c1tpXTtcbiAgICAgIGZvciAoaW50IGogPSBpOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGhlaWdodCA9IE1hdGgubWluKGhlaWdodCwgaGVpZ2h0c1tqXSk7XG4gICAgICAgIGFucyA9IE1hdGgubWF4KGFucywgKGogLSBpICsgMSkgKiBoZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYW5zO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBsYXJnZXN0UmVjdGFuZ2xlQXJlYShzZWxmLCBoZWlnaHRzOiBMaXN0W2ludF0pIC0+IGludDpcbiAgICAgICAgbiwgYW5zID0gbGVuKGhlaWdodHMpLCAwXG4gICAgICAgIGlmIG4gIT0gMDpcbiAgICAgICAgICAgIGFucyA9IGhlaWdodHNbMF1cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2Uobik6XG4gICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHRzW2ldXG4gICAgICAgICAgICBmb3IgaiBpbiByYW5nZShpLCBuKTpcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBtaW4oaGVpZ2h0LCBoZWlnaHRzW2pdKVxuICAgICAgICAgICAgICAgIGFucyA9IG1heChhbnMsIChqIC0gaSArIDEpICogaGVpZ2h0KVxuICAgICAgICByZXR1cm4gYW5zXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE3LjIuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI2luY2x1ZGUgPHZlY3Rvcj5cbiNpbmNsdWRlIDxhbGdvcml0aG0+XG51c2luZyBuYW1lc3BhY2Ugc3RkO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIGludCBsYXJnZXN0UmVjdGFuZ2xlQXJlYSh2ZWN0b3I8aW50PiYgaGVpZ2h0cykge1xuICAgIGludCBuID0gaGVpZ2h0cy5zaXplKCksIGFucyA9IDA7XG4gICAgdmVjdG9yPGludD4gbCwgcjtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgbC5wdXNoX2JhY2soLTEpO1xuICAgICAgci5wdXNoX2JhY2sobik7XG4gICAgfVxuICAgIGZvciAoaW50IGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICBpbnQgaiA9IGkgLSAxO1xuICAgICAgd2hpbGUgKGogPj0gMCAmJiBoZWlnaHRzW2pdID49IGhlaWdodHNbaV0pXG4gICAgICAgIGogLT0gMTtcbiAgICAgIGxbaV0gPSBqO1xuICAgIH1cbiAgICBmb3IgKGludCBpID0gbiAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpbnQgaiA9IGkgKyAxO1xuICAgICAgd2hpbGUgKGogPCBuICYmIGhlaWdodHNbal0gPj0gaGVpZ2h0c1tpXSlcbiAgICAgICAgaiArPSAxO1xuICAgICAgcltpXSA9IGo7XG4gICAgfVxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKVxuICAgICAgYW5zID0gbWF4KGFucywgaGVpZ2h0c1tpXSAqIChyW2ldIC0gbFtpXSAtIDEpKTtcbiAgICByZXR1cm4gYW5zO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiaW1wb3J0IGphdmEudXRpbC4qO1xuaW1wb3J0IGphdmEubGFuZy5NYXRoO1xuXG5wdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICBwdWJsaWMgaW50IGxhcmdlc3RSZWN0YW5nbGVBcmVhKGludFtdIGhlaWdodHMpIHtcbiAgICBpbnQgbiA9IGhlaWdodHMubGVuZ3RoLCBhbnMgPSAwO1xuICAgIExpc3Q8SW50ZWdlcj4gbCA9IG5ldyBBcnJheUxpc3Q8PigpLFxuICAgICAgciA9IG5ldyBBcnJheUxpc3Q8PigpO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsLmFkZCgtMSk7XG4gICAgICByLmFkZChuKTtcbiAgICB9XG4gICAgZm9yIChpbnQgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgIGludCBqID0gaSAtIDE7XG4gICAgICB3aGlsZSAoaiA+IDAgJiYgaGVpZ2h0c1tqXSA+PSBoZWlnaHRzW2ldKVxuICAgICAgICBqIC09IDE7XG4gICAgICBsLnNldChpLCBqKTtcbiAgICB9XG4gICAgZm9yIChpbnQgaSA9IG4gLSAyOyBpID49IDA7IGktLSkge1xuICAgICAgaW50IGogPSBpICsgMTtcbiAgICAgIHdoaWxlIChqIDwgbiAmJiBoZWlnaHRzW2pdID49IGhlaWdodHNbaV0pXG4gICAgICAgIGogKz0gMTtcbiAgICAgIHIuc2V0KGksIGopO1xuICAgIH1cbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG47IGkrKylcbiAgICAgIGFucyA9IE1hdGgubWF4KGFucywgaGVpZ2h0c1tpXSAqIChyLmdldChpKSAtIGwuZ2V0KGkpIC0gMSkpO1xuICAgIHJldHVybiBhbnM7XG4gIH1cbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgbGFyZ2VzdFJlY3RhbmdsZUFyZWEoc2VsZiwgaGVpZ2h0czogTGlzdFtpbnRdKSAtPiBpbnQ6XG4gICAgICAgIG4gPSBsZW4oaGVpZ2h0cylcbiAgICAgICAgbCwgciwgYW5zID0gWy0xXSAqIG4sIFtuXSAqIG4sIDBcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMSwgbik6XG4gICAgICAgICAgICBqID0gaSAtIDFcbiAgICAgICAgICAgIHdoaWxlIGogPj0gMCBhbmQgaGVpZ2h0c1tqXSA+PSBoZWlnaHRzW2ldOlxuICAgICAgICAgICAgICAgIGogLT0gMVxuICAgICAgICAgICAgbFtpXSA9IGpcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UobiAtIDIsIC0xLCAtMSk6XG4gICAgICAgICAgICBqID0gaSArIDFcbiAgICAgICAgICAgIHdoaWxlIGogPCBuIGFuZCBoZWlnaHRzW2pdID49IGhlaWdodHNbaV06XG4gICAgICAgICAgICAgICAgaiArPSAxXG4gICAgICAgICAgICByW2ldID0galxuICAgICAgICBmb3IgaSBpbiByYW5nZShuKTpcbiAgICAgICAgICAgIGFucyA9IG1heChhbnMsIGhlaWdodHNbaV0gKiAocltpXSAtIGxbaV0gLSAxKSlcbiAgICAgICAgcmV0dXJuIGFuc1xuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExNy4yLjMiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDx2ZWN0b3I+XG4jaW5jbHVkZSA8YWxnb3JpdGhtPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICBpbnQgbGFyZ2VzdFJlY3RhbmdsZUFyZWEodmVjdG9yPGludD4mIGhlaWdodHMpIHtcbiAgICBpbnQgbiA9IGhlaWdodHMuc2l6ZSgpLCBhbnMgPSAwO1xuICAgIHZlY3RvcjxpbnQ+IGwsIHI7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGwucHVzaF9iYWNrKC0xKTtcbiAgICAgIHIucHVzaF9iYWNrKG4pO1xuICAgIH1cbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgaW50IGogPSBpIC0gMTtcbiAgICAgIHdoaWxlIChqID49IDAgJiYgaGVpZ2h0c1tqXSA+PSBoZWlnaHRzW2ldKVxuICAgICAgICBqID0gbFtqXTtcbiAgICAgIGxbaV0gPSBqO1xuICAgIH1cbiAgICBmb3IgKGludCBpID0gbiAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpbnQgaiA9IGkgKyAxO1xuICAgICAgd2hpbGUgKGogPCBuICYmIGhlaWdodHNbal0gPj0gaGVpZ2h0c1tpXSlcbiAgICAgICAgaiA9IHJbal07XG4gICAgICByW2ldID0gajtcbiAgICB9XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuOyBpKyspXG4gICAgICBhbnMgPSBtYXgoYW5zLCBoZWlnaHRzW2ldICogKHJbaV0gLSBsW2ldIC0gMSkpO1xuICAgIHJldHVybiBhbnM7XG4gIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJpbXBvcnQgamF2YS51dGlsLio7XG5pbXBvcnQgamF2YS5sYW5nLk1hdGg7XG5cbnB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBpbnQgbGFyZ2V0c3RSZWN0YW5nbGVBcmVhKGludFtdIGhlaWdodHMpIHtcbiAgICBpbnQgbiA9IGhlaWdodHMubGVuZ3RoLCBhbnMgPSAwO1xuICAgIExpc3Q8SW50ZWdlcj4gbCA9IG5ldyBBcnJheUxpc3Q8PigpLFxuICAgICAgciA9IG5ldyBBcnJheUxpc3Q8PigpO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsLmFkZCgtMSk7XG4gICAgICByLmFkZChuKTtcbiAgICB9XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGludCBqID0gaSAtIDE7XG4gICAgICB3aGlsZSAoaiA+PSAwICYmIGhlaWdodHNbal0gPj0gaGVpZ2h0c1tpXSlcbiAgICAgICAgaiA9IGwuZ2V0KGopO1xuICAgICAgbC5zZXQoaSwgaik7XG4gICAgfVxuICAgIGZvciAoaW50IGkgPSBuIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGludCBqID0gaSArIDE7XG4gICAgICB3aGlsZSAoaiA8IG4gJiYgaGVpZ2h0c1tqXSA+PSBoZWlnaHRzW2ldKVxuICAgICAgICBqID0gci5nZXQoaik7XG4gICAgICByLnNldChpLCBqKTtcbiAgICB9XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuOyBpKyspXG4gICAgICBhbnMgPSBNYXRoLm1heChhbnMsIGhlaWdodHNbaV0gKiAoci5nZXQoaSkgLSBsLmdldChpKSAtIDEpKTtcbiAgICByZXR1cm4gYW5zO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGxhcmdlc3RSZWN0YW5nbGVBcmVhKHNlbGYsIGhlaWdodHM6IExpc3RbaW50XSkgLT4gaW50OlxuICAgICAgICBuID0gbGVuKGhlaWdodHMpXG4gICAgICAgIGwsIHIsIGFucyA9IFstMV0gKiBuLCBbbl0gKiBuLCAwXG5cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMSwgbik6XG4gICAgICAgICAgICBqID0gaSAtIDFcbiAgICAgICAgICAgIHdoaWxlIGogPj0gMCBhbmQgaGVpZ2h0c1tqXSA+PSBoZWlnaHRzW2ldOlxuICAgICAgICAgICAgICAgIGogPSBsW2pdXG4gICAgICAgICAgICBsW2ldID0galxuICAgICAgICBmb3IgaSBpbiByYW5nZShuIC0gMiwgLTEsIC0xKTpcbiAgICAgICAgICAgIGogPSBpICsgMVxuICAgICAgICAgICAgd2hpbGUgaiA8IG4gYW5kIGhlaWdodHNbal0gPj0gaGVpZ2h0c1tpXTpcbiAgICAgICAgICAgICAgICBqID0gcltqXVxuICAgICAgICAgICAgcltpXSA9IGpcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2Uobik6XG4gICAgICAgICAgICBhbnMgPSBtYXgoYW5zLCBoZWlnaHRzW2ldICogKHJbaV0gLSBsW2ldIC0gMSkpXG4gICAgICAgIHJldHVybiBhbnNcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTcuMi40IiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8dmVjdG9yPlxuI2luY2x1ZGUgPGFsZ29yaXRobT5cbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgaW50IGxhcmdlc3RSZWN0YW5nbGVBcmVhKHZlY3RvcjxpbnQ+JiBoZWlnaHRzKSB7XG4gICAgaW50IG4gPSBoZWlnaHRzLnNpemUoKSwgYW5zID0gMDtcbiAgICB2ZWN0b3I8aW50PiBzdDtcbiAgICBoZWlnaHRzLnB1c2hfYmFjaygwKTtcbiAgICBmb3IgKGludCBpID0gaGVpZ2h0cy5zaXplKCk7IGkgPiAwOyBpLS0pXG4gICAgICBzd2FwKGhlaWdodHNbaV0sIGhlaWdodHNbaSAtIDFdKTtcbiAgICBoZWlnaHRzLnB1c2hfYmFjaygwKTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG4gKyAyOyBpKyspIHtcbiAgICAgIHdoaWxlIChzdC5zaXplKCkgJiYgaGVpZ2h0c1tzdC5iYWNrKCldID4gaGVpZ2h0c1tpXSkge1xuICAgICAgICBpbnQgYnVmID0gc3QuYmFjaygpO1xuICAgICAgICBzdC5wb3BfYmFjaygpO1xuICAgICAgICBhbnMgPSBtYXgoYW5zLCBoZWlnaHRzW2J1Zl0gKiAoaSAtIHN0LmJhY2soKSAtIDEpKTtcbiAgICAgIH1cbiAgICAgIHN0LnB1c2hfYmFjayhpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFucztcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBqYXZhLnV0aWwuKjtcbmltcG9ydCBqYXZhLmxhbmcuTWF0aDtcblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGludCBsYXJnZXN0UmVjdGFuZ2xlQXJlYShMaXN0PEludGVnZXI+IGhlaWdodHMpIHtcbiAgICBpbnQgbiA9IGhlaWdodHMuc2l6ZSgpLCBhbnMgPSAwO1xuICAgIExpc3Q8SW50ZWdlcj4gc3QgPSBuZXcgQXJyYXlMaXN0PD4oKTtcbiAgICBoZWlnaHRzLmFkZCgwKTtcbiAgICBmb3IgKGludCBpID0gaGVpZ2h0cy5zaXplKCk7IGkgPiAwOyBpLS0pIHtcbiAgICAgIGludCB0bXAgPSBoZWlnaHRzLmdldChpKTtcbiAgICAgIGhlaWdodHMuc2V0KGksIGhlaWdodHMuZ2V0KGkgLSAxKSk7XG4gICAgICBoZWlnaHRzLnNldChpIC0gMSwgdG1wKTtcbiAgICB9XG4gICAgaGVpZ2h0cy5hZGQoMCk7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuICsgMjsgaSArKykge1xuICAgICAgd2hpbGUgKHN0LnNpemUoKSAhPSAwICYmXG4gICAgICAgICAgIGhlaWdodHMuZ2V0KHN0LmdldChzdC5zaXplKCkgLSAxKSkgPiBoZWlnaHRzLmdldChpKSkge1xuICAgICAgICBpbnQgYnVmID0gc3QuZ2V0KHN0LnNpemUoKSAtIDEpO1xuICAgICAgICBzdC5yZW1vdmUoc3Quc2l6ZSgpIC0gMSk7XG4gICAgICAgIGFucyA9IE1hdGgubWF4KGFucywgaGVpZ2h0cy5nZXQoYnVmKSAqIChpXG4gICAgICAgICAgICAgIC0gc3QuZ2V0KHN0LnNpemUoKSAtIDEpIC0gMSkpO1xuICAgICAgfVxuICAgICAgc3QuYWRkKGkpO1xuICAgIH1cbiAgICByZXR1cm4gYW5zO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGxhcmdlc3RSZWN0YW5nbGVBcmVhKHNlbGYsIGhlaWdodHM6IExpc3RbaW50XSkgLT4gaW50OlxuICAgICAgICBuLCBoZWlnaHRzLCBzdCwgYW5zID0gbGVuKGhlaWdodHMpLCBbMF0gKyBoZWlnaHRzICsgWzBdLCBbXSwgMFxuICAgICAgICBmb3IgaSBpbiByYW5nZShuICsgMik6XG4gICAgICAgICAgICB3aGlsZSBzdCBhbmQgaGVpZ2h0c1tzdFstMV1dID4gaGVpZ2h0c1tpXTpcbiAgICAgICAgICAgICAgICBhbnMgPSBtYXgoYW5zLCBoZWlnaHRzW3N0LnBvcCgtMSldICogKGkgLSBzdFstMV0gLSAxKSlcbiAgICAgICAgICAgIHN0LmFwcGVuZChpKVxuICAgICAgICByZXR1cm4gYW5zXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE3LjMuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI2luY2x1ZGUgPHN0cmluZz5cbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgc3RyaW5nIGRheU9mVGhlV2VlayhpbnQgZGF5LCBpbnQgbW9udGgsIGludCB5ZWFyKSB7XG4gICAgaW50IG1vbnRoc1tdID0gezMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSxcbiAgICAgICAgICAgICAgICAgICAgMzAsIDMxLCAzMCwgMzF9O1xuICAgIGludCBsZWFwX21vbnRoc1tdID0gezMxLCAyOSwgMzEsIDMwLCAzMSwgMzAsIDMxLFxuICAgICAgICAgICAgICAgICAgICAgICAgMzEsIDMwLCAzMSwgMzAsIDMxfTtcbiAgICBzdHJpbmcgZGF5c1tdID0ge1wiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIiwgXCJTdW5kYXlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIn07XG4gICAgaW50IHllYXJzID0geWVhciAtIDE5NzEsIGxlYXBzID0gMCwgaSA9IDE5NzI7XG4gICAgd2hpbGUgKGkgPCB5ZWFyKSB7XG4gICAgICBpZiAoaSAlIDQwMCA9PSAwIHx8IChpICUgNCA9PSAwICYmIGkgJSAxMDApKVxuICAgICAgICBsZWFwcyArPSAxO1xuICAgICAgaSArPSAxO1xuICAgIH1cbiAgICBpbnQgZGlmZiA9ICh5ZWFycyAqIDM2NSkgKyBsZWFwcztcbiAgICBmb3IgKGludCBtID0gMDsgbSA8IG1vbnRoIC0gMTsgbSsrKSB7XG4gICAgICBpZiAoaSAlIDQwMCA9PSAwIHx8IChpICUgNCA9PSAwICYmIGkgJSAxMDApKVxuICAgICAgICBkaWZmICs9IGxlYXBfbW9udGhzW21dO1xuICAgICAgZWxzZVxuICAgICAgICBkaWZmICs9IG1vbnRoc1ttXTtcbiAgICB9XG4gICAgZGlmZiArPSBkYXkgLSAxO1xuICAgIHJldHVybiBkYXlzW2RpZmYgJSA3XTtcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBqYXZhLnV0aWwuKjtcblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIFN0cmluZyBkYXlPZlRoZVdlZWsoaW50IGRheSwgaW50IG1vbnRoLCBpbnQgeWVhcikge1xuICAgIGludFtdIG1vbnRocyA9IHszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsXG4gICAgMzAsIDMxLCAzMCwgMzF9O1xuICAgIGludFtdIGxlYXBfbW9udGhzID0gezMxLCAyOSwgMzEsIDMwLCAzMSwgMzAsIDMxLFxuICAgIDMxLCAzMCwgMzEsIDMwLCAzMX07XG4gICAgU3RyaW5nW10gZGF5cyA9IHtcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCIsIFwiU3VuZGF5XCIsXG4gICAgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIn07XG4gICAgaW50IHllYXJzID0geWVhciAtIDE5NzEsIGxlYXBzID0gMCwgaSA9IDE5NzI7XG4gICAgd2hpbGUgKGkgPCB5ZWFyKSB7XG4gICAgICBpZiAoaSAlIDQwMCA9PSAwIHx8IChpICUgNCA9PSAwICYmIGkgJSAxMDAgIT0gMCkpXG4gICAgICAgIGxlYXBzICs9IDE7XG4gICAgICBpICs9IDE7XG4gICAgfVxuICAgIGludCBkaWZmID0gKHllYXJzICogMzY1KSArIGxlYXBzO1xuICAgIGZvciAoaW50IG0gPSAwOyBtIDwgbW9udGggLSAxOyBtKyspIHtcbiAgICAgIGlmIChpICUgNDAwID09IDAgfHwgKGkgJSA0ID09IDAgJiYgaSAlIDEwMCAhPSAwKSlcbiAgICAgICAgZGlmZiArPSBsZWFwX21vbnRoc1ttXTtcbiAgICAgIGVsc2VcbiAgICAgICAgZGlmZiArPSBtb250aHNbbV07XG4gICAgfVxuICAgIGRpZmYgKz0gZGF5IC0gMTtcbiAgICByZXR1cm4gZGF5c1tkaWZmICUgN107XG4gIH1cbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgZGF5T2ZUaGVXZWVrKHNlbGYsIGRheTogaW50LCBtb250aDogaW50LCB5ZWFyOiBpbnQpIC0+IHN0cjpcbiAgICAgICAgbW9udGhzID0gWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdXG4gICAgICAgIGxlYXBfbW9udGhzID0gWzMxLCAyOSwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdXG4gICAgICAgICMgMTk3MS0wMS0wMSDkvZzkuLrln7rlh4bml6XmnJ9cbiAgICAgICAgIyAxOTcxLTAxLTAxIOaYr+WRqOS6lFxuICAgICAgICBkYXlzID0gW1xuICAgICAgICAgICAgXCJGcmlkYXlcIixcbiAgICAgICAgICAgIFwiU2F0dXJkYXlcIixcbiAgICAgICAgICAgIFwiU3VuZGF5XCIsXG4gICAgICAgICAgICBcIk1vbmRheVwiLFxuICAgICAgICAgICAgXCJUdWVzZGF5XCIsXG4gICAgICAgICAgICBcIldlZG5lc2RheVwiLFxuICAgICAgICAgICAgXCJUaHVyc2RheVwiLFxuICAgICAgICBdXG4gICAgICAgIHllYXJzID0geWVhciAtIDE5NzFcbiAgICAgICAgbGVhcHMgPSAwXG4gICAgICAgIGkgPSAxOTcyXG4gICAgICAgICMg5aSE55CG5bm0XG4gICAgICAgIHdoaWxlIGkgPCB5ZWFyOlxuICAgICAgICAgICAgaWYgaSAlIDQwMCA9PSAwIG9yIChpICUgNCA9PSAwIGFuZCBpICUgMTAwICE9IDApOlxuICAgICAgICAgICAgICAgIGxlYXBzICs9IDFcbiAgICAgICAgICAgIGkgKz0gMVxuICAgICAgICBkaWZmID0gKHllYXJzICogMzY1KSArIGxlYXBzXG4gICAgICAgICMg5aSE55CG5pyIXG4gICAgICAgIGZvciBtIGluIHJhbmdlKG1vbnRoIC0gMSk6XG4gICAgICAgICAgICBpZiBpICUgNDAwID09IDAgb3IgKGkgJSA0ID09IDAgYW5kIGkgJSAxMDAgIT0gMCk6XG4gICAgICAgICAgICAgICAgZGlmZiArPSBsZWFwX21vbnRoc1ttXVxuICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICBkaWZmICs9IG1vbnRoc1ttXVxuICAgICAgICAjIOWkhOeQhuaXpVxuICAgICAgICBkaWZmICs9IGRheSAtIDFcbiAgICAgICAgcmV0dXJuIGRheXNbZGlmZiAlIDddXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE3LjMuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI2luY2x1ZGUgPHN0cmluZz5cbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgc3RyaW5nIGRheU9mVGhlV2VlayhpbnQgZGF5LCBpbnQgbW9udGgsIGludCB5ZWFyKSB7XG4gICAgc3RyaW5nIGxpc3Rfb2ZfZGF5c1tdID0ge1xuICAgICAgXCJTYXR1cmRheVwiLCBcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIixcbiAgICAgIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIlxuICAgIH07XG4gICAgaWYgKG1vbnRoID09IDEgfHwgbW9udGggPT0gMikge1xuICAgICAgeWVhciAtPSAxO1xuICAgICAgbW9udGggKz0gMTI7XG4gICAgfVxuICAgIGludCB5ID0geWVhciAlIDEwMCwgYyA9IHllYXIgLyAxMDA7XG4gICAgaW50IHdlZWtkYXkgPSAoZGF5ICsgMTMgKiAobW9udGggKyAxKSAvIDUgKyB5ICsgXFxcbiAgICAgICAgICAgICAgICAgIHkgLyA0ICsgYyAvIDQgKyA1ICogYykgJSA3O1xuICAgIHJldHVybiBsaXN0X29mX2RheXNbd2Vla2RheV07XG4gIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJpbXBvcnQgamF2YS51dGlsLio7XG5cbnB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBTdHJpbmcgZGF5T2ZUaGVXZWVrKGludCBkYXksIGludCBtb250aCwgaW50IHllYXIpIHtcbiAgICBTdHJpbmdbXSBsaXN0X29mX2RheXMgPSB7XG4gICAgICBcIlNhdHVyZGF5XCIsIFwiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLFxuICAgICAgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiXG4gICAgfTtcbiAgICBpZiAobW9udGggPT0gMSB8fCBtb250aCA9PSAyKSB7XG4gICAgICB5ZWFyIC09IDE7XG4gICAgICBtb250aCArPSAxMjtcbiAgICB9XG4gICAgaW50IHkgPSB5ZWFyICUgMTAwLCBjID0geWVhciAvIDEwMDtcbiAgICBpbnQgd2Vla2RheSA9IChkYXkgKyAxMyAqIChtb250aCArIDEpIC8gNSArIHlcbiAgICAgICAgKyB5IC8gNCArIGMgLyA0ICsgNSAqIGMpICUgNztcbiAgICByZXR1cm4gbGlzdF9vZl9kYXlzW3dlZWtkYXldO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGRheU9mVGhlV2VlayhzZWxmLCBkYXk6IGludCwgbW9udGg6IGludCwgeWVhcjogaW50KSAtPiBzdHI6XG4gICAgICAgIGxpc3Rfb2ZfZGF5cyA9IFtcbiAgICAgICAgICAgIFwiU2F0dXJkYXlcIixcbiAgICAgICAgICAgIFwiU3VuZGF5XCIsXG4gICAgICAgICAgICBcIk1vbmRheVwiLFxuICAgICAgICAgICAgXCJUdWVzZGF5XCIsXG4gICAgICAgICAgICBcIldlZG5lc2RheVwiLFxuICAgICAgICAgICAgXCJUaHVyc2RheVwiLFxuICAgICAgICAgICAgXCJGcmlkYXlcIixcbiAgICAgICAgXVxuICAgICAgICBpZiBtb250aCA9PSAxIG9yIG1vbnRoID09IDI6XG4gICAgICAgICAgICB5ZWFyID0geWVhciAtIDFcbiAgICAgICAgICAgIG1vbnRoID0gbW9udGggKyAxMlxuICAgICAgICB5ID0geWVhciAlIDEwMFxuICAgICAgICBjID0geWVhciAvLyAxMDBcbiAgICAgICAgd2Vla2RheSA9IGludCgoZGF5ICsgMTMgKiAobW9udGggKyAxKSAvLyA1ICsgeSArIHkgLy8gNCArIGMgLy8gNCArIDUgKiBjKSAlIDcpXG4gICAgICAgIHJlcXVpcmVkX2RheSA9IGxpc3Rfb2ZfZGF5c1t3ZWVrZGF5XVxuICAgICAgICByZXR1cm4gcmVxdWlyZWRfZGF5XG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE3LjQuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI2luY2x1ZGUgPHV0aWxpdHk+XG4jaW5jbHVkZSA8c2V0PlxuI2luY2x1ZGUgPHF1ZXVlPlxuI2luY2x1ZGUgPGFsZ29yaXRobT5cbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgYm9vbCBjYW5NZWFzdXJlV2F0ZXIoaW50IHgsIGludCB5LCBpbnQgeikge1xuICAgIGlmICh4ICsgeSA8IHopIHJldHVybiBmYWxzZTtcbiAgICBxdWV1ZTxwYWlyPGludCwgaW50PiA+IHE7XG4gICAgcS5wdXNoKG1ha2VfcGFpcigwLCAwKSk7XG4gICAgc2V0PHBhaXI8aW50LCBpbnQ+ID4gc2VlbjtcbiAgICBzZWVuLmluc2VydChtYWtlX3BhaXIoMCwgMCkpO1xuICAgIHdoaWxlIChxLnNpemUoKSkge1xuICAgICAgcGFpcjxpbnQsIGludD4gYnVmID0gcS5mcm9udCgpO1xuICAgICAgcS5wb3AoKTtcbiAgICAgIGludCBhID0gYnVmLmZpcnN0LCBiID0gYnVmLnNlY29uZDtcbiAgICAgIGlmIChhID09IHogfHwgYiA9PSB6IHx8IGEgKyBiID09IHopIHJldHVybiB0cnVlO1xuICAgICAgc2V0PHBhaXI8aW50LCBpbnQ+ID4gc3RhdGVzO1xuICAgICAgc3RhdGVzLmluc2VydChtYWtlX3BhaXIoeCwgYikpO1xuICAgICAgc3RhdGVzLmluc2VydChtYWtlX3BhaXIoYSwgeSkpO1xuICAgICAgc3RhdGVzLmluc2VydChtYWtlX3BhaXIoMCwgYikpO1xuICAgICAgc3RhdGVzLmluc2VydChtYWtlX3BhaXIoYSwgMCkpO1xuICAgICAgaW50IHZhbCA9ICgoYiA8IHggLSBhKSA/IDAgOiAoYiAtICh4IC0gYSkpKTtcbiAgICAgIHN0YXRlcy5pbnNlcnQobWFrZV9wYWlyKG1pbih4LCBiICsgYSksIHZhbCkpO1xuICAgICAgdmFsID0gKChhICsgYiA8IHkpID8gMCA6IChhIC0gKHkgLSBiKSkpO1xuICAgICAgc3RhdGVzLmluc2VydChtYWtlX3BhaXIodmFsLCBtaW4oYiArIGEsIHkpKSk7XG4gICAgICBmb3IgKHNldDxwYWlyPGludCwgaW50PiA+OjppdGVyYXRvciBpdCA9IFxcXG4gICAgICAgICAgc3RhdGVzLmJlZ2luKCk7IGl0ICE9IHN0YXRlcy5lbmQoKTsgaXQrKykge1xuICAgICAgICBpZiAoc2Vlbi5jb3VudCgqaXQpKSBjb250aW51ZTtcbiAgICAgICAgcS5wdXNoKCppdCk7XG4gICAgICAgIHNlZW4uaW5zZXJ0KCppdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBqYXZhLnV0aWwuKjtcbmltcG9ydCBqYXZhLmxhbmcuTWF0aDtcblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGNsYXNzIFBhaXIge1xuICAgIHB1YmxpYyBmaW5hbCBpbnQgZmlyc3Q7XG4gICAgcHVibGljIGZpbmFsIGludCBzZWNvbmQ7XG4gICAgcHVibGljIFBhaXIoaW50IHgsIGludCB5KSB7XG4gICAgICB0aGlzLmZpcnN0ID0geDtcbiAgICAgIHRoaXMuc2Vjb25kID0geTtcbiAgICB9XG4gIH1cbiAgcHVibGljIFBhaXIgbWFrZV9wYWlyKGludCB4LCBpbnQgeSkge1xuICAgIFBhaXIgYnVmID0gbmV3IFBhaXIoeCwgeSk7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuICBwdWJsaWMgYm9vbGVhbiBjYW5NZWFzdXJlV2F0ZXIoaW50IHgsIGludCB5LCBpbnQgeikge1xuICAgIGlmICh4ICsgeSA8IHopIHJldHVybiBmYWxzZTtcbiAgICBRdWV1ZTxQYWlyPiBxID0gbmV3IExpbmtlZExpc3Q8UGFpcj4oKTtcbiAgICBxLm9mZmVyKG1ha2VfcGFpcigwLCAwKSk7XG4gICAgU2V0PFBhaXI+IHNlZW4gPSBuZXcgSGFzaFNldDxQYWlyPigpO1xuICAgIHNlZW4uYWRkKG1ha2VfcGFpcigwLCAwKSk7XG4gICAgd2hpbGUgKHEuc2l6ZSgpICE9IDApIHtcbiAgICAgIFBhaXIgYnVmID0gcS5wb2xsKCk7XG4gICAgICBpbnQgYSA9IGJ1Zi5maXJzdCwgYiA9IGJ1Zi5zZWNvbmQ7XG4gICAgICBpZiAoYSA9PSB6IHx8IGIgPT0geiB8fCBhICsgYiA9PSB6KSByZXR1cm4gdHJ1ZTtcbiAgICAgIFNldDxQYWlyPiBzdGF0ZXMgPSBuZXcgSGFzaFNldDxQYWlyPigpO1xuICAgICAgc3RhdGVzLmFkZChtYWtlX3BhaXIoeCwgYikpO1xuICAgICAgc3RhdGVzLmFkZChtYWtlX3BhaXIoYSwgeSkpO1xuICAgICAgc3RhdGVzLmFkZChtYWtlX3BhaXIoMCwgYikpO1xuICAgICAgc3RhdGVzLmFkZChtYWtlX3BhaXIoYSwgMCkpO1xuICAgICAgaW50IHZhbCA9ICgoYiA8IHggLSBhKSA/IDAgOiAoYiAtICh4IC0gYSkpKTtcbiAgICAgIHN0YXRlcy5hZGQobWFrZV9wYWlyKE1hdGgubWluKHgsIGIgKyBhKSwgdmFsKSk7XG4gICAgICB2YWwgPSAoKGEgKyBiIDwgeSkgPyAwIDogKGEgLSAoeSAtIGIpKSk7XG4gICAgICBzdGF0ZXMuYWRkKG1ha2VfcGFpcih2YWwsIE1hdGgubWluKGIgKyBhLCB5KSkpO1xuICAgICAgSXRlcmF0b3I8UGFpcj4gaXQgPSBzdGF0ZXMuaXRlcmF0b3IoKTtcbiAgICAgIHdoaWxlIChpdC5oYXNOZXh0KCkpIHtcbiAgICAgICAgUGFpciBub2RlID0gaXQubmV4dCgpO1xuICAgICAgICBpZiAoc2Vlbi5jb250YWlucyhub2RlKSkgY29udGludWU7XG4gICAgICAgIHEub2ZmZXIobm9kZSk7XG4gICAgICAgIHNlZW4uYWRkKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgY2FuTWVhc3VyZVdhdGVyKHNlbGYsIHg6IGludCwgeTogaW50LCB6OiBpbnQpIC0+IGJvb2w6XG4gICAgICAgIGlmIHggKyB5IDwgejpcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxuICAgICAgICBxdWV1ZSA9IFsoMCwgMCldXG4gICAgICAgIHNlZW4gPSBzZXQoKDAsIDApKVxuXG4gICAgICAgIHdoaWxlIGxlbihxdWV1ZSkgPiAwOlxuICAgICAgICAgICAgYSwgYiA9IHF1ZXVlLnBvcCgwKVxuICAgICAgICAgICAgaWYgYSA9PSB6IG9yIGIgPT0geiBvciBhICsgYiA9PSB6OlxuICAgICAgICAgICAgICAgIHJldHVybiBUcnVlXG4gICAgICAgICAgICBzdGF0ZXMgPSBzZXQoKVxuXG4gICAgICAgICAgICBzdGF0ZXMuYWRkKCh4LCBiKSlcbiAgICAgICAgICAgIHN0YXRlcy5hZGQoKGEsIHkpKVxuICAgICAgICAgICAgc3RhdGVzLmFkZCgoMCwgYikpXG4gICAgICAgICAgICBzdGF0ZXMuYWRkKChhLCAwKSlcbiAgICAgICAgICAgIHN0YXRlcy5hZGQoKG1pbih4LCBiICsgYSksIDAgaWYgYiA8IHggLSBhIGVsc2UgYiAtICh4IC0gYSkpKVxuICAgICAgICAgICAgc3RhdGVzLmFkZCgoMCBpZiBhICsgYiA8IHkgZWxzZSBhIC0gKHkgLSBiKSwgbWluKGIgKyBhLCB5KSkpXG4gICAgICAgICAgICBmb3Igc3RhdGUgaW4gc3RhdGVzOlxuICAgICAgICAgICAgICAgIGlmIHN0YXRlIGluIHNlZW46XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgcXVldWUuYXBwZW5kKHN0YXRlKVxuICAgICAgICAgICAgICAgIHNlZW4uYWRkKHN0YXRlKVxuICAgICAgICByZXR1cm4gRmFsc2VcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTcuNC4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8YWxnb3JpdGhtPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICBpbnQgZ2NkKGludCBhLCBpbnQgYikge1xuICAgIGludCBzbWFsbGVyID0gbWluKGEsIGIpO1xuICAgIHdoaWxlIChzbWFsbGVyKSB7XG4gICAgICBpZiAoYSAlIHNtYWxsZXIgPT0gMCAmJiBiICUgc21hbGxlciA9PSAwKVxuICAgICAgICByZXR1cm4gc21hbGxlcjtcbiAgICAgIHNtYWxsZXIgLT0gMTtcbiAgICB9XG4gIH1cbiAgYm9vbCBjYW5NZWFzdXJlV2F0ZXIoaW50IHgsIGludCB5LCBpbnQgeikge1xuICAgIGlmICh4ICsgeSA8IHopIHJldHVybiBmYWxzZTtcbiAgICBpZiAoeiA9PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoeCA9PSAwKSByZXR1cm4geSA9PSB6O1xuICAgIGlmICh5ID09IDApIHJldHVybiB4ID09IHo7XG4gICAgcmV0dXJuIHogJSBnY2QoeCwgeSkgPT0gMDtcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBqYXZhLmxhbmcuTWF0aDtcblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGludCBnY2QoaW50IGEsIGludCBiKSB7XG4gICAgaW50IHNtYWxsZXIgPSBNYXRoLm1pbihhLCBiKTtcbiAgICB3aGlsZSAoc21hbGxlciAhPSAwKSB7XG4gICAgICBpZiAoYSAlIHNtYWxsZXIgPT0gMCAmJiBiICUgc21hbGxlciA9PSAwKVxuICAgICAgICByZXR1cm4gc21hbGxlcjtcbiAgICAgIHNtYWxsZXIgLT0gMTtcbiAgICB9XG4gIH1cbiAgYm9vbGVhbiBjYW5NZWFzdXJlV2F0ZXIoaW50IHgsIGludCB5LCBpbnQgeikge1xuICAgIGlmICh4ICsgeSA8IHopIHJldHVybiBmYWxzZTtcbiAgICBpZiAoeiA9PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoeCA9PSAwKSByZXR1cm4geSA9PSB6O1xuICAgIGlmICh5ID09IDApIHJldHVybiB4ID09IHo7XG4gICAgcmV0dXJuIHogJSBnY2QoeCwgeSkgPT0gMDtcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBjYW5NZWFzdXJlV2F0ZXIoc2VsZiwgeDogaW50LCB5OiBpbnQsIHo6IGludCkgLT4gYm9vbDpcbiAgICAgICAgaWYgeCArIHkgPCB6OlxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXG5cbiAgICAgICAgaWYgeiA9PSAwOlxuICAgICAgICAgICAgcmV0dXJuIFRydWVcblxuICAgICAgICBpZiB4ID09IDA6XG4gICAgICAgICAgICByZXR1cm4geSA9PSB6XG5cbiAgICAgICAgaWYgeSA9PSAwOlxuICAgICAgICAgICAgcmV0dXJuIHggPT0gelxuXG4gICAgICAgIGRlZiBHQ0QoYTogaW50LCBiOiBpbnQpIC0+IGludDpcbiAgICAgICAgICAgIHNtYWxsZXIgPSBtaW4oYSwgYilcbiAgICAgICAgICAgIHdoaWxlIHNtYWxsZXI6XG4gICAgICAgICAgICAgICAgaWYgYSAlIHNtYWxsZXIgPT0gMCBhbmQgYiAlIHNtYWxsZXIgPT0gMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNtYWxsZXJcbiAgICAgICAgICAgICAgICBzbWFsbGVyIC09IDFcblxuICAgICAgICByZXR1cm4geiAlIEdDRCh4LCB5KSA9PSAwXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE3LjQuMyIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiaW50IGdjZChpbnQgYSwgaW50IGIpIHtcbiAgcmV0dXJuIChiID09IDApID8gYSA6IGdjZChiLCBhICUgYik7XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJwdWJsaWMgY2xhc3MgR2NkIHtcbiAgcHVibGljIGludCBnY2QoaW50IGEsIGludCBiKSB7XG4gICAgcmV0dXJuIChiID09IDApID8gYSA6IGdjZChiLCBhICUgYik7XG4gIH1cbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJkZWYgR0NEKGE6IGludCwgYjogaW50KSAtPiBpbnQ6XG4gICAgcmV0dXJuIGEgaWYgYiA9PSAwIGVsc2UgR0NEKGIsIGEgJSBiKVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExNy40LjQiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImludCBnY2QoaW50IGEsIGludCBiKSB7XG4gIGlmIChhID09IGIpIHJldHVybiBhO1xuICBpZiAoYSA8IGIpXG4gICAgcmV0dXJuIGdjZChiIC0gYSwgYSk7XG4gIHJldHVybiBnY2QoYSAtIGIsIGIpO1xufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicHVibGljIGNsYXNzIEdjZCB7XG4gIHB1YmxpYyBpbnQgZ2NkKGludCBhLCBpbnQgYikge1xuICAgIGlmIChhID09IGIpIHJldHVybiBhO1xuICAgIGlmIChhIDwgYilcbiAgICAgIHJldHVybiBnY2QoYiAtIGEsIGEpO1xuICAgIHJldHVybiBnY2QoYSAtIGIsIGIpO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZGVmIEdDRChhOiBpbnQsIGI6IGludCkgLT4gaW50OlxuICAgIGlmIGEgPT0gYjpcbiAgICAgICAgcmV0dXJuIGFcbiAgICBpZiBhIDwgYjpcbiAgICAgICAgcmV0dXJuIEdDRChiIC0gYSwgYSlcbiAgICByZXR1cm4gR0NEKGEgLSBiLCBiKVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExNy41LjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDxjc3RkbGliPlxuI2luY2x1ZGUgPGNtYXRoPlxuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIGludCBwb29yUGlncyhpbnQgYnVja2V0cywgaW50IG1pbnV0ZXNUb0RpZSxcbiAgICAgIGludCBtaW51dGVzVG9UZXN0KSB7XG4gICAgaW50IGNudCA9IDA7XG4gICAgd2hpbGUgKHBvdyhtaW51dGVzVG9UZXN0IC8gbWludXRlc1RvRGllICsgMSwgY250KSA8XFxcbiAgICAgICAgYnVja2V0cylcbiAgICAgIGNudCArPSAxO1xuICAgIHJldHVybiBjbnQ7XG4gIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJpbXBvcnQgamF2YS5sYW5nLk1hdGg7XG5cbnB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBpbnQgcG9vclBpZ3MoaW50IGJ1Y2tldHMsIGludCBtaW51dGVzVG9EaWUsXG4gICAgICBpbnQgbWludXRlc1RvVGVzdCkge1xuICAgIGludCBjbnQgPSAwO1xuICAgIHdoaWxlIChNYXRoLnBvdyhtaW51dGVzVG9UZXN0IC8gbWludXRlc1RvRGllICsgMSwgY250KVxuICAgICAgICA8IGJ1Y2tldHMpXG4gICAgICBjbnQgKz0gMTtcbiAgICByZXR1cm4gY250O1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHBvb3JQaWdzKHNlbGYsIGJ1Y2tldHM6IGludCwgbWludXRlc1RvRGllOiBpbnQsIG1pbnV0ZXNUb1Rlc3Q6IGludCkgLT4gaW50OlxuICAgICAgICBjbnQgPSAwXG4gICAgICAgIHdoaWxlIChtaW51dGVzVG9UZXN0IC8gbWludXRlc1RvRGllICsgMSkgKiogY250IDwgYnVja2V0czpcbiAgICAgICAgICAgIGNudCArPSAxXG4gICAgICAgIHJldHVybiBjbnRcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTcuNS4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8Y21hdGg+XG4jaW5jbHVkZSA8Y3N0ZGxpYj5cblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICBpbnQgcG9vclBpZ3MoaW50IGJ1Y2tldHMsIGludCBtaW51dGVzVG9EaWUsXG4gICAgICBpbnQgbWludXRlc1RvVGVzdCkge1xuICAgIHJldHVybiBjZWlsKGxvZyhidWNrZXRzKSAvIGxvZyhtaW51dGVzVG9UZXN0IC9cXFxuICAgICAgICAgIG1pbnV0ZXNUb0RpZSArIDEpKTtcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBqYXZhLmxhbmcuTWF0aDtcblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGludCBwb29yUGlncyhpbnQgYnVja2V0cywgaW50IG1pbnV0ZXNUb0RpZSxcbiAgICAgIGludCBtaW51dGVzVG9UZXN0KSB7XG4gICAgcmV0dXJuIChpbnQpTWF0aC5jZWlsKE1hdGgubG9nKGJ1Y2tldHMpIC8gTWF0aC5sb2coXG4gICAgICAgICAgbWludXRlc1RvVGVzdCAvIG1pbnV0ZXNUb0RpZSArIDFcbiAgICAgICAgICApKTtcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBtYXRoXG5cblxuY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHBvb3JQaWdzKHNlbGYsIGJ1Y2tldHM6IGludCwgbWludXRlc1RvRGllOiBpbnQsIG1pbnV0ZXNUb1Rlc3Q6IGludCkgLT4gaW50OlxuICAgICAgICByZXR1cm4gbWF0aC5jZWlsKG1hdGgubG9nKGJ1Y2tldHMsIG1pbnV0ZXNUb1Rlc3QgLyBtaW51dGVzVG9EaWUgKyAxKSlcblxuIgogICAgfV0KICB9XQp9LCB7CiAgImlkIjogIjE4IiwKICAibmFtZSI6ICLnrKzljYHlhavnq6AiLAogICJsaXN0IjogW3sKICAgICJ0aXRsZSI6ICLku6PnoIExOC4xLjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImludCBicyh2ZWN0b3I8aW50PiYgbnVtcywgaW50IHRhcmdldCkge1xyXG4gICAgaW50IG4gPSBudW1zLnNpemUoKTtcclxuICAgIGludCBsID0gMCwgaCA9IG4gLSAxO1xyXG4gICAgd2hpbGUgKGwgPD0gaCkge1xyXG4gICAgICAgIGludCBtaWQgPSBsICsgKGggLSBsKSAvIDI7XHJcbiAgICAgICAgaWYgKG51bXNbbWlkXSA9PSB0YXJnZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1pZDtcclxuICAgICAgICB9IGVsc2UgaWYgKG51bXNbbWlkXSA8IHRhcmdldCkge1xyXG4gICAgICAgICAgICBsID0gbWlkICsgMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBoID0gbWlkIC0gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJwdWJsaWMgaW50IGJzKGludFtdIG51bXMsIGludCB0YXJnZXQpIHtcclxuXHRpbnQgbiA9IG51bXMubGVuZ3RoO1xyXG5cdGludCBsID0gMCwgaCA9IG4gLSAxO1xyXG5cdHdoaWxlIChsIDw9IGgpIHtcclxuXHRcdGludCBtaWQgPSBsICsgKGggLSBsKSAvIDI7XHJcblx0XHRpZiAobnVtc1ttaWRdID09IHRhcmdldCkge1xyXG5cdFx0XHRyZXR1cm4gbWlkO1xyXG5cdFx0fSBlbHNlIGlmIChudW1zW21pZF0gPCB0YXJnZXQpIHtcclxuXHRcdFx0bCA9IG1pZCArIDE7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoID0gbWlkIC0gMTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIC0xO1xyXG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogIiMg5p+l5om+IG51bXMg5pWw57uE5Lit5YWD57Sg5YC85Li6IHRhcmdldCDnmoTkuIvmoIfvvIzlpoLmnpzkuI3lrZjlnKjliJnov5Tlm54gLTFcbmRlZiBicyhudW1zOiBbXSwgdGFyZ2V0OiBpbnQpIC0+IGludDpcbiAgICBuID0gbGVuKG51bXMpXG4gICAgbCwgaCA9IDAsIG4gLSAxXG4gICAgd2hpbGUgbCA8PSBoOlxuICAgICAgICBtaWQgPSBsICsgKGggLSBsKSAvLyAyXG4gICAgICAgIGlmIG51bXNbbWlkXSA9PSB0YXJnZXQ6XG4gICAgICAgICAgICByZXR1cm4gbWlkXG4gICAgICAgIGVsaWYgbnVtc1ttaWRdIDwgdGFyZ2V0OlxuICAgICAgICAgICAgbCA9IG1pZCArIDFcbiAgICAgICAgZWxzZTpcbiAgICAgICAgICAgIGggPSBtaWQgLSAxXG4gICAgcmV0dXJuIC0xXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE4LjEuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI+afpeaJvuesrOS4gOS4quWkp+S6juetieS6jiB4IOeahOWFg+e0oFxyXG5pbnQgYnModmVjdG9yPGludD4mIG51bXMsIGludCB4KSB7XHJcbiAgICBpbnQgbCA9IDAsIGggPSBudW1zLnNpemUoKSAtIDE7XHJcbiAgICB3aGlsZSAobCA8PSBoKSB7XHJcbiAgICAgICAgaW50IG1pZCA9IGwgKyAoaCAtIGwpIC8gMjtcclxuICAgICAgICBpZiAobCA9PSBoKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobnVtc1ttaWRdID49IHgpIHtcclxuICAgICAgICAgICAgaCA9IG1pZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsID0gbWlkICsgMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVtc1tsXTtcclxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogIiMg5p+l5om+56ys5LiA5Liq5aSn5LqO562J5LqOIHgg55qE5YWD57SgXHJcbnB1YmxpYyBpbnQgYnMoaW50W10gbnVtcywgaW50IHgpIHtcclxuXHRpbnQgbCA9IDAsIGggPSBudW1zLmxlbmd0aCAtIDE7XHJcblx0d2hpbGUgKGwgPD0gaCkge1xyXG5cdFx0aW50IG1pZCA9IGwgKyAoaCAtIGwpIC8gMjtcclxuXHRcdGlmIChsID09IGgpIHtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHR9IGVsc2UgaWYgKG51bXNbbWlkXSA+PSB4KSB7XHJcblx0XHRcdGggPSBtaWQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsID0gbWlkICsgMTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG51bXNbbF07XHJcbn1cclxuXHJcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICIjIOafpeaJvuesrOS4gOS4quWkp+S6juetieS6jiB4IOeahOWFg+e0oFxuZGVmIGJzKG51bXM6IExpc3RbaW50XSwgeDogaW50KSAtPiBpbnQ6XG4gICAgbCwgaCA9IDAsIGxlbihudW1zKSAtIDFcbiAgICB3aGlsZSBsIDw9IGg6XG4gICAgICAgIG1pZCA9IGwgKyAoaCAtIGwpIC8vIDJcbiAgICAgICAgaWYgbCA9PSBoOlxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgZWxpZiBudW1zW21pZF0gPj0geDpcbiAgICAgICAgICAgIGggPSBtaWRcbiAgICAgICAgZWxzZTpcbiAgICAgICAgICAgIGwgPSBtaWQgKyAxXG4gICAgcmV0dXJuIG51bXNbbF1cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTguMS4zIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIj5p+l5om+5pyA5ZCO5LiA5Liq5bCP5LqO562J5LqOIHgg55qE5YWD57SgXHJcbmludCBicyh2ZWN0b3I8aW50PiYgbnVtcywgaW50IHgpIHtcclxuICAgIGludCBsID0gMCwgaCA9IG51bXMuc2l6ZSgpIC0gMTtcclxuICAgIHdoaWxlIChsIDw9IGgpIHtcclxuICAgICAgICBpbnQgbWlkID0gbCArIChoIC0gbCkgLyAyO1xyXG4gICAgICAgIGlmIChsID09IGggfHwgbCArIDEgPT0gaCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2UgaWYgKG51bXNbbWlkXSA8PSB4KSB7XHJcbiAgICAgICAgICAgIGwgPSBtaWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaCA9IG1pZCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG51bXNbaF0gPD0geCkge1xyXG4gICAgICAgIHJldHVybiBudW1zW2hdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVtc1tsXTtcclxuICAgIH1cclxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogIiMg5p+l5om+5pyA5ZCO5LiA5Liq5bCP5LqO562J5LqOIHgg55qE5YWD57SgXHJcbnB1YmxpYyBpbnQgYnMoaW50W10gbnVtcywgaW50IHgpIHtcclxuICAgIGludCBsID0gMCwgaCA9IG51bXMubGVuZ3RoIC0gMTtcclxuICAgIHdoaWxlIChsIDw9IGgpIHtcclxuICAgICAgICBpbnQgbWlkID0gbCArIChoIC0gbCkgLyAyO1xyXG4gICAgICAgIGlmIChsID09IGggfHwgbCArIDEgPT0gaCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2UgaWYgKG51bXNbbWlkXSA8PSB4KSB7XHJcbiAgICAgICAgICAgIGwgPSBtaWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaCA9IG1pZCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG51bXNbaF0gPD0geCkge1xyXG4gICAgICAgIHJldHVybiBudW1zW2hdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVtc1tsXTtcclxuICAgIH1cclxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICIjIOafpeaJvuacgOWQjuS4gOS4quWwj+S6juetieS6jiB4IOeahOWFg+e0oFxuZGVmIGJzKG51bXM6IExpc3RbaW50XSwgeDogaW50KSAtPiBpbnQ6XG4gICAgbCwgaCA9IDAsIGxlbihudW1zKSAtIDFcbiAgICB3aGlsZSBsIDw9IGg6XG4gICAgICAgIG1pZCA9IGwgKyAoaCAtIGwpIC8vIDJcbiAgICAgICAgaWYgbCA9PSBoIG9yIGwgKyAxID09IGg6XG4gICAgICAgICAgICBicmVha1xuICAgICAgICBlbGlmIG51bXNbbWlkXSA8PSB4OlxuICAgICAgICAgICAgbCA9IG1pZFxuICAgICAgICBlbHNlOlxuICAgICAgICAgICAgaCA9IG1pZCAtIDFcbiAgICBpZiBudW1zW2hdIDw9IHg6XG4gICAgICAgIHJldHVybiBudW1zW2hdXG4gICAgZWxzZTpcbiAgICAgICAgcmV0dXJuIG51bXNbbF1cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTguMy4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBVbmlvbkZpbmQge1xyXG5wdWJsaWM6XHJcbiAgICAvLyDmr4/kuKroioLngrnnmoTniLboioLngrlcclxuICAgIGludCogcGFyZW50O1xyXG4gICAgLy8g5Lul6K+l6IqC54K55Li65qC555qE5qCR5p2D5YC877yI5qCR6auY5bqm77yJXHJcbiAgICBpbnQqIHJhbms7XHJcbiAgICAvLyDov57pgJrljLrln5/mlbDph49cclxuICAgIGludCBjbnQ7XHJcblxyXG4gICAgVW5pb25GaW5kKGludCBuKSB7XHJcbiAgICAgICAgcGFyZW50ID0gbmV3IGludFtuXTtcclxuICAgICAgICByYW5rID0gbmV3IGludFtuXTtcclxuICAgICAgICBjbnQgPSBuO1xyXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhcmVudFtpXSA9IGk7XHJcbiAgICAgICAgICAgIHJhbmtbaV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpbnQgZmluZChpbnQgcCkge1xyXG4gICAgICAgIHdoaWxlIChwICE9IHBhcmVudFtwXSkge1xyXG4gICAgICAgICAgICBwID0gcGFyZW50W3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuXHJcbiAgICB2b2lkIG1lcmdlKGludCBwLCBpbnQgcSkge1xyXG4gICAgICAgIGludCByb290X3AgPSBmaW5kKHApLCByb290X3EgPSBmaW5kKHEpO1xyXG4gICAgICAgIGlmIChyb290X3AgPT0gcm9vdF9xKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhbmtbcm9vdF9wXSA+IHJhbmtbcm9vdF9xXSkge1xyXG4gICAgICAgICAgICBwYXJlbnRbcm9vdF9xXSA9IHJvb3RfcDtcclxuICAgICAgICB9IGVsc2UgaWYgKHJhbmtbcm9vdF9wXSA8IHJhbmtbcm9vdF9xXSkge1xyXG4gICAgICAgICAgICBwYXJlbnRbcm9vdF9wXSA9IHJvb3RfcTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJlbnRbcm9vdF9wXSA9IHJvb3RfcTtcclxuICAgICAgICAgICAgcmFua1tyb290X3FdICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNudCAtPSAxO1xyXG4gICAgfVxyXG59O1xuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFVuaW9uRmluZCB7XHJcbiAgICAvLyDmr4/kuKroioLngrnnmoTniLboioLngrlcclxuICAgIGludFtdIHBhcmVudDtcclxuICAgIC8vIOS7peivpeiKgueCueS4uuagueeahOagkeadg+WAvO+8iOagkemrmOW6pu+8iVxyXG4gICAgaW50W10gcmFuaztcclxuICAgIC8vIOi/numAmuWMuuWfn+aVsOmHj1xyXG4gICAgaW50IGNudDtcclxuICAgIFxyXG4gICAgcHVibGljIFVuaW9uRmluZChpbnQgbikge1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gbmV3IGludFtuXTtcclxuICAgICAgICB0aGlzLnJhbmsgPSBuZXcgaW50W25dO1xyXG4gICAgICAgIHRoaXMuY250ID0gbjtcclxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudFtpXSA9IGk7XHJcbiAgICAgICAgICAgIHRoaXMucmFua1tpXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpbnQgZmluZChpbnQgcCkge1xyXG4gICAgICAgIHdoaWxlIChwICE9IHRoaXMucGFyZW50W3BdKSB7XHJcbiAgICAgICAgICAgIHAgPSB0aGlzLnBhcmVudFtwXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHZvaWQgdW5pb24oaW50IHAsIGludCBxKSB7XHJcbiAgICAgICAgaW50IHJvb3RfcCA9IHRoaXMuZmluZChwKSwgcm9vdF9xID0gdGhpcy5maW5kKHEpO1xyXG4gICAgICAgIGlmIChyb290X3AgPT0gcm9vdF9xKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucmFua1tyb290X3BdID4gdGhpcy5yYW5rW3Jvb3RfcV0pIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnRbcm9vdF9xXSA9IHJvb3RfcDtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmFua1tyb290X3BdIDwgdGhpcy5yYW5rW3Jvb3RfcV0pIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnRbcm9vdF9wXSA9IHJvb3RfcTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudFtyb290X3BdID0gcm9vdF9xO1xyXG4gICAgICAgICAgICB0aGlzLnJhbmtbcm9vdF9xXSArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNudCAtPSAxO1xyXG4gICAgfVxyXG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFVuaW9uRmluZDpcbiAgICBkZWYgX19pbml0X18oc2VsZiwgbjogaW50KTpcbiAgICAgICAgIyDmr4/kuKroioLngrnnmoTniLboioLngrlcbiAgICAgICAgc2VsZi5wYXJlbnQgPSBbaSBmb3IgaSBpbiByYW5nZShuKV1cbiAgICAgICAgIyDku6Xor6XoioLngrnkuLrmoLnnmoTmoJHmnYPlgLzvvIjmoJHpq5jluqbvvIlcbiAgICAgICAgc2VsZi5yYW5rID0gWzAgZm9yIGkgaW4gcmFuZ2UobildXG4gICAgICAgICMg6L+e6YCa5Yy65Z+f5pWw6YePXG4gICAgICAgIHNlbGYuY250ID0gblxuXG4gICAgZGVmIGZpbmQoc2VsZiwgcDogaW50KSAtPiBpbnQ6XG4gICAgICAgIHdoaWxlIHAgIT0gc2VsZi5wYXJlbnRbcF06XG4gICAgICAgICAgICBwID0gc2VsZi5wYXJlbnRbcF1cbiAgICAgICAgcmV0dXJuIHBcblxuICAgIGRlZiB1bmlvbihzZWxmLCBwOiBpbnQsIHE6IGludCk6XG4gICAgICAgIHJvb3RfcCwgcm9vdF9xID0gc2VsZi5maW5kKHApLCBzZWxmLmZpbmQocSlcbiAgICAgICAgaWYgcm9vdF9wID09IHJvb3RfcTpcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICBpZiBzZWxmLnJhbmtbcm9vdF9wXSA+IHNlbGYucmFua1tyb290X3FdOlxuICAgICAgICAgICAgc2VsZi5wYXJlbnRbcm9vdF9xXSA9IHJvb3RfcFxuICAgICAgICBlbGlmIHNlbGYucmFua1tyb290X3BdIDwgc2VsZi5yYW5rW3Jvb3RfcV06XG4gICAgICAgICAgICBzZWxmLnBhcmVudFtyb290X3BdID0gcm9vdF9xXG4gICAgICAgIGVsc2U6XG4gICAgICAgICAgICBzZWxmLnBhcmVudFtyb290X3FdID0gcm9vdF9wXG4gICAgICAgICAgICBzZWxmLnJhbmtbcm9vdF9wXSArPSAxXG4gICAgICAgIHNlbGYuY250IC09IDFcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTguMy4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBVbmlvbkZpbmQge1xucHVibGljOlxuICAgIC8vIOavj+S4quiKgueCueeahOeItuiKgueCuVxuICAgIGludCogcGFyZW50O1xuICAgIC8vIOS7peivpeiKgueCueS4uuagueeahOagkeadg+WAvO+8iOagkemrmOW6pu+8iVxuICAgIGludCogcmFuaztcbiAgICAvLyDov57pgJrljLrln5/mlbDph49cbiAgICBpbnQgY250O1xuXG4gICAgVW5pb25GaW5kKGludCBuKSB7XG4gICAgICAgIHBhcmVudCA9IG5ldyBpbnRbbl07XG4gICAgICAgIHJhbmsgPSBuZXcgaW50W25dO1xuICAgICAgICBjbnQgPSBuO1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcGFyZW50W2ldID0gaTtcbiAgICAgICAgICAgIHJhbmtbaV0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW50IGZpbmQoaW50IHApIHtcbiAgICAgICAgaWYgKHAgIT0gcGFyZW50W3BdKSB7XG4gICAgICAgICAgICBwYXJlbnRbcF0gPSBmaW5kKHBhcmVudFtwXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudFtwXTtcbiAgICB9XG5cbiAgICB2b2lkIG1lcmdlKGludCBwLCBpbnQgcSkge1xuICAgICAgICBpbnQgcm9vdF9wID0gZmluZChwKSwgcm9vdF9xID0gZmluZChxKTtcbiAgICAgICAgaWYgKHJvb3RfcCA9PSByb290X3EpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmFua1tyb290X3BdID4gcmFua1tyb290X3FdKSB7XG4gICAgICAgICAgICBwYXJlbnRbcm9vdF9xXSA9IHJvb3RfcDtcbiAgICAgICAgfSBlbHNlIGlmIChyYW5rW3Jvb3RfcF0gPCByYW5rW3Jvb3RfcV0pIHtcbiAgICAgICAgICAgIHBhcmVudFtyb290X3BdID0gcm9vdF9xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50W3Jvb3RfcF0gPSByb290X3E7XG4gICAgICAgICAgICByYW5rW3Jvb3RfcV0gKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBjbnQgLT0gMTtcbiAgICB9XG59O1xuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFVuaW9uRmluZCB7XHJcbiAgICAvLyDmr4/kuKroioLngrnnmoTniLboioLngrlcclxuICAgIGludFtdIHBhcmVudDtcclxuICAgIC8vIOS7peivpeiKgueCueS4uuagueeahOagkeadg+WAvO+8iOagkemrmOW6pu+8iVxyXG4gICAgaW50W10gcmFuaztcclxuICAgIC8vIOi/numAmuWMuuWfn+aVsOmHj1xyXG4gICAgaW50IGNudDtcclxuICAgIFxyXG4gICAgcHVibGljIFVuaW9uRmluZChpbnQgbikge1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gbmV3IGludFtuXTtcclxuICAgICAgICB0aGlzLnJhbmsgPSBuZXcgaW50W25dO1xyXG4gICAgICAgIHRoaXMuY250ID0gbjtcclxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudFtpXSA9IGk7XHJcbiAgICAgICAgICAgIHRoaXMucmFua1tpXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpbnQgZmluZChpbnQgcCkge1xyXG4gICAgICAgIGlmIChwICE9IHRoaXMucGFyZW50W3BdKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50W3BdID0gdGhpcy5maW5kKHRoaXMucGFyZW50W3BdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50W3BdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2b2lkIHVuaW9uKGludCBwLCBpbnQgcSkge1xyXG4gICAgICAgIGludCByb290X3AgPSB0aGlzLmZpbmQocCksIHJvb3RfcSA9IHRoaXMuZmluZChxKTtcclxuICAgICAgICBpZiAocm9vdF9wID09IHJvb3RfcSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnJhbmtbcm9vdF9wXSA+IHRoaXMucmFua1tyb290X3FdKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50W3Jvb3RfcV0gPSByb290X3A7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJhbmtbcm9vdF9wXSA8IHRoaXMucmFua1tyb290X3FdKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50W3Jvb3RfcF0gPSByb290X3E7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnRbcm9vdF9wXSA9IHJvb3RfcTtcclxuICAgICAgICAgICAgdGhpcy5yYW5rW3Jvb3RfcV0gKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jbnQgLT0gMTtcclxuICAgIH1cclxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBVbmlvbkZpbmQ6XG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIG46IGludCk6XG4gICAgICAgICMg5q+P5Liq6IqC54K555qE54i26IqC54K5XG4gICAgICAgIHNlbGYucGFyZW50ID0gW2kgZm9yIGkgaW4gcmFuZ2UobildXG4gICAgICAgICMg5Lul6K+l6IqC54K55Li65qC555qE5qCR5p2D5YC877yI5qCR6auY5bqm77yJXG4gICAgICAgIHNlbGYucmFuayA9IFswIGZvciBpIGluIHJhbmdlKG4pXVxuICAgICAgICAjIOi/numAmuWMuuWfn+aVsOmHj1xuICAgICAgICBzZWxmLmNudCA9IG5cblxuICAgIGRlZiBmaW5kKHNlbGYsIHA6IGludCkgLT4gaW50OlxuICAgICAgICBpZiBwICE9IHNlbGYucGFyZW50W3BdOlxuICAgICAgICAgICAgc2VsZi5wYXJlbnRbcF0gPSBzZWxmLmZpbmQoc2VsZi5wYXJlbnRbcF0pXG4gICAgICAgIHJldHVybiBzZWxmLnBhcmVudFtwXVxuXG4gICAgZGVmIHVuaW9uKHNlbGYsIHA6IGludCwgcTogaW50KTpcbiAgICAgICAgcm9vdF9wLCByb290X3EgPSBzZWxmLmZpbmQocCksIHNlbGYuZmluZChxKVxuICAgICAgICBpZiByb290X3AgPT0gcm9vdF9xOlxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIGlmIHNlbGYucmFua1tyb290X3BdID4gc2VsZi5yYW5rW3Jvb3RfcV06XG4gICAgICAgICAgICBzZWxmLnBhcmVudFtyb290X3FdID0gcm9vdF9wXG4gICAgICAgIGVsaWYgc2VsZi5yYW5rW3Jvb3RfcF0gPCBzZWxmLnJhbmtbcm9vdF9xXTpcbiAgICAgICAgICAgIHNlbGYucGFyZW50W3Jvb3RfcF0gPSByb290X3FcbiAgICAgICAgZWxzZTpcbiAgICAgICAgICAgIHNlbGYucGFyZW50W3Jvb3RfcV0gPSByb290X3BcbiAgICAgICAgICAgIHNlbGYucmFua1tyb290X3BdICs9IDFcbiAgICAgICAgc2VsZi5jbnQgLT0gMVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExOC40LjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogInZlY3Rvcjx2ZWN0b3I8aW50Pj4gZ3JpZCg1LCB2ZWN0b3I8aW50Pig1LCAwKSk7XG4vLyBuICogbSDlpKflsI/nmoTnn6npmLVcbmludCBuID0gZ3JpZC5zaXplKCksIG0gPSBncmlkWzBdLnNpemUoKTtcbi8vIOaJqeWxleaWueWQkVxuaW50IGRpcmVjdGlvbls0XVsyXSA9IHt7MCwgMX0sIHsxLCAwfSwgey0xLCAwfSwgezAsIC0xfX07XG4vLyDorrDlvZXoioLngrnmmK/lkKbooqvorr/pl65cbmJvb2wgdmlzaXRlZFtuXVttXTtcbmZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgbWVtc2V0KHZpc2l0ZWRbaV0sIGZhbHNlLCBtKTtcbn1cbnF1ZXVlPHBhaXI8aW50LCBpbnQ+PiBxdWU7XG4vLyDmt7HluqZcbmludCBsZXZlbCA9IDA7XG4vLyDliqDlhaXliJ3lp4voioLngrlcbnF1ZS5wdXNoKHBhaXIoMCwgMCkpO1xudmlzaXRlZFswXVswXSA9IHRydWU7XG53aGlsZSAocXVlLnNpemUoKSA+IDApIHtcbiAgICBpbnQgY250ID0gcXVlLnNpemUoKTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IGNudDsgaSsrKSB7XG4gICAgICAgIHBhaXI8aW50LCBpbnQ+IHRvcCA9IHF1ZS5mcm9udCgpO1xuICAgICAgICBxdWUucG9wKCk7XG4gICAgICAgIGludCB4ID0gdG9wLmZpcnN0LCB5ID0gdG9wLnNlY29uZDtcbiAgICAgICAgLy8g5omp5bGV6IqC54K5XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICBpbnQgbmV4dF94ID0geCArIGRpcmVjdGlvbltpXVswXTtcbiAgICAgICAgICAgIGludCBuZXh0X3kgPSB5ICsgZGlyZWN0aW9uW2ldWzFdO1xuICAgICAgICAgICAgLy8g5Yik5pat55u46YK76IqC54K55piv5ZCm5pyJ5pWIXG4gICAgICAgICAgICBpZiAobmV4dF94IDwgMCB8fCBuZXh0X3ggPj0gbiB8fCBuZXh0X3kgPCAwIHx8IG5leHRfeSA+PSBtIHx8IHZpc2l0ZWRbbmV4dF94XVtuZXh0X3ldKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWUucHVzaChwYWlyKG5leHRfeCwgbmV4dF95KSk7XG4gICAgICAgICAgICB2aXNpdGVkW25leHRfeF1bbmV4dF95XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8g5rex5bqm5aKe5YqgXG4gICAgbGV2ZWwgKz0gMTtcbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJpbnRbXVtdIGdyaWQgPSBuZXcgaW50WzVdWzVdO1xuLy8gbiAqIG0g5aSn5bCP55qE55+p6Zi1XG5pbnQgbiA9IGdyaWQubGVuZ3RoLCBtID0gZ3JpZFswXS5sZW5ndGg7XG4vLyDmianlsZXmlrnlkJFcbmludFtdW10gZGlyZWN0aW9uID0gbmV3IGludFtdW117ezAsIDF9LCB7MSwgMH0sIHstMSwgMH0sIHswLCAtMX19O1xuLy8g6K6w5b2V6IqC54K55piv5ZCm6KKr6K6/6ZeuXG5ib29sZWFuW11bXSB2aXNpdGVkID0gbmV3IGJvb2xlYW5bbl1bbV07XG5RdWV1ZTxpbnRbXT4gcXVldWUgPSBuZXcgTGlua2VkTGlzdDw+KCk7XG4vLyDmt7HluqZcbmludCBsZXZlbCA9IDA7XG4vLyDliqDlhaXliJ3lp4voioLngrlcbnF1ZXVlLm9mZmVyKG5ldyBpbnRbXXswLCAwfSk7XG52aXNpdGVkWzBdWzBdID0gdHJ1ZTtcbndoaWxlIChxdWV1ZS5zaXplKCkgPiAwKSB7XG4gICAgaW50IGNudCA9IHF1ZXVlLnNpemUoKTtcbiAgICBTeXN0ZW0ub3V0LnByaW50bG4oXCItLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBjbnQ7IGkrKykge1xuICAgICAgICBpbnRbXSB0b3AgPSBxdWV1ZS5wb2xsKCk7XG4gICAgICAgIGludCB4ID0gdG9wWzBdLCB5ID0gdG9wWzFdO1xuICAgICAgICBTeXN0ZW0ub3V0LnByaW50bG4oeCArIFwiOlwiICsgeSk7XG4gICAgICAgIC8vIOaJqeWxleiKgueCuVxuICAgICAgICBmb3IgKGludFtdIGQgOiBkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGludCBuZXh0X3ggPSB4ICsgZFswXTtcbiAgICAgICAgICAgIGludCBuZXh0X3kgPSB5ICsgZFsxXTtcbiAgICAgICAgICAgIC8vIOWIpOaWreebuOmCu+iKgueCueaYr+WQpuacieaViFxuICAgICAgICAgICAgaWYgKG5leHRfeCA8IDAgfHwgbmV4dF94ID49IG4gfHwgbmV4dF95IDwgMCB8fCBuZXh0X3kgPj0gbSB8fCB2aXNpdGVkW25leHRfeF1bbmV4dF95XSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWUub2ZmZXIobmV3IGludFtde25leHRfeCwgbmV4dF95fSk7XG4gICAgICAgICAgICB2aXNpdGVkW25leHRfeF1bbmV4dF95XSA9IHRydWU7XG4gICAgICAgIH0gXG4gICAgfVxuICAgIC8vIOa3seW6puWinuWKoFxuICAgIGxldmVsICs9IDE7XG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImZyb20gY29sbGVjdGlvbnMgaW1wb3J0IGRlcXVlXG5cbmdyaWQgPSBbWzBdICogNSBmb3IgXyBpbiByYW5nZSg1KV1cbiMgbiAqIG0g5aSn5bCP55qE55+p6Zi1XG5uLCBtID0gbGVuKGdyaWQpLCBsZW4oZ3JpZFswXSlcbiMg5omp5bGV5pa55ZCRXG5kaXJlY3Rpb24gPSBbWzAsIDFdLCBbMCwgLTFdLCBbLTEsIDBdLCBbMSwgMF1dXG4jIOiusOW9leiKgueCueaYr+WQpuiiq+iuv+mXrlxudmlzaXRlZCA9IFtbRmFsc2UgZm9yIF8gaW4gcmFuZ2UobSldIGZvciBfIGluIHJhbmdlKG4pXVxucXVldWUgPSBkZXF1ZSgpXG4jIOa3seW6plxubGV2ZWwgPSAwXG4jIOWKoOWFpeWIneWni+iKgueCuVxucXVldWUuYXBwZW5kKFswLCAwXSlcbnZpc2l0ZWRbMF1bMF0gPSBUcnVlXG53aGlsZSBsZW4ocXVldWUpID4gMDpcbiAgICBzeiA9IGxlbihxdWV1ZSlcbiAgICBmb3IgXyBpbiByYW5nZShzeik6XG4gICAgICAgIHRvcCA9IHF1ZXVlLnBvcGxlZnQoKVxuICAgICAgICB4LCB5ID0gdG9wWzBdLCB0b3BbMV1cbiAgICAgICAgIyDmianlsZXoioLngrlcbiAgICAgICAgZm9yIGQgaW4gZGlyZWN0aW9uOlxuICAgICAgICAgICAgbmV4dF94ID0geCArIGRbMF1cbiAgICAgICAgICAgIG5leHRfeSA9IHkgKyBkWzFdXG4gICAgICAgICAgICAjIOWIpOaWreebuOmCu+iKgueCueaYr+WQpuacieaViFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG5leHRfeCA8IDBcbiAgICAgICAgICAgICAgICBvciBuZXh0X3ggPj0gblxuICAgICAgICAgICAgICAgIG9yIG5leHRfeSA8IDBcbiAgICAgICAgICAgICAgICBvciBuZXh0X3kgPj0gbVxuICAgICAgICAgICAgICAgIG9yIHZpc2l0ZWRbbmV4dF94XVtuZXh0X3ldXG4gICAgICAgICAgICApOlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICBxdWV1ZS5hcHBlbmQoW25leHRfeCwgbmV4dF95XSlcbiAgICAgICAgICAgIHZpc2l0ZWRbbmV4dF94XVtuZXh0X3ldID0gVHJ1ZVxuICAgICMg5rex5bqm5aKe5YqgXG4gICAgbGV2ZWwgKz0gMVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExOC42LjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogImJvb2wgaXNQcmltZShpbnQgbikge1xyXG4gICAgaWYgKG4gPD0gMSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGludCBpID0gMjtcclxuICAgIHdoaWxlIChpICogaSA8PSBuKSB7XHJcbiAgICAgICAgaWYgKG4gJSBpID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpICs9IDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogInB1YmxpYyBib29sZWFuIGlzUHJpbWUoaW50IG4pIHtcbiAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW50IGkgPSAyO1xuICAgIHdoaWxlIChpICogaSA8PSBuKSB7XG4gICAgICAgIGlmIChuICUgaSA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaSArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZGVmIGlzUHJpbWUobjogaW50KSAtPiBib29sZWFuOlxuICAgIGlmIG4gPD0gMTpcbiAgICAgICAgcmV0dXJuIEZhbHNlXG4gICAgaSA9IDJcbiAgICB3aGlsZSBpICogaSA8PSBuOlxuICAgICAgICBpZiBuICUgaSA9PSAwOlxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXG4gICAgICAgIGkgKz0gMVxuICAgIHJldHVybiBUcnVlXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE4LjYuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiaW50IGNvdW50UHJpbWVzKGludCBuKSB7XHJcbiAgICBpZiAobiA8PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICB2ZWN0b3I8Ym9vbD4gdG1wKG4sIHRydWUpO1xyXG4gICAgaW50IGFucyA9IDA7XHJcbiAgICB0bXBbMF0gPSBmYWxzZTtcclxuICAgIHRtcFsxXSA9IGZhbHNlO1xyXG4gICAgZm9yIChpbnQgaSA9IDI7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBpZiAoIXRtcFtpXSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5p+l5om+IGkg5YCN5pWw55qE5LyY5YyW57uG6IqC77yaaSAqIGnlvIDlp4tcclxuICAgICAgICBmb3IgKGludCBqID0gaSAqIGk7IGogPCBuOyBqICs9IGkpIHtcclxuICAgICAgICAgICAgdG1wW2pdID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBpZiAodG1wW2ldKSB7XHJcbiAgICAgICAgICAgIGFucyArPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhbnM7XHJcbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJwdWJsaWMgaW50IGNvdW50UHJpbWVzKGludCBuKSB7XHJcbiAgICBpZiAobiA8PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBib29sZWFuW10gdG1wID0gbmV3IGJvb2xlYW5bbl07XHJcbiAgICBBcnJheXMuZmlsbCh0bXAsIHRydWUpO1xyXG4gICAgaW50IGFucyA9IDA7XHJcbiAgICB0bXBbMF0gPSBmYWxzZTtcclxuICAgIHRtcFsxXSA9IGZhbHNlO1xyXG4gICAgZm9yIChpbnQgaSA9IDI7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBpZiAoIXRtcFtpXSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5p+l5om+IGkg5YCN5pWw55qE5LyY5YyW57uG6IqC77yaaSAqIGnlvIDlp4tcclxuICAgICAgICBmb3IgKGludCBqID0gaSAqIGk7IGogPCBuOyBqICs9IGkpIHtcclxuICAgICAgICAgICAgdG1wW2pdID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBpZiAodG1wW2ldKSB7XHJcbiAgICAgICAgICAgIGFucyArPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhbnM7XHJcbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGNvdW50UHJpbWVzKHNlbGYsIG46IGludCkgLT4gaW50OlxuICAgICAgICBpZiBuIDw9IDE6XG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB0bXAgPSBbVHJ1ZSBmb3IgaSBpbiByYW5nZShuKV1cbiAgICAgICAgYW5zID0gMFxuICAgICAgICB0bXBbMF0gPSBGYWxzZVxuICAgICAgICB0bXBbMV0gPSBGYWxzZVxuICAgICAgICBmb3IgaSBpbiByYW5nZSgyLCBuKTpcbiAgICAgICAgICAgIGlmIG5vdCB0bXBbaV06XG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICMg5p+l5om+IGkg5YCN5pWw55qE5LyY5YyW57uG6IqC77yaaSAqIGnlvIDlp4tcbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKGkgKiBpLCBuLCBpKTpcbiAgICAgICAgICAgICAgICB0bXBbal0gPSBGYWxzZVxuICAgICAgICBmb3IgaSBpbiByYW5nZShuKTpcbiAgICAgICAgICAgIGlmIHRtcFtpXTpcbiAgICAgICAgICAgICAgICBhbnMgKz0gMVxuICAgICAgICByZXR1cm4gYW5zXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE4LjYuMyIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiaW50IGdjZChpbnQgYSwgaW50IGIpIHtcclxuICAgIHJldHVybiBiID09IDAgPyBhIDogZ2NkKGIsIGEgJSBiKTtcclxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogInB1YmxpYyBpbnQgZ2NkKGludCBhLCBpbnQgYikge1xyXG4gICAgcmV0dXJuIGIgPT0gMCA/IGEgOiBnY2QoYiwgYSAlIGIpO1xyXG59XG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImRlZiBnY2QoYTogaW50LCBiOiBpbnQpIC0+IGludDpcbiAgICByZXR1cm4gYSBpZiBiID09IDAgZWxzZSBnY2QoYiwgYSAlIGIpXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE4LjYuNCIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiaW50IGdjZChpbnQgYSwgaW50IGIpIHtcclxuICAgIHJldHVybiBiID09IDAgPyBhIDogZ2NkKGIsIGEgJSBiKTtcclxufVxyXG5cclxuaW50IGxjbShpbnQgYSwgaW50IGIpIHtcclxuICAgIHJldHVybiBhICogYiAvIGdjZChhLCBiKTtcclxufVxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogInB1YmxpYyBpbnQgZ2NkKGludCBhLCBpbnQgYikge1xyXG4gICAgcmV0dXJuIGIgPT0gMCA/IGEgOiBnY2QoYiwgYSAlIGIpO1xyXG59XHJcbiAgICBcclxucHVibGljIGludCBsY20oaW50IGEsIGludCBiKSB7XHJcbiAgICByZXR1cm4gYSAqIGIgLyBnY2QoYSwgYik7XHJcbn1cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZGVmIGdjZChhOiBpbnQsIGI6IGludCkgLT4gaW50OlxuICAgIHJldHVybiBhIGlmIGIgPT0gMCBlbHNlIGdjZChiLCBhICUgYilcblxuXG5kZWYgbGNtKGE6IGludCwgYjogaW50KSAtPiBpbnQ6XG4gICAgcmV0dXJuIGEgKiBiIC8vIGdjZChhLCBiKVxuXG4iCiAgICB9XQogIH1dCn0sIHsKICAiaWQiOiAiMTkiLAogICJuYW1lIjogIuesrOWNgeS5neeroCIsCiAgImxpc3QiOiBbewogICAgInRpdGxlIjogIuS7o+eggTE5LjEuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI2luY2x1ZGUgPHZlY3Rvcj5cbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgdm9pZCByb3RhdGUodmVjdG9yPGludD4mIG51bXMsIGludCBrKSB7XG4gICAgdmVjdG9yPGludD4gY29weSA9IG51bXM7XG4gICAgaW50IG4gPSBudW1zLnNpemUoKTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG47IGkrKylcbiAgICAgIG51bXNbKGsgKyBpKSAlIG5dID0gY29weVtpXTtcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogInB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyB2b2lkIHJvdGF0ZShpbnRbXSBudW1zLCBpbnQgaykge1xuICAgIGludFtdIGNvcHkgPSBuZXcgaW50W251bXMubGVuZ3RoXTtcbiAgICBpbnQgbiA9IG51bXMubGVuZ3RoO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKSBjb3B5W2ldID0gbnVtc1tpXTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG47IGkrKylcbiAgICAgIG51bXNbKGsgKyBpKSAlIG5dID0gY29weVtpXTtcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiByb3RhdGUoc2VsZiwgbnVtczogTGlzdFtpbnRdLCBrOiBpbnQpIC0+IE5vbmU6XG4gICAgICAgIGNvcHkgPSBudW1zLmNvcHkoKVxuICAgICAgICBuID0gbGVuKG51bXMpXG5cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2Uobik6XG4gICAgICAgICAgICBudW1zWyhrICsgaSkgJSBuXSA9IGNvcHlbaV1cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTkuMS4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8dmVjdG9yPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICB2b2lkIHJvdGF0ZSh2ZWN0b3I8aW50PiYgbnVtcywgaW50IGspIHtcbiAgICB2ZWN0b3I8aW50PiBjb3B5ID0gbnVtcztcbiAgICBpbnQgbiA9IG51bXMuc2l6ZSgpO1xuICAgIGlmIChrICUgbiA9PSAwKSByZXR1cm47XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuOyBpKyspXG4gICAgICBudW1zWyhrICsgaSkgJSBuXSA9IGNvcHlbaV07XG4gIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJwdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICBwdWJsaWMgdm9pZCByb3RhdGUoaW50W10gbnVtcywgaW50IGspIHtcbiAgICBpbnRbXSBjb3B5ID0gbmV3IGludFtudW1zLmxlbmd0aF07XG4gICAgaW50IG4gPSBudW1zLmxlbmd0aDtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG47IGkrKykgY29weVtpXSA9IG51bXNbaV07XG4gICAgaWYgKGsgJSBuID09IDApIHJldHVybjtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG47IGkrKylcbiAgICAgIG51bXNbKGsgKyBpKSAlIG5dID0gY29weVtpXTtcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiByb3RhdGUoc2VsZiwgbnVtczogTGlzdFtpbnRdLCBrOiBpbnQpIC0+IE5vbmU6XG4gICAgICAgIGNvcHkgPSBudW1zLmNvcHkoKVxuICAgICAgICBuID0gbGVuKG51bXMpXG4gICAgICAgIGlmIGsgJSBuID09IDA6XG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICBmb3IgaSBpbiByYW5nZShuKTpcbiAgICAgICAgICAgIG51bXNbKGsgKyBpKSAlIG5dID0gY29weVtpXVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExOS4xLjMiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDx2ZWN0b3I+XG51c2luZyBuYW1lc3BhY2Ugc3RkO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIHZvaWQgcm90YXRlKHZlY3RvcjxpbnQ+JiBudW1zLCBpbnQgaykge1xuICAgIGludCBuID0gbnVtcy5zaXplKCksIHQsIG9mZnNldCA9IG4gLSBrICUgbjtcbiAgICBpZiAob2Zmc2V0ID09IDApIHJldHVybjtcbiAgICB3aGlsZSAob2Zmc2V0KSB7XG4gICAgICB0ID0gbnVtc1swXTtcbiAgICAgIG9mZnNldCAtPSAxO1xuICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuIC0gMTsgaSsrKVxuICAgICAgICBudW1zW2ldID0gbnVtc1tpICsgMV07XG4gICAgICBudW1zW24gLSAxXSA9IHQ7XG4gICAgfVxuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIHZvaWQgcm90YXRlKGludFtdIG51bXMsIGludCBrKSB7XG4gICAgaW50IG4gPSBudW1zLmxlbmd0aCwgdCwgb2Zmc2V0ID0gbiAtIGsgJSBuO1xuICAgIGlmIChvZmZzZXQgPT0gMCkgcmV0dXJuO1xuICAgIHdoaWxlIChvZmZzZXQgIT0gMCkge1xuICAgICAgdCA9IG51bXNbMF07XG4gICAgICBvZmZzZXQgLT0gMTtcbiAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbiAtIDE7IGkrKylcbiAgICAgICAgbnVtc1tpXSA9IG51bXNbaSArIDFdO1xuICAgICAgbnVtc1tuIC0gMV0gPSB0O1xuICAgIH1cbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiByb3RhdGUoc2VsZiwgbnVtczogTGlzdFtpbnRdLCBrOiBpbnQpIC0+IE5vbmU6XG4gICAgICAgIFwiXCJcIlxuICAgICAgICBEbyBub3QgcmV0dXJuIGFueXRoaW5nLCBtb2RpZnkgbnVtcyBpbi1wbGFjZSBpbnN0ZWFkLlxuICAgICAgICBcIlwiXCJcbiAgICAgICAgbiA9IGxlbihudW1zKVxuICAgICAgICB0ID0gTm9uZVxuICAgICAgICBvZmZzZXQgPSBuIC0gayAlIG4gICMg5Y+z56e75Y+Y5bem56e7XG4gICAgICAgIGlmIG9mZnNldCA9PSAwOlxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIHdoaWxlIG9mZnNldDpcbiAgICAgICAgICAgIHQgPSBudW1zWzBdXG4gICAgICAgICAgICBvZmZzZXQgLT0gMVxuICAgICAgICAgICAgZm9yIGkgaW4gcmFuZ2UobiAtIDEpOlxuICAgICAgICAgICAgICAgIG51bXNbaV0gPSBudW1zW2kgKyAxXVxuICAgICAgICAgICAgbnVtc1tuIC0gMV0gPSB0XG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE5LjEuNCIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI2luY2x1ZGUgPHZlY3Rvcj5cbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgdmVjdG9yPGludD4gcm90YXRlKHZlY3RvcjxpbnQ+JiBudW1zLCBpbnQgaykge1xuICAgIGludCBuID0gbnVtcy5zaXplKCksIG9mZnNldCA9IGsgJSBuO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKSBudW1zLnB1c2hfYmFjayhudW1zW2ldKTtcbiAgICB2ZWN0b3I8aW50PiBhbnM7XG4gICAgZm9yIChpbnQgaSA9IG4gLSBvZmZzZXQ7IGkgPCBuICogMiAtIG9mZnNldDsgaSsrKVxuICAgICAgYW5zLnB1c2hfYmFjayhudW1zW2ldKTtcbiAgICByZXR1cm4gYW5zO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGludFtdIHJvdGF0ZShpbnRbXSBudW1zLCBpbnQgaykge1xuICAgIGludCBuID0gbnVtcy5sZW5ndGgsIG9mZnNldCA9IGsgJSBuO1xuICAgIGludFtdIGFub19udW1zID0gbmV3IGludFsyICogbl07XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuOyBpKyspXG4gICAgICBhbm9fbnVtc1tpXSA9IGFub19udW1zW24gKyBpXSA9IG51bXNbaV07XG4gICAgaW50W10gYW5zID0gbmV3IGludFtuXTtcbiAgICBmb3IgKGludCBpID0gbiAtIG9mZnNldDsgaSA8IG4gKiAyIC0gb2Zmc2V0OyBpKyspXG4gICAgICBhbnNbaSAtIG4gKyBvZmZzZXRdID0gYW5vX251bXNbaV07XG4gICAgcmV0dXJuIGFucztcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiByb3RhdGUoc2VsZiwgbnVtczogTGlzdFtpbnRdLCBrOiBpbnQpIC0+IE5vbmU6XG4gICAgICAgIFwiXCJcIlxuICAgICAgICBEbyBub3QgcmV0dXJuIGFueXRoaW5nLCBtb2RpZnkgbnVtcyBpbi1wbGFjZSBpbnN0ZWFkLlxuICAgICAgICBcIlwiXCJcbiAgICAgICAgbiA9IGxlbihudW1zKVxuICAgICAgICBvZmZzZXQgPSBrICUgblxuICAgICAgICBudW1zID0gbnVtcyArIG51bXMuY29weSgpXG4gICAgICAgIHJldHVybiBudW1zW24gLSBvZmZzZXQgOiBuICogMiAtIG9mZnNldF1cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTkuMS41IiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8dmVjdG9yPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICB2b2lkIHJldmVyc2UodmVjdG9yPGludD4mIGFyciwgaW50IHN0YXJ0LCBpbnQgZW5kKSB7XG4gICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICBpbnQgdCA9IGFycltzdGFydF07XG4gICAgICBhcnJbc3RhcnRdID0gYXJyW2VuZF07XG4gICAgICBhcnJbZW5kXSA9IHQ7XG4gICAgICBzdGFydCArPSAxO1xuICAgICAgZW5kIC09IDE7XG4gICAgfVxuICB9XG4gIHZvaWQgcm90YXRlKHZlY3RvcjxpbnQ+JiBudW1zLCBpbnQgaykge1xuICAgIGludCBuID0gbnVtcy5zaXplKCksIG9mZnNldCA9IGsgJSBuO1xuICAgIGlmIChvZmZzZXQgPT0gMCkgcmV0dXJuO1xuICAgIHJldmVyc2UobnVtcywgMCwgbiAtIG9mZnNldCAtIDEpO1xuICAgIHJldmVyc2UobnVtcywgbiAtIG9mZnNldCwgbiAtIDEpO1xuICAgIHJldmVyc2UobnVtcywgMCwgbiAtIDEpO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIHZvaWQgcmV2ZXJzZShpbnRbXSBhcnIsIGludCBzdGFydCwgaW50IGVuZCkge1xuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgaW50IHQgPSBhcnJbc3RhcnRdO1xuICAgICAgYXJyW3N0YXJ0XSA9IGFycltlbmRdO1xuICAgICAgYXJyW2VuZF0gPSB0O1xuICAgICAgc3RhcnQgKz0gMTtcbiAgICAgIGVuZCAtPSAxO1xuICAgIH1cbiAgfVxuICBwdWJsaWMgdm9pZCByb3RhdGUoaW50W10gbnVtcywgaW50IGspIHtcbiAgICBpbnQgbiA9IG51bXMubGVuZ3RoLCBvZmZzZXQgPSBrICUgbjtcbiAgICBpZiAob2Zmc2V0ID09IDApIHJldHVybjtcbiAgICByZXZlcnNlKG51bXMsIDAsIG4gLSBvZmZzZXQgLSAxKTtcbiAgICByZXZlcnNlKG51bXMsIG4gLSBvZmZzZXQsIG4gLSAxKTtcbiAgICByZXZlcnNlKG51bXMsIDAsIG4gLSAxKTtcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiByb3RhdGUoc2VsZiwgbnVtczogTGlzdFtpbnRdLCBrOiBpbnQpIC0+IE5vbmU6XG4gICAgICAgIFwiXCJcIlxuICAgICAgICBEbyBub3QgcmV0dXJuIGFueXRoaW5nLCBtb2RpZnkgbnVtcyBpbi1wbGFjZSBpbnN0ZWFkLlxuICAgICAgICBcIlwiXCJcbiAgICAgICAgIyDpppblsL7kuqTmjaLms5VcbiAgICAgICAgZGVmIHJldmVyc2UobGlzdDogTGlzdFtpbnRdLCBzdGFydDogaW50LCBlbmQ6IGludCkgLT4gTm9uZTpcbiAgICAgICAgICAgIHdoaWxlIHN0YXJ0IDwgZW5kOlxuICAgICAgICAgICAgICAgIHQgPSBsaXN0W3N0YXJ0XVxuICAgICAgICAgICAgICAgIGxpc3Rbc3RhcnRdID0gbGlzdFtlbmRdXG4gICAgICAgICAgICAgICAgbGlzdFtlbmRdID0gdFxuICAgICAgICAgICAgICAgIHN0YXJ0ICs9IDFcbiAgICAgICAgICAgICAgICBlbmQgLT0gMVxuXG4gICAgICAgIG4gPSBsZW4obnVtcylcbiAgICAgICAgb2Zmc2V0ID0gayAlIG5cbiAgICAgICAgaWYgb2Zmc2V0ID09IDA6XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgcmV2ZXJzZShudW1zLCAwLCBuIC0gb2Zmc2V0IC0gMSlcbiAgICAgICAgcmV2ZXJzZShudW1zLCBuIC0gb2Zmc2V0LCBuIC0gMSlcbiAgICAgICAgcmV2ZXJzZShudW1zLCAwLCBuIC0gMSlcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTkuMi4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8Y3N0ZGlvPlxuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIExpc3ROb2RlICpyb3RhdGVSaWdodChMaXN0Tm9kZSAqaGVhZCwgaW50IGspIHtcbiAgICBpZiAoaGVhZCA9PSBOVUxMIHx8IGhlYWQtPm5leHQgPT0gTlVMTCkgcmV0dXJuIGhlYWQ7XG4gICAgTGlzdE5vZGUgKnAxID0gaGVhZCwgKnJlcyA9IE5VTEw7XG4gICAgaW50IG4gPSAxO1xuICAgIHdoaWxlIChwMSAmJiBwMS0+bmV4dCkge1xuICAgICAgcDEgPSBwMS0+bmV4dDtcbiAgICAgIG4gKz0gMTtcbiAgICB9XG4gICAgaW50IGN1ciA9IDE7XG4gICAgTGlzdE5vZGUgKnAyID0gaGVhZDtcbiAgICB3aGlsZSAoY3VyIDwgbiAtIGsgJSBuKSB7XG4gICAgICBwMiA9IHAyLT5uZXh0O1xuICAgICAgY3VyICs9IDE7XG4gICAgfVxuICAgIHAxLT5uZXh0ID0gaGVhZDtcbiAgICByZXMgPSBwMi0+bmV4dDtcbiAgICBwMi0+bmV4dCA9IE5VTEw7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogInB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBMaXN0Tm9kZSByb3RhdGVSaWdodChMaXN0Tm9kZSBoZWFkLCBpbnQgaykge1xuICAgIGlmIChoZWFkID09IG51bGwgfHwgaGVhZC5uZXh0ID09IG51bGwpIHJldHVybiBoZWFkO1xuICAgIExpc3ROb2RlIHAxID0gaGVhZCwgcmVzID0gbnVsbDtcbiAgICBpbnQgbiA9IDE7XG4gICAgd2hpbGUgKHAxICE9IG51bGwgJiYgcDEubmV4dCAhPSBudWxsKSB7XG4gICAgICBwMSA9IHAxLm5leHQ7XG4gICAgICBuICs9IDE7XG4gICAgfVxuICAgIGludCBjdXIgPSAxO1xuICAgIExpc3ROb2RlIHAyID0gaGVhZDtcbiAgICB3aGlsZSAoY3VyIDwgbiAtIGsgJSBuKSB7XG4gICAgICBwMiA9IHAyLm5leHQ7XG4gICAgICBjdXIgKz0gMTtcbiAgICB9XG4gICAgcDEubmV4dCA9IGhlYWQ7XG4gICAgcmVzID0gcDIubmV4dDtcbiAgICBwMi5uZXh0ID0gbnVsbDtcbiAgICByZXR1cm4gcmVzO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHJvdGF0ZVJpZ2h0KHNlbGYsIGhlYWQ6IExpc3ROb2RlLCBrOiBpbnQpIC0+IExpc3ROb2RlOlxuICAgICAgICBpZiBoZWFkID09IE5vbmUgb3IgaGVhZC5uZXh0ID09IE5vbmU6XG4gICAgICAgICAgICByZXR1cm4gaGVhZFxuICAgICAgICBwMSA9IGhlYWRcbiAgICAgICAgcmVzID0gTm9uZVxuICAgICAgICBuID0gMVxuXG4gICAgICAgIHdoaWxlIHAxIGFuZCBwMS5uZXh0OlxuICAgICAgICAgICAgcDEgPSBwMS5uZXh0XG4gICAgICAgICAgICBuICs9IDFcbiAgICAgICAgY3VyID0gMVxuICAgICAgICBwMiA9IGhlYWRcbiAgICAgICAgd2hpbGUgY3VyIDwgbiAtIGsgJSBuOlxuICAgICAgICAgICAgcDIgPSBwMi5uZXh0XG4gICAgICAgICAgICBjdXIgKz0gMVxuICAgICAgICBwMS5uZXh0ID0gaGVhZFxuICAgICAgICByZXMgPSBwMi5uZXh0XG4gICAgICAgIHAyLm5leHQgPSBOb25lXG5cbiAgICAgICAgcmV0dXJuIHJlc1xuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExOS4zLjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDxzdHJpbmc+XG4jaW5jbHVkZSA8YWxnb3JpdGhtPlxuI2luY2x1ZGUgPG1hcD5cbiNpbmNsdWRlIDx1dGlsaXR5PlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICBpbnQgaGVscGVyKHN0cmluZyB3b3JkMSwgaW50IHMxLCBpbnQgZTEsXG4gICAgICBzdHJpbmcgd29yZDIsIGludCBzMiwgaW50IGUyLFxuICAgICAgbWFwPHBhaXI8aW50LCBpbnQ+LCBpbnQ+JiBtZW1vKSB7XG4gICAgaWYgKHMxID4gZTEpIHJldHVybiBlMiAtIHMyICsgMTtcbiAgICBlbHNlIGlmIChzMiA+IGUyKSByZXR1cm4gZTEgLSBzMSArIDE7XG4gICAgY2hhciBjMSA9IHdvcmQxW3MxXSwgYzIgPSB3b3JkMltzMl07XG4gICAgcGFpcjxpbnQsIGludD4ga2V5ID0gbWFrZV9wYWlyKHMxLCBzMik7XG4gICAgaWYgKG1lbW8uY291bnQoa2V5KSkgcmV0dXJuIG1lbW9ba2V5XTtcbiAgICBpZiAoYzEgPT0gYzIpXG4gICAgICByZXR1cm4gbWVtb1trZXldID0gaGVscGVyKHdvcmQxLCBzMSArIDEsIGUxLCB3b3JkMixcbiAgICAgICAgICBzMiArIDEsIGUyLCBtZW1vKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gbWVtb1trZXldID0gbWluKG1pbihoZWxwZXIod29yZDEsIHMxICsgMSxcbiAgICAgICAgICAgIGUxLCB3b3JkMiwgczIsIGUyLCBtZW1vKSwgaGVscGVyKHdvcmQxLFxuICAgICAgICAgICAgICBzMSwgZTEsIHdvcmQyLCBzMiArIDEsIGUyLCBtZW1vKSksIGhlbHBlcihcbiAgICAgICAgICAgICAgd29yZDEsIHMxICsgMSwgZTEsIHdvcmQyLCBzMiArIDEsIGUyLCBtZW1vXG4gICAgICAgICAgICAgICkpICsgMTtcbiAgfVxuICBpbnQgbWluRGlzdGFuY2Uoc3RyaW5nIHdvcmQxLCBzdHJpbmcgd29yZDIpIHtcbiAgICBtYXA8cGFpcjxpbnQsIGludD4sIGludD4gZGljdDtcbiAgICByZXR1cm4gaGVscGVyKHdvcmQxLCAwLCB3b3JkMS5zaXplKCkgLSAxLFxuICAgICAgICB3b3JkMiwgMCwgd29yZDIuc2l6ZSgpIC0gMSwgZGljdCk7XG4gIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJpbXBvcnQgamF2YS51dGlsLio7XG5pbXBvcnQgamF2YS5sYW5nLk1hdGg7XG5cbnB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBjbGFzcyBQYWlyIHtcbiAgICBwdWJsaWMgZmluYWwgaW50IGZpcnN0O1xuICAgIHB1YmxpYyBmaW5hbCBpbnQgc2Vjb25kO1xuICAgIHB1YmxpYyBQYWlyKGludCB4LCBpbnQgeSkge1xuICAgICAgdGhpcy5maXJzdCA9IHg7XG4gICAgICB0aGlzLnNlY29uZCA9IHk7XG4gICAgfVxuICB9XG4gIHB1YmxpYyBQYWlyIG1ha2VfcGFpcihpbnQgeCwgaW50IHkpIHtcbiAgICBQYWlyIG5vZGUgPSBuZXcgUGFpcih4LCB5KTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwdWJsaWMgaW50IGhlbHBlcihTdHJpbmcgd29yZDEsIGludCBzMSwgaW50IGUxLFxuICAgICAgU3RyaW5nIHdvcmQyLCBpbnQgczIsIGludCBlMixcbiAgICAgIE1hcDxQYWlyLCBJbnRlZ2VyPiBtZW1vKSB7XG4gICAgaWYgKHMxID4gZTEpIHJldHVybiBlMiAtIHMyICsgMTtcbiAgICBlbHNlIGlmIChzMiA+IGUyKSByZXR1cm4gZTEgLSBzMSArIDE7XG4gICAgY2hhciBjMSA9IHdvcmQxLmNoYXJBdChzMSksIGMyID0gd29yZDIuY2hhckF0KHMyKTtcbiAgICBQYWlyIGtleSA9IG1ha2VfcGFpcihzMSwgczIpO1xuICAgIGlmIChtZW1vLmdldChrZXkpICE9IG51bGwpIHJldHVybiBtZW1vLmdldChrZXkpO1xuICAgIGlmIChjMSA9PSBjMikge1xuICAgICAgaW50IGJ1Zl92YWwgPSBoZWxwZXIod29yZDEsIHMxICsgMSwgZTEsIHdvcmQyLFxuICAgICAgICAgIHMyICsgMSwgZTIsIG1lbW8pO1xuICAgICAgbWVtby5wdXQoa2V5LCBidWZfdmFsKTtcbiAgICAgIHJldHVybiBidWZfdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnQgYnVmX3ZhbCA9IE1hdGgubWluKE1hdGgubWluKGhlbHBlcih3b3JkMSxcbiAgICAgICAgICAgICAgczEgKyAxLCBlMSwgd29yZDIsIHMyLCBlMiwgbWVtbyksXG4gICAgICAgICAgICBoZWxwZXIod29yZDEsIHMxLCBlMSwgd29yZDIsIHMyICsgMSwgZTIsXG4gICAgICAgICAgICAgIG1lbW8pKSwgaGVscGVyKHdvcmQxLCBzMSArIDEsIGUxLCB3b3JkMixcbiAgICAgICAgICAgICAgczIgKyAxLCBlMiwgbWVtbykpICsgMTtcbiAgICAgIG1lbW8ucHV0KGtleSwgYnVmX3ZhbCk7XG4gICAgICByZXR1cm4gYnVmX3ZhbDtcbiAgICB9XG4gIH1cbiAgcHVibGljIGludCBtaW5EaXN0YW5jZShTdHJpbmcgd29yZDEsIFN0cmluZyB3b3JkMikge1xuICAgIE1hcDxQYWlyLCBJbnRlZ2VyPiBkaWN0ID0gbmV3IEhhc2hNYXA8UGFpciwgSW50ZWdlcj4oKTtcbiAgICByZXR1cm4gaGVscGVyKHdvcmQxLCAwLCB3b3JkMS5sZW5ndGgoKSAtIDEsXG4gICAgICAgIHdvcmQyLCAwLCB3b3JkMi5sZW5ndGgoKSAtIDEsIGRpY3QpO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGhlbHBlcihcbiAgICAgICAgc2VsZiwgd29yZDE6IHN0ciwgczE6IGludCwgZTE6IGludCwgd29yZDI6IHN0ciwgczI6IGludCwgZTI6IGludCwgbWVtbzogZGljdFxuICAgICkgLT4gaW50OlxuICAgICAgICBpZiBzMSA+IGUxOlxuICAgICAgICAgICAgcmV0dXJuIGUyIC0gczIgKyAxXG4gICAgICAgIGVsaWYgczIgPiBlMjpcbiAgICAgICAgICAgIHJldHVybiBlMSAtIHMxICsgMVxuICAgICAgICBjMSA9IHdvcmQxW3MxXVxuICAgICAgICBjMiA9IHdvcmQyW3MyXVxuICAgICAgICBrZXkgPSAoczEsIHMyKVxuICAgICAgICBpZiBrZXkgaW4gbWVtbzpcbiAgICAgICAgICAgIHJldHVybiBtZW1vW2tleV1cbiAgICAgICAgaWYgYzEgPT0gYzI6XG4gICAgICAgICAgICBtZW1vW2tleV0gPSBzZWxmLmhlbHBlcih3b3JkMSwgczEgKyAxLCBlMSwgd29yZDIsIHMyICsgMSwgZTIsIG1lbW8pXG4gICAgICAgICAgICByZXR1cm4gbWVtb1trZXldXG4gICAgICAgIGVsc2U6XG4gICAgICAgICAgICBtZW1vW2tleV0gPSAoXG4gICAgICAgICAgICAgICAgbWluKFxuICAgICAgICAgICAgICAgICAgICBzZWxmLmhlbHBlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmQxLCBzMSArIDEsIGUxLCB3b3JkMiwgczIsIGUyLCBtZW1vXG4gICAgICAgICAgICAgICAgICAgICksICAjIGRlbGV0ZSBvciBhZGRcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5oZWxwZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JkMSwgczEsIGUxLCB3b3JkMiwgczIgKyAxLCBlMiwgbWVtb1xuICAgICAgICAgICAgICAgICAgICApLCAgIyBkZWxldGUgb3IgYWRkXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaGVscGVyKHdvcmQxLCBzMSArIDEsIGUxLCB3b3JkMiwgczIgKyAxLCBlMiwgbWVtbyksICAjIHJlcGxhY2VcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKyAxXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHJldHVybiBtZW1vW2tleV1cblxuICAgIGRlZiBtaW5EaXN0YW5jZShzZWxmLCB3b3JkMTogc3RyLCB3b3JkMjogc3RyKSAtPiBpbnQ6XG4gICAgICAgIHJldHVybiBzZWxmLmhlbHBlcih3b3JkMSwgMCwgbGVuKHdvcmQxKSAtIDEsIHdvcmQyLCAwLCBsZW4od29yZDIpIC0gMSwgZGljdCgpKVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExOS4zLjIiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDxjc3RkbGliPlxuI2luY2x1ZGUgPHN0cmluZz5cbiNpbmNsdWRlIDxhbGdvcml0aG0+XG51c2luZyBuYW1lc3BhY2Ugc3RkO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIGludCBtaW5EaXN0YW5jZShzdHJpbmcgd29yZDEsIHN0cmluZyB3b3JkMikge1xuICAgIGludCBtID0gd29yZDEubGVuZ3RoKCksIG4gPSB3b3JkMi5sZW5ndGgoKTtcbiAgICBpbnQgKipkcCA9IChpbnQgKiopbWFsbG9jKChtICsgMSkgKiBzaXplb2YoaW50ICopKTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8PSBtOyBpKyspIHtcbiAgICAgIGRwW2ldID0gKGludCAqKW1hbGxvYygobiArIDEpICogc2l6ZW9mKGludCkpO1xuICAgICAgZm9yIChpbnQgaiA9IDA7IGogPD0gbjsgaisrKVxuICAgICAgICBkcFtpXVtqXSA9IDA7XG4gICAgfVxuICAgIGZvciAoaW50IGkgPSAxOyBpIDw9IG07IGkrKykgZHBbaV1bMF0gPSBpO1xuICAgIGZvciAoaW50IGogPSAxOyBqIDw9IG47IGorKykgZHBbMF1bal0gPSBqO1xuICAgIGZvciAoaW50IGkgPSAxOyBpIDw9IG07IGkrKylcbiAgICAgIGZvciAoaW50IGogPSAxOyBqIDw9IG47IGorKykge1xuICAgICAgICBpZiAod29yZDFbaSAtIDFdID09IHdvcmQyW2ogLSAxXSlcbiAgICAgICAgICBkcFtpXVtqXSA9IGRwW2kgLSAxXVtqIC0gMV07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBkcFtpXVtqXSA9IG1pbihtaW4oZHBbaSAtIDFdW2ogLSAxXSxcXFxuICAgICAgICAgICAgICAgIGRwW2ldW2ogLSAxXSksIGRwW2kgLSAxXVtqXSkgKyAxO1xuICAgICAgfVxuICAgIGludCBhbnMgPSBkcFttXVtuXTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8PSBtOyBpKyspIGZyZWUoZHBbaV0pO1xuICAgIGZyZWUoZHApO1xuICAgIHJldHVybiBhbnM7XG4gIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJpbXBvcnQgamF2YS5sYW5nLk1hdGhcblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGludCBtaW5EaXN0YW5jZShTdHJpbmcgd29yZDEsIFN0cmluZyB3b3JkMikge1xuICAgIGludCBtID0gd29yZDEubGVuZ3RoKCksIG4gPSB3b3JkMi5sZW5ndGgoKTtcbiAgICBpbnRbXVtdIGRwID0gbmV3IGludFttICsgMV1bbiArIDFdO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDw9IG07IGkrKylcbiAgICAgIGZvciAoaW50IGogPSAwOyBqIDw9IG47IGorKykgZHBbaV1bal0gPSAwO1xuICAgIGZvciAoaW50IGkgPSAxOyBpIDw9IG07IGkrKykgZHBbaV1bMF0gPSBpO1xuICAgIGZvciAoaW50IGogPSAxOyBqIDw9IG47IGorKykgZHBbMF1bal0gPSBqO1xuICAgIGZvciAoaW50IGkgPSAxOyBpIDw9IG07IGkrKylcbiAgICAgIGZvciAgKGludCBqID0gMTsgaiA8PSBuOyBqKyspXG4gICAgICAgIGlmICh3b3JkMS5jaGFyQXQoaSAtIDEpID09IHdvcmQyLmNoYXJBdChqIC0gMSkpXG4gICAgICAgICAgZHBbaV1bal0gPSBkcFtpIC0gMV1baiAtIDFdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZHBbaV1bal0gPSBNYXRoLm1pbihNYXRoLm1pbihkcFtpIC0gMV1baiAtIDFdLFxuICAgICAgICAgICAgICAgIGRwW2ldW2ogLSAxXSksIGRwW2kgLSAxXVtqXSkgKyAxO1xuICAgIHJldHVybiBkcFttXVtuXTtcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBtaW5EaXN0YW5jZShzZWxmLCB3b3JkMTogc3RyLCB3b3JkMjogc3RyKSAtPiBpbnQ6XG4gICAgICAgIG0gPSBsZW4od29yZDEpXG4gICAgICAgIG4gPSBsZW4od29yZDIpXG4gICAgICAgIGRwID0gW1swIGZvciBqIGluIHJhbmdlKG4gKyAxKV0gZm9yIGkgaW4gcmFuZ2UobSArIDEpXVxuXG4gICAgICAgIGZvciBpIGluIHJhbmdlKDEsIG0gKyAxKTpcbiAgICAgICAgICAgIGRwW2ldWzBdID0gaVxuICAgICAgICBmb3IgaiBpbiByYW5nZSgxLCBuICsgMSk6XG4gICAgICAgICAgICBkcFswXVtqXSA9IGpcblxuICAgICAgICBmb3IgaSBpbiByYW5nZSgxLCBtICsgMSk6XG4gICAgICAgICAgICBmb3IgaiBpbiByYW5nZSgxLCBuICsgMSk6XG4gICAgICAgICAgICAgICAgaWYgd29yZDFbaSAtIDFdID09IHdvcmQyW2ogLSAxXTpcbiAgICAgICAgICAgICAgICAgICAgZHBbaV1bal0gPSBkcFtpIC0gMV1baiAtIDFdXG4gICAgICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICAgICAgZHBbaV1bal0gPSBtaW4oZHBbaSAtIDFdW2ogLSAxXSwgZHBbaV1baiAtIDFdLCBkcFtpIC0gMV1bal0pICsgMVxuICAgICAgICByZXR1cm4gZHBbbV1bbl1cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTkuMy4zIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8c3RyaW5nPlxuI2luY2x1ZGUgPGNzdGRsaWI+XG4jaW5jbHVkZSA8YWxnb3JpdGhtPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICBpbnQgbWluRGlzdGFuY2Uoc3RyaW5nIHdvcmQxLCBzdHJpbmcgd29yZDIpIHtcbiAgICBpbnQgbSA9IHdvcmQxLmxlbmd0aCgpLCBuID0gd29yZDIubGVuZ3RoKCk7XG4gICAgaW50ICpwcmUgPSAoaW50ICopbWFsbG9jKChuICsgMSkgKiBzaXplb2YoaW50KSk7XG4gICAgaW50ICpjdXIgPSAoaW50ICopbWFsbG9jKChuICsgMSkgKiBzaXplb2YoaW50KSk7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPD0gbjsgaSsrKSBwcmVbaV0gPSBjdXJbaV0gPSAwO1xuICAgIGZvciAoaW50IGkgPSAxOyBpIDw9IG47IGkrKykgcHJlW2ldID0gaTtcbiAgICBmb3IgKGludCBpID0gMTsgaSA8PSBtOyBpKyspIHtcbiAgICAgIGN1clswXSA9IGk7XG4gICAgICBmb3IgKGludCBqID0gMTsgaiA8PSBuOyBqKyspIHtcbiAgICAgICAgaWYgKHdvcmQxW2kgLSAxXSA9PSB3b3JkMltqIC0gMV0pXG4gICAgICAgICAgY3VyW2pdID0gcHJlW2ogLSAxXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGN1cltqXSA9IG1pbihtaW4ocHJlW2pdLCBwcmVbaiAtIDFdKSxcbiAgICAgICAgICAgICAgY3VyW2ogLSAxXSkgKyAxO1xuICAgICAgfVxuICAgICAgZm9yIChpbnQgayA9IDA7IGsgPD0gbjsgaysrKSBwcmVba10gPSBjdXJba107XG4gICAgfVxuICAgIGludCBhbnMgPSBwcmVbbl07XG4gICAgZnJlZShwcmUpO1xuICAgIGZyZWUoY3VyKTtcbiAgICByZXR1cm4gYW5zO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiaW1wb3J0IGphdmEubGFuZy5NYXRoO1xuXG5wdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICBwdWJsaWMgaW50IG1pbkRpc3RhbmNlKFN0cmluZyB3b3JkMSwgU3RyaW5nIHdvcmQyKSB7XG4gICAgaW50IG0gPSB3b3JkMS5sZW5ndGgoKSwgbiA9IHdvcmQyLmxlbmd0aCgpO1xuICAgIGludFtdIHByZSA9IG5ldyBpbnRbbiArIDFdO1xuICAgIGludFtdIGN1ciA9IG5ldyBpbnRbbiArIDFdO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDw9IG47IGkrKykgcHJlW2ldID0gY3VyW2ldID0gMDtcbiAgICBmb3IgKGludCBpID0gMTsgaSA8PSBuOyBpKyspIHByZVtpXSA9IGk7XG4gICAgZm9yIChpbnQgaSA9IDE7IGkgPD0gbTsgaSsrKSB7XG4gICAgICBjdXJbMF0gPSBpO1xuICAgICAgZm9yIChpbnQgaiA9IDE7IGogPD0gbjsgaisrKSB7XG4gICAgICAgIGlmICh3b3JkMS5jaGFyQXQoaSAtIDEpID09IHdvcmQyLmNoYXJBdChqIC0gMSkpXG4gICAgICAgICAgY3VyW2pdID0gcHJlW2ogLSAxXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGN1cltqXSA9IE1hdGgubWluKE1hdGgubWluKHByZVtqXSwgcHJlW2ogLSAxXSksXG4gICAgICAgICAgICAgIGN1cltqIC0gMV0pICsgMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaW50IGsgPSAwOyBrIDw9IG47IGsrKykgcHJlW2tdID0gY3VyW2tdO1xuICAgIH1cbiAgICByZXR1cm4gcHJlW25dO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIG1pbkRpc3RhbmNlKHNlbGYsIHdvcmQxOiBzdHIsIHdvcmQyOiBzdHIpIC0+IGludDpcbiAgICAgICAgbSA9IGxlbih3b3JkMSlcbiAgICAgICAgbiA9IGxlbih3b3JkMilcbiAgICAgICAgcHJlID0gWzBdICogKG4gKyAxKVxuICAgICAgICBjdXIgPSBbMF0gKiAobiArIDEpXG5cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMSwgbiArIDEpOlxuICAgICAgICAgICAgcHJlW2ldID0gaVxuICAgICAgICBmb3IgaSBpbiByYW5nZSgxLCBtICsgMSk6XG4gICAgICAgICAgICBjdXJbMF0gPSBpXG4gICAgICAgICAgICBmb3IgaiBpbiByYW5nZSgxLCBuICsgMSk6XG4gICAgICAgICAgICAgICAgaWYgd29yZDFbaSAtIDFdID09IHdvcmQyW2ogLSAxXTpcbiAgICAgICAgICAgICAgICAgICAgY3VyW2pdID0gcHJlW2ogLSAxXVxuICAgICAgICAgICAgICAgIGVsc2U6XG4gICAgICAgICAgICAgICAgICAgIGN1cltqXSA9IG1pbihwcmVbal0sIHByZVtqIC0gMV0sIGN1cltqIC0gMV0pICsgMVxuICAgICAgICAgICAgIyBtb3ZlIG9uXG4gICAgICAgICAgICBwcmUgPSBjdXIuY29weSgpXG4gICAgICAgICMg5pyA5ZCO6L+b6KGM5LqG5LiA5qyh5Lqk5o2i77yMIGN1cuWPmOaIkOS6hnByZe+8jOWboOatpOaIkeS7rOW6lOivpeWPlnByZVtuXe+8jOiAjOS4jeaYr2N1cltuXVxuICAgICAgICByZXR1cm4gcHJlW25dXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTE5LjMuNCIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI2luY2x1ZGUgPGNzdGRsaWI+XG4jaW5jbHVkZSA8c3RyaW5nPlxuI2luY2x1ZGUgPGFsZ29yaXRobT5cbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgaW50IG1pbkRpc3RhbmNlKHN0cmluZyB3b3JkMSwgc3RyaW5nIHdvcmQyKSB7XG4gICAgaW50IG0gPSB3b3JkMS5zaXplKCksIG4gPSB3b3JkMi5zaXplKCk7XG4gICAgaW50ICpjdXIgPSAoaW50ICopbWFsbG9jKChuICsgMSkgKiBzaXplb2YoaW50KSk7XG4gICAgY3VyWzBdID0gMDtcbiAgICBpbnQgcHJlO1xuICAgIGZvciAoaW50IGkgPSAxOyBpIDw9IG47IGkrKykgY3VyW2ldID0gaTtcbiAgICBmb3IgKGludCBpID0gMTsgaSA8PSBtOyBpKyspIHtcbiAgICAgIHByZSA9IGN1clswXTtcbiAgICAgIGN1clswXSA9IGk7XG4gICAgICBmb3IgKGludCBqID0gMTsgaiA8PSBuOyBqKyspIHtcbiAgICAgICAgaW50IHRlbXAgPSBjdXJbal07XG4gICAgICAgIGlmICh3b3JkMVtpIC0gMV0gPT0gd29yZDJbaiAtIDFdKVxuICAgICAgICAgIGN1cltqXSA9IHByZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGN1cltqXSA9IG1pbihtaW4oY3VyW2pdLCBjdXJbaiAtIDFdKSwgcHJlKSArIDE7XG4gICAgICAgIHByZSA9IHRlbXA7XG4gICAgICB9XG4gICAgfVxuICAgIGludCBhbnMgPSBjdXJbbl07XG4gICAgZnJlZShjdXIpO1xuICAgIHJldHVybiBhbnM7XG4gIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJpbXBvcnQgamF2YS5sYW5nLk1hdGg7XG5cbnB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBpbnQgbWluRGlzdGFuY2UoU3RyaW5nIHdvcmQxLCBTdHJpbmcgd29yZDIpIHtcbiAgICBpbnQgbSA9IHdvcmQxLmxlbmd0aCgpLCBuID0gd29yZDIubGVuZ3RoKCk7XG4gICAgaW50W10gY3VyID0gbmV3IGludFtuICsgMV07XG4gICAgaW50IHByZTtcbiAgICBmb3IgKGludCBpID0gMTsgaSA8PSBuOyBpKyspIGN1cltpXSA9IGk7XG4gICAgZm9yIChpbnQgaSA9IDE7IGkgPD0gbTsgaSsrKSB7XG4gICAgICBwcmUgPSBjdXJbMF07XG4gICAgICBjdXJbMF0gPSBpO1xuICAgICAgZm9yIChpbnQgaiA9IDE7IGogPD0gbjsgaisrKSB7XG4gICAgICAgIGludCB0ZW1wID0gY3VyW2pdO1xuICAgICAgICBpZiAod29yZDEuY2hhckF0KGkgLSAxKSA9PSB3b3JkMi5jaGFyQXQoaiAtIDEpKVxuICAgICAgICAgIGN1cltqXSA9IHByZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGN1cltqXSA9IE1hdGgubWluKE1hdGgubWluKGN1cltqXSwgY3VyW2ogLSAxXSksXG4gICAgICAgICAgICAgIHByZSkgKyAxO1xuICAgICAgICBwcmUgPSB0ZW1wO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VyW25dO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIG1pbkRpc3RhbmNlKHNlbGYsIHdvcmQxOiBzdHIsIHdvcmQyOiBzdHIpIC0+IGludDpcbiAgICAgICAgbSA9IGxlbih3b3JkMSlcbiAgICAgICAgbiA9IGxlbih3b3JkMilcbiAgICAgICAgY3VyID0gWzBdICogKG4gKyAxKVxuICAgICAgICBwcmUgPSBOb25lXG5cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMSwgbiArIDEpOlxuICAgICAgICAgICAgY3VyW2ldID0gaVxuICAgICAgICBmb3IgaSBpbiByYW5nZSgxLCBtICsgMSk6XG4gICAgICAgICAgICBwcmUgPSBjdXJbMF1cbiAgICAgICAgICAgIGN1clswXSA9IGlcbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKDEsIG4gKyAxKTpcbiAgICAgICAgICAgICAgICB0ZW1wID0gY3VyW2pdXG4gICAgICAgICAgICAgICAgaWYgd29yZDFbaSAtIDFdID09IHdvcmQyW2ogLSAxXTpcbiAgICAgICAgICAgICAgICAgICAgY3VyW2pdID0gcHJlXG4gICAgICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICAgICAgY3VyW2pdID0gbWluKGN1cltqXSwgY3VyW2ogLSAxXSwgcHJlKSArIDFcbiAgICAgICAgICAgICAgICBwcmUgPSB0ZW1wXG4gICAgICAgIHJldHVybiBjdXJbbl1cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMTkuNC4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8Y3RpbWU+XG4jaW5jbHVkZSA8Y3N0ZGxpYj5cbiNpbmNsdWRlIDxhbGdvcml0aG0+XG4jaW5jbHVkZSA8dmVjdG9yPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICAvLyBmaW5kIHRoZSBpZHgtdGggc21hbGxlc3QgZWxlbWVudFxuICAvLyAwLXRoIHNtYWxsZXN0IGVsZW1lbnQgaXMgdGhlIHNtYWxsZXN0IGdsb2JhbGx5XG4gIC8vIHRpbWUgY29tcGxleGl0eSBpcyBPKG4pXG4gIGludCBsb2NhdGUodmVjdG9yPGludD4mIGFycixcbiAgICAgIGludCBzdCwgaW50IGVkLCBpbnQgaWR4KSB7XG4gICAgaWYgKHN0ID09IGVkKSByZXR1cm4gYXJyW3N0XTtcblxuICAgIC8vIGF2b2lkIHRoZSB3b3JzdCBjYXNlXG4gICAgaW50IHJkID0gc3QgKyByYW5kKCkgJSAoZWQgLSBzdCArIDEpO1xuICAgIHN3YXAoYXJyW3JkXSwgYXJyW2VkXSk7XG5cbiAgICBpbnQgbm93ID0gc3Q7XG4gICAgZm9yIChpbnQgaSA9IHN0OyBpIDwgZWQ7IGkrKylcbiAgICAgIGlmIChhcnJbaV0gPCBhcnJbZWRdKSBzd2FwKGFycltpXSwgYXJyW25vdysrXSk7XG4gICAgc3dhcChhcnJbbm93XSwgYXJyW2VkXSk7XG4gICAgaWYgKG5vdyA9PSBzdCArIGlkeCkgcmV0dXJuIGFycltub3ddO1xuICAgIGVsc2UgaWYgKG5vdyA8IHN0ICsgaWR4KVxuICAgICAgcmV0dXJuIGxvY2F0ZShhcnIsIG5vdyArIDEsIGVkLFxuICAgICAgICAgIGlkeCAtIChub3cgLSBzdCkgLSAxKTtcbiAgICBlbHNlIHJldHVybiBsb2NhdGUoYXJyLCBzdCwgbm93IC0gMSwgaWR4KTtcbiAgfVxuICBpbnQgZmluZEt0aExhcmdlc3QodmVjdG9yPGludD4mIG51bXMsIGludCBrKXtcbiAgICByZXR1cm4gbG9jYXRlKG51bXMsIDAsIG51bXMuc2l6ZSgpIC0gMSxcbiAgICAgICAgbnVtcy5zaXplKCkgLSBrKTtcbiAgfVxufTtcblxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiaW1wb3J0IGphdmEudXRpbC4qO1xuXG5wdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICBwdWJsaWMgaW50IGxvY2F0ZShpbnRbXSBhcnIsIGludCBzdCwgaW50IGVkLCBpbnQgaWR4KSB7XG4gICAgaWYgKHN0ID09IGVkKSByZXR1cm4gYXJyW3N0XTtcbiAgICBSYW5kb20gciA9IG5ldyBSYW5kb20oKTtcbiAgICBpbnQgcmQgPSBzdCArIHIubmV4dEludChlZCAtIHN0ICsgMSk7XG4gICAgaW50IHRtcCA9IGFycltyZF07XG4gICAgYXJyW3JkXSA9IGFycltlZF07XG4gICAgYXJyW2VkXSA9IHRtcDtcbiAgICBpbnQgbm93ID0gc3Q7XG4gICAgZm9yIChpbnQgaSA9IHN0OyBpIDwgZWQ7IGkrKylcbiAgICAgIGlmIChhcnJbaV0gPCBhcnJbZWRdKSB7XG4gICAgICAgIHRtcCA9IGFycltpXTtcbiAgICAgICAgYXJyW2ldID0gYXJyW25vd107XG4gICAgICAgIGFycltub3ddID0gdG1wO1xuICAgICAgICBub3cgKz0gMTtcbiAgICAgIH1cbiAgICB0bXAgPSBhcnJbbm93XTtcbiAgICBhcnJbbm93XSA9IGFycltlZF07XG4gICAgYXJyW2VkXSA9IHRtcDtcbiAgICBpZiAobm93ID09IHN0ICsgaWR4KSByZXR1cm4gYXJyW25vd107XG4gICAgZWxzZSBpZiAobm93IDwgc3QgKyBpZHgpXG4gICAgICByZXR1cm4gbG9jYXRlKGFyciwgbm93ICsgMSwgZWQsXG4gICAgICAgICAgaWR4IC0gKG5vdyAtIHN0KSAtIDEpO1xuICAgIGVsc2UgcmV0dXJuIGxvY2F0ZShhcnIsIHN0LCBub3cgLSAxLCBpZHgpO1xuICB9XG4gIGludCBmaW5kS3RoTGFyZ2VzdChpbnRbXSBudW1zLCBpbnQgaykge1xuICAgIHJldHVybiBsb2NhdGUobnVtcywgMCwgbnVtcy5sZW5ndGggLSAxLFxuICAgICAgICBudW1zLmxlbmd0aCAtIGspO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiZnJvbSBoZWFwcSBpbXBvcnQgbmxhcmdlc3RcblxuXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgZmluZEt0aExhcmdlc3Qoc2VsZiwgbnVtczogTGlzdFtpbnRdLCBrOiBpbnQpIC0+IGludDpcbiAgICAgICAgcmV0dXJuIG5sYXJnZXN0KGssIG51bXMpWy0xXVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExOS40LjIiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDxxdWV1ZT5cbiNpbmNsdWRlIDx2ZWN0b3I+XG4jaW5jbHVkZSA8YWxnb3JpdGhtPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuY2xhc3MgS3RoTGFyZ2VzdCB7XG5wdWJsaWM6XG4gIHByaW9yaXR5X3F1ZXVlPGludCwgdmVjdG9yPGludD4sIGxlc3M8aW50PiA+IHFsYXJnZTtcbiAgcHJpb3JpdHlfcXVldWU8aW50LCB2ZWN0b3I8aW50PiwgZ3JlYXRlcjxpbnQ+ID4gcXNtYWxsO1xuICBpbnQgaztcbiAgS3RoTGFyZ2VzdChpbnQgYnVmX2ssIHZlY3RvcjxpbnQ+JiBudW1zKSB7XG4gICAgd2hpbGUgKCFxbGFyZ2UuZW1wdHkoKSkgcWxhcmdlLnBvcCgpO1xuICAgIHdoaWxlICghcXNtYWxsLmVtcHR5KCkpIHFzbWFsbC5wb3AoKTtcbiAgICBrID0gYnVmX2s7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBudW1zLnNpemUoKTsgaSsrKVxuICAgICAgcWxhcmdlLnB1c2gobnVtc1tpXSk7XG4gICAgd2hpbGUgKHFzbWFsbC5zaXplKCkgPCBrIC0gMSkge1xuICAgICAgcXNtYWxsLnB1c2gocWxhcmdlLnRvcCgpKTtcbiAgICAgIHFsYXJnZS5wb3AoKTtcbiAgICB9XG4gIH1cbiAgaW50IGFkZChpbnQgdmFsKSB7XG4gICAgaW50IGNtcDtcbiAgICBpZiAoayA+IDEpIGNtcCA9IHFzbWFsbC50b3AoKTtcbiAgICBlbHNlIHtcbiAgICAgIHFsYXJnZS5wdXNoKHZhbCk7XG4gICAgICByZXR1cm4gcWxhcmdlLnRvcCgpO1xuICAgIH1cbiAgICBpZiAoY21wIDwgdmFsKSB7XG4gICAgICBxc21hbGwucG9wKCk7XG4gICAgICBxc21hbGwucHVzaCh2YWwpO1xuICAgICAgcWxhcmdlLnB1c2goY21wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcWxhcmdlLnB1c2godmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHFsYXJnZS50b3AoKTtcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBqYXZhLnV0aWwuKjtcblxuY2xhc3MgS3RoTGFyZ2VzdCB7XG4gIHB1YmxpYyBzdGF0aWMgQ29tcGFyYXRvcjxJbnRlZ2VyPiBsZXNzID0gbmV3XG4gICAgQ29tcGFyYXRvcjxJbnRlZ2VyPigpIHtcbiAgICAgIHB1YmxpYyBpbnQgY29tcGFyZShJbnRlZ2VyIGUxLCBJbnRlZ2VyIGUyKSB7XG4gICAgICAgIHJldHVybiBlMiAtIGUxO1xuICAgICAgfVxuICAgIH07XG4gIHB1YmxpYyBzdGF0aWMgQ29tcGFyYXRvcjxJbnRlZ2VyPiBncmVhdGVyID0gbmV3XG4gICAgQ29tcGFyYXRvcjxJbnRlZ2VyPigpIHtcbiAgICAgIHB1YmxpYyBpbnQgY29tcGFyZShJbnRlZ2VyIGUxLCBJbnRlZ2VyIGUyKSB7XG4gICAgICAgIHJldHVybiBlMSAtIGUyO1xuICAgICAgfVxuICAgIH07XG4gIHB1YmxpYyBRdWV1ZTxJbnRlZ2VyPiBxbGFyZ2U7XG4gIHB1YmxpYyBRdWV1ZTxJbnRlZ2VyPiBxc21hbGw7XG4gIHB1YmxpYyBpbnQgaztcbiAgcHVibGljIEt0aExhcmdlc3QoaW50IGJ1Zl9rLCBpbnRbXSBudW1zKSB7XG4gICAgcWxhcmdlID0gbmV3IFByaW9yaXR5UXVldWU8PihsZXNzKTtcbiAgICBxc21hbGwgPSBuZXcgUHJpb3JpdHlRdWV1ZTw+KGdyZWF0ZXIpO1xuICAgIGsgPSBidWZfaztcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspXG4gICAgICBxbGFyZ2UuYWRkKG51bXNbaV0pO1xuICAgIHdoaWxlIChxc21hbGwuc2l6ZSgpIDwgayAtIDEpIHtcbiAgICAgIHFzbWFsbC5hZGQocWxhcmdlLnBlZWsoKSk7XG4gICAgICBxbGFyZ2UucG9sbCgpO1xuICAgIH1cbiAgfVxuICBwdWJsaWMgaW50IGFkZChpbnQgdmFsKSB7XG4gICAgaW50IGNtcDtcbiAgICBpZiAoayA+IDEpIGNtcCA9IHFzbWFsbC5wZWVrKCk7XG4gICAgZWxzZSB7XG4gICAgICBxbGFyZ2UuYWRkKHZhbCk7XG4gICAgICByZXR1cm4gcWxhcmdlLnBlZWsoKTtcbiAgICB9XG4gICAgaWYgKGNtcCA8IHZhbCkge1xuICAgICAgcXNtYWxsLnBvbGwoKTtcbiAgICAgIHFzbWFsbC5hZGQodmFsKTtcbiAgICAgIHFsYXJnZS5hZGQoY21wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcWxhcmdlLmFkZCh2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gcWxhcmdlLnBlZWsoKTtcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBoZWFwcVxuXG5cbmNsYXNzIEt0aExhcmdlc3Q6XG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIGs6IGludCwgbnVtczogTGlzdFtpbnRdKTpcbiAgICAgICAgc2VsZi5rID0ga1xuICAgICAgICBzZWxmLm51bXMgPSBoZWFwcS5ubGFyZ2VzdChrLCBudW1zICsgW2Zsb2F0KFwiLWluZlwiKV0pXG4gICAgICAgIGhlYXBxLmhlYXBpZnkoc2VsZi5udW1zKVxuXG4gICAgZGVmIGFkZChzZWxmLCB2YWw6IGludCkgLT4gaW50OlxuICAgICAgICBoZWFwcS5oZWFwcHVzaHBvcChzZWxmLm51bXMsIHZhbClcbiAgICAgICAgcmV0dXJuIHNlbGYubnVtc1swXVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExOS40LjMiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDxjc3RkaW8+XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgaW50IGNvdW50Tm9kZXMoVHJlZU5vZGUgKm5vZGUpIHtcbiAgICBpZiAobm9kZSA9PSBOVUxMKSByZXR1cm4gMDtcbiAgICBpbnQgbCA9IGNvdW50Tm9kZXMobm9kZS0+bGVmdCk7XG4gICAgaW50IHIgPSBjb3VudE5vZGVzKG5vZGUtPnJpZ2h0KTtcbiAgICByZXR1cm4gbCArIHIgKyAxO1xuICB9XG4gIGludCBrdGhTbWFsbGVzdChUcmVlTm9kZSAqcm9vdCwgaW50IGspIHtcbiAgICBpbnQgY250ID0gY291bnROb2Rlcyhyb290LT5sZWZ0KTtcbiAgICBpZiAoY250ID09IGsgLSAxKSByZXR1cm4gcm9vdC0+dmFsO1xuICAgIGVsc2UgaWYgKGNudCA+IGsgLSAxKVxuICAgICAgcmV0dXJuIGt0aFNtYWxsZXN0KHJvb3QtPmxlZnQsIGspO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBrdGhTbWFsbGVzdChyb290LT5yaWdodCwgayAtIGNudCAtIDEpO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICBwdWJsaWMgaW50IGNvdW50Tm9kZXMoVHJlZU5vZGUgbm9kZSkge1xuICAgIGlmIChub2RlID09IG51bGwpIHJldHVybiAwO1xuICAgIGludCBsID0gY291bnROb2Rlcyhub2RlLmxlZnQpO1xuICAgIGludCByID0gY291bnROb2Rlcyhub2RlLnJpZ2h0KTtcbiAgICByZXR1cm4gbCArIHIgKyAxO1xuICB9XG4gIHB1YmxpYyBpbnQga3RoU21hbGxlc3QoVHJlZU5vZGUgcm9vdCwgaW50IGspIHtcbiAgICBpbnQgY250ID0gY291bnROb2Rlcyhyb290LmxlZnQpO1xuICAgIGlmIChjbnQgPT0gayAtIDEpIHJldHVybiByb290LnZhbDtcbiAgICBlbHNlIGlmIChjbnQgPiBrIC0gMSlcbiAgICAgIHJldHVybiBrdGhTbWFsbGVzdChyb290LmxlZnQsIGspO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBrdGhTbWFsbGVzdChyb290LnJpZ2h0LCBrIC0gY250IC0gMSk7XG4gIH1cbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYga3RoU21hbGxlc3Qoc2VsZiwgcm9vdDogVHJlZU5vZGUsIGs6IGludCkgLT4gaW50OlxuICAgICAgICAjIOi/lOWbnuivpeiKgueCueS7peWPiuWFtuaJgOacieWtkOiKgueCueeahOS4quaVsFxuICAgICAgICBkZWYgY291bnROb2Rlcyhub2RlKSAtPiBpbnQ6XG4gICAgICAgICAgICBpZiBub2RlID09IE5vbmU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgICAgIGwgPSBjb3VudE5vZGVzKG5vZGUubGVmdClcbiAgICAgICAgICAgIHIgPSBjb3VudE5vZGVzKG5vZGUucmlnaHQpXG4gICAgICAgICAgICByZXR1cm4gbCArIHIgKyAxXG5cbiAgICAgICAgY250ID0gY291bnROb2Rlcyhyb290LmxlZnQpXG4gICAgICAgIGlmIGNudCA9PSBrIC0gMTpcbiAgICAgICAgICAgIHJldHVybiByb290LnZhbFxuICAgICAgICBlbGlmIGNudCA+IGsgLSAxOlxuICAgICAgICAgICAgcmV0dXJuIHNlbGYua3RoU21hbGxlc3Qocm9vdC5sZWZ0LCBrKVxuXG4gICAgICAgIHJldHVybiBzZWxmLmt0aFNtYWxsZXN0KHJvb3QucmlnaHQsIGsgLSBjbnQgLSAxKVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExOS40LjQiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDx2ZWN0b3I+XG51c2luZyBuYW1lc3BhY2Ugc3RkO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIGludCBjb3VudE5vdEdyZWF0ZXIoY29uc3QgdmVjdG9yPHZlY3RvcjxpbnQ+ID4mIG1hdHJpeCxcbiAgICAgIGludCB0YXJnZXQpIHtcbiAgICBpbnQgbiA9IG1hdHJpeC5zaXplKCk7XG4gICAgaW50IGkgPSAwLCBqID0gbiAtIDEsIGNudCA9IDA7XG4gICAgd2hpbGUgKGkgPCBuICYmIGogPj0gMCkge1xuICAgICAgaWYgKG1hdHJpeFtpXVtqXSA8PSB0YXJnZXQpIHtcbiAgICAgICAgY250ICs9IGogKyAxO1xuICAgICAgICBpICs9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqIC09IDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbnQ7XG4gIH1cbiAgaW50IGt0aFNtYWxsZXN0KHZlY3Rvcjx2ZWN0b3I8aW50PiA+JiBtYXRyaXgsIGludCBrKSB7XG4gICAgaW50IG4gPSBtYXRyaXguc2l6ZSgpO1xuICAgIGludCBsbyA9IG1hdHJpeFswXVswXSwgaGkgPSBtYXRyaXhbbiAtIDFdW24gLSAxXTtcbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgaW50IG1pZCA9IChsbyArIGhpKSAvIDI7XG4gICAgICBpbnQgY250ID0gY291bnROb3RHcmVhdGVyKG1hdHJpeCwgbWlkKTtcbiAgICAgIGlmIChjbnQgPCBrKSBsbyA9IG1pZCArIDE7XG4gICAgICBlbHNlIGhpID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG87XG4gIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJwdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICBwdWJsaWMgaW50IGNvdW50Tm90R3JlYXRlcihpbnRbXVtdIG1hdHJpeCwgaW50IHRhcmdldCkge1xuICAgIGludCBuID0gbWF0cml4Lmxlbmd0aDtcbiAgICBpbnQgaSA9IDAsIGogPSBuIC0gMSwgY250ID0gMDtcbiAgICB3aGlsZSAoaSA8IG4gJiYgaiA+PSAwKSB7XG4gICAgICBpZiAobWF0cml4W2ldW2pdIDw9IHRhcmdldCkge1xuICAgICAgICBjbnQgKz0gaiArIDE7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaiAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gY250O1xuICB9XG4gIGludCBrdGhTbWFsbGVzdChpbnRbXVtdIG1hdHJpeCwgaW50IGspIHtcbiAgICBpbnQgbiA9IG1hdHJpeC5sZW5ndGg7XG4gICAgaW50IGxvID0gbWF0cml4WzBdWzBdLCBoaSA9IG1hdHJpeFtuIC0gMV1bbiAtIDFdO1xuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICBpbnQgbWlkID0gKGxvICsgaGkpIC8gMjtcbiAgICAgIGludCBjbnQgPSBjb3VudE5vdEdyZWF0ZXIobWF0cml4LCBtaWQpO1xuICAgICAgaWYgKGNudCA8IGspIGxvID0gbWlkICsgMTtcbiAgICAgIGVsc2UgaGkgPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsbztcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBrdGhTbWFsbGVzdChzZWxmLCBtYXRyaXg6IExpc3RbTGlzdFtpbnRdXSwgazogaW50KSAtPiBpbnQ6XG4gICAgICAgIG4gPSBsZW4obWF0cml4KVxuICAgICAgICBsbyA9IG1hdHJpeFswXVswXVxuICAgICAgICBoaSA9IG1hdHJpeFtuIC0gMV1bbiAtIDFdXG5cbiAgICAgICAgZGVmIGNvdW50Tm90R3JlYXRlcih0YXJnZXQ6IGludCkgLT4gaW50OlxuICAgICAgICAgICAgaSwgaiA9IDAsIG4gLSAxXG4gICAgICAgICAgICBjbnQgPSAwXG4gICAgICAgICAgICB3aGlsZSBpIDwgbiBhbmQgaiA+PSAwOlxuICAgICAgICAgICAgICAgIGlmIG1hdHJpeFtpXVtqXSA8PSB0YXJnZXQ6XG4gICAgICAgICAgICAgICAgICAgIGNudCArPSBqICsgMVxuICAgICAgICAgICAgICAgICAgICBpICs9IDFcbiAgICAgICAgICAgICAgICBlbHNlOlxuICAgICAgICAgICAgICAgICAgICBqIC09IDFcbiAgICAgICAgICAgIHJldHVybiBjbnRcblxuICAgICAgICB3aGlsZSBsbyA8IGhpOlxuICAgICAgICAgICAgbWlkID0gKGxvICsgaGkpIC8vIDJcbiAgICAgICAgICAgIGNudCA9IGNvdW50Tm90R3JlYXRlcihtaWQpXG5cbiAgICAgICAgICAgIGlmIGNudCA8IGs6XG4gICAgICAgICAgICAgICAgbG8gPSBtaWQgKyAxXG4gICAgICAgICAgICBlbHNlOlxuICAgICAgICAgICAgICAgIGhpID0gbWlkXG4gICAgICAgIHJldHVybiBsb1xuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIExOS40LjUiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDx2ZWN0b3I+XG4jaW5jbHVkZSA8YWxnb3JpdGhtPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICBpbnQgY291bnROb3RHcmVhdGVyKGludCBtaWQsIGludCBtLCBpbnQgbikge1xuICAgIGludCBjbnQgPSAwO1xuICAgIGZvciAoaW50IGkgPSAxOyBpIDw9IG07IGkrKylcbiAgICAgIGNudCArPSBtaW4obWlkIC8gaSwgbik7XG4gICAgcmV0dXJuIGNudDtcbiAgfVxuICBpbnQgZmluZEt0aE51bWJlcihpbnQgbSwgaW50IG4sIGludCBrKSB7XG4gICAgaW50IGxvID0gMSwgaGkgPSBtICogbjtcbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgaW50IG1pZCA9IChsbyArIGhpKSAvIDI7XG4gICAgICBpZiAoY291bnROb3RHcmVhdGVyKG1pZCwgbSwgbikgPCBrKVxuICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICBlbHNlXG4gICAgICAgIGhpID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG87XG4gIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJpbXBvcnQgamF2YS5sYW5nLk1hdGg7XG5cbnB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBpbnQgY291bnROb3RHcmVhdGVyKGludCBtaWQsIGludCBtLCBpbnQgbikge1xuICAgIGludCBjbnQgPSAwO1xuICAgIGZvciAoaW50IGkgPSAxOyBpIDw9IG07IGkrKylcbiAgICAgIGNudCArPSBNYXRoLm1pbihtaWQgLyBpLCBuKTtcbiAgICByZXR1cm4gY250O1xuICB9XG4gIHB1YmxpYyBpbnQgZmluZEt0aE51bWJlcihpbnQgbSwgaW50IG4sIGludCBrKSB7XG4gICAgaW50IGxvID0gMSwgaGkgPSBtICogbjtcbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgaW50IG1pZCA9IChsbyArIGhpKSAvIDI7XG4gICAgICBpZiAoY291bnROb3RHcmVhdGVyKG1pZCwgbSwgbikgPCBrKVxuICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICBlbHNlXG4gICAgICAgIGhpID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG87XG4gIH1cbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgZmluZEt0aE51bWJlcihzZWxmLCBtOiBpbnQsIG46IGludCwgazogaW50KSAtPiBpbnQ6XG4gICAgICAgIGxvID0gMVxuICAgICAgICBoaSA9IG0gKiBuXG5cbiAgICAgICAgZGVmIGNvdW50Tm90R3JlYXRlcihtaWQ6IGludCwgbTogaW50LCBuOiBpbnQpIC0+IGludDpcbiAgICAgICAgICAgIGNudCA9IDBcbiAgICAgICAgICAgIGZvciBpIGluIHJhbmdlKDEsIG0gKyAxKTpcbiAgICAgICAgICAgICAgICBjbnQgKz0gbWluKG1pZCAvLyBpLCBuKVxuICAgICAgICAgICAgcmV0dXJuIGNudFxuXG4gICAgICAgIHdoaWxlIGxvIDwgaGk6XG4gICAgICAgICAgICBtaWQgPSAobG8gKyBoaSkgLy8gMlxuICAgICAgICAgICAgaWYgY291bnROb3RHcmVhdGVyKG1pZCwgbSwgbikgPCBrOlxuICAgICAgICAgICAgICAgIGxvID0gbWlkICsgMVxuICAgICAgICAgICAgZWxzZTpcbiAgICAgICAgICAgICAgICBoaSA9IG1pZFxuICAgICAgICByZXR1cm4gbG9cblxuIgogICAgfV0KICB9XQp9LCB7CiAgImlkIjogIjIwIiwKICAibmFtZSI6ICLnrKzkuozljYHnq6AiLAogICJsaXN0IjogW3sKICAgICJ0aXRsZSI6ICLku6PnoIEyMC4xLjEiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIlxuI2luY2x1ZGUgPHZlY3Rvcj5cbiNpbmNsdWRlIDxzdHJpbmc+XG4jaW5jbHVkZSA8bWFwPlxuI2luY2x1ZGUgPHF1ZXVlPlxuI2luY2x1ZGUgPHNldD5cbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgdm9pZCBmbGlwKG1hcDxzdHJpbmcsIHN0cmluZz4mIG1hcHBlciwgdmVjdG9yPHN0cmluZz4mIHN0YXRlLCBpbnQgaSwgaW50IG0sIGludCBuKSB7XG4gICAgc3RhdGVbaV0gPSBtYXBwZXJbc3RhdGVbaV1dO1xuICAgIGlmIChpICUgbiAhPSAwKVxuICAgICAgc3RhdGVbaSAtIDFdID0gbWFwcGVyW3N0YXRlW2kgLSAxXV07XG4gICAgaWYgKGkgJSBuIDwgbiAtIDEpXG4gICAgICBzdGF0ZVtpICsgMV0gPSBtYXBwZXJbc3RhdGVbaSArIDFdXTtcbiAgICBpZiAoaSA+PSBuKVxuICAgICAgc3RhdGVbaSAtIG5dID0gbWFwcGVyW3N0YXRlW2kgLSBuXV07XG4gICAgaWYgKGkgPCAobSAtIDEpICogbilcbiAgICAgIHN0YXRlW2kgKyBuXSA9IG1hcHBlcltzdGF0ZVtpICsgbl1dO1xuICB9XG4gIGludCBtaW5GbGlwcyh2ZWN0b3I8dmVjdG9yPGludD4gPiYgbWF0KSB7XG4gICAgbWFwPHN0cmluZywgc3RyaW5nPiBtYXBwZXI7XG4gICAgaW50IG0gPSBtYXQuc2l6ZSgpO1xuICAgIGludCBuID0gbWF0WzBdLnNpemUoKTtcbiAgICBzdHJpbmcgdGFyZ2V0KFwiXCIpLCBjdXIoXCJcIik7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBtOyBpKyspXG4gICAgICBmb3IgKGludCBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICB0YXJnZXQgKz0gXCIwXCI7XG4gICAgICAgIGN1ciArPSB0b19zdHJpbmcobWF0W2ldW2pdKTtcbiAgICAgIH1cbiAgICBxdWV1ZTxzdHJpbmc+IHE7XG4gICAgcS5wdXNoKGN1cik7XG4gICAgc2V0PHN0cmluZz4gdmlzaXRlZDtcbiAgICBpbnQgc3RlcHMgPSAwO1xuICAgIG1hcHBlcltcIjBcIl0gPSBcIjFcIjtcbiAgICBtYXBwZXJbXCIxXCJdID0gXCIwXCI7XG4gICAgd2hpbGUgKCFxLmVtcHR5KCkpIHtcbiAgICAgIGludCBsYXN0X3Ffc2l6ZSA9IHEuc2l6ZSgpO1xuICAgICAgZm9yIChpbnQgZmxnID0gMDsgZmxnIDwgbGFzdF9xX3NpemU7IGZsZysrKSB7XG4gICAgICAgIGN1ciA9IHEuZnJvbnQoKTtcbiAgICAgICAgcS5wb3AoKTtcbiAgICAgICAgaWYgKGN1ciA9PSB0YXJnZXQpIHJldHVybiBzdGVwcztcbiAgICAgICAgaWYgKHZpc2l0ZWQuY291bnQoY3VyKSkgY29udGludWU7XG4gICAgICAgIHZpc2l0ZWQuaW5zZXJ0KGN1cik7XG4gICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgY3VyLmxlbmd0aCgpOyBqKyspIHtcbiAgICAgICAgICB2ZWN0b3I8c3RyaW5nPiBzO1xuICAgICAgICAgIGZvciAoaW50IHd3ID0gMDsgd3cgPCBjdXIubGVuZ3RoKCk7IHd3KyspXG4gICAgICAgICAgICBzLnB1c2hfYmFjayhzdHJpbmcoMSwgY3VyW3d3XSkpO1xuICAgICAgICAgIGZsaXAobWFwcGVyLCBzLCBqLCBtLCBuKTtcbiAgICAgICAgICBzdHJpbmcgdG9fYWRkKFwiXCIpO1xuICAgICAgICAgIGZvciAoaW50IHd3ID0gMDsgd3cgPCBzLnNpemUoKTsgd3crKylcbiAgICAgICAgICAgIHRvX2FkZCArPSBzW3d3XTtcbiAgICAgICAgICBxLnB1c2godG9fYWRkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RlcHMgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG59O1xuXG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJpbXBvcnQgamF2YS51dGlsLio7XG5cbnB1YmxpYyBjbGFzcyBTb2x1dGlvbiB7XG4gICAgTWFwPFN0cmluZywgU3RyaW5nPiBtYXBwZXIgPSBuZXcgSGFzaE1hcDxTdHJpbmcsIFN0cmluZz4oKTtcbiAgICBpbnQgbTtcbiAgICBpbnQgbjtcbiAgICBwcml2YXRlIHZvaWQgZmxpcChTdHJpbmdbXSBzdGF0ZSwgaW50IGkpIHtcbiAgICAgICAgc3RhdGVbaV0gPSBtYXBwZXIuZ2V0KHN0YXRlW2ldKTtcbiAgICAgICAgaWYgKChpICUgbikgIT0gMCkge1xuICAgICAgICAgICAgc3RhdGVbaSAtIDFdID0gbWFwcGVyLmdldChzdGF0ZVtpIC0gMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaSAlIG4pIDwgbiAtIDEpIHtcbiAgICAgICAgICAgIHN0YXRlW2kgKyAxXSA9IG1hcHBlci5nZXQoc3RhdGVbaSArIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+PSBuKSB7XG4gICAgICAgICAgICBzdGF0ZVtpIC0gbl0gPSBtYXBwZXIuZ2V0KHN0YXRlW2kgLSBuXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCAobSAtIDEpICogbikge1xuICAgICAgICAgICAgc3RhdGVbaSArIG5dID0gbWFwcGVyLmdldChzdGF0ZVtpICsgbl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1YmxpYyBpbnQgbWluRmxpcHMoaW50W11bXSBtYXQpIHtcbiAgICAgICAgbSA9IG1hdC5sZW5ndGg7XG4gICAgICAgIG4gPSBtYXRbMF0ubGVuZ3RoO1xuICAgICAgICBpbnRbXVtdIGluaXRpYWwgPSBuZXcgaW50W21dW25dO1xuICAgICAgICBTdHJpbmdCdWZmZXIgdGFyZ2V0QnVmZmVyID0gbmV3IFN0cmluZ0J1ZmZlcigpO1xuICAgICAgICBTdHJpbmdCdWZmZXIgY3VyQnVmZmZlciA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcbiAgICAgICAgZm9yKGludCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgZm9yKGludCBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgICAgIHRhcmdldEJ1ZmZlci5hcHBlbmQoU3RyaW5nLnZhbHVlT2YoaW5pdGlhbFtpXVtqXSkpO1xuICAgICAgICAgICAgICAgIGN1ckJ1ZmZmZXIuYXBwZW5kKFN0cmluZy52YWx1ZU9mKG1hdFtpXVtqXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFN0cmluZyB0YXJnZXQgPSB0YXJnZXRCdWZmZXIudG9TdHJpbmcoKTtcbiAgICAgICAgU3RyaW5nIGN1ciA9IGN1ckJ1ZmZmZXIudG9TdHJpbmcoKTtcbiAgICAgICAgTGlua2VkTGlzdDxTdHJpbmc+IHF1ZXVlID0gbmV3IExpbmtlZExpc3Q8U3RyaW5nPigpO1xuICAgICAgICBxdWV1ZS5vZmZlcihjdXIpO1xuXHRcdFNldCB2aXNpdGVkID0gbmV3IEhhc2hTZXQoKTtcbiAgICAgICAgaW50IHN0ZXBzID0gMDtcbiAgICAgICAgbWFwcGVyLnB1dChcIjBcIiwgXCIxXCIpO1xuICAgICAgICBtYXBwZXIucHV0KFwiMVwiLCBcIjBcIik7XG4gICAgICAgIHdoaWxlICghcXVldWUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBpbnQgc2l6ZSA9IHF1ZXVlLnNpemUoKTtcbiAgICAgICAgICAgIGZvcihpbnQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXIgPSBxdWV1ZS5wb2xsKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5lcXVhbHModGFyZ2V0KSkgcmV0dXJuIHN0ZXBzO1xuICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkLmNvbnRhaW5zKGN1cikpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHZpc2l0ZWQuYWRkKGN1cik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yKGludCBqID0gMDsgaiA8IGN1ci5sZW5ndGgoKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIFN0cmluZ1tdIHMgPSBjdXIuc3BsaXQoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIGZsaXAocywgaik7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLmFkZChTdHJpbmcuam9pbihcIlwiLCBzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RlcHMgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBtaW5GbGlwcyhzZWxmLCBtYXQ6IExpc3RbTGlzdFtpbnRdXSkgLT4gaW50OlxuICAgICAgICAjIOaUvuWIsCBmbGlwIOWHveaVsOWklumdouWPr+S7peWHj+Wwkeiuoeeul1xuICAgICAgICBtYXBwZXIgPSB7XCIwXCI6IFwiMVwiLCBcIjFcIjogXCIwXCJ9XG5cbiAgICAgICAgZGVmIGZsaXAoc3RhdGU6IExpc3Rbc3RyXSwgaTogaW50KSAtPiBOb25lOlxuICAgICAgICAgICAgc3RhdGVbaV0gPSBtYXBwZXJbc3RhdGVbaV1dXG4gICAgICAgICAgICBpZiBpICUgbiAhPSAwOlxuICAgICAgICAgICAgICAgIHN0YXRlW2kgLSAxXSA9IG1hcHBlcltzdGF0ZVtpIC0gMV1dXG4gICAgICAgICAgICBpZiBpICUgbiA8IG4gLSAxOlxuICAgICAgICAgICAgICAgIHN0YXRlW2kgKyAxXSA9IG1hcHBlcltzdGF0ZVtpICsgMV1dXG4gICAgICAgICAgICBpZiBpID49IG46XG4gICAgICAgICAgICAgICAgc3RhdGVbaSAtIG5dID0gbWFwcGVyW3N0YXRlW2kgLSBuXV1cbiAgICAgICAgICAgIGlmIGkgPCAobSAtIDEpICogbjpcbiAgICAgICAgICAgICAgICBzdGF0ZVtpICsgbl0gPSBtYXBwZXJbc3RhdGVbaSArIG5dXVxuXG4gICAgICAgIG0gPSBsZW4obWF0KVxuICAgICAgICBuID0gbGVuKG1hdFswXSlcbiAgICAgICAgdGFyZ2V0ID0gXCIwXCIgKiAobSAqIG4pXG4gICAgICAgIGN1ciA9IFwiXCIuam9pbihzdHIoY2VsbCkgZm9yIHJvdyBpbiBtYXQgZm9yIGNlbGwgaW4gcm93KVxuXG4gICAgICAgIHF1ZXVlID0gW2N1cl1cbiAgICAgICAgdmlzaXRlZCA9IHNldCgpXG4gICAgICAgIHN0ZXBzID0gMFxuXG4gICAgICAgIHdoaWxlIGxlbihxdWV1ZSkgPiAwOlxuICAgICAgICAgICAgZm9yIF8gaW4gcmFuZ2UobGVuKHF1ZXVlKSk6XG4gICAgICAgICAgICAgICAgY3VyID0gcXVldWUucG9wKDApXG4gICAgICAgICAgICAgICAgaWYgY3VyID09IHRhcmdldDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0ZXBzXG4gICAgICAgICAgICAgICAgaWYgY3VyIGluIHZpc2l0ZWQ6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgICAgICAgICB2aXNpdGVkLmFkZChjdXIpXG4gICAgICAgICAgICAgICAgZm9yIGkgaW4gcmFuZ2UobGVuKGN1cikpOlxuICAgICAgICAgICAgICAgICAgICBzID0gbGlzdChjdXIpXG4gICAgICAgICAgICAgICAgICAgIGZsaXAocywgaSlcbiAgICAgICAgICAgICAgICAgICAgcXVldWUuYXBwZW5kKFwiXCIuam9pbihzKSlcbiAgICAgICAgICAgIHN0ZXBzICs9IDFcblxuICAgICAgICByZXR1cm4gLTFcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMjAuMS4yIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8dmVjdG9yPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICB2b2lkIHNldFJvd1plcm9zKHZlY3Rvcjx2ZWN0b3I8aW50PiA+JiBtYXRyaXgsIGludCBpKSB7XG4gICAgZm9yIChpbnQgaiA9IDA7IGogPCBtYXRyaXhbaV0uc2l6ZSgpOyBqKyspXG4gICAgICBtYXRyaXhbaV1bal0gPSAwO1xuICB9XG4gIHZvaWQgc2V0Q29sWmVyb3ModmVjdG9yPHZlY3RvcjxpbnQ+ID4mIG1hdHJpeCwgaW50IGopIHtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG1hdHJpeC5zaXplKCk7IGkrKylcbiAgICAgIG1hdHJpeFtpXVtqXSA9IDA7XG4gIH1cbiAgdm9pZCBzZXRaZXJvZXModmVjdG9yPHZlY3RvcjxpbnQ+ID4mIG1hdHJpeCkge1xuICAgIGJvb2wgaXNDb2wgPSBmYWxzZTtcbiAgICBpbnQgUiA9IG1hdHJpeC5zaXplKCksIEMgPSBtYXRyaXhbMF0uc2l6ZSgpO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUjsgaSsrKSB7XG4gICAgICBpZiAobWF0cml4W2ldWzBdID09IDApIGlzQ29sID0gdHJ1ZTtcbiAgICAgIGZvciAoaW50IGogPSAxOyBqIDwgQzsgaisrKVxuICAgICAgICBpZiAobWF0cml4W2ldW2pdID09IDApIHtcbiAgICAgICAgICBtYXRyaXhbaV1bMF0gPSAwO1xuICAgICAgICAgIG1hdHJpeFswXVtqXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpbnQgaiA9IDE7IGogPCBDOyBqKyspXG4gICAgICBpZiAobWF0cml4WzBdW2pdID09IDApXG4gICAgICAgIHNldENvbFplcm9zKG1hdHJpeCwgaik7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBSOyBpKyspXG4gICAgICBpZiAobWF0cml4W2ldWzBdID09IDApXG4gICAgICAgIHNldFJvd1plcm9zKG1hdHJpeCwgaSk7XG4gICAgaWYgKGlzQ29sKSBzZXRDb2xaZXJvcyhtYXRyaXgsIDApO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb24ge1xuICBwdWJsaWMgdm9pZCBzZXRSb3daZXJvcyhpbnRbXVtdIG1hdHJpeCwgaW50IGkpIHtcbiAgICBmb3IgKGludCBqID0gMDsgaiA8IG1hdHJpeFtpXS5sZW5ndGg7IGorKylcbiAgICAgIG1hdHJpeFtpXVtqXSA9IDA7XG4gIH1cbiAgcHVibGljIHZvaWQgc2V0Q29sWmVvcnMoaW50W11bXSBtYXRyaXgsIGludCBqKSB7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBtYXRyaXgubGVuZ3RoOyBpKyspXG4gICAgICBtYXRyaXhbaV1bal0gPSAwO1xuICB9XG4gIHB1YmxpYyB2b2lkIHNldFplcm9lcyhpbnRbXVtdIG1hdHJpeCkge1xuICAgIGJvb2xlYW4gaXNDb2wgPSBmYWxzZTtcbiAgICBpbnQgUiA9IG1hdHJpeC5sZW5ndGgsIEMgPSBtYXRyaXhbMF0ubGVuZ3RoO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUjsgaSsrKSB7XG4gICAgICBpZiAobWF0cml4W2ldWzBdID09IDApIGlzQ29sID0gdHJ1ZTtcbiAgICAgIGZvciAoaW50IGogPSAxOyBqIDwgQzsgaisrKVxuICAgICAgICBpZiAobWF0cml4W2ldW2pdID09IDApIHtcbiAgICAgICAgICBtYXRyaXhbaV1bMF0gPSAwO1xuICAgICAgICAgIG1hdHJpeFswXVtqXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpbnQgaiA9IDE7IGogPCBDOyBqKyspXG4gICAgICBpZiAobWF0cml4WzBdW2pdID09IDApXG4gICAgICAgIHNldENvbFplb3JzKG1hdHJpeCwgaik7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBSOyBpKyspXG4gICAgICBpZiAobWF0cml4W2ldWzBdID09IDApXG4gICAgICAgIHNldFJvd1plcm9zKG1hdHJpeCwgaSk7XG4gICAgaWYgKGlzQ29sKSBzZXRDb2xaZW9ycyhtYXRyaXgsIDApO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHNldFplcm9lcyhzZWxmLCBtYXRyaXg6IExpc3RbTGlzdFtpbnRdXSkgLT4gTm9uZTpcbiAgICAgICAgXCJcIlwiXG4gICAgICAgIERvIG5vdCByZXR1cm4gYW55dGhpbmcsIG1vZGlmeSBtYXRyaXggaW4tcGxhY2UgaW5zdGVhZC5cbiAgICAgICAgXCJcIlwiXG5cbiAgICAgICAgZGVmIHNldFJvd1plcm9zKG1hdHJpeDogTGlzdFtMaXN0W2ludF1dLCBpOiBpbnQpIC0+IE5vbmU6XG4gICAgICAgICAgICBDID0gbGVuKG1hdHJpeFswXSlcbiAgICAgICAgICAgIG1hdHJpeFtpXSA9IFswXSAqIENcblxuICAgICAgICBkZWYgc2V0Q29sWmVyb3MobWF0cml4OiBMaXN0W0xpc3RbaW50XV0sIGo6IGludCkgLT4gTm9uZTpcbiAgICAgICAgICAgIFIgPSBsZW4obWF0cml4KVxuICAgICAgICAgICAgZm9yIGkgaW4gcmFuZ2UoUik6XG4gICAgICAgICAgICAgICAgbWF0cml4W2ldW2pdID0gMFxuXG4gICAgICAgIGlzQ29sID0gRmFsc2VcbiAgICAgICAgUiA9IGxlbihtYXRyaXgpXG4gICAgICAgIEMgPSBsZW4obWF0cml4WzBdKVxuXG4gICAgICAgIGZvciBpIGluIHJhbmdlKFIpOlxuICAgICAgICAgICAgaWYgbWF0cml4W2ldWzBdID09IDA6XG4gICAgICAgICAgICAgICAgaXNDb2wgPSBUcnVlXG4gICAgICAgICAgICBmb3IgaiBpbiByYW5nZSgxLCBDKTpcbiAgICAgICAgICAgICAgICBpZiBtYXRyaXhbaV1bal0gPT0gMDpcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4W2ldWzBdID0gMFxuICAgICAgICAgICAgICAgICAgICBtYXRyaXhbMF1bal0gPSAwXG4gICAgICAgIGZvciBqIGluIHJhbmdlKDEsIEMpOlxuICAgICAgICAgICAgaWYgbWF0cml4WzBdW2pdID09IDA6XG4gICAgICAgICAgICAgICAgc2V0Q29sWmVyb3MobWF0cml4LCBqKVxuXG4gICAgICAgIGZvciBpIGluIHJhbmdlKFIpOlxuICAgICAgICAgICAgaWYgbWF0cml4W2ldWzBdID09IDA6XG4gICAgICAgICAgICAgICAgc2V0Um93WmVyb3MobWF0cml4LCBpKVxuXG4gICAgICAgIGlmIGlzQ29sOlxuICAgICAgICAgICAgc2V0Q29sWmVyb3MobWF0cml4LCAwKVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIEyMC4xLjMiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDx2ZWN0b3I+XG51c2luZyBuYW1lc3BhY2Ugc3RkO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIHZvaWQgc2V0WmVyb2VzKHZlY3Rvcjx2ZWN0b3I8aW50PiA+JiBtYXRyaXgpIHtcbiAgICBjb25zdCBpbnQgbm9uZSA9IC0weDdmZmZmZmZmO1xuICAgIGludCByb3dzID0gbWF0cml4LnNpemUoKSwgY29scyA9IG1hdHJpeFswXS5zaXplKCk7XG4gICAgZm9yIChpbnQgciA9IDA7IHIgPCByb3dzOyByKyspXG4gICAgICBmb3IgKGludCBjID0gMDsgYyA8IGNvbHM7IGMrKylcbiAgICAgICAgaWYgKG1hdHJpeFtyXVtjXSAhPSBub25lICYmIG1hdHJpeFtyXVtjXSA9PSAwKSB7XG4gICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCByb3dzOyBpKyspXG4gICAgICAgICAgICBtYXRyaXhbaV1bY10gPSAoKG1hdHJpeFtpXVtjXSAhPSAwKSA/IG5vbmUgOiAwKTtcbiAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IGNvbHM7IGorKylcbiAgICAgICAgICAgIG1hdHJpeFtyXVtqXSA9ICgobWF0cml4W3JdW2pdICE9IDApID8gbm9uZSA6IDApO1xuICAgICAgICB9XG4gICAgZm9yIChpbnQgciA9IDA7IHIgPCByb3dzOyByKyspXG4gICAgICBmb3IgKGludCBjID0gMDsgYyA8IGNvbHM7IGMrKylcbiAgICAgICAgaWYgKG1hdHJpeFtyXVtjXSA9PSBub25lKVxuICAgICAgICAgIG1hdHJpeFtyXVtjXSA9IDA7XG4gIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJwdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICBwdWJsaWMgdm9pZCBzZXRaZXJvZXMoaW50W11bXSBtYXRyaXgpIHtcbiAgICBpbnQgbm9uZSA9IC0weDdmZmZmZmZmO1xuICAgIGludCByb3dzID0gbWF0cml4Lmxlbmd0aCwgY29scyA9IG1hdHJpeFswXS5sZW5ndGg7XG4gICAgZm9yIChpbnQgciA9IDA7IHIgPCByb3dzOyByKyspXG4gICAgICBmb3IgKGludCBjID0gMDsgYyA8IGNvbHM7IGMrKylcbiAgICAgICAgaWYgKG1hdHJpeFtyXVtjXSAhPSBub25lICYmIG1hdHJpeFtyXVtjXSA9PSAwKSB7XG4gICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCByb3dzOyBpKyspXG4gICAgICAgICAgICBtYXRyaXhbaV1bY10gPSAoKG1hdHJpeFtpXVtjXSAhPSAwKSA/IG5vbmU6IDApO1xuICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgY29sczsgaisrKVxuICAgICAgICAgICAgbWF0cml4W3JdW2pdID0gKChtYXRyaXhbcl1bal0gIT0gMCkgPyBub25lOiAwKTtcbiAgICAgICAgfVxuICAgIGZvciAoaW50IHIgPSAwOyByIDwgcm93czsgcisrKVxuICAgICAgZm9yIChpbnQgYyA9IDA7IGMgPCBjb2xzOyBjKyspXG4gICAgICAgIGlmIChtYXRyaXhbcl1bY10gPT0gbm9uZSlcbiAgICAgICAgICBtYXRyaXhbcl1bY10gPSAwO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHNldFplcm9lcyhzZWxmLCBtYXRyaXg6IExpc3RbTGlzdFtpbnRdXSkgLT4gTm9uZTpcbiAgICAgICAgXCJcIlwiXG4gICAgICAgIOi/memimOimgeino+WGs+eahOmXrumimOaYr++8jOW/hemhu+acieS4quWcsOaWueiusOW9leWIpOaWree7k+aenO+8jOS9huWPiOS4jeiDveW9seWTjeS4i+S4gOatpeeahOWIpOaWreadoeS7tu+8m1xuICAgICAgICDnm7TmjqXmlLnkuLogMCDnmoTor53vvIzkvJrlvbHlk43kuIvkuIDmraXnmoTliKTmlq3mnaHku7bvvJtcbiAgICAgICAg5Zug5q2k77yM5pyJ5LiA56eN5oCd6Lev5piv5YWI5pS55Li6IE5vbmXvvIzmnIDlkI7lho3lsIYgTm9uZSDmlLnkuLogMO+8m1xuICAgICAgICDku47mnaHku7bkuIrnnIvvvIzlpoLmnpzlj6/ku6XlsIbnrKzkuIDooYzjgIHnrKzkuozooYzkvZzkuLrorrDlvZXnqbrpl7TvvIzpgqPkuYjvvIznlKggTm9uZSDlupTor6XkuZ/kuI3nrpfov53og4zpopjnm67mnaHku7bvvJtcbiAgICAgICAgXCJcIlwiXG4gICAgICAgIHJvd3MgPSBsZW4obWF0cml4KVxuICAgICAgICBjb2xzID0gbGVuKG1hdHJpeFswXSlcbiAgICAgICAgIyDpgY3ljobnn6npmLXvvIznlKggTm9uZSDorrDlvZXopoHmlLnnmoTlnLDmlrnvvIzms6jmhI/lpoLmnpzmmK8gMCDliJnopoHkv53nlZnvvIzlkKbliJnkvJrlvbHlk43kuIvkuIDmraXliKTmlq1cbiAgICAgICAgZm9yIHIgaW4gcmFuZ2Uocm93cyk6XG4gICAgICAgICAgICBmb3IgYyBpbiByYW5nZShjb2xzKTpcbiAgICAgICAgICAgICAgICBpZiBtYXRyaXhbcl1bY10gaXMgbm90IE5vbmUgYW5kIG1hdHJpeFtyXVtjXSA9PSAwOlxuICAgICAgICAgICAgICAgICAgICAjIOaUueWAvFxuICAgICAgICAgICAgICAgICAgICBmb3IgaSBpbiByYW5nZShyb3dzKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeFtpXVtjXSA9IE5vbmUgaWYgbWF0cml4W2ldW2NdICE9IDAgZWxzZSAwXG4gICAgICAgICAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKGNvbHMpOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4W3JdW2pdID0gTm9uZSBpZiBtYXRyaXhbcl1bal0gIT0gMCBlbHNlIDBcbiAgICAgICAgIyDlho3mrKHpgY3ljobvvIzlsIYgTm9uZSDmlLnkuLogMFxuICAgICAgICBmb3IgciBpbiByYW5nZShyb3dzKTpcbiAgICAgICAgICAgIGZvciBjIGluIHJhbmdlKGNvbHMpOlxuICAgICAgICAgICAgICAgIGlmIG1hdHJpeFtyXVtjXSBpcyBOb25lOlxuICAgICAgICAgICAgICAgICAgICBtYXRyaXhbcl1bY10gPSAwXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTIwLjIuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI2luY2x1ZGUgPHZlY3Rvcj5cbiNpbmNsdWRlIDxzdHJpbmc+XG51c2luZyBuYW1lc3BhY2Ugc3RkO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIHZlY3RvcjxpbnQ+IHNlcXVlbnRpYWxEaWdpdHMoaW50IGxvdywgaW50IGhpZ2gpIHtcbiAgICBzdHJpbmcgbnVtYmVycyhcIjEyMzQ1Njc4OVwiKTtcbiAgICB2ZWN0b3I8aW50PiBpbnM7XG4gICAgaW50IG4gPSBudW1iZXJzLnNpemUoKTtcbiAgICBmb3IgKGludCBpID0gMTsgaSA8IG47IGkrKylcbiAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgbiAtIGk7IGorKylcbiAgICAgICAgaW5zLnB1c2hfYmFjayhhdG9pKG51bWJlcnMuc3Vic3RyKGosIGkgKyAxKS5jX3N0cigpKSk7XG4gICAgdmVjdG9yPGludD4gYW5zO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgaW5zLnNpemUoKTsgaSsrKVxuICAgICAgaWYgKGluc1tpXSA+PSBsb3cgJiYgaW5zW2ldIDw9IGhpZ2gpXG4gICAgICAgIGFucy5wdXNoX2JhY2soaW5zW2ldKTtcbiAgICByZXR1cm4gYW5zO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiaW1wb3J0IGphdmEudXRpbC4qO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBMaXN0PEludGVnZXI+IHNlcXVlbnRpYWxEaWdpdHMoaW50IGxvdywgaW50IGhpZ2gpIHtcbiAgICBTdHJpbmcgbnVtYmVycyA9IFwiMTIzNDU2Nzg5XCI7XG4gICAgTGlzdDxJbnRlZ2VyPiBpbnMgPSBuZXcgQXJyYXlMaXN0PD4oKTtcbiAgICBpbnQgbiA9IG51bWJlcnMubGVuZ3RoKCk7XG4gICAgZm9yIChpbnQgaSA9IDE7IGkgPCBuOyBpKyspXG4gICAgICBmb3IgKGludCBqID0gMDsgaiA8IG4gLSBpOyBqKyspXG4gICAgICAgIGlucy5hZGQoSW50ZWdlci5wYXJzZUludChudW1iZXJzLnN1YnN0cmluZyhcbiAgICAgICAgICAgICAgICBqLCBpICsgaiArIDFcbiAgICAgICAgICAgICAgICApKSk7XG4gICAgTGlzdDxJbnRlZ2VyPiBhbnMgPSBuZXcgQXJyYXlMaXN0PD4oKTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IGlucy5zaXplKCk7IGkrKylcbiAgICAgIGlmIChpbnMuZ2V0KGkpID49IGxvdyAmJiBpbnMuZ2V0KGkpIDw9IGhpZ2gpXG4gICAgICAgIGFucy5hZGQoaW5zLmdldChpKSk7XG4gICAgcmV0dXJuIGFucztcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBzZXF1ZW50aWFsRGlnaXRzKHNlbGYsIGxvdzogaW50LCBoaWdoOiBpbnQpIC0+IExpc3RbaW50XTpcbiAgICAgICAgbnVtYmVycyA9IFwiMTIzNDU2Nzg5XCJcbiAgICAgICAgaW5zID0gW11cbiAgICAgICAgbiA9IGxlbihudW1iZXJzKVxuICAgICAgICBmb3IgaSBpbiByYW5nZSgxLCBuKTpcbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKG4gLSBpKTpcbiAgICAgICAgICAgICAgICBpbnMuYXBwZW5kKGludChudW1iZXJzW2ogOiBpICsgaiArIDFdKSlcbiAgICAgICAgcmV0dXJuIFt4IGZvciB4IGluIGlucyBpZiB4ID49IGxvdyBhbmQgeCA8PSBoaWdoXVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIEyMC4yLjIiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDx2ZWN0b3I+XG4jaW5jbHVkZSA8c3RyaW5nPlxuI2luY2x1ZGUgPGFsZ29yaXRobT5cbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgdmVjdG9yPGludD4gc2VxdWVudGlhbERpZ2l0cyhpbnQgbG93LCBpbnQgaGlnaCkge1xuICAgIHN0cmluZyBudW1iZXJzKFwiMTIzNDU2Nzg5XCIpO1xuICAgIHZlY3RvcjxpbnQ+IGlucztcbiAgICBpbnQgbiA9IG51bWJlcnMubGVuZ3RoKCk7XG4gICAgZm9yIChpbnQgaSA9IDE7IGkgPCBuOyBpKyspXG4gICAgICBmb3IgKGludCBqID0gMDsgaiA8IG4gLSBpOyBqKyspXG4gICAgICAgIGlucy5wdXNoX2JhY2soYXRvaShudW1iZXJzLnN1YnN0cihqLCBpICsgMSkuY19zdHIoKSkpO1xuICAgIHZlY3RvcjxpbnQ+OjppdGVyYXRvciBzdCA9IGxvd2VyX2JvdW5kKGlucy5iZWdpbigpLCBpbnMuZW5kKCksIGxvdyk7XG4gICAgdmVjdG9yPGludD46Oml0ZXJhdG9yIGVkID0gdXBwZXJfYm91bmQoaW5zLmJlZ2luKCksIGlucy5lbmQoKSwgaGlnaCk7XG4gICAgdmVjdG9yPGludD4gYW5zO1xuICAgIHdoaWxlIChzdCAhPSBlZCkgYW5zLnB1c2hfYmFjaygqc3QrKyk7XG4gICAgcmV0dXJuIGFucztcbiAgfVxufTtcblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiSmF2YSIsCiAgICAgICJjb250ZW50IjogImltcG9ydCBqYXZhLnV0aWwuKjtcblxucHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGludCBsb3dlcl9ib3VuZChMaXN0PEludGVnZXI+IGFyciwgaW50IGZpcnN0LFxuICAgICAgaW50IGxhc3QsIGludCB2YWx1ZSkge1xuICAgIHdoaWxlIChmaXJzdCA8IGxhc3QpIHtcbiAgICAgIGludCBtaWQgPSBmaXJzdCArIChsYXN0IC0gZmlyc3QpIC8gMjtcbiAgICAgIGlmIChhcnIuZ2V0KG1pZCkgPCB2YWx1ZSkgZmlyc3QgPSBtaWQgKyAxO1xuICAgICAgZWxzZSBsYXN0ID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3Q7XG4gIH1cbiAgcHVibGljIGludCB1cHBlcl9ib3VuZChMaXN0PEludGVnZXI+IGFyciwgaW50IGZpcnN0LFxuICAgICAgaW50IGxhc3QsIGludCB2YWx1ZSkge1xuICAgIHdoaWxlIChmaXJzdCA8IGxhc3QpIHtcbiAgICAgIGludCBtaWQgPSBmaXJzdCArIChsYXN0IC0gZmlyc3QpIC8gMjtcbiAgICAgIGlmIChhcnIuZ2V0KG1pZCkgPD0gdmFsdWUpIGZpcnN0ID0gbWlkICsgMTtcbiAgICAgIGVsc2UgbGFzdCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0O1xuICB9XG4gIExpc3Q8SW50ZWdlcj4gc2VxdWVudGlhbERpZ2l0cyhpbnQgbG93LCBpbnQgaGlnaCkge1xuICAgIFN0cmluZyBudW1iZXJzID0gXCIxMjM0NTY3ODlcIjtcbiAgICBMaXN0PEludGVnZXI+IGlucyA9IG5ldyBBcnJheUxpc3Q8PigpO1xuICAgIGludCBuID0gbnVtYmVycy5sZW5ndGgoKTtcbiAgICBmb3IgKGludCBpID0gMTsgaSA8IG47IGkrKylcbiAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgbiAtIGk7IGorKylcbiAgICAgICAgaW5zLmFkZChJbnRlZ2VyLnBhcnNlSW50KG51bWJlcnMuc3Vic3RyaW5nKFxuICAgICAgICAgICAgICAgIGosIGkgKyBqICsgMVxuICAgICAgICAgICAgICAgICkpKTtcbiAgICBpbnQgc3QgPSBsb3dlcl9ib3VuZChpbnMsIDAsIGlucy5zaXplKCksIGxvdyk7XG4gICAgaW50IGVkID0gdXBwZXJfYm91bmQoaW5zLCAwLCBpbnMuc2l6ZSgpLCBoaWdoKTtcbiAgICBMaXN0PEludGVnZXI+IGFucyA9IG5ldyBBcnJheUxpc3Q8PigpO1xuICAgIGZvciAoOyBzdCAhPSBlZDsgc3QrKylcbiAgICAgIGFucy5hZGQoaW5zLmdldChzdCkpO1xuICAgIHJldHVybiBhbnM7XG4gIH1cbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgc2VxdWVudGlhbERpZ2l0cyhzZWxmLCBsb3c6IGludCwgaGlnaDogaW50KSAtPiBMaXN0W2ludF06XG4gICAgICAgIG51bWJlcnMgPSBcIjEyMzQ1Njc4OVwiXG4gICAgICAgIGlucyA9IFtdXG4gICAgICAgIG4gPSBsZW4obnVtYmVycylcbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMSwgbik6XG4gICAgICAgICAgICBmb3IgaiBpbiByYW5nZShuIC0gaSk6XG4gICAgICAgICAgICAgICAgaW5zLmFwcGVuZChpbnQobnVtYmVyc1tqIDogaSArIGogKyAxXSkpXG4gICAgICAgIHJldHVybiBpbnNbYmlzZWN0LmJpc2VjdF9sZWZ0KGlucywgbG93KSA6IGJpc2VjdC5iaXNlY3QoaW5zLCBoaWdoKV1cblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMjAuMi4zIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8c3RyaW5nPlxuI2luY2x1ZGUgPHZlY3Rvcj5cbiNpbmNsdWRlIDxhbGdvcml0aG0+XG51c2luZyBuYW1lc3BhY2Ugc3RkO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG5wdWJsaWM6XG4gIHZlY3RvcjxpbnQ+IHNlcXVlbnRpYWxEaWdpdHMoaW50IGxvdywgaW50IGhpZ2gpIHtcbiAgICB2ZWN0b3I8aW50PiBpbnMge1xuICAgICAgICAgICAgMTIsXG4gICAgICAgICAgICAyMyxcbiAgICAgICAgICAgIDM0LFxuICAgICAgICAgICAgNDUsXG4gICAgICAgICAgICA1NixcbiAgICAgICAgICAgIDY3LFxuICAgICAgICAgICAgNzgsXG4gICAgICAgICAgICA4OSxcbiAgICAgICAgICAgIDEyMyxcbiAgICAgICAgICAgIDIzNCxcbiAgICAgICAgICAgIDM0NSxcbiAgICAgICAgICAgIDQ1NixcbiAgICAgICAgICAgIDU2NyxcbiAgICAgICAgICAgIDY3OCxcbiAgICAgICAgICAgIDc4OSxcbiAgICAgICAgICAgIDEyMzQsXG4gICAgICAgICAgICAyMzQ1LFxuICAgICAgICAgICAgMzQ1NixcbiAgICAgICAgICAgIDQ1NjcsXG4gICAgICAgICAgICA1Njc4LFxuICAgICAgICAgICAgNjc4OSxcbiAgICAgICAgICAgIDEyMzQ1LFxuICAgICAgICAgICAgMjM0NTYsXG4gICAgICAgICAgICAzNDU2NyxcbiAgICAgICAgICAgIDQ1Njc4LFxuICAgICAgICAgICAgNTY3ODksXG4gICAgICAgICAgICAxMjM0NTYsXG4gICAgICAgICAgICAyMzQ1NjcsXG4gICAgICAgICAgICAzNDU2NzgsXG4gICAgICAgICAgICA0NTY3ODksXG4gICAgICAgICAgICAxMjM0NTY3LFxuICAgICAgICAgICAgMjM0NTY3OCxcbiAgICAgICAgICAgIDM0NTY3ODksXG4gICAgICAgICAgICAxMjM0NTY3OCxcbiAgICAgICAgICAgIDIzNDU2Nzg5LFxuICAgICAgICAgICAgMTIzNDU2Nzg5LFxuICAgIH07XG4gICAgdmVjdG9yPGludD46Oml0ZXJhdG9yIHN0ID0gbG93ZXJfYm91bmQoaW5zLmJlZ2luKCksXG4gICAgICAgIGlucy5lbmQoKSwgbG93KTtcbiAgICB2ZWN0b3I8aW50Pjo6aXRlcmF0b3IgZWQgPSB1cHBlcl9ib3VuZChpbnMuYmVnaW4oKSxcbiAgICAgICAgaW5zLmVuZCgpLCBoaWdoKTtcbiAgICB2ZWN0b3I8aW50PiBhbnM7XG4gICAgd2hpbGUgKHN0ICE9IGVkKSBhbnMucHVzaF9iYWNrKCpzdCsrKTtcbiAgICByZXR1cm4gYW5zO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiaW1wb3J0IGphdmEudXRpbC4qO1xuXG5wdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICBwdWJsaWMgaW50IGxvd2VyX2JvdW5kKGludFtdIGFyciwgaW50IGZpcnN0LCBpbnQgbGFzdCxcbiAgICAgIGludCB2YWx1ZSkge1xuICAgIHdoaWxlIChmaXJzdCA8IGxhc3QpIHtcbiAgICAgIGludCBtaWQgPSBmaXJzdCArIChsYXN0IC0gZmlyc3QpIC8gMjtcbiAgICAgIGlmIChhcnJbbWlkXSA8IHZhbHVlKSBmaXJzdCA9IG1pZCArIDE7XG4gICAgICBlbHNlIGxhc3QgPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBmaXJzdDtcbiAgfVxuICBwdWJsaWMgaW50IHVwcGVyX2JvdW5kKGludFtdIGFyciwgaW50IGZpcnN0LCBpbnQgbGFzdCxcbiAgICAgIGludCB2YWx1ZSkge1xuICAgIHdoaWxlIChmaXJzdCA8IGxhc3QpIHtcbiAgICAgIGludCBtaWQgPSBmaXJzdCArIChsYXN0IC0gZmlyc3QpIC8gMjtcbiAgICAgIGlmIChhcnJbbWlkXSA8PSB2YWx1ZSkgZmlyc3QgPSBtaWQgKyAxO1xuICAgICAgZWxzZSBsYXN0ID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3Q7XG4gIH1cbiAgcHVibGljIExpc3Q8SW50ZWdlcj4gc2VxdWVudGlhbERpZ2l0cyhpbnQgbG93LCBpbnQgaGlnaCkge1xuICAgIGludFtdIGlucyA9IHtcbiAgICAgICAgICAgIDEyLFxuICAgICAgICAgICAgMjMsXG4gICAgICAgICAgICAzNCxcbiAgICAgICAgICAgIDQ1LFxuICAgICAgICAgICAgNTYsXG4gICAgICAgICAgICA2NyxcbiAgICAgICAgICAgIDc4LFxuICAgICAgICAgICAgODksXG4gICAgICAgICAgICAxMjMsXG4gICAgICAgICAgICAyMzQsXG4gICAgICAgICAgICAzNDUsXG4gICAgICAgICAgICA0NTYsXG4gICAgICAgICAgICA1NjcsXG4gICAgICAgICAgICA2NzgsXG4gICAgICAgICAgICA3ODksXG4gICAgICAgICAgICAxMjM0LFxuICAgICAgICAgICAgMjM0NSxcbiAgICAgICAgICAgIDM0NTYsXG4gICAgICAgICAgICA0NTY3LFxuICAgICAgICAgICAgNTY3OCxcbiAgICAgICAgICAgIDY3ODksXG4gICAgICAgICAgICAxMjM0NSxcbiAgICAgICAgICAgIDIzNDU2LFxuICAgICAgICAgICAgMzQ1NjcsXG4gICAgICAgICAgICA0NTY3OCxcbiAgICAgICAgICAgIDU2Nzg5LFxuICAgICAgICAgICAgMTIzNDU2LFxuICAgICAgICAgICAgMjM0NTY3LFxuICAgICAgICAgICAgMzQ1Njc4LFxuICAgICAgICAgICAgNDU2Nzg5LFxuICAgICAgICAgICAgMTIzNDU2NyxcbiAgICAgICAgICAgIDIzNDU2NzgsXG4gICAgICAgICAgICAzNDU2Nzg5LFxuICAgICAgICAgICAgMTIzNDU2NzgsXG4gICAgICAgICAgICAyMzQ1Njc4OSxcbiAgICAgICAgICAgIDEyMzQ1Njc4OVxuICAgIH07XG4gICAgaW50IHN0ID0gbG93ZXJfYm91bmQoaW5zLCAwLCBpbnMubGVuZ3RoLCBsb3cpO1xuICAgIGludCBlZCA9IHVwcGVyX2JvdW5kKGlucywgMCwgaW5zLmxlbmd0aCwgaGlnaCk7XG4gICAgTGlzdDxJbnRlZ2VyPiBhbnMgPSBuZXcgQXJyYXlMaXN0PD4oKTtcbiAgICBmb3IgKGludCBpID0gc3Q7IGkgIT0gZWQ7IGkrKylcbiAgICAgIGFucy5hZGQoaW5zW2ldKTtcbiAgICByZXR1cm4gYW5zO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHNlcXVlbnRpYWxEaWdpdHMoc2VsZiwgbG93OiBpbnQsIGhpZ2g6IGludCkgLT4gTGlzdFtpbnRdOlxuICAgICAgICBpbnMgPSBbXG4gICAgICAgICAgICAxMixcbiAgICAgICAgICAgIDIzLFxuICAgICAgICAgICAgMzQsXG4gICAgICAgICAgICA0NSxcbiAgICAgICAgICAgIDU2LFxuICAgICAgICAgICAgNjcsXG4gICAgICAgICAgICA3OCxcbiAgICAgICAgICAgIDg5LFxuICAgICAgICAgICAgMTIzLFxuICAgICAgICAgICAgMjM0LFxuICAgICAgICAgICAgMzQ1LFxuICAgICAgICAgICAgNDU2LFxuICAgICAgICAgICAgNTY3LFxuICAgICAgICAgICAgNjc4LFxuICAgICAgICAgICAgNzg5LFxuICAgICAgICAgICAgMTIzNCxcbiAgICAgICAgICAgIDIzNDUsXG4gICAgICAgICAgICAzNDU2LFxuICAgICAgICAgICAgNDU2NyxcbiAgICAgICAgICAgIDU2NzgsXG4gICAgICAgICAgICA2Nzg5LFxuICAgICAgICAgICAgMTIzNDUsXG4gICAgICAgICAgICAyMzQ1NixcbiAgICAgICAgICAgIDM0NTY3LFxuICAgICAgICAgICAgNDU2NzgsXG4gICAgICAgICAgICA1Njc4OSxcbiAgICAgICAgICAgIDEyMzQ1NixcbiAgICAgICAgICAgIDIzNDU2NyxcbiAgICAgICAgICAgIDM0NTY3OCxcbiAgICAgICAgICAgIDQ1Njc4OSxcbiAgICAgICAgICAgIDEyMzQ1NjcsXG4gICAgICAgICAgICAyMzQ1Njc4LFxuICAgICAgICAgICAgMzQ1Njc4OSxcbiAgICAgICAgICAgIDEyMzQ1Njc4LFxuICAgICAgICAgICAgMjM0NTY3ODksXG4gICAgICAgICAgICAxMjM0NTY3ODksXG4gICAgICAgIF1cbiAgICAgICAgcmV0dXJuIGluc1tiaXNlY3QuYmlzZWN0X2xlZnQoaW5zLCBsb3cpIDogYmlzZWN0LmJpc2VjdChpbnMsIGhpZ2gpXVxuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIEyMC4yLjQiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDx2ZWN0b3I+XG4jaW5jbHVkZSA8c3RyaW5nPlxuI2luY2x1ZGUgPHF1ZXVlPlxuI2luY2x1ZGUgPHNldD5cbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgaW50IGxhZGRlckxlbmd0aChzdHJpbmcgYmVnaW5Xb3JkLCBzdHJpbmcgZW5kV29yZCxcbiAgICAgIHZlY3RvcjxzdHJpbmc+JiB3b3JkTGlzdCkge1xuICAgIHF1ZXVlPHN0cmluZz4gcTtcbiAgICBxLnB1c2goYmVnaW5Xb3JkKTtcbiAgICBzZXQ8c3RyaW5nPiB2aXNpdGVkO1xuICAgIGludCBzdGVwcyA9IDEsIEwgPSBiZWdpbldvcmQubGVuZ3RoKCk7XG4gICAgd2hpbGUgKCFxLmVtcHR5KCkpIHtcbiAgICAgIGludCBsYXN0X3Ffc2l6ZSA9IHEuc2l6ZSgpO1xuICAgICAgZm9yIChpbnQgZmxnID0gMDsgZmxnIDwgbGFzdF9xX3NpemU7IGZsZysrKSB7XG4gICAgICAgIHN0cmluZyBjdXIgPSBxLmZyb250KCk7XG4gICAgICAgIHEucG9wKCk7XG4gICAgICAgIGlmICh2aXNpdGVkLmNvdW50KGN1cikpIGNvbnRpbnVlO1xuICAgICAgICB2aXNpdGVkLmluc2VydChjdXIpO1xuICAgICAgICBpZiAoY3VyID09IGVuZFdvcmQpIHJldHVybiBzdGVwcztcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBMOyBpKyspXG4gICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCAyNjsgaisrKSB7XG4gICAgICAgICAgICBzdHJpbmcgcyA9IGN1cjtcbiAgICAgICAgICAgIHNbaV0gPSAnYScgKyBqO1xuICAgICAgICAgICAgZm9yIChpbnQgayA9IDA7IGsgPCB3b3JkTGlzdC5zaXplKCk7IGsrKykge1xuICAgICAgICAgICAgICBzdHJpbmcmIHdvcmQgPSB3b3JkTGlzdFtrXTtcbiAgICAgICAgICAgICAgaWYgKHdvcmQgPT0gcylcbiAgICAgICAgICAgICAgICBxLnB1c2god29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RlcHMgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIkphdmEiLAogICAgICAiY29udGVudCI6ICJpbXBvcnQgamF2YS51dGlsLio7XG5cbmNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGludCBsYWRkZXJMZW5ndGgoU3RyaW5nIGJlZ2luV29yZCxcbiAgICAgIFN0cmluZyBlbmRXb3JkLCBMaXN0PFN0cmluZz4gd29yZExpc3QpIHtcbiAgICBRdWV1ZTxTdHJpbmc+IHEgPSBuZXcgTGlua2VkTGlzdDxTdHJpbmc+KCk7XG4gICAgcS5vZmZlcihiZWdpbldvcmQpO1xuICAgIFNldDxTdHJpbmc+IHZpc2l0ZWQgPSBuZXcgSGFzaFNldDxTdHJpbmc+KCk7XG4gICAgaW50IHN0ZXBzID0gMSwgTCA9IGJlZ2luV29yZC5sZW5ndGgoKTtcbiAgICB3aGlsZSAocS5zaXplKCkgIT0gMCkge1xuICAgICAgaW50IGxhc3RfcV9zaXplID0gcS5zaXplKCk7XG4gICAgICBmb3IgKGludCBmbGcgPSAwOyBmbGcgPCBsYXN0X3Ffc2l6ZTsgZmxnKyspIHtcbiAgICAgICAgU3RyaW5nIGN1ciA9IHEucG9sbCgpO1xuICAgICAgICBpZiAodmlzaXRlZC5jb250YWlucyhjdXIpKSBjb250aW51ZTtcbiAgICAgICAgdmlzaXRlZC5hZGQoY3VyKTtcbiAgICAgICAgaWYgKGN1ci5lcXVhbHMoZW5kV29yZCkpIHJldHVybiBzdGVwcztcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBMOyBpKyspXG4gICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCAyNjsgaisrKSB7XG4gICAgICAgICAgICBTdHJpbmcgcyA9IFwiXCI7XG4gICAgICAgICAgICBmb3IgKGludCB3dyA9IDA7IHd3IDwgaTsgd3crKylcbiAgICAgICAgICAgICAgcyA9IHMgKyBTdHJpbmcudmFsdWVPZihjdXIuY2hhckF0KHd3KSk7XG4gICAgICAgICAgICBzID0gcyArIFN0cmluZy52YWx1ZU9mKChjaGFyKSgnYScgKyBqKSk7XG4gICAgICAgICAgICBmb3IgKGludCB3dyA9IGkgKyAxOyB3dyA8IGN1ci5sZW5ndGgoKTsgd3crKylcbiAgICAgICAgICAgICAgcyA9IHMgKyBTdHJpbmcudmFsdWVPZihjdXIuY2hhckF0KHd3KSk7XG4gICAgICAgICAgICBmb3IgKGludCBrID0gMDsgayA8IHdvcmRMaXN0LnNpemUoKTsgaysrKVxuICAgICAgICAgICAgICBpZiAod29yZExpc3QuZ2V0KGspLmVxdWFscyhzKSkge1xuICAgICAgICAgICAgICAgIHEuYWRkKHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RlcHMgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJmcm9tIGNvbGxlY3Rpb25zIGltcG9ydCBkZWZhdWx0ZGljdFxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBsYWRkZXJMZW5ndGgoc2VsZiwgYmVnaW5Xb3JkOiBzdHIsIGVuZFdvcmQ6IHN0ciwgd29yZExpc3Q6IExpc3Rbc3RyXSkgLT4gaW50OlxuICAgICAgICBxdWV1ZSA9IFtiZWdpbldvcmRdXG4gICAgICAgIHZpc2l0ZWQgPSBzZXQoKVxuICAgICAgICBzdGVwcyA9IDFcbiAgICAgICAgTCA9IGxlbihiZWdpbldvcmQpXG5cbiAgICAgICAgd2hpbGUgbGVuKHF1ZXVlKSA+IDA6XG4gICAgICAgICAgICBmb3IgXyBpbiByYW5nZShsZW4ocXVldWUpKTpcbiAgICAgICAgICAgICAgICBjdXIgPSBxdWV1ZS5wb3AoMClcbiAgICAgICAgICAgICAgICBpZiBjdXIgaW4gdmlzaXRlZDpcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICB2aXNpdGVkLmFkZChjdXIpXG4gICAgICAgICAgICAgICAgaWYgY3VyID09IGVuZFdvcmQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGVwc1xuICAgICAgICAgICAgICAgICMg6L+Z6YeM5oiR5Lus5bCd6K+V5p6a5Li+5omA5pyJ5Y+v6IO955qE6L2s5o2i77yM5bm25p+l55yL5piv5ZCm5Zyod29yZExpc3TkuK3vvIzlpoLmnpzlnKjvvIzmiJHku6zlsIblhbbliqDlhaXpmJ/liJdcblxuICAgICAgICAgICAgICAgICMg5Y2V6K+N5Lit55qE5q+P5LiA5L2N6YO96L+b6KGM5Y+Y5o2iXG4gICAgICAgICAgICAgICAgZm9yIGkgaW4gcmFuZ2UoTCk6XG4gICAgICAgICAgICAgICAgICAgICMgY3VyW2ldIOS+neasoeWPmOaIkDI25Liq5bCP5YaZ5a2X5q+N5Lit55qE5q+P5LiA5LiqXG4gICAgICAgICAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKDI2KTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBsaXN0KGN1cilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNbaV0gPSBjaHIob3JkKFwiYVwiKSArIGopXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3Igd29yZCBpbiB3b3JkTGlzdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiB3b3JkID09IFwiXCIuam9pbihzKTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuYXBwZW5kKHdvcmQpXG4gICAgICAgICAgICBzdGVwcyArPSAxXG4gICAgICAgIHJldHVybiAwXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTIwLjIuNSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI2luY2x1ZGUgPHZlY3Rvcj5cbiNpbmNsdWRlIDxzdHJpbmc+XG4jaW5jbHVkZSA8bWFwPlxuI2luY2x1ZGUgPHF1ZXVlPlxuI2luY2x1ZGUgPHNldD5cbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgaW50IGxhZGRlckxlbmd0aChzdHJpbmcgYmVnaW5Xb3JkLCBzdHJpbmcgZW5kV29yZCxcbiAgICAgIHZlY3RvcjxzdHJpbmc+JiB3b3JkTGlzdCkge1xuICAgIHF1ZXVlPHN0cmluZz4gcTtcbiAgICBxLnB1c2goYmVnaW5Xb3JkKTtcbiAgICBzZXQ8c3RyaW5nPiB2aXNpdGVkO1xuICAgIGludCBzdGVwcyA9IDEsIG4gPSB3b3JkTGlzdC5zaXplKCksIEwgPSBiZWdpbldvcmQubGVuZ3RoKCk7XG4gICAgbWFwPHN0cmluZywgdmVjdG9yPHN0cmluZz4gPiB3aXphcmRzO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzdHJpbmcgd29yZCA9IHdvcmRMaXN0W2ldO1xuICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBMOyBqKyspIHtcbiAgICAgICAgc3RyaW5nIGtleSA9IHdvcmQuc3Vic3RyKDAsIGopICsgc3RyaW5nKFwiKlwiKSArIFxcXG4gICAgICAgICAgICAgICAgICAgICB3b3JkLnN1YnN0cihqICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICB3b3JkLmxlbmd0aCgpIC0gaiAtIDEpO1xuICAgICAgICBpZiAoIXdpemFyZHMuY291bnQoa2V5KSlcbiAgICAgICAgICB3aXphcmRzW2tleV0gPSB2ZWN0b3I8c3RyaW5nPigpO1xuICAgICAgICB3aXphcmRzW2tleV0ucHVzaF9iYWNrKHdvcmQpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoIXEuZW1wdHkoKSkge1xuICAgICAgaW50IGxhc3RfcV9zaXplID0gcS5zaXplKCk7XG4gICAgICBmb3IgKGludCBmbGcgPSAwOyBmbGcgPCBsYXN0X3Ffc2l6ZTsgZmxnKyspIHtcbiAgICAgICAgc3RyaW5nIGN1ciA9IHEuZnJvbnQoKTtcbiAgICAgICAgcS5wb3AoKTtcbiAgICAgICAgaWYgKHZpc2l0ZWQuY291bnQoY3VyKSkgY29udGludWU7XG4gICAgICAgIHZpc2l0ZWQuaW5zZXJ0KGN1cik7XG4gICAgICAgIGlmIChjdXIgPT0gZW5kV29yZCkgcmV0dXJuIHN0ZXBzO1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEw7IGkrKykge1xuICAgICAgICAgIHN0cmluZyBrZXkgPSBjdXIuc3Vic3RyKDAsIGkpICsgc3RyaW5nKFwiKlwiKSArIFxcXG4gICAgICAgICAgICAgICAgICAgICAgIGN1ci5zdWJzdHIoaSArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIubGVuZ3RoKCkgLSBpIC0gMSk7XG4gICAgICAgICAgaWYgKCF3aXphcmRzLmNvdW50KGtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgd2l6YXJkc1trZXldLnNpemUoKTsgaisrKVxuICAgICAgICAgICAgcS5wdXNoKHdpemFyZHNba2V5XVtqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0ZXBzICs9IDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiaW1wb3J0IGphdmEudXRpbC4qO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBpbnQgbGFkZGVyTGVuZ3RoKFN0cmluZyBiZWdpbldvcmQsIFN0cmluZyBlbmRXb3JkLFxuICAgICAgTGlzdDxTdHJpbmc+IHdvcmRMaXN0KSB7XG4gICAgUXVldWU8U3RyaW5nPiBxID0gbmV3IExpbmtlZExpc3Q8U3RyaW5nPigpO1xuICAgIHEuYWRkKGJlZ2luV29yZCk7XG4gICAgU2V0PFN0cmluZz4gdmlzaXRlZCA9IG5ldyBIYXNoU2V0PFN0cmluZz4oKTtcbiAgICBpbnQgc3RlcHMgPSAxLCBuID0gd29yZExpc3Quc2l6ZSgpLFxuICAgICAgICBMID0gYmVnaW5Xb3JkLmxlbmd0aCgpO1xuICAgIE1hcDxTdHJpbmcsIExpc3Q8U3RyaW5nPiA+IHdpemFyZHMgPVxuICAgICAgbmV3IEhhc2hNYXA8U3RyaW5nLCBMaXN0PFN0cmluZz4gPigpO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBTdHJpbmcgd29yZCA9IHdvcmRMaXN0LmdldChpKTtcbiAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgTDsgaisrKSB7XG4gICAgICAgIFN0cmluZyBrZXkgPSB3b3JkLnN1YnN0cmluZygwLCBqKSArIFwiKlwiXG4gICAgICAgICAgKyB3b3JkLnN1YnN0cmluZyhqICsgMSwgd29yZC5sZW5ndGgoKSk7XG4gICAgICAgIGlmICh3aXphcmRzLmdldChrZXkpID09IG51bGwpIHtcbiAgICAgICAgICBMaXN0PFN0cmluZz4gbWFnaWMgPSBuZXcgQXJyYXlMaXN0PD4oKTtcbiAgICAgICAgICB3aXphcmRzLnB1dChrZXksIG1hZ2ljKTtcbiAgICAgICAgfVxuICAgICAgICBMaXN0PFN0cmluZz4gbWFnaWMgPSB3aXphcmRzLmdldChrZXkpO1xuICAgICAgICBtYWdpYy5hZGQod29yZCk7XG4gICAgICAgIHdpemFyZHMucHV0KGtleSwgbWFnaWMpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAocS5zaXplKCkgIT0gMCkge1xuICAgICAgaW50IGxhc3RfcV9zaXplID0gcS5zaXplKCk7XG4gICAgICBmb3IgKGludCBmbGcgPSAwOyBmbGcgPCBsYXN0X3Ffc2l6ZTsgZmxnKyspIHtcbiAgICAgICAgU3RyaW5nIGN1ciA9IHEucG9sbCgpO1xuICAgICAgICBpZiAodmlzaXRlZC5jb250YWlucyhjdXIpKSBjb250aW51ZTtcbiAgICAgICAgdmlzaXRlZC5hZGQoY3VyKTtcbiAgICAgICAgaWYgKGN1ci5lcXVhbHMoZW5kV29yZCkpIHJldHVybiBzdGVwcztcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBMOyBpKyspIHtcbiAgICAgICAgICBTdHJpbmcga2V5ID0gY3VyLnN1YnN0cmluZygwLCBpKSArIFwiKlwiXG4gICAgICAgICAgICArIGN1ci5zdWJzdHJpbmcoaSArIDEsIGN1ci5sZW5ndGgoKSk7XG4gICAgICAgICAgaWYgKHdpemFyZHMuZ2V0KGtleSkgPT0gbnVsbCkgY29udGludWU7XG4gICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCB3aXphcmRzLmdldChrZXkpLnNpemUoKTsgaisrKVxuICAgICAgICAgICAgcS5hZGQod2l6YXJkcy5nZXQoa2V5KS5nZXQoaikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGVwcyArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImZyb20gY29sbGVjdGlvbnMgaW1wb3J0IGRlZmF1bHRkaWN0XG5cblxuY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGxhZGRlckxlbmd0aChzZWxmLCBiZWdpbldvcmQ6IHN0ciwgZW5kV29yZDogc3RyLCB3b3JkTGlzdDogTGlzdFtzdHJdKSAtPiBpbnQ6XG4gICAgICAgIHF1ZXVlID0gW2JlZ2luV29yZF1cbiAgICAgICAgdmlzaXRlZCA9IHNldCgpXG4gICAgICAgIHN0ZXBzID0gMVxuICAgICAgICBuID0gbGVuKHdvcmRMaXN0KVxuICAgICAgICBMID0gbGVuKGJlZ2luV29yZClcbiAgICAgICAgd2l6YXJkcyA9IGRlZmF1bHRkaWN0KGxpc3QpXG4gICAgICAgIGZvciBpIGluIHJhbmdlKG4pOlxuICAgICAgICAgICAgd29yZCA9IHdvcmRMaXN0W2ldXG4gICAgICAgICAgICBmb3IgaiBpbiByYW5nZShMKTpcbiAgICAgICAgICAgICAgICB3aXphcmRzW3dvcmRbOmpdICsgXCIqXCIgKyB3b3JkW2ogKyAxIDpdXS5hcHBlbmQod29yZClcblxuICAgICAgICB3aGlsZSBsZW4ocXVldWUpID4gMDpcbiAgICAgICAgICAgIGZvciBfIGluIHJhbmdlKGxlbihxdWV1ZSkpOlxuICAgICAgICAgICAgICAgIGN1ciA9IHF1ZXVlLnBvcCgwKVxuICAgICAgICAgICAgICAgIGlmIGN1ciBpbiB2aXNpdGVkOlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgIHZpc2l0ZWQuYWRkKGN1cilcbiAgICAgICAgICAgICAgICBpZiBjdXIgPT0gZW5kV29yZDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0ZXBzXG4gICAgICAgICAgICAgICAgZm9yIGkgaW4gcmFuZ2UoTCk6XG4gICAgICAgICAgICAgICAgICAgIGZvciB3b3JkIGluIHdpemFyZHMuZ2V0KGN1cls6aV0gKyBcIipcIiArIGN1cltpICsgMSA6XSwgW10pOlxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuYXBwZW5kKHdvcmQpXG5cbiAgICAgICAgICAgIHN0ZXBzICs9IDFcbiAgICAgICAgcmV0dXJuIDBcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMjAuMy4xIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8dmVjdG9yPlxuI2luY2x1ZGUgPGNzdGRsaWI+XG4jaW5jbHVkZSA8YWxnb3JpdGhtPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICBpbnQgY291bnRTcXVhcmVzKHZlY3Rvcjx2ZWN0b3I8aW50PiA+JiBtYXRyaXgpIHtcbiAgICBpbnQgcmVzID0gMCwgbSA9IG1hdHJpeC5zaXplKCksIG4gPSBtYXRyaXhbMF0uc2l6ZSgpO1xuICAgIGludCAqKmRwID0gKGludCAqKiltYWxsb2MoKG0gKyAxKSAqIHNpemVvZihpbnQgKikpO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDw9IG07IGkrKykge1xuICAgICAgZHBbaV0gPSAoaW50ICopbWFsbG9jKChuICsgMSkgKiBzaXplb2YoaW50KSk7XG4gICAgICBmb3IgKGludCBqID0gMDsgaiA8PSBuOyBqKyspIGRwW2ldW2pdID0gMDtcbiAgICB9XG4gICAgZm9yIChpbnQgaSA9IDE7IGkgPD0gbTsgaSsrKVxuICAgICAgZm9yIChpbnQgaiA9IDE7IGogPD0gbjsgaisrKSB7XG4gICAgICAgIGlmIChtYXRyaXhbaSAtIDFdW2ogLSAxXSA9PSAxKVxuICAgICAgICAgIGRwW2ldW2pdID0gbWluKG1pbihkcFtpIC0gMV1bal0sIGRwW2ldW2ogLSAxXSksXFxcbiAgICAgICAgICAgICAgZHBbaSAtIDFdW2ogLSAxXSkgKyAxO1xuICAgICAgICByZXMgKz0gZHBbaV1bal07XG4gICAgICB9XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPD0gbTsgaSsrKSBmcmVlKGRwW2ldKTtcbiAgICBmcmVlKGRwKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiaW1wb3J0IGphdmEubGFuZy5NYXRoO1xuXG5wdWJsaWMgY2xhc3MgU29sdXRpb24ge1xuICBwdWJsaWMgaW50IGNvdW50U3F1YXJlcyhpbnRbXVtdIG1hdHJpeCkge1xuICAgIGludCByZXMgPSAwLCBtID0gbWF0cml4Lmxlbmd0aCxcbiAgICAgICAgbiA9IG1hdHJpeFswXS5sZW5ndGg7XG4gICAgaW50W11bXSBkcCA9IG5ldyBpbnRbbSArIDFdW24gKyAxXTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8PSBtOyBpKyspXG4gICAgICBmb3IgKGludCBqID0gMDsgaiA8PSBuOyBqKyspIGRwW2ldW2pdID0gMDtcbiAgICBmb3IgKGludCBpID0gMTsgaSA8PSBtOyBpKyspXG4gICAgICBmb3IgKGludCBqID0gMTsgaiA8PSBuOyBqKyspIHtcbiAgICAgICAgaWYgKG1hdHJpeFtpIC0gMV1baiAtIDFdID09IDEpXG4gICAgICAgICAgZHBbaV1bal0gPSBNYXRoLm1pbihNYXRoLm1pbihkcFtpIC0gMV1bal0sXG4gICAgICAgICAgICAgIGRwW2ldW2ogLSAxXSksIGRwW2kgLSAxXVtqIC0gMV0pICsgMTtcbiAgICAgICAgcmVzICs9IGRwW2ldW2pdO1xuICAgICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJjbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgY291bnRTcXVhcmVzKHNlbGYsIG1hdHJpeDogTGlzdFtMaXN0W2ludF1dKSAtPiBpbnQ6XG4gICAgICAgIHJlcyA9IDBcbiAgICAgICAgbSA9IGxlbihtYXRyaXgpXG4gICAgICAgIG4gPSBsZW4obWF0cml4WzBdKVxuICAgICAgICBkcCA9IFtbMF0gKiAobiArIDEpIGZvciBfIGluIHJhbmdlKG0gKyAxKV1cbiAgICAgICAgZm9yIGkgaW4gcmFuZ2UoMSwgbSArIDEpOlxuICAgICAgICAgICAgZm9yIGogaW4gcmFuZ2UoMSwgbiArIDEpOlxuICAgICAgICAgICAgICAgIGlmIG1hdHJpeFtpIC0gMV1baiAtIDFdID09IDE6XG4gICAgICAgICAgICAgICAgICAgIGRwW2ldW2pdID0gbWluKGRwW2kgLSAxXVtqXSwgZHBbaV1baiAtIDFdLCBkcFtpIC0gMV1baiAtIDFdKSArIDFcbiAgICAgICAgICAgICAgICByZXMgKz0gZHBbaV1bal1cbiAgICAgICAgcmV0dXJuIHJlc1xuXG4iCiAgICB9XQogIH0sIHsKICAgICJ0aXRsZSI6ICLku6PnoIEyMC4zLjIiLAogICAgImNvZGVzIjogW3sKICAgICAgImxhbmd1YWdlIjogIkNwcCIsCiAgICAgICJjb250ZW50IjogIiNpbmNsdWRlIDxzdHJpbmc+XG4jaW5jbHVkZSA8bWFwPlxuI2luY2x1ZGUgPGFsZ29yaXRobT5cbiNpbmNsdWRlIDxjc3RyaW5nPlxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcblxuY2xhc3MgU29sdXRpb24ge1xucHVibGljOlxuICBpbnQgbWF4RnJlcShzdHJpbmcgcywgaW50IG1heExldHRlcnMsIGludCBtaW5TaXplLFxuICAgICAgaW50IG1heFNpemUpIHtcbiAgICBtYXA8c3RyaW5nLCBpbnQ+IGNvdW50ZXI7XG4gICAgaW50IHJlcyA9IDA7XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBzLnNpemUoKSAtIG1pblNpemUgKyAxOyBpKyspXG4gICAgICBmb3IgKGludCBsZW5ndGggPSBtaW5TaXplOyBsZW5ndGggPD0gbWF4U2l6ZTsgbGVuZ3RoKyspIHtcbiAgICAgICAgaWYgKGkgKyBsZW5ndGggPiBzLmxlbmd0aCgpKSBicmVhaztcbiAgICAgICAgYm9vbCBhbHBoYVsyNl07XG4gICAgICAgIG1lbXNldChhbHBoYSwgMCwgc2l6ZW9mKGFscGhhKSk7XG4gICAgICAgIGludCBjbnQgPSAwO1xuICAgICAgICBzdHJpbmcgc3ViKFwiXCIpO1xuICAgICAgICBmb3IgKGludCB3dyA9IDA7IHd3IDwgbGVuZ3RoOyB3dysrKSB7XG4gICAgICAgICAgc3ViLnB1c2hfYmFjayhzW2kgKyB3d10pO1xuICAgICAgICAgIGlmICghYWxwaGFbc1tpICsgd3ddIC0gJ2EnXSkge1xuICAgICAgICAgICAgKytjbnQ7XG4gICAgICAgICAgICBhbHBoYVtzW2kgKyB3d10gLSAnYSddID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNudCA8PSBtYXhMZXR0ZXJzKSB7XG4gICAgICAgICAgaW50IGJ1Zl92YWw7XG4gICAgICAgICAgYnVmX3ZhbCA9IGNvdW50ZXJbc3ViXSA9IChjb3VudGVyLmNvdW50KHN1YikgPyBcXFxuICAgICAgICAgICAgICBjb3VudGVyW3N1Yl0gOiAwKSArIDE7XG4gICAgICAgICAgcmVzID0gbWF4KHJlcywgYnVmX3ZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiaW1wb3J0IGphdmEudXRpbC4qO1xuaW1wb3J0IGphdmEubGFuZy5NYXRoO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBpbnQgbWF4RnJlcShTdHJpbmcgcywgaW50IG1heExldHRlcnMsXG4gICAgICBpbnQgbWluU2l6ZSwgaW50IG1heFNpemUpIHtcbiAgICBNYXA8U3RyaW5nLCBJbnRlZ2VyPiBjb3VudGVyID1cbiAgICAgIG5ldyBIYXNoTWFwPFN0cmluZywgSW50ZWdlcj4oKTtcbiAgICBpbnQgcmVzID0gMDtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IHMubGVuZ3RoKCkgLSBtaW5TaXplICsgMTsgaSsrKVxuICAgICAgZm9yIChpbnQgbGVuZ3RoID0gbWluU2l6ZTsgbGVuZ3RoIDw9IG1heFNpemU7XG4gICAgICAgICAgbGVuZ3RoKyspIHtcbiAgICAgICAgaWYgKGkgKyBsZW5ndGggPiBzLmxlbmd0aCgpKSBicmVhaztcbiAgICAgICAgU3RyaW5nIHN1YiA9IHMuc3Vic3RyaW5nKGksIGkgKyBsZW5ndGgpO1xuICAgICAgICBib29sZWFuW10gYWxwaGEgPSBuZXcgYm9vbGVhblsyNl07XG4gICAgICAgIGludCBjbnQgPSAwO1xuICAgICAgICBmb3IgKGludCB3dyA9IDA7IHd3IDwgc3ViLmxlbmd0aCgpOyB3dysrKVxuICAgICAgICAgIGlmICghYWxwaGFbc3ViLmNoYXJBdCh3dykgLSAnYSddKSB7XG4gICAgICAgICAgICBjbnQgKz0gMTtcbiAgICAgICAgICAgIGFscGhhW3N1Yi5jaGFyQXQod3cpIC0gJ2EnXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICBpZiAoY250IDw9IG1heExldHRlcnMpIHtcbiAgICAgICAgICBpZiAoY291bnRlci5nZXQoc3ViKSA9PSBudWxsKVxuICAgICAgICAgICAgY291bnRlci5wdXQoc3ViLCAwKTtcbiAgICAgICAgICBjb3VudGVyLnB1dChzdWIsIGNvdW50ZXIuZ2V0KHN1YikgKyAxKTtcbiAgICAgICAgICByZXMgPSBNYXRoLm1heChyZXMsIGNvdW50ZXIuZ2V0KHN1YikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxufVxuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJQeSIsCiAgICAgICJjb250ZW50IjogImNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBtYXhGcmVxKHNlbGYsIHM6IHN0ciwgbWF4TGV0dGVyczogaW50LCBtaW5TaXplOiBpbnQsIG1heFNpemU6IGludCkgLT4gaW50OlxuICAgICAgICBjb3VudGVyLCByZXMgPSB7fSwgMFxuICAgICAgICBmb3IgaSBpbiByYW5nZSgwLCBsZW4ocykgLSBtaW5TaXplICsgMSk6XG4gICAgICAgICAgICBmb3IgbGVuZ3RoIGluIHJhbmdlKG1pblNpemUsIG1heFNpemUgKyAxKTpcbiAgICAgICAgICAgICAgICBpZiBpICsgbGVuZ3RoID4gbGVuKHMpOlxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIHN1YiA9IHNbaSA6IGkgKyBsZW5ndGhdXG4gICAgICAgICAgICAgICAgaWYgbGVuKHNldChzdWIpKSA8PSBtYXhMZXR0ZXJzOlxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyW3N1Yl0gPSBjb3VudGVyLmdldChzdWIsIDApICsgMVxuICAgICAgICAgICAgICAgICAgICByZXMgPSBtYXgocmVzLCBjb3VudGVyW3N1Yl0pXG4gICAgICAgIHJldHVybiByZXNcblxuIgogICAgfV0KICB9LCB7CiAgICAidGl0bGUiOiAi5Luj56CBMjAuMy4zIiwKICAgICJjb2RlcyI6IFt7CiAgICAgICJsYW5ndWFnZSI6ICJDcHAiLAogICAgICAiY29udGVudCI6ICIjaW5jbHVkZSA8c3RyaW5nPlxuI2luY2x1ZGUgPGFsZ29yaXRobT5cbiNpbmNsdWRlIDxtYXA+XG4jaW5jbHVkZSA8Y3N0cmluZz5cbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgaW50IG1heEZyZXEoc3RyaW5nIHMsIGludCBtYXhMZXR0ZXJzLCBpbnQgbWluU2l6ZSwgXFxcbiAgICAgIGludCBtYXhTaXplKSB7XG4gICAgbWFwPHN0cmluZywgaW50PiBjb3VudGVyO1xuICAgIGludCByZXMgPSAwO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDw9IHMubGVuZ3RoKCkgLSBtaW5TaXplOyBpKyspIHtcbiAgICAgIHN0cmluZyBzdWIgPSBzLnN1YnN0cihpLCBtaW5TaXplKTtcbiAgICAgIGJvb2wgYWxwaGFbMjZdO1xuICAgICAgbWVtc2V0KGFscGhhLCAwLCBzaXplb2YoYWxwaGEpKTtcbiAgICAgIGludCBjbnQgPSAwO1xuICAgICAgZm9yIChpbnQgd3cgPSAwOyB3dyA8IHN1Yi5sZW5ndGgoKTsgd3crKylcbiAgICAgICAgaWYgKCFhbHBoYVtzdWJbd3ddIC0gJ2EnXSkge1xuICAgICAgICAgICsrY250O1xuICAgICAgICAgIGFscGhhW3N1Ylt3d10gLSAnYSddID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgaWYgKGNudCA8PSBtYXhMZXR0ZXJzKSB7XG4gICAgICAgIGNvdW50ZXJbc3ViXSA9IChjb3VudGVyLmNvdW50KHN1YikgPyBcXFxuICAgICAgICAgICAgY291bnRlcltzdWJdIDogMCk7XG4gICAgICAgIGNvdW50ZXJbc3ViXSArPSAxO1xuICAgICAgICByZXMgPSBtYXgocmVzLCBjb3VudGVyW3N1Yl0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAiaW1wb3J0IGphdmEudXRpbC4qO1xuaW1wb3J0IGphdmEubGFuZy5NYXRoO1xuXG5jbGFzcyBTb2x1dGlvbiB7XG4gIHB1YmxpYyBpbnQgbWF4RnJlcShTdHJpbmcgcywgaW50IG1heExldHRlcnMsXG4gICAgICBpbnQgbWluU2l6ZSwgaW50IG1heFNpemUpIHtcbiAgICBNYXA8U3RyaW5nLCBJbnRlZ2VyPiBjb3VudGVyID1cbiAgICAgIG5ldyBIYXNoTWFwPFN0cmluZywgSW50ZWdlcj4oKTtcbiAgICBpbnQgcmVzID0gMDtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8PSBzLmxlbmd0aCgpIC0gbWluU2l6ZTsgaSsrKSB7XG4gICAgICBTdHJpbmcgc3ViID0gcy5zdWJzdHJpbmcoaSwgaSArIG1pblNpemUpO1xuICAgICAgYm9vbGVhbltdIGFscGhhID0gbmV3IGJvb2xlYW5bMjZdO1xuICAgICAgaW50IGNudCA9IDA7XG4gICAgICBmb3IgKGludCB3dyA9IDA7IHd3IDwgc3ViLmxlbmd0aCgpOyB3dysrKVxuICAgICAgICBpZiAoIWFscGhhW3N1Yi5jaGFyQXQod3cpIC0gJ2EnXSkge1xuICAgICAgICAgICsrY250O1xuICAgICAgICAgIGFscGhhW3N1Yi5jaGFyQXQod3cpIC0gJ2EnXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIGlmIChjbnQgPD0gbWF4TGV0dGVycykge1xuICAgICAgICBpZiAoY291bnRlci5nZXQoc3ViKSA9PSBudWxsKVxuICAgICAgICAgIGNvdW50ZXIucHV0KHN1YiwgMCk7XG4gICAgICAgIGNvdW50ZXIucHV0KHN1YiwgY291bnRlci5nZXQoc3ViKSArIDEpO1xuICAgICAgICByZXMgPSBNYXRoLm1heChyZXMsIGNvdW50ZXIuZ2V0KHN1YikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiY2xhc3MgU29sdXRpb246XG4gICAgZGVmIG1heEZyZXEoc2VsZiwgczogc3RyLCBtYXhMZXR0ZXJzOiBpbnQsIG1pblNpemU6IGludCwgbWF4U2l6ZTogaW50KSAtPiBpbnQ6XG4gICAgICAgIGNvdW50ZXIsIHJlcyA9IHt9LCAwXG4gICAgICAgIGZvciBpIGluIHJhbmdlKDAsIGxlbihzKSAtIG1pblNpemUgKyAxKTpcbiAgICAgICAgICAgIHN1YiA9IHNbaSA6IGkgKyBtaW5TaXplXVxuICAgICAgICAgICAgaWYgbGVuKHNldChzdWIpKSA8PSBtYXhMZXR0ZXJzOlxuICAgICAgICAgICAgICAgIGNvdW50ZXJbc3ViXSA9IGNvdW50ZXIuZ2V0KHN1YiwgMCkgKyAxXG4gICAgICAgICAgICAgICAgcmVzID0gbWF4KHJlcywgY291bnRlcltzdWJdKVxuICAgICAgICByZXR1cm4gcmVzXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTIwLjQuMSIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI2luY2x1ZGUgPHZlY3Rvcj5cbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgaW50IGNudExpdmVDZWxsKGludCBpLCBpbnQgaiwgXFxcbiAgICAgIGNvbnN0IHZlY3Rvcjx2ZWN0b3I8aW50PiA+JiBvbGQpIHtcbiAgICBpbnQgY250ID0gMCwgbSA9IG9sZC5zaXplKCksIG4gPSBvbGRbMF0uc2l6ZSgpO1xuICAgIGludCBkaXJlY3Rpb25zWzhdWzJdID0ge1xuICAgICAgezAsIDF9LFxuICAgICAgezAsIC0xfSxcbiAgICAgIHstMSwgMH0sXG4gICAgICB7MSwgMH0sXG4gICAgICB7MSwgMX0sXG4gICAgICB7MSwgLTF9LFxuICAgICAgey0xLCAxfSxcbiAgICAgIHstMSwgLTF9XG4gICAgfTtcbiAgICBmb3IgKGludCBwID0gMDsgcCA8IDg7IHArKykge1xuICAgICAgaW50IGR4ID0gZGlyZWN0aW9uc1twXVswXSwgZHkgPSBkaXJlY3Rpb25zW3BdWzFdO1xuICAgICAgaWYgKGkgKyBkeCA+PSAwICYmIGkgKyBkeCA8IG0gJiYgaiArIGR5ID49IDAgJiYgXFxcbiAgICAgICAgICBqICsgZHkgPCBuKVxuICAgICAgICBjbnQgKz0gb2xkW2kgKyBkeF1baiArIGR5XTtcbiAgICB9XG4gICAgcmV0dXJuIGNudDtcbiAgfVxuICB2b2lkIGdhbWVPZkxpZmUodmVjdG9yPHZlY3RvcjxpbnQ+ID4mIGJvYXJkKSB7XG4gICAgaW50IG0gPSBib2FyZC5zaXplKCk7XG4gICAgaWYgKG0gPD0gMCkgcmV0dXJuO1xuICAgIGludCBuID0gYm9hcmRbMF0uc2l6ZSgpO1xuICAgIGlmIChuIDw9IDApIHJldHVybjtcbiAgICB2ZWN0b3I8dmVjdG9yPGludD4gPiBvbGQgPSBib2FyZDtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG07IGkrKylcbiAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGludCBjbnQgPSBjbnRMaXZlQ2VsbChpLCBqLCBvbGQpO1xuICAgICAgICBpZiAob2xkW2ldW2pdID09IDAgJiYgY250ID09IDMpXG4gICAgICAgICAgYm9hcmRbaV1bal0gPSAxO1xuICAgICAgICBpZiAob2xkW2ldW2pdID09IDEgJiYgKGNudCA+IDMgfHwgY250IDwgMikpXG4gICAgICAgICAgYm9hcmRbaV1bal0gPSAwO1xuICAgICAgfVxuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGludCBjbnRMaXZlQ2VsbChpbnQgaSwgaW50IGosXG4gICAgICBpbnRbXVtdIG9sZCkge1xuICAgIGludCBjbnQgPSAwLCBtID0gb2xkLmxlbmd0aCwgbiA9IG9sZFswXS5sZW5ndGg7XG4gICAgaW50W11bXSBkaXJlY3Rpb25zID0ge1xuICAgICAgezAsMX0sXG4gICAgICB7MCwtMX0sXG4gICAgICB7LTEsMH0sXG4gICAgICB7MSwwfSxcbiAgICAgIHsxLDF9LFxuICAgICAgezEsLTF9LFxuICAgICAgey0xLDF9LFxuICAgICAgey0xLC0xfVxuICAgIH07XG4gICAgZm9yIChpbnQgcCA9IDA7IHAgPCA4OyBwKyspIHtcbiAgICAgIGludCBkeCA9IGRpcmVjdGlvbnNbcF1bMF0sIGR5ID0gZGlyZWN0aW9uc1twXVsxXTtcbiAgICAgIGlmIChpICsgZHggPj0gMCAmJiBpICsgZHggPCBtICYmIGogKyBkeSA+PSAwICYmXG4gICAgICAgICAgaiArIGR5IDwgbilcbiAgICAgICAgY250ICs9IG9sZFtpICsgZHhdW2ogKyBkeV07XG4gICAgfVxuICAgIHJldHVybiBjbnQ7XG4gIH1cbiAgdm9pZCBnYW1lT2ZMaWZlKGludFtdW10gYm9hcmQpIHtcbiAgICBpbnQgbSA9IGJvYXJkLmxlbmd0aDtcbiAgICBpZiAobSA8PSAwKSByZXR1cm47XG4gICAgaW50IG4gPSBib2FyZFswXS5sZW5ndGg7XG4gICAgaWYgKG4gPD0gMCkgcmV0dXJuO1xuICAgIGludFtdW10gb2xkID0gbmV3IGludFttXVtuXTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG07IGkrKylcbiAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgbjsgaisrKSBvbGRbaV1bal0gPSBib2FyZFtpXVtqXTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG07IGkrKylcbiAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGludCBjbnQgPSBjbnRMaXZlQ2VsbChpLCBqLCBvbGQpO1xuICAgICAgICBpZiAob2xkW2ldW2pdID09IDAgJiYgY250ID09IDMpXG4gICAgICAgICAgYm9hcmRbaV1bal0gPSAxO1xuICAgICAgICBpZiAob2xkW2ldW2pdID09IDEgJiYgKGNudCA+IDMgfHwgY250IDwgMikpXG4gICAgICAgICAgYm9hcmRbaV1bal0gPSAwO1xuICAgICAgfVxuICB9XG59XG5cbiIKICAgIH0sIHsKICAgICAgImxhbmd1YWdlIjogIlB5IiwKICAgICAgImNvbnRlbnQiOiAiaW1wb3J0IGNvcHlcblxuXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgZ2FtZU9mTGlmZShzZWxmLCBib2FyZDogTGlzdFtMaXN0W2ludF1dKSAtPiBOb25lOlxuICAgICAgICBtID0gbGVuKGJvYXJkKVxuICAgICAgICBuID0gbGVuKGJvYXJkWzBdKVxuICAgICAgICBpZiBtIDw9IDAgb3IgbiA8PSAwOlxuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIG9sZCA9IGNvcHkuZGVlcGNvcHkoYm9hcmQpXG5cbiAgICAgICAgZGVmIGNudExpdmVDZWxsKGk6IGludCwgajogaW50KSAtPiBpbnQ6XG4gICAgICAgICAgICBjbnQgPSAwXG4gICAgICAgICAgICBkaXJlY3Rpb25zID0gW1xuICAgICAgICAgICAgICAgICgwLCAxKSxcbiAgICAgICAgICAgICAgICAoMCwgLTEpLFxuICAgICAgICAgICAgICAgICgtMSwgMCksXG4gICAgICAgICAgICAgICAgKDEsIDApLFxuICAgICAgICAgICAgICAgICgxLCAxKSxcbiAgICAgICAgICAgICAgICAoMSwgLTEpLFxuICAgICAgICAgICAgICAgICgtMSwgMSksXG4gICAgICAgICAgICAgICAgKC0xLCAtMSksXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICBmb3IgKGR4LCBkeSkgaW4gZGlyZWN0aW9uczpcbiAgICAgICAgICAgICAgICBpZiBpICsgZHggPj0gMCBhbmQgaSArIGR4IDwgbSBhbmQgaiArIGR5ID49IDAgYW5kIGogKyBkeSA8IG46XG4gICAgICAgICAgICAgICAgICAgIGNudCArPSBvbGRbaSArIGR4XVtqICsgZHldXG5cbiAgICAgICAgICAgIHJldHVybiBjbnRcblxuICAgICAgICBmb3IgaSBpbiByYW5nZShtKTpcbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKG4pOlxuICAgICAgICAgICAgICAgICMg5YWr5Liq5pa55ZCR5pyJ5Yeg5Liq5rS757uG6IOeXG4gICAgICAgICAgICAgICAgY250ID0gY250TGl2ZUNlbGwoaSwgailcbiAgICAgICAgICAgICAgICBpZiBvbGRbaV1bal0gPT0gMCBhbmQgY250ID09IDM6XG4gICAgICAgICAgICAgICAgICAgIGJvYXJkW2ldW2pdID0gMVxuICAgICAgICAgICAgICAgIGlmIG9sZFtpXVtqXSA9PSAxIGFuZCAoY250ID4gMyBvciBjbnQgPCAyKTpcbiAgICAgICAgICAgICAgICAgICAgYm9hcmRbaV1bal0gPSAwXG5cbiIKICAgIH1dCiAgfSwgewogICAgInRpdGxlIjogIuS7o+eggTIwLjQuMiIsCiAgICAiY29kZXMiOiBbewogICAgICAibGFuZ3VhZ2UiOiAiQ3BwIiwKICAgICAgImNvbnRlbnQiOiAiI2luY2x1ZGUgPHZlY3Rvcj5cbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XG5cbmNsYXNzIFNvbHV0aW9uIHtcbnB1YmxpYzpcbiAgaW50IGNudExpdmVDZWxsKGludCBpLCBpbnQgaixcbiAgICAgIGNvbnN0IHZlY3Rvcjx2ZWN0b3I8aW50PiA+JiBib2FyZCkge1xuICAgIGludCBjbnQgPSAwLCBkaXJlY3Rpb25zWzhdWzJdID0ge1xuICAgICAgezAsIDF9LFxuICAgICAgezAsIC0xfSxcbiAgICAgIHstMSwgMH0sXG4gICAgICB7MSwgMH0sXG4gICAgICB7MSwgMX0sXG4gICAgICB7MSwgLTF9LFxuICAgICAgey0xLCAxfSxcbiAgICAgIHstMSwgLTF9XG4gICAgfTtcbiAgICBpbnQgbSA9IGJvYXJkLnNpemUoKSwgbiA9IGJvYXJkWzBdLnNpemUoKTtcbiAgICBmb3IgKGludCBwID0gMDsgcCA8IDg7IHArKykge1xuICAgICAgaW50IGR4ID0gZGlyZWN0aW9uc1twXVswXSwgZHkgPSBkaXJlY3Rpb25zW3BdWzFdO1xuICAgICAgaWYgKGkgKyBkeCA+PSAwICYmIGkgKyBkeCA8IG0gJiYgaiArIGR5ID49IDAgJiYgXFxcbiAgICAgICAgICBqICsgZHkgPCBuKVxuICAgICAgICBjbnQgKz0gYm9hcmRbaSArIGR4XVtqICsgZHldICYgMTtcbiAgICB9XG4gICAgcmV0dXJuIGNudDtcbiAgfVxuICB2b2lkIGdhbWVPZkxpZmUodmVjdG9yPHZlY3RvcjxpbnQ+ID4mIGJvYXJkKSB7XG4gICAgaW50IG0gPSBib2FyZC5zaXplKCk7XG4gICAgaWYgKG0gPD0gMCkgcmV0dXJuO1xuICAgIGludCBuID0gYm9hcmRbMF0uc2l6ZSgpO1xuICAgIGlmIChuIDw9IDApIHJldHVybjtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IG07IGkrKylcbiAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGludCBjbnQgPSBjbnRMaXZlQ2VsbChpLCBqLCBib2FyZCk7XG4gICAgICAgIGJvYXJkW2ldW2pdIHw9IGNudCA8PCAxO1xuICAgICAgfVxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbTsgaSsrKVxuICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgaW50IGNlbGwgPSBib2FyZFtpXVtqXSAmIDE7XG4gICAgICAgIGludCBjbnQgPSBib2FyZFtpXVtqXSA+PiAxO1xuICAgICAgICBpZiAoY2VsbCA9PSAwICYmIGNudCA9PSAzKSBib2FyZFtpXVtqXSA9IDE7XG4gICAgICAgIGVsc2UgaWYgKGNlbGwgPT0gMSAmJiAoY250ID4gMyB8fCBjbnQgPCAyKSlcbiAgICAgICAgICBib2FyZFtpXVtqXSA9IDA7XG4gICAgICAgIGVsc2UgYm9hcmRbaV1bal0gPSBjZWxsO1xuICAgICAgfVxuICB9XG59O1xuXG4iCiAgICB9LCB7CiAgICAgICJsYW5ndWFnZSI6ICJKYXZhIiwKICAgICAgImNvbnRlbnQiOiAicHVibGljIGNsYXNzIFNvbHV0aW9uIHtcbiAgcHVibGljIGludCBjbnRMaXZlQ2VsbChpbnQgaSwgaW50IGosXG4gICAgICBpbnRbXVtdIGJvYXJkKSB7XG4gICAgaW50IGNudCA9IDA7XG4gICAgaW50W11bXSBkaXJlY3Rpb25zID0ge1xuICAgICAgezAsIDF9LFxuICAgICAgezAsIC0xfSxcbiAgICAgIHstMSwgMH0sXG4gICAgICB7MSwgMH0sXG4gICAgICB7MSwgMX0sXG4gICAgICB7MSwgLTF9LFxuICAgICAgey0xLCAxfSxcbiAgICAgIHstMSwgLTF9XG4gICAgfTtcbiAgICBpbnQgbSA9IGJvYXJkLmxlbmd0aCwgbiA9IGJvYXJkWzBdLmxlbmd0aDtcbiAgICBmb3IgKGludCBwID0gMDsgcCA8IDg7IHArKykge1xuICAgICAgaW50IGR4ID0gZGlyZWN0aW9uc1twXVswXSwgZHkgPSBkaXJlY3Rpb25zW3BdWzFdO1xuICAgICAgaWYgKGkgKyBkeCA+PSAwICYmIGkgKyBkeCA8IG0gJiYgaiArIGR5ID49IDAgJiZcbiAgICAgICAgICBqICsgZHkgPCBuKVxuICAgICAgICBjbnQgKz0gYm9hcmRbaSArIGR4XVtqICsgZHldICYgMTtcbiAgICB9XG4gICAgcmV0dXJuIGNudDtcbiAgfVxuICBwdWJsaWMgdm9pZCBnYW1lT2ZMaWZlKGludFtdW10gYm9hcmQpIHtcbiAgICBpbnQgbSA9IGJvYXJkLmxlbmd0aDtcbiAgICBpZiAobSA8PSAwKSByZXR1cm47XG4gICAgaW50IG4gPSBib2FyZFswXS5sZW5ndGg7XG4gICAgaWYgKG4gPD0gMCkgcmV0dXJuO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbTsgaSsrKVxuICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgaW50IGNudCA9IGNudExpdmVDZWxsKGksIGosIGJvYXJkKTtcbiAgICAgICAgYm9hcmRbaV1bal0gPSBib2FyZFtpXVtqXSB8IChjbnQgPDwgMSk7XG4gICAgICB9XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBtOyBpKyspXG4gICAgICBmb3IgKGludCBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICBpbnQgY2VsbCA9IGJvYXJkW2ldW2pdICYgMTtcbiAgICAgICAgaW50IGNudCA9IGJvYXJkW2ldW2pdID4+IDE7XG4gICAgICAgIGlmIChjZWxsID09IDAgJiYgY250ID09IDMpIGJvYXJkW2ldW2pdID0gMTtcbiAgICAgICAgZWxzZSBpZiAoY2VsbCA9PSAxICYmIChjbnQgPiAzIHx8IGNudCA8IDIpKVxuICAgICAgICAgIGJvYXJkW2ldW2pdID0gMDtcbiAgICAgICAgZWxzZSBib2FyZFtpXVtqXSA9IGNlbGw7XG4gICAgICB9XG4gIH1cbn1cblxuIgogICAgfSwgewogICAgICAibGFuZ3VhZ2UiOiAiUHkiLAogICAgICAiY29udGVudCI6ICJpbXBvcnQgY29weVxuXG5cbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBnYW1lT2ZMaWZlKHNlbGYsIGJvYXJkOiBMaXN0W0xpc3RbaW50XV0pIC0+IE5vbmU6XG4gICAgICAgIG0gPSBsZW4oYm9hcmQpXG4gICAgICAgIG4gPSBsZW4oYm9hcmRbMF0pXG4gICAgICAgIGlmIG0gPD0gMCBvciBuIDw9IDA6XG4gICAgICAgICAgICByZXR1cm4gW11cblxuICAgICAgICBkZWYgY250TGl2ZUNlbGwoaTogaW50LCBqOiBpbnQpIC0+IGludDpcbiAgICAgICAgICAgIGNudCA9IDBcbiAgICAgICAgICAgIGRpcmVjdGlvbnMgPSBbXG4gICAgICAgICAgICAgICAgKDAsIDEpLFxuICAgICAgICAgICAgICAgICgwLCAtMSksXG4gICAgICAgICAgICAgICAgKC0xLCAwKSxcbiAgICAgICAgICAgICAgICAoMSwgMCksXG4gICAgICAgICAgICAgICAgKDEsIDEpLFxuICAgICAgICAgICAgICAgICgxLCAtMSksXG4gICAgICAgICAgICAgICAgKC0xLCAxKSxcbiAgICAgICAgICAgICAgICAoLTEsIC0xKSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIGZvciAoZHgsIGR5KSBpbiBkaXJlY3Rpb25zOlxuICAgICAgICAgICAgICAgIGlmIGkgKyBkeCA+PSAwIGFuZCBpICsgZHggPCBtIGFuZCBqICsgZHkgPj0gMCBhbmQgaiArIGR5IDwgbjpcbiAgICAgICAgICAgICAgICAgICAgY250ICs9IGJvYXJkW2kgKyBkeF1baiArIGR5XSAmIDFcbiAgICAgICAgICAgIHJldHVybiBjbnRcblxuICAgICAgICBmb3IgaSBpbiByYW5nZShtKTpcbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKG4pOlxuICAgICAgICAgICAgICAgICMg5YWr5Liq5pa55ZCR5pyJ5Yeg5Liq5rS757uG6IOeXG4gICAgICAgICAgICAgICAgY250ID0gY250TGl2ZUNlbGwoaSwgailcbiAgICAgICAgICAgICAgICBib2FyZFtpXVtqXSB8PSBjbnQgPDwgMVxuICAgICAgICBmb3IgaSBpbiByYW5nZShtKTpcbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKG4pOlxuICAgICAgICAgICAgICAgICMg5Y+Y5YyW5LmL5YmN5b2T5YmNY2VsbOeahOWAvFxuICAgICAgICAgICAgICAgIGNlbGwgPSBib2FyZFtpXVtqXSAmIDFcbiAgICAgICAgICAgICAgICBjbnQgPSBib2FyZFtpXVtqXSA+PiAxXG4gICAgICAgICAgICAgICAgaWYgY2VsbCA9PSAwIGFuZCBjbnQgPT0gMzpcbiAgICAgICAgICAgICAgICAgICAgYm9hcmRbaV1bal0gPSAxXG4gICAgICAgICAgICAgICAgZWxpZiBjZWxsID09IDEgYW5kIChjbnQgPiAzIG9yIGNudCA8IDIpOlxuICAgICAgICAgICAgICAgICAgICBib2FyZFtpXVtqXSA9IDBcbiAgICAgICAgICAgICAgICBlbHNlOlxuICAgICAgICAgICAgICAgICAgICBib2FyZFtpXVtqXSA9IGNlbGxcblxuIgogICAgfV0KICB9XQp9XTs="},{"version":3,"sources":["/Users/luxiaopeng/github/leetcode-pp/src/views/Book.js"],"names":[],"mappings":"AAAA;AACA,eAAe,CAAC;AAAC,QAAK,IAAN;AAAW,UAAO,KAAlB;AAAwB,UAAO,CAAC;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA8I;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA9I,EAAkU;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAlU,EAA0c;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA1c;AAA3B,GAAD,EAAgnB;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAkX;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAlX,EAA2vB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA3vB,EAAmnC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAnnC;AAA3B,GAAhnB,EAA2mE;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA6Y;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA7Y,EAAqyB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAryB,EAAopC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAppC;AAA3B,GAA3mE,EAAorH;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA4c;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA5c,EAA29B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA39B,EAA04C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA14C;AAA3B,GAAprH,EAAkgL;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAyL;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAzL,EAAkW;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAlW,EAAoe;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAApe;AAA3B,GAAlgL,EAAopM;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAg+B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAh+B,EAAsyD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAtyD,EAAmxE;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAnxE;AAA3B,GAAppM;AAA/B,CAAD,EAA2zS;AAAC,QAAK,IAAN;AAAW,UAAO,KAAlB;AAAwB,UAAO,CAAC;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAub;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAvb,EAAu2B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAv2B,EAAgyC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAhyC;AAA3B,GAAD,EAAquD;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAgX;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAhX,EAAyvB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAzvB,EAAinC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAjnC;AAA3B,GAAruD,EAA8zG;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAy2B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAz2B,EAAstD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAttD,EAA89E;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA99E;AAA3B,GAA9zG,EAAoxN;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAmjC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAnjC,EAAwlE;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAxlE;AAA3B,GAApxN,EAAk2T;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA2gD;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA3gD,EAAixG;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAjxG;AAA3B,GAAl2T,EAA+pd;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAmuB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAnuB,EAAw6C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAx6C;AAA3B,GAA/pd,EAAwghB;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA4vB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA5vB,EAAg8C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAh8C;AAA3B,GAAxghB,EAA8xlB;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAyb;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAzb,EAAu0B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAv0B;AAA3B,GAA9xlB,EAAk/nB;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAogC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAApgC,EAA67D;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA77D;AAA3B,GAAl/nB,EAA60tB;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAuiB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAviB,EAAwiC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAxiC;AAA3B,GAA70tB,EAAyzwB;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAka;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAla,EAA8xB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA9xB;AAA3B,GAAzzwB,EAA68yB;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAu4B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAv4B,EAAikE;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAjkE;AAA3B,GAA78yB,EAA4g4B;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAmyB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAnyB,EAA6kD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA7kD;AAA3B,GAA5g4B,EAAqy7B;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAu8B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAv8B,EAAoiE;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAApiE;AAA3B,GAAry7B,EAAophC;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA61C;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA71C,EAAiuG;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAjuG;AAA3B,GAApphC,EAA24oC;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAoF;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAApF,EAAyK;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAzK;AAA3B,GAA34oC,EAAw3pC;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA85B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA95B,EAAm1D;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAn1D;AAA5B,GAAx3pC;AAA/B,CAA3zS,EAAi7hD;AAAC,QAAK,IAAN;AAAW,UAAO,KAAlB;AAAwB,UAAO,CAAC;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAyQ;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAzQ,EAA6hB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA7hB,EAAkuB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAluB;AAA3B,GAAD,EAA+9B;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAunB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAvnB,EAA8vC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA9vC,EAAg2D;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAh2D;AAA3B,GAA/9B,EAAkjH;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAiV;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAjV,EAAunB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAvnB;AAA3B,GAAljH,EAAw+I;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA0jB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA1jB,EAAmmC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAnmC;AAA3B,GAAx+I,EAAmxM;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAwU;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAxU,EAA2pB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA3pB;AAA3B,GAAnxM,EAAg1O;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAoqB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAApqB,EAAi3C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAj3C;AAA3B,GAAh1O,EAAs3S;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAgxB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAhxB,EAAi2C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAj2C;AAA3B,GAAt3S,EAAivW;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA0vB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA1vB,EAA+2C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA/2C;AAA3B,GAAjvW,EAAmoa;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA62B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA72B,EAAwjD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAxjD;AAA3B,GAAnoa,EAAyze;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAikD;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAjkD,EAAw+F;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAx+F;AAA3B,GAAzze;AAA/B,CAAj7hD,EAAqjpE;AAAC,QAAK,IAAN;AAAW,UAAO,KAAlB;AAAwB,UAAO,CAAC;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA2wB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA3wB,EAA+nD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA/nD;AAA3B,GAAD,EAA4tE;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAquB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAruB,EAAo9C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAp9C;AAA3B,GAA5tE,EAAu7I;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAyyC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAzyC,EAAkqH;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAlqH;AAA3B,GAAv7I,EAAu8T;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAmiD;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAniD,EAAo/G;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAp/G;AAA3B,GAAv8T,EAAike;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAopE;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAppE,EAAgrJ;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAhrJ;AAA3B,GAAjke,EAAyusB;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAwpG;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAxpG,EAAohN;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAphN;AAA3B,GAAzusB,EAA64/B;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAg7C;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAh7C,EAA2tH;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA3tH;AAA3B,GAA74/B;AAA/B,CAArjpE,EAA66yG;AAAC,QAAK,IAAN;AAAW,UAAO,KAAlB;AAAwB,UAAO,CAAC;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA4iB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA5iB,EAAw+B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAx+B;AAA3B,GAAD,EAAqjD;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA6vB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA7vB,EAA0sD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA1sD;AAA3B,GAArjD,EAAy9H;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAD,EAAinC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAjnC;AAA3B,GAAz9H,EAAg0L;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAD,EAA4zC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA5zC;AAA3B,GAAh0L,EAAk8P;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAiuB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAjuB,EAAi9C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAj9C;AAA3B,GAAl8P,EAA4kU;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAy8B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAz8B,EAAk3D;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAl3D;AAA3B,GAA5kU,EAAkzZ;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAD;AAA3B,GAAlzZ,EAA4pc;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAiqD;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAjqD,EAA83G;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA93G;AAA3B,GAA5pc,EAAq8lB;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA2iE;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA3iE,EAA8hJ;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA9hJ;AAA3B,GAAr8lB,EAAqozB;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAD;AAA3B,GAArozB;AAA/B,CAA76yG,EAAm1rI;AAAC,QAAK,IAAN;AAAW,UAAO,KAAlB;AAAwB,UAAO,CAAC;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA4gB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA5gB,EAAghC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAhhC;AAA3B,GAAD,EAAi7C;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA+d;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA/d,EAAs7B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAt7B;AAA3B,GAAj7C,EAAixF;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAk3B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAl3B,EAAwrD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAxrD;AAA3B,GAAjxF,EAAyhK;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAyiB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAziB,EAAmlC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAnlC;AAA3B,GAAzhK,EAA2iN;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA2X;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA3X,EAAgtB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAhtB;AAA3B,GAA3iN,EAA2lP;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA4d;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA5d,EAAw7B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAx7B;AAA3B,GAA3lP,EAA+7R;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAqjB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAArjB,EAAkmC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAlmC;AAA3B,GAA/7R,EAAwgV;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA6gC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA7gC,EAAo/D;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAp/D;AAA3B,GAAxgV;AAA/B,CAAn1rI,EAAyjmJ;AAAC,QAAK,IAAN;AAAW,UAAO,KAAlB;AAAwB,UAAO,CAAC;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAoS;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAApS,EAAkqB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAlqB;AAA3B,GAAD,EAAy7B;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA0P;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA1P,EAAkiB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAliB;AAA3B,GAAz7B,EAA0tD;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAwV;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAxV,EAA2mB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA3mB;AAA3B,GAA1tD,EAA2sF;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAgf;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAhf,EAAo3B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAp3B;AAA3B,GAA3sF,EAAo6H;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAsf;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAtf,EAAigC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAjgC;AAA3B,GAAp6H,EAAmyK;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAqiB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAriB,EAAglC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAhlC;AAA3B,GAAnyK,EAA+wN;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAqY;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAArY,EAAovB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAApvB;AAA3B,GAA/wN,EAAiwP;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAqR;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAArR,EAAugB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAvgB;AAA3B,GAAjwP,EAAolR;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAD,EAAiQ;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAjQ;AAA3B,GAAplR,EAAqgS;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAklB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAllB,EAAsiC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAtiC;AAA3B,GAArgS,EAAmlV;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAD,EAAqd;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAArd;AAA3B,GAAnlV;AAA/B,CAAzjmJ,EAA8n9J;AAAC,QAAK,IAAN;AAAW,UAAO,KAAlB;AAAwB,UAAO,CAAC;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAgf;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAhf,EAA4hD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA5hD;AAA3B,GAAD,EAA+1E;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAgf;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAhf,EAA4hD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA5hD;AAA3B,GAA/1E,EAA21J;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAgf;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAhf,EAAu/C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAv/C;AAA3B,GAA31J,EAAy/N;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAujC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAvjC,EAAm3D;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAn3D;AAA3B,GAAz/N,EAAmqT;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAq/B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAr/B,EAAskF;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAtkF;AAA3B,GAAnqT,EAA8ta;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAgvE;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAhvE,EAA+zI;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA/zI;AAA3B,GAA9ta,EAAw+mB;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA8zE;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA9zE,EAAo7J;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAp7J;AAA3B,GAAx+mB,EAA2n1B;AAAC,aAAQ,SAAT;AAAmB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA2sE;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA3sE,EAA0xK;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA1xK;AAA3B,GAA3n1B;AAA/B,CAA9n9J,EAA2giM;AAAC,QAAK,IAAN;AAAW,UAAO,KAAlB;AAAwB,UAAO,CAAC;AAAC,aAAQ,eAAT;AAAyB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAif;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAjf,EAA67B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA77B;AAAjC,GAAD,EAAi6C;AAAC,aAAQ,aAAT;AAAuB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA+e;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA/e,EAA41B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA51B;AAA/B,GAAj6C,EAAwmF;AAAC,aAAQ,qBAAT;AAA+B,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA2b;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA3b,EAA60B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA70B;AAAvC,GAAxmF,EAAi1H;AAAC,aAAQ,qBAAT;AAA+B,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAkgB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAlgB,EAAs9B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAt9B;AAAvC,GAAj1H,EAA2xK;AAAC,aAAQ,kBAAT;AAA4B,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAwhB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAxhB,EAAmsC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAnsC;AAApC,GAA3xK,EAA42N;AAAC,aAAQ,kBAAT;AAA4B,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAyrB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAzrB,EAAi8C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAj8C;AAApC,GAA52N,EAAy2R;AAAC,aAAQ,gBAAT;AAA0B,aAAQ,CAAC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAD,EAAkuB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAluB;AAAlC,GAAz2R,EAA0sU;AAAC,aAAQ,gBAAT;AAA0B,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAkwB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAlwB,EAAk3C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAl3C;AAAlC,GAA1sU,EAA6oY;AAAC,aAAQ,gBAAT;AAA0B,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAw3B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAx3B,EAAmoD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAnoD;AAAlC,GAA7oY,EAA4+c;AAAC,aAAQ,gBAAT;AAA0B,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAif;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAjf,EAA4hC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA5hC;AAAlC,GAA5+c;AAA/B,CAA3giM,EAA4giN;AAAC,QAAK,IAAN;AAAW,UAAO,KAAlB;AAAwB,UAAO,CAAC;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA6V;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA7V,EAA6sB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA7sB;AAA5B,GAAD,EAA+gC;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA+Y;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA/Y,EAAowB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAApwB;AAA5B,GAA/gC,EAA0rE;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAqZ;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAArZ,EAAgtB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAhtB;AAA5B,GAA1rE,EAA2pG;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA8jB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA9jB,EAA2lC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA3lC;AAA5B,GAA3pG,EAA40J;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA6d;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA7d,EAAm2B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAn2B;AAA5B,GAA50J,EAA8kM;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA4b;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA5b,EAAyyB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAzyB;AAA5B,GAA9kM,EAA+tO;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAyrB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAzrB,EAAqyC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAryC;AAA5B,GAA/tO,EAAymS;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAgjB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAhjB,EAAs7B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAt7B;AAA5B,GAAzmS,EAAs3U;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAsX;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAtX,EAAoqB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAApqB;AAA5B,GAAt3U,EAAmzW;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA6b;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA7b,EAA0rC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA1rC;AAA5B,GAAnzW,EAAw4Z;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA4hB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA5hB,EAA2mC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA3mC;AAA5B,GAAx4Z,EAAqid;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAiX;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAjX,EAAqzB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAArzB;AAA5B,GAArid;AAA/B,CAA5giN,EAAkvhO;AAAC,QAAK,IAAN;AAAW,UAAO,MAAlB;AAAyB,UAAO,CAAC;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAukB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAvkB,EAAupC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAvpC;AAA5B,GAAD,EAA6uD;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAke;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAle,EAA+wC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA/wC;AAA5B,GAA7uD,EAAigH;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAD,EAAyiD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAziD;AAA5B,GAAjgH,EAAy3M;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA2rC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA3rC;AAA5B,GAAz3M,EAAmgS;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA0wB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA1wB,EAAo9C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAp9C;AAA5B,GAAngS,EAAw9V;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA0kB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA1kB,EAAwkC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAxkC;AAA5B,GAAx9V,EAA0/Y;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAD;AAA5B,GAA1/Y,EAAysa;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAypB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAzpB,EAAyzD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAzzD;AAA5B,GAAzsa;AAAhC,CAAlvhO,EAAg9hP;AAAC,QAAK,IAAN;AAAW,UAAO,MAAlB;AAAyB,UAAO,CAAC;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA0J;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA1J,EAA+T;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA/T;AAA5B,GAAD,EAAsf;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA8nC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA9nC,EAAsvE;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAtvE;AAA5B,GAAtf,EAA48H;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAipC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAjpC,EAAogE;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAApgE;AAA5B,GAA58H,EAA2rO;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAymB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAzmB,EAAwpC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAxpC;AAA5B,GAA3rO,EAAg0R;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAohB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAphB,EAAwjC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAxjC;AAA5B,GAAh0R,EAAs1U;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAggB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAhgB,EAAi6B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAj6B;AAA5B,GAAt1U,EAA2lX;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAsY;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAtY,EAA+yB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA/yB;AAA5B,GAA3lX,EAAytZ;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAiI;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAjI,EAA0V;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA1V;AAA5B,GAAztZ,EAA2sa;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAqc;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAArc,EAA65B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA75B;AAA5B,GAA3sa,EAA6md;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAktB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAltB,EAAu5C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAv5C;AAA5B,GAA7md;AAAhC,CAAh9hP,EAAgzjQ;AAAC,QAAK,IAAN;AAAW,UAAO,MAAlB;AAAyB,UAAO,CAAC;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAD;AAA5B,GAAD,EAA0b;AAAC,aAAQ,eAAT;AAAyB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAkd;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAld;AAAjC,GAA1b,EAAyxC;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAD;AAA5B,GAAzxC,EAAgvD;AAAC,aAAQ,eAAT;AAAyB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAse;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAte;AAAjC,GAAhvD,EAAyoF;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAD;AAA5B,GAAzoF,EAAikG;AAAC,aAAQ,aAAT;AAAuB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAmX;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAnX;AAA/B,GAAjkG,EAAg1H;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAD;AAA5B,GAAh1H,EAAy8I;AAAC,aAAQ,eAAT;AAAyB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAopB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAppB;AAAjC,GAAz8I,EAAksL;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAD;AAA5B,GAAlsL,EAA2wM;AAAC,aAAQ,eAAT;AAAyB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAkiB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAliB;AAAjC,GAA3wM,EAAkzO;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAD;AAA5B,GAAlzO,EAAihQ;AAAC,aAAQ,eAAT;AAAyB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA2wB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA3wB;AAAjC,GAAjhQ,EAAu3S;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAD;AAA5B,GAAv3S,EAA4+T;AAAC,aAAQ,eAAT;AAAyB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA4gB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA5gB;AAAjC,GAA5+T,EAA2+V;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAD;AAA5B,GAA3+V,EAAunX;AAAC,aAAQ,eAAT;AAAyB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA2oB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA3oB;AAAjC,GAAvnX,EAA4la;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAD;AAA5B,GAA5la,EAAqic;AAAC,aAAQ,eAAT;AAAyB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAmjC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAnjC;AAAjC,GAAric,EAAk2f;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA2c;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA3c,EAA67B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA77B;AAA5B,GAAl2f;AAAhC,CAAhzjQ,EAAmkmR;AAAC,QAAK,IAAN;AAAW,UAAO,MAAlB;AAAyB,UAAO,CAAC;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAqd;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAArd,EAAq7B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAr7B;AAA5B,GAAD,EAAy/C;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA8oB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA9oB,EAAmwC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAnwC;AAA5B,GAAz/C,EAAs8G;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAiyB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAjyB,EAAo9C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAp9C;AAA5B,GAAt8G,EAAk3L;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA+6B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA/6B,EAA48D;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA58D;AAA5B,GAAl3L,EAAk5R;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAusB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAvsB,EAAutD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAvtD;AAA5B,GAAl5R,EAAy2W;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAqS;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAArS,EAAshB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAthB;AAA5B,GAAz2W,EAAylY;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA6+B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA7+B,EAAmgE;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAngE;AAA5B,GAAzlY,EAA4kd;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA6+B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA7+B,EAAmgE;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAngE;AAA5B,GAA5kd,EAA+zhB;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAu9B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAv9B,EAA49D;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA59D;AAA5B,GAA/zhB,EAAg/oB;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAu9B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAv9B,EAA49D;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA59D;AAA5B,GAAh/oB,EAAq4vB;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAiV;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAjV,EAA6rB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA7rB;AAA5B,GAAr4vB,EAA2oyB;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAiV;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAjV,EAA6rB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA7rB;AAA5B,GAA3oyB,EAAow1B;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAwf;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAxf,EAAiiE;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAjiE;AAA5B,GAApw1B,EAAwm8B;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAwf;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAxf,EAAk1D;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAl1D;AAA5B,GAAxm8B,EAAs8hC;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAwf;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAxf,EAAmgC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAngC;AAA5B,GAAt8hC,EAAm6mC;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAwf;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAxf,EAAmgC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAngC;AAA5B,GAAn6mC;AAAhC,CAAnkmR,EAAgmwT;AAAC,QAAK,IAAN;AAAW,UAAO,MAAlB;AAAyB,UAAO,CAAC;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA4sB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA5sB,EAAi3C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAj3C;AAA5B,GAAD,EAAq6D;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA6e;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA7e,EAA07B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA17B;AAA5B,GAAr6D,EAAqtG;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAsnB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAtnB,EAA6kC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA7kC;AAA5B,GAArtG,EAA2sJ;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAk3B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAl3B,EAA++C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA/+C;AAA5B,GAA3sJ,EAAgxN;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAw3B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAx3B,EAA6uD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA7uD;AAA5B,GAAhxN,EAA0+R;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA26B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA36B,EAAgyD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAhyD;AAA5B,GAA1+R;AAAhC,CAAhmwT,EAAkjnU;AAAC,QAAK,IAAN;AAAW,UAAO,MAAlB;AAAyB,UAAO,CAAC;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAs6B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAt6B,EAAm3D;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAn3D;AAA5B,GAAD,EAAyrF;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAiuC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAjuC,EAAy+E;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAz+E;AAA5B,GAAzrF,EAA0zM;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA+hB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA/hB,EAAqmC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAArmC;AAA5B,GAA1zM,EAAg4P;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAsuB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAtuB,EAAogD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAApgD;AAA5B,GAAh4P,EAAq/T;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAwpD;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAxpD,EAAwuG;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAxuG;AAA5B,GAAr/T;AAAhC,CAAljnU,EAAoxkV;AAAC,QAAK,IAAN;AAAW,UAAO,MAAlB;AAAyB,UAAO,CAAC;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAulC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAvlC,EAAuqE;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAvqE;AAA5B,GAAD,EAAqsG;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAwe;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAxe,EAAs8B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAt8B;AAA5B,GAArsG,EAA2kJ;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAuuB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAvuB,EAAg/C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAh/C;AAA5B,GAA3kJ,EAA2rN;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA2uB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA3uB,EAAkgD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAlgD;AAA5B,GAA3rN,EAAm0R;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAqpB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAArpB,EAA88C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA98C;AAA5B,GAAn0R,EAAurV;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAu7B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAv7B,EAA+xD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA/xD;AAA5B,GAAvrV,EAAuhb;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA8jB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA9jB,EAA+lC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA/lC;AAA5B,GAAvhb,EAA8xe;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAiqC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAjqC,EAA2iF;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA3iF;AAA5B,GAA9xe,EAAgslB;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA+f;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA/f,EAA2/B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA3/B;AAA5B,GAAhslB,EAAuxoB;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAuG;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAvG,EAAkP;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAlP;AAA5B,GAAvxoB,EAAoppB;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA0J;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA1J,EAA8V;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA9V;AAA5B,GAApppB,EAA2rqB;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA2T;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA3T,EAA+mB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA/mB;AAA5B,GAA3rqB,EAA8ksB;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA+Q;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA/Q,EAAmjB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAnjB;AAA5B,GAA9ksB;AAAhC,CAApxkV,EAA4ryW;AAAC,QAAK,IAAN;AAAW,UAAO,MAAlB;AAAyB,UAAO,CAAC;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAua;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAva,EAA8xB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA9xB;AAA5B,GAAD,EAAqrC;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA+Y;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA/Y,EAAyvB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAzvB;AAA5B,GAArrC,EAA+wE;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAif;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAjf,EAAm+B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAn+B;AAA5B,GAA/wE,EAA+pH;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAwgC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAxgC,EAAynE;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAznE;AAA5B,GAA/pH,EAAonN;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAy8B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAz8B,EAA4lE;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA5lE;AAA5B,GAApnN,EAA8kT;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAujC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAvjC,EAAunE;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAvnE;AAA5B,GAA9kT,EAA6qZ;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAyR;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAzR,EAAoiB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAApiB;AAA5B,GAA7qZ,EAA48a;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAokB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAApkB,EAAmrC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAnrC;AAA5B,GAA58a,EAAkre;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAyG;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAzG,EAAyN;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAzN;AAA5B,GAAlre,EAAshf;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA8K;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA9K,EAA8W;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA9W;AAA5B,GAAthf;AAAhC,CAA5ryW,EAAizyX;AAAC,QAAK,IAAN;AAAW,UAAO,MAAlB;AAAyB,UAAO,CAAC;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA0R;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA1R,EAAokB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAApkB;AAA5B,GAAD,EAAu0B;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAuT;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAvT,EAA8nB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA9nB;AAA5B,GAAv0B,EAAmvD;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAgZ;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAhZ,EAAuvB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAvvB;AAA5B,GAAnvD,EAA6/F;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAqY;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAArY,EAAqyB;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAryB;AAA5B,GAA7/F,EAA6oI;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAkiB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAliB,EAAshC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAthC;AAA5B,GAA7oI,EAAk3L;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAohB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAphB,EAA2hC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA3hC;AAA5B,GAAl3L,EAA27O;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA6hC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA7hC,EAAy7E;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAz7E;AAA5B,GAA37O,EAAqkW;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAi7B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAj7B,EAA6oD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA7oD;AAA5B,GAArkW,EAA83a;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAm2B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAn2B,EAAykD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAzkD;AAA5B,GAA93a,EAAupf;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAqvB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAArvB,EAAo5C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAp5C;AAA5B,GAAvpf,EAA4sjB;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAm8B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAn8B,EAAk0D;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAl0D;AAA5B,GAA5sjB,EAAmunB;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAk5B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAl5B,EAAmhE;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAnhE;AAA5B,GAAnunB,EAAknsB;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAwgB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAxgB,EAAu/B;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAv/B;AAA5B,GAAlnsB,EAAmsvB;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAuvB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAvvB,EAAi5C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAj5C;AAA5B,GAAnsvB,EAA41zB;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAyhB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAzhB,EAA2hC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA3hC;AAA5B,GAA51zB;AAAhC,CAAjzyX,EAAmwpZ;AAAC,QAAK,IAAN;AAAW,UAAO,MAAlB;AAAyB,UAAO,CAAC;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAurD;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAvrD,EAA8rH;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA9rH;AAA5B,GAAD,EAAy/J;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAs8B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAt8B,EAAq0D;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAr0D;AAA5B,GAAz/J,EAAm6P;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAwuB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAxuB,EAAm5C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAn5C;AAA5B,GAAn6P,EAA6zU;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAsjB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAtjB,EAAkqC;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAlqC;AAA5B,GAA7zU,EAAs3X;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAypB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAzpB,EAA4zD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA5zD;AAA5B,GAAt3X,EAA2lc;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAiqC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAjqC,EAAuuF;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAvuF;AAA5B,GAA3lc,EAAsvjB;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAqgC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAArgC,EAAsrE;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAtrE;AAA5B,GAAtvjB,EAAq/pB;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAg/C;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAh/C,EAA6gG;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA7gG;AAA5B,GAAr/pB,EAAigyB;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA2xB;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA3xB,EAAs3C;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAt3C;AAA5B,GAAjgyB,EAAk41B;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA6/B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA7/B,EAA4+D;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAA5+D;AAA5B,GAAl41B,EAA076B;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAAi1B;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAAj1B,EAAsqD;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAtqD;AAA5B,GAA176B,EAAii/B;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA2lC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA3lC,EAAqrE;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAArrE;AAA5B,GAAji/B,EAA8zlC;AAAC,aAAQ,UAAT;AAAoB,aAAQ,CAAC;AAAC,kBAAW,KAAZ;AAAkB,iBAAU;AAA5B,KAAD,EAA4wC;AAAC,kBAAW,MAAZ;AAAmB,iBAAU;AAA7B,KAA5wC,EAAy+E;AAAC,kBAAW,IAAZ;AAAiB,iBAAU;AAA3B,KAAz+E;AAA5B,GAA9zlC;AAAhC,CAAnwpZ,CAAf","sourcesContent":["/* eslint-disable */\nexport default [{\"id\":\"01\",\"name\":\"第一章\",\"list\":[{\"title\":\"代码1.3.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"\\nint sum(int n) {\\n  int res = 0;\\n  for (int i = 0; i < n; i++) {\\n    res += i;\\n  }\\n  return res;\\n}\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  public int sum(int n) {\\n    int res = 0;\\n    for (int i = 0; i < n; i++) {\\n      res += i;\\n    }\\n    return res;\\n  }\\n}\\n\"},{\"language\":\"Js\",\"content\":\"function sum(n) {\\n  let res = 0\\n  for (let i = 0; i < n; i++) {\\n    res += i\\n  }\\n  return res\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"def sum(n: int) -> int:\\n    res = 0\\n    for i in range(1, n + 1):\\n        res += i\\n    return res\\n\\n\"}]},{\"title\":\"代码1.3.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n  vector<int> twoSum(vector<int> &nums, int target) {\\n\\n    unordered_map<int, int> mapper;\\n\\n    for (int i = 0; i < nums.size(); i++) {\\n      if (mapper.find(target - nums[i]) != mapper.end())\\n        return {mapper[target - nums[i]], i};\\n\\n      mapper[nums[i]] = i;\\n    }\\n    return {};\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  public int[] twoSum(int[] nums, int target) {\\n    Map<Integer, Integer> mapper = new HashMap<>();\\n    for (int i = 0; i < nums.length; i++) {\\n      if (mapper.containsKey(target - nums[i])) {\\n        return new int[] {mapper.get(target - nums[i]), i};\\n      }\\n      mapper.put(nums[i], i);\\n    }\\n    return new int[] {};\\n  }\\n}\\n\\n\"},{\"language\":\"Js\",\"content\":\"/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[]}\\n */\\nconst twoSum = function(nums, target) {\\n  const n = nums.length\\n  const mapper = {}\\n  for (let i = 0; i < n; i++) {\\n    if (mapper[target - nums[i]] !== void 0)\\n      return [mapper[target - nums[i]], i]\\n    mapper[nums[i]] = i\\n  }\\n  return []\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        n = len(nums)\\n        mapper = {}\\n        for i in range(n):\\n            if target - nums[i] in mapper:\\n                return [mapper[target - nums[i]], i]\\n            else:\\n                mapper[nums[i]] = i\\n\\n        return []\\n\\n\"}]},{\"title\":\"代码1.3.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n  vector<int> dailyTemperatures(vector<int> &T) {\\n    stack<int> st;\\n    vector<int> ans(T.size(), 0);\\n    for (int i = 0; i < T.size(); i++) {\\n      while (!st.empty() && T[i] > T[st.top()]) {\\n        int top = st.top();\\n        st.pop();\\n        ans[top] = i - top;\\n      }\\n      st.push(i);\\n    }\\n    return ans;\\n  }\\n};\\n\"},{\"language\":\"Js\",\"content\":\"/**\\n * @param {number[]} T\\n * @return {number[]}\\n */\\nconst dailyTemperatures = function(T) {\\n  const stack = []\\n  const ans = []\\n\\n  for (let i = 0; i < T.length; i++) {\\n    ans[i] = 0\\n    while (stack.length !== 0 && T[i] > T[stack[stack.length - 1]]) {\\n      const peek = stack.pop()\\n      ans[peek] = i - peek\\n    }\\n    stack.push(i)\\n  }\\n\\n  return ans\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def dailyTemperatures(self, T: List[int]) -> List[int]:\\n        stack = []\\n        ans = [0] * len(T)\\n        for i in range(len(T)):\\n            while stack and T[i] > T[stack[-1]]:\\n                peek = stack.pop(-1)\\n                ans[peek] = i - peek\\n            stack.append(i)\\n        return ans\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  public int[] dailyTemperatures(int[] T) {\\n    Stack<Integer> stack = new Stack<Integer>();\\n    int[] ans = new int[T.length];\\n    for (int i = 0; i < T.length; i++) {\\n      while (!stack.empty() && T[i] > T[stack.peek()]) {\\n        int top = stack.pop();\\n        ans[top] = i - top;\\n      }\\n      stack.push(i);\\n    }\\n    return ans;\\n  }\\n}\\n\\n\"}]},{\"title\":\"代码1.3.4\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"\\nint binarySearch(vector<int>& nums, int target){\\n  if(nums.size() == 0)\\n    return -1;\\n\\n  int left = 0, right = nums.size() - 1;\\n  while(left <= right){\\n    int mid = left + ((right - left) >> 1);\\n    if(nums[mid] == target){ return mid; }\\n    // 搜索区间变为 [mid+1, right]\\n    else if(nums[mid] < target)\\n  left = mid + 1;\\n    // 搜索区间变为 [left, mid - 1]\\n    else\\n  right = mid - 1;\\n  }\\n  return -1;\\n}\\n          \\n\"},{\"language\":\"Java\",\"content\":\"public int binarySearch(int[] nums, int target) {\\n    // 左右都闭合的区间 [l, r]\\n    int left = 0;\\n    int right = nums.length - 1;\\n\\n    while(left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if(nums[mid] == target)\\n            return mid;\\n        if (nums[mid] < target)\\n                // 搜索区间变为 [mid+1, right]\\n            left = mid + 1;\\n        if (nums[mid] > target)\\n            // 搜索区间变为 [left, mid - 1]\\n            right = mid - 1;\\n    }\\n    return -1;\\n}\\n\"},{\"language\":\"Js\",\"content\":\"function binarySearch(nums, target) {\\n  let left = 0\\n  let right = nums.length - 1\\n  while (left <= right) {\\n    const mid = Math.floor(left + (right - left) / 2)\\n    if (nums[mid] == target) return mid\\n    if (nums[mid] < target)\\n      // 搜索区间变为 [mid+1, right]\\n      left = mid + 1\\n    if (nums[mid] > target)\\n      // 搜索区间变为 [left, mid - 1]\\n      right = mid - 1\\n  }\\n  return -1\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"def binarySearch(nums, target):\\n    # 左右都闭合的区间 [l, r]\\n    l, r = 0, len(nums) - 1\\n    while l <= r:\\n        mid = (left + right) >> 1\\n        if nums[mid] == target:\\n            return mid\\n        # 搜索区间变为 [mid+1, right]\\n        if nums[mid] < target:\\n            l = mid + 1\\n        # 搜索区间变为 [left, mid - 1]\\n        if nums[mid] > target:\\n            r = mid - 1\\n    return -1\\n\"}]},{\"title\":\"代码1.3.5\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n  int fibonacci(int n) {\\n    if (n < 2) {\\n      return n\\n    }\\n    return fibonacci(n - 1) + fibonacci(n - 2);\\n  }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  public int fibonacci(int n) {\\n    if (n < 2) return n;\\n    return fibonacci(n - 1) + fibonacci(n - 2);\\n  }\\n}\\n\\n\"},{\"language\":\"Js\",\"content\":\"function fibonacci(n) {\\n  if (n < 2) return n\\n  return fibonacci(n - 1) + fibonacci(n - 2)\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"def fibonacci(n: int) -> int:\\n    if n < 2:\\n        return n\\n    return fibonacci(n - 1) + fibonacci(n - 2)\\n\\n\"}]},{\"title\":\"代码1.3.6\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n  vector<vector<int>> ans;\\n  void dfs(int idx, vector<int> path, vector<int> nums, int n,\\n           vector<bool> visited) {\\n    // 结束条件\\n    // 1. 找到解\\n    if (path.size() == n) {\\n      vector<int> temp(path.size());\\n      std::copy(path.begin(), path.end(), temp.begin());\\n      ans.push_back(temp);\\n      return;\\n    }\\n\\n    // 2. 搜索完毕\\n    if (idx == n)\\n      return;\\n\\n    // 考虑可能的解，进入下一层递归\\n    for (int i = 0; i < n; ++i) {\\n      int num = nums[i];\\n      // 非法解忽略\\n      if (visited[i])\\n        continue;\\n      // 更新状态\\n      visited[i] = true;\\n      path.push_back(num);\\n      dfs(idx + 1, path, nums, n, visited);\\n      // 恢复状态\\n      path.pop_back();\\n      visited[i] = false;\\n    }\\n  }\\n  vector<vector<int>> permute(vector<int> &nums) {\\n    vector<int> path;\\n    vector<bool> visited(nums.size(), false);\\n    int n = nums.size();\\n    dfs(0, path, nums, n, visited);\\n    return ans;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  private void backtrack(\\n      List<List<Integer>> ans, ArrayList<Integer> tempList, ArrayList<Integer> nums) {\\n    if (tempList.size() == nums.size()) {\\n      ans.add(new ArrayList<Integer>(tempList));\\n      return;\\n    }\\n    for (int i = 0; i < nums.size(); i++) {\\n      if (tempList.contains(nums.get(i))) continue;\\n      tempList.add(nums.get(i));\\n      backtrack(ans, tempList, nums);\\n      tempList.remove(tempList.size() - 1);\\n    }\\n  }\\n\\n  public List<List<Integer>> permute(int[] nums) {\\n    List<List<Integer>> ans = new LinkedList();\\n    ArrayList<Integer> tempList = new ArrayList<Integer>();\\n    ArrayList<Integer> anums = new ArrayList<Integer>();\\n    for (int num : nums) anums.add(num);\\n    backtrack(ans, tempList, anums);\\n    return ans;\\n  }\\n}\\n\\n\"},{\"language\":\"Js\",\"content\":\"function backtrack(list, tempList, nums) {\\n  if (tempList.length === nums.length) return list.push([...tempList])\\n  for (let i = 0; i < nums.length; i++) {\\n    if (tempList.includes(nums[i])) continue\\n    tempList.push(nums[i])\\n    backtrack(list, tempList, nums)\\n    tempList.pop()\\n  }\\n}\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nconst permute = function(nums) {\\n  const list = []\\n  backtrack(list, [], nums)\\n  return list\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(idx: int, path: List[int]) -> None:\\n            # 结束条件\\n            # 1. 找到解\\n            if len(path) == n:\\n                ans.append(path.copy())\\n                return\\n            # 2. 搜索完毕\\n            if idx == n:\\n                return\\n\\n            # 考虑可能的解，进入下一层递归\\n            for num in nums:\\n                # 非法解忽略\\n                if num in visited:\\n                    continue\\n                # 更新状态\\n                visited.add(num)\\n                path.append(num)\\n                dfs(idx + 1, path)\\n                # 恢复状态\\n                path.pop()\\n                visited.remove(num)\\n\\n        ans = []\\n        visited = set()\\n        n = len(nums)\\n        dfs(0, [])\\n        return ans\\n\\n\"}]}]},{\"id\":\"02\",\"name\":\"第二章\",\"list\":[{\"title\":\"代码2.1.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n  vector<int> twoSum(vector<int> &nums, int target) {\\n    int n = nums.size();\\n    sort(nums.begin(), nums.end());\\n    int l = 0;\\n    int r = n - 1;\\n    while (l < r) {\\n      if (nums[l] + nums[r] < target) {\\n        l += 1;\\n      } else if (nums[l] + nums[r] > target) {\\n        r -= 1;\\n      } else {\\n        return {l, r};\\n      }\\n    }\\n    return {};\\n  }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  public int[] twoSum(int[] nums, int target) {\\n    int n = nums.length;\\n    Arrays.sort(nums);\\n    int l = 0;\\n    int r = n - 1;\\n    while (l < r) {\\n      if (nums[l] + nums[r] < target) {\\n        l += 1;\\n      } else if (nums[l] + nums[r] > target) {\\n        r -= 1;\\n      } else {\\n        return new int[] {l, r};\\n      }\\n    }\\n    return new int[] {};\\n  }\\n}\\n\\n\"},{\"language\":\"Js\",\"content\":\"/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[]}\\n */\\nconst twoSum = function(nums, target) {\\n  const n = nums.length\\n  nums.sort((a, b) => a - b)\\n  let l = 0\\n  let r = n - 1\\n  while (l < r) {\\n    if (nums[l] + nums[r] < target) {\\n      l += 1\\n    } else if (nums[l] + nums[r] > target) {\\n      r -= 1\\n    } else {\\n      return [l, r]\\n    }\\n  }\\n  return []\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        n = len(nums)\\n        nums.sort()\\n        l = 0\\n        r = n - 1\\n        while l < r:\\n            if nums[l] + nums[r] < target:\\n                l += 1\\n            elif nums[l] + nums[r] > target:\\n                r -= 1\\n            else:\\n                return [l, r]\\n        return []\\n\\n\"}]},{\"title\":\"代码2.1.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n  vector<int> twoSum(vector<int> &nums, int target) {\\n\\n    unordered_map<int, int> mapper;\\n\\n    for (int i = 0; i < nums.size(); i++) {\\n      if (mapper.find(target - nums[i]) != mapper.end())\\n        return {mapper[target - nums[i]], i};\\n\\n      mapper[nums[i]] = i;\\n    }\\n    return {};\\n  }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  public int[] twoSum(int[] nums, int target) {\\n    Map<Integer, Integer> mapper = new HashMap<>();\\n    for (int i = 0; i < nums.length; i++) {\\n      if (mapper.containsKey(target - nums[i])) {\\n        return new int[] {mapper.get(target - nums[i]), i};\\n      }\\n      mapper.put(nums[i], i);\\n    }\\n    return new int[] {};\\n  }\\n}\\n\\n\"},{\"language\":\"Js\",\"content\":\"/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[]}\\n */\\nconst twoSum = function(nums, target) {\\n  const n = nums.length\\n  const mapper = {}\\n  for (let i = 0; i < n; i++) {\\n    if (mapper[target - nums[i]] !== void 0)\\n      return [mapper[target - nums[i]], i]\\n    mapper[nums[i]] = i\\n  }\\n  return []\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        n = len(nums)\\n        mapper = {}\\n        for i in range(n):\\n            if target - nums[i] in mapper:\\n                # 实际上这里返回的索引顺序是不重要的\\n                # 即返回 [i, mapper[target - nums[i]]] 也是正确的\\n                return [mapper[target - nums[i]], i]\\n            else:\\n                mapper[nums[i]] = i\\n\\n        return []\\n\\n\"}]},{\"title\":\"代码2.2.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n  vector<vector<int>> threeSum(vector<int> &nums) {\\n    int n = nums.size();\\n    sort(nums.begin(), nums.end());\\n    vector<vector<int>> res;\\n\\n    for (int i = 0; i < n - 2; i++) {\\n      if (i > 0 && nums[i] == nums[i - 1])\\n        continue;\\n      int l = i + 1;\\n      int r = n - 1;\\n      while (l < r) {\\n        if (nums[i] + nums[l] + nums[r] < 0) {\\n          l += 1;\\n        } else if (nums[i] + nums[l] + nums[r] > 0) {\\n          r -= 1;\\n        } else {\\n          res.push_back(vector<int>{nums[i], nums.at(l), nums.at(r)});\\n          while (l < r && nums[l] == nums[l + 1]) {\\n            l += 1;\\n          }\\n          while (l < r && nums[r] == nums[r - 1]) {\\n            r -= 1;\\n          }\\n          l += 1;\\n          r -= 1;\\n        }\\n      }\\n    }\\n    return res;\\n  }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  public List<List<Integer>> threeSum(int[] nums) {\\n    int n = nums.length;\\n    Arrays.sort(nums);\\n    List<List<Integer>> res = new ArrayList<>();\\n\\n    for (int i = 0; i < n - 2; i++) {\\n      if (i > 0 && nums[i] == nums[i - 1]) continue;\\n      int l = i + 1;\\n      int r = n - 1;\\n      while (l < r) {\\n        if (nums[i] + nums[l] + nums[r] < 0) {\\n          l += 1;\\n        } else if (nums[i] + nums[l] + nums[r] > 0) {\\n          r -= 1;\\n        } else {\\n          res.add(new ArrayList<Integer>(Arrays.asList(nums[i], nums[l], nums[r])));\\n          while (l < r && nums[l] == nums[l + 1]) {\\n            l += 1;\\n          }\\n          while (l < r && nums[r] == nums[r - 1]) {\\n            r -= 1;\\n          }\\n          l += 1;\\n          r -= 1;\\n        }\\n      }\\n    }\\n    return res;\\n  }\\n}\\n\\n\"},{\"language\":\"Js\",\"content\":\"/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nconst threeSum = function(nums) {\\n  const n = nums.length\\n  nums.sort((a, b) => a - b)\\n  const res = []\\n\\n  for (let i = 0; i < n - 2; i++) {\\n    if (i > 0 && nums[i] == nums[i - 1]) continue\\n    let l = i + 1\\n    let r = n - 1\\n    while (l < r) {\\n      if (nums[i] + nums[l] + nums[r] < 0) {\\n        l += 1\\n      } else if (nums[i] + nums[l] + nums[r] > 0) {\\n        r -= 1\\n      } else {\\n        res.push([nums[i], nums[l], nums[r]])\\n        while (l < r && nums[l] == nums[l + 1]) {\\n          l += 1\\n        }\\n        while (l < r && nums[r] == nums[r - 1]) {\\n          r -= 1\\n        }\\n        l += 1\\n        r -= 1\\n      }\\n    }\\n  }\\n  return res\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums)\\n        nums.sort()\\n        res = []\\n\\n        # 要找到三个数字，因此只需要找到倒数 n-3 个数字即可\\n        for i in range(n - 2):\\n            # 去重\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n            # 固定 i，寻找 l 和 r ，使用双指针法\\n            l = i + 1\\n            r = n - 1\\n            while l < r:\\n                if nums[i] + nums[l] + nums[r] < 0:\\n                    l += 1\\n                elif nums[i] + nums[l] + nums[r] > 0:\\n                    r -= 1\\n                else:\\n                    res.append([nums[i], nums[l], nums[r]])\\n                    # 去重\\n                    while l < r and nums[l] == nums[l + 1]:\\n                        l += 1\\n                    while l < r and nums[r] == nums[r - 1]:\\n                        r -= 1\\n                    l += 1\\n                    r -= 1\\n\\n        return res\\n\\n\"}]},{\"title\":\"代码2.3.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"\\nclass Solution {\\npublic:\\n  vector<vector<int>> res;\\n  set<string> set;\\n  void backtrack(vector<int> &nums, int n, vector<int> tempList, int remain,\\n                 int start) {\\n    if (tempList.size() > 4) {\\n      return;\\n    }\\n    if (remain == 0 && tempList.size() == 4) {\\n      stringstream ss;\\n      copy(tempList.begin(), tempList.end(), ostream_iterator<int>(ss, \\\"\\\"));\\n      string s = ss.str();\\n      if (set.count(s) != 0) {\\n        return;\\n      } else {\\n        set.insert(s);\\n        vector<int> copy;\\n        copy.assign(tempList.begin(), tempList.end());\\n        res.push_back(copy);\\n        return;\\n      }\\n    }\\n    for (int i = start; i < n; i++) {\\n      tempList.push_back(nums[i]);\\n      backtrack(nums, n, tempList, remain - nums[i], i + 1);\\n      tempList.pop_back();\\n    }\\n  }\\n  vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n    sort(nums.begin(), nums.end());\\n    vector<int> tempList;\\n    backtrack(nums, nums.size(), tempList, target, 0);\\n    return res;\\n  }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  private void backtrack(\\n      List<List<Integer>> res,\\n      int[] nums,\\n      int n,\\n      List<Integer> tempList,\\n      int remain,\\n      int start,\\n      HashSet set) {\\n    if (tempList.size() > 4) {\\n      return;\\n    }\\n    if (remain == 0 && tempList.size() == 4) {\\n      if (set.contains(tempList.toString())) {\\n        return;\\n      } else {\\n        set.add(tempList.toString());\\n        res.add(new ArrayList<Integer>(tempList));\\n        return;\\n      }\\n    }\\n    for (int i = start; i < n; i++) {\\n      tempList.add(nums[i]);\\n      backtrack(res, nums, n, tempList, remain - nums[i], i + 1, set);\\n      tempList.remove(tempList.size() - 1);\\n    }\\n  }\\n\\n  public List<List<Integer>> fourSum(int[] nums, int target) {\\n    List<List<Integer>> res = new ArrayList<>();\\n    HashSet set = new HashSet();\\n    Arrays.sort(nums);\\n    List<Integer> tempList = new ArrayList<Integer>();\\n    backtrack(res, nums, nums.length, tempList, target, 0, set);\\n    return res;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def backtrack(\\n        self,\\n        res: List[List[int]],\\n        nums: List[int],\\n        n: int,\\n        tempList: List[int],\\n        remain: int,\\n        start: int,\\n        hashmap: dict,\\n    ) -> None:\\n        if len(tempList) > 4:\\n            return\\n        if remain == 0 and len(tempList) == 4:\\n            if str(tempList) in hashmap:\\n                return\\n            else:\\n                hashmap[str(tempList)] = True\\n                res.append(tempList.copy())\\n                return\\n        for i in range(start, n):\\n            tempList.append(nums[i])\\n            self.backtrack(res, nums, n, tempList, remain - nums[i], i + 1, hashmap)\\n            tempList.pop()\\n\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        hashmap = {}\\n        nums.sort()\\n        self.backtrack(res, nums, len(nums), [], target, 0, hashmap)\\n        return res\\n\\n\"}]},{\"title\":\"代码2.3.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  vector<vector<int> > fourSum(vector<int>& nums,\\n      int target) {\\n    sort(nums.begin(), nums.end());\\n    vector<vector<int> > results;\\n    vector<int> tempList;\\n    findNsum(nums, target, 4, tempList, results);\\n    return results;\\n  }\\n  void findNsum(vector<int> nums, int target, int N,\\n      vector<int> tempList,\\n      vector<vector<int> >& results) {\\n    if (nums.size() < N || N < 2) return;\\n    if (N == 2) {\\n      int l = 0, r = nums.size() - 1;\\n      while (l < r) {\\n        if (nums[l] + nums[r] == target) {\\n          vector<int> bufList = tempList;\\n          bufList.push_back(nums[l]);\\n          bufList.push_back(nums[r]);\\n          results.push_back(bufList);\\n          l += 1;\\n          r -= 1;\\n          while (l < r && nums[l] == nums[l - 1])\\n            l += 1;\\n          while (r > l && nums[r] == nums[r + 1])\\n            r -= 1;\\n        }\\n        else if (nums[l] + nums[r] < target) l += 1;\\n        else r -= 1;\\n      }\\n    } else {\\n      for (int i = 0; i < nums.size(); i++)\\n        if (i == 0 || i > 0 && nums[i - 1] != nums[i]) {\\n          vector<int> buf_nums;\\n          for (int j = i + 1; j < nums.size(); j++)\\n            buf_nums.push_back(nums[j]);\\n          vector<int> bufList = tempList;\\n          bufList.push_back(nums[i]);\\n          findNsum(buf_nums, target - nums[i],\\n              N - 1, bufList, results);\\n        }\\n    }\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\nimport java.lang.Math;\\n\\npublic class Solution {\\n  public List<List<Integer> > fourSum(\\n      int[] nums, int target\\n      ) {\\n    Arrays.sort(nums);\\n    List<List<Integer> > results = new ArrayList<List<Integer> >();\\n    List<Integer> tempList = new ArrayList<>();\\n    findNsum(nums, target, 4, tempList, results);\\n    return results;\\n  }\\n  void findNsum(int[] nums, int target, int N,\\n      List<Integer> tempList,\\n      List<List<Integer> > results) {\\n    if (nums.length < N || N < 2) return;\\n    if (N == 2) {\\n      int l = 0, r = nums.length - 1;\\n      while (l < r) {\\n        if (nums[l] + nums[r] == target) {\\n          List<Integer> bufList = new ArrayList<>();\\n          for (int ww = 0; ww < tempList.size(); ww++)\\n            bufList.add(tempList.get(ww));\\n          bufList.add(nums[l]);\\n          bufList.add(nums[r]);\\n          results.add(bufList);\\n          l += 1;\\n          r -= 1;\\n          while (l < r && nums[l] == nums[l - 1])\\n            l += 1;\\n          while (r > l && nums[r] == nums[r + 1])\\n            r -= 1;\\n        }\\n        else if (nums[l] + nums[r] < target) l += 1;\\n        else r -= 1;\\n      }\\n    } else {\\n      for (int i = 0; i < nums.length; i++)\\n        if (i == 0 || i > 0 && nums[i - 1] != nums[i]) {\\n          int[] buf_nums = new int[nums.length - i - 1];\\n          for (int j = i + 1; j < nums.length; j++)\\n            buf_nums[j - i - 1] = nums[j];\\n          List<Integer> bufList = new ArrayList<>();\\n          for (int ww = 0; ww < tempList.size(); ww++)\\n            bufList.add(tempList.get(ww));\\n          bufList.add(nums[i]);\\n          findNsum(buf_nums, target - nums[i], N - 1,\\n              bufList, results);\\n        }\\n    }\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def fourSum(self, nums: List[int], target: int):\\n        nums.sort()\\n        results = []\\n        self.findNsum(nums, target, 4, [], results)\\n        return results\\n\\n    def findNsum(\\n        self,\\n        nums: List[int],\\n        target: int,\\n        N: int,\\n        tempList: List[int],\\n        results: List[List[int]],\\n    ) -> None:\\n        if len(nums) < N or N < 2:\\n            return\\n\\n        # two-sum\\n        if N == 2:\\n            l = 0\\n            r = len(nums) - 1\\n            while l < r:\\n                if nums[l] + nums[r] == target:\\n                    results.append(tempList + [nums[l], nums[r]])\\n                    l += 1\\n                    r -= 1\\n                    # skip duplicated\\n                    while l < r and nums[l] == nums[l - 1]:\\n                        l += 1\\n                    while r > l and nums[r] == nums[r + 1]:\\n                        r -= 1\\n                elif nums[l] + nums[r] < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        # 缩减问题规模\\n        else:\\n            for i in range(0, len(nums)):\\n                # skip duplicated\\n                if i == 0 or i > 0 and nums[i - 1] != nums[i]:\\n                    self.findNsum(\\n                        nums[i + 1 :],\\n                        target - nums[i],\\n                        N - 1,\\n                        tempList + [nums[i]],\\n                        results,\\n                    )\\n        return\\n\\n\"}]},{\"title\":\"代码2.4.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\n#include <map>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int fourSumCount(const vector<int>& A,\\n      const vector<int>& B,\\n      const vector<int>& C,\\n      const vector<int>& D) {\\n    map<int, int> mapper;\\n    int res = 0;\\n    for (int i = 0; i < A.size(); i++)\\n      for (int j = 0; j < B.size(); j++) {\\n        if (mapper.count(A[i] + B[j]))\\n          mapper[A[i] + B[j]] = mapper[A[i] + B[j]] + 1;\\n        else\\n          mapper[A[i] + B[j]] = 1;\\n      }\\n    for (int i = 0; i < C.size(); i++)\\n      for (int j = 0; j < D.size(); j++)\\n        if (mapper.count(-1 * (C[i] + D[j])))\\n          res += mapper[-1 * (C[i] + D[j])];\\n    return res;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\n\\npublic class Solution {\\n  public int fourSumCount(int[] A,\\n      int[] B, int[] C, int[] D) {\\n    Map<Integer, Integer> mapper = new HashMap<Integer, Integer>();\\n    int res = 0;\\n    for (int i = 0; i < A.length; i++)\\n      for (int j = 0; j < B.length; j++) {\\n        if (mapper.get(A[i] + B[j]) != null)\\n          mapper.put(A[i] + B[j], mapper.get(A[i] + B[j]) + 1);\\n        else\\n          mapper.put(A[i] + B[j], 1);\\n      }\\n    for (int i = 0; i < C.length; i++)\\n      for (int j = 0; j < D.length; j++)\\n        if (mapper.get(-1 * (C[i] + D[j])) != null)\\n          res += mapper.get(-1 * (C[i] + D[j]));\\n    return res;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def fourSumCount(\\n        self, A: List[int], B: List[int], C: List[int], D: List[int]\\n    ) -> int:\\n        mapper = {}\\n        res = 0\\n        for i in A:\\n            for j in B:\\n                mapper[i + j] = mapper.get(i + j, 0) + 1\\n\\n        for i in C:\\n            for j in D:\\n                res += mapper.get(-1 * (i + j), 0)\\n        return res\\n\\n\"}]},{\"title\":\"代码2.5.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\n#include <cmath>\\n#include <cstdlib>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int threeSumClosest(vector<int>& nums, int target) {\\n    int n = nums.size();\\n    //if (n < 3) return;\\n    sort(nums.begin(), nums.end());\\n    int res = nums[0] + nums[1] + nums[2];\\n    for (int i = 0; i < n - 2; i++) {\\n      if (i && nums[i] == nums[i - 1]) continue;\\n      int l = i + 1, r = n - 1;\\n      while (l < r) {\\n        int s = nums[i] + nums[l] + nums[r];\\n        if (s == target) return s;\\n        if (abs(s - target) < abs(res - target))\\n          res = s;\\n        if (s < target) l += 1;\\n        else if (s > target) r -= 1;\\n      }\\n    }\\n    return res;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.lang.Math;\\nimport java.util.*;\\n\\npublic class Solution {\\n  public int threeSumClosest(int[] nums, int target) {\\n    int n = nums.length;\\n    //if (n < 3) return;\\n    Arrays.sort(nums);\\n    int res = nums[0] + nums[1] + nums[2];\\n    for (int i = 0; i < n - 2; i ++) {\\n      if (i != 0 && nums[i] == nums[i - 1]) continue;\\n      int l = i + 1, r = n - 1;\\n      while (l < r) {\\n        int s = nums[i] + nums[l] + nums[r];\\n        if (s == target) return s;\\n        if (Math.abs(s - target) < Math.abs(res - target))\\n          res = s;\\n        if (s < target) l += 1;\\n        else if (s > target) r -= 1;\\n      }\\n    }\\n    return res;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        if n < 3:\\n            return\\n        nums.sort()\\n        res = nums[0] + nums[1] + nums[2]\\n        for i in range(n - 2):\\n            # 去重\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n            # 固定 i，寻找 l 和 r，使用双指针法\\n            l = i + 1\\n            r = n - 1\\n            while l < r:\\n                s = nums[i] + nums[l] + nums[r]\\n                if s == target:\\n                    return s\\n\\n                if abs(s - target) < abs(res - target):\\n                    res = s\\n\\n                if s < target:\\n                    l += 1\\n                elif s > target:\\n                    r -= 1\\n\\n        return res\\n\\n\"}]},{\"title\":\"代码2.6.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <algorithm>\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int maxSubArray(const vector<int>& nums) {\\n    int n = nums.size();\\n    int maxSum = -0x7fffffff, total = 0;\\n    for (int i = 0; i < n; i++) {\\n      total = 0;\\n      for (int j = i; j < n; j++) {\\n        total += nums[j];\\n        maxSum = max(maxSum, total);\\n      }\\n    }\\n    return maxSum;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.lang.Math;\\n\\npublic class Solution {\\n  public int maxSubArray(int[] nums) {\\n    int n = nums.length;\\n    int maxSum = -0x7fffffff, total = 0;\\n    for (int i = 0; i < n; i++) {\\n      total = 0;\\n      for (int j = i; j < n; j++) {\\n        total += nums[j];\\n        maxSum = Math.max(maxSum, total);\\n      }\\n    }\\n    return maxSum;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        maxSum = float(\\\"-inf\\\")\\n        total = 0\\n        for i in range(n):\\n            total = 0\\n            for j in range(i, n):\\n                total += nums[j]\\n                maxSum = max(maxSum, total)\\n\\n        return maxSum\\n\\n\"}]},{\"title\":\"代码2.6.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int helper(const vector<int>& nums, int l, int r) {\\n    if (l > r) return -0x7fffffff;\\n    int mid = (l + r) / 2;\\n    int left = helper(nums, l, mid - 1);\\n    int right = helper(nums, mid + 1, r);\\n    int left_suffix_max_sum = 0;\\n    int right_prefix_max_sum = 0;\\n    int total = 0;\\n    for (int i = mid - 1; i >= l; i--) {\\n      total += nums[i];\\n      left_suffix_max_sum = max(left_suffix_max_sum,\\n          total);\\n    }\\n    total = 0;\\n    for (int i = mid + 1; i < r + 1; i++) {\\n      total += nums[i];\\n      right_prefix_max_sum = max(right_prefix_max_sum,\\n          total);\\n    }\\n    int cross_max_sum = left_suffix_max_sum + \\\\\\n                        right_prefix_max_sum + \\\\\\n                        nums[mid];\\n    return max(cross_max_sum, max(left, right));\\n  }\\n  int maxSubArray(const vector<int>& nums) {\\n    return helper(nums, 0, nums.size() - 1);\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.lang.Math;\\n\\npublic class Solution {\\n  public int helper(int[] nums, int l, int r) {\\n    if (l > r) return -0x7fffffff;\\n    int mid = (l + r) / 2;\\n    int left = helper(nums, l, mid - 1);\\n    int right = helper(nums, mid + 1, r);\\n    int left_suffix_max_sum = 0;\\n    int right_prefix_max_sum = 0;\\n    int total = 0;\\n    for (int i = mid - 1; i >= l; i--) {\\n      total += nums[i];\\n      left_suffix_max_sum = Math.max(left_suffix_max_sum,\\n          total);\\n    }\\n    total = 0;\\n    for (int i = mid + 1; i < r + 1; i ++) {\\n      total += nums[i];\\n      right_prefix_max_sum = Math.max(right_prefix_max_sum,\\n          total);\\n    }\\n    int cross_max_sum = left_suffix_max_sum\\n      + right_prefix_max_sum\\n      + nums[mid];\\n    return Math.max(cross_max_sum, Math.max(left, right));\\n  }\\n  public int maxSubArray(int[] nums) {\\n    return helper(nums, 0, nums.length - 1);\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        return self.helper(nums, 0, len(nums) - 1)\\n\\n    def helper(self, nums: List[int], l: int, r: int) -> int:\\n        if l > r:\\n            return float(\\\"-inf\\\")\\n        mid = (l + r) // 2\\n        left = self.helper(nums, l, mid - 1)\\n        right = self.helper(nums, mid + 1, r)\\n        left_suffix_max_sum = right_prefix_max_sum = 0\\n        total = 0\\n        for i in reversed(range(l, mid)):\\n            total += nums[i]\\n            left_suffix_max_sum = max(left_suffix_max_sum, total)\\n        total = 0\\n        for i in range(mid + 1, r + 1):\\n            total += nums[i]\\n            right_prefix_max_sum = max(right_prefix_max_sum, total)\\n        cross_max_sum = left_suffix_max_sum + right_prefix_max_sum + nums[mid]\\n        return max(cross_max_sum, left, right)\\n\\n\"}]},{\"title\":\"代码2.6.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int maxSubArray(const vector<int>& nums) {\\n    int n = nums.size();\\n    int max_sum_ending_curr_idx = nums[0];\\n    int max_sum = nums[0];\\n    for (int i = 1; i < n; i++) {\\n      max_sum_ending_curr_idx = max(\\n          max_sum_ending_curr_idx + nums[i],\\n          nums[i]\\n          );\\n      max_sum = max(\\n          max_sum_ending_curr_idx,\\n          max_sum\\n          );\\n    }\\n    return max_sum;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.lang.Math;\\n\\npublic class Solution {\\n  public int maxSubArray(int[] nums) {\\n    int n = nums.length;\\n    int max_sum_ending_curr_idx = nums[0];\\n    int max_sum = nums[0];\\n    for (int i = 1; i < n; i++) {\\n      max_sum_ending_curr_idx = Math.max(\\n          max_sum_ending_curr_idx + nums[i],\\n          nums[i]\\n          );\\n      max_sum = Math.max(\\n          max_sum_ending_curr_idx,\\n          max_sum\\n          );\\n    }\\n    return max_sum;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        max_sum_ending_curr_index = max_sum = nums[0]\\n        for i in range(1, n):\\n            max_sum_ending_curr_index = max(\\n                max_sum_ending_curr_index + nums[i], nums[i]\\n            )\\n            max_sum = max(max_sum_ending_curr_index, max_sum)\\n\\n        return max_sum\\n\\n\"}]},{\"title\":\"代码2.6.4\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <algorithm>\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int maxSubArray(const vector<int>& nums) {\\n    int n = nums.size();\\n    int maxSum = nums[0], minSum = 0, sum = 0;\\n    for (int i = 0; i < n; i++) {\\n      sum += nums[i];\\n      maxSum = max(maxSum, sum - minSum);\\n      minSum = min(minSum, sum);\\n    }\\n    return maxSum;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.lang.Math;\\n\\npublic class Solution {\\n  public int maxSubArray(int[] nums) {\\n    int n = nums.length;\\n    int maxSum = nums[0], minSum = 0, sum = 0;\\n    for (int i = 0; i < n; i++) {\\n      sum += nums[i];\\n      maxSum = Math.max(maxSum, sum - minSum);\\n      minSum = Math.min(minSum, sum);\\n    }\\n    return maxSum;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        maxSum = nums[0]\\n        minSum = sum = 0\\n        for i in range(n):\\n            sum += nums[i]\\n            maxSum = max(maxSum, sum - minSum)\\n            minSum = min(minSum, sum)\\n\\n        return maxSum\\n\\n\"}]},{\"title\":\"代码2.7.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <string>\\n#include <vector>\\n#include <algorithm>\\n#include <cstdlib>\\n#include <cstdio>\\nusing namespace std;\\n\\nstruct my_str {\\n  string str;\\n  my_str(int num): str(to_string(num)) {}\\n  bool operator < (const my_str& rhs) const {\\n    return str + rhs.str > rhs.str + str;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  string largestNumber(const vector<int>& nums) {\\n    vector<my_str> s;\\n    for (int i = 0; i < nums.size(); i++)\\n      s.push_back(my_str(nums[i]));\\n    sort(s.begin(), s.end());\\n    string ans(\\\"\\\");\\n    for (int i = 0; i < nums.size(); i++)\\n      ans += s[i].str;\\n    string real_ans(\\\"\\\");\\n    bool flag = false;\\n    for (int i = 0; i < ans.length(); i++) {\\n      if (!flag) flag = !(ans[i] == '0');\\n      if (flag) real_ans.push_back(ans[i]);\\n    }\\n    if (!flag) return string(\\\"0\\\");\\n    else return real_ans;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\n\\npublic class Solution {\\n  public class my_str {\\n    public String str;\\n    public void setStr(int num) {\\n        Integer buf_num = new Integer(num);\\n        this.str = buf_num.toString();\\n    }\\n  }\\n  public class my_cmp implements Comparator<my_str> {\\n    @Override\\n    public int compare(my_str a, my_str b) {\\n      if (a != null && b != null) {\\n        String left = a.str + b.str;\\n        String right = b.str + a.str;\\n        return right.compareTo(left);\\n      }\\n      return 0;\\n    }\\n  }\\n  String largestNumber(int[] nums) {\\n    my_str[] s;\\n    s = new my_str[nums.length];\\n    for (int i = 0; i < nums.length; i++) {\\n        s[i] = new my_str();\\n        s[i].setStr(nums[i]);\\n    }\\n    Arrays.sort(s, new my_cmp());\\n    String ans = \\\"\\\";\\n    for (int i = 0; i < nums.length; i++)\\n      if (s[i] != null) ans = ans + s[i].str;\\n    String real_ans = \\\"\\\";\\n    boolean flag = false;\\n    for (int i = 0; i < ans.length(); i++) {\\n      if (!flag) flag = !(ans.charAt(i) == '0');\\n      if (flag) real_ans = real_ans + ans.substring(i, i + 1);\\n    }\\n    if (!flag) return \\\"0\\\";\\n    else return real_ans;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"import functools\\n\\n\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        s = [str(i) for i in nums]\\n\\n        def comp(a, b):\\n            if (a + b) > (b + a):\\n                return 1\\n            if (a + b) < (b + a):\\n                return -1\\n            return 0\\n\\n        # 这里加了一次 int 转换过程，用于处理第一个数字为 0 的情况\\n        s.sort(reverse=True, key=functools.cmp_to_key(comp))\\n        return str(int(\\\"\\\".join(s)))\\n\\n\"}]},{\"title\":\"代码2.7.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\n#include <algorithm>\\n#include <cstdio>\\n#include <string>\\n#include <cstdlib>\\nusing namespace std;\\n\\nstring largestNumber(const vector<int>& nums) {\\n  vector<string> s;\\n  for (int i = 0; i < nums.size(); i++)\\n    s.push_back(to_string(nums[i]));\\n  // clang++/g++: need parameter '-std=c++11'\\n  sort(s.begin(), s.end(), [](string a, string b)\\n      -> bool {\\n      return a + b > b + a;\\n      });\\n  string ans(\\\"\\\");\\n  for (int i = 0; i < nums.size(); i++)\\n    ans += s[i];\\n    string real_ans(\\\"\\\");\\n    bool flag = false;\\n    for (int i = 0; i < ans.length(); i++) {\\n      if (!flag) flag = !(ans[i] == '0');\\n      if (flag) real_ans.push_back(ans[i]);\\n    }\\n    if (!flag) return string(\\\"0\\\");\\n    else return real_ans;\\n}\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\n\\npublic class Solution {\\n  public String largestNumber(int[] nums) {\\n    String[] s = new String[nums.length];\\n    for (int i = 0; i < nums.length; i++)\\n      s[i] = String.valueOf(nums[i]);\\n    List<String> str = Arrays.asList(s);\\n    str.sort((String a, String b) -> {\\n      String left = a + b, right = b + a;\\n      return right.compareTo(left);\\n    });\\n    String ans = \\\"\\\";\\n    for (int i = 0; i < nums.length; i++)\\n      ans = ans + str.get(i);\\n    String real_ans = \\\"\\\";\\n    boolean flag = false;\\n    for (int i = 0; i < ans.length(); i++) {\\n      if (!flag) flag = !(ans.charAt(i) == '0');\\n      if (flag) real_ans = real_ans + ans.substring(i, i + 1);\\n    }\\n    if (!flag) return \\\"0\\\";\\n    else return real_ans;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"def largestNumber(self, nums: List[int]) -> str:\\n    return str(int(\\\"\\\".join(sorted(map(str, nums), cmp=lambda a, b: cmp(b + a, a + b)))))\\n\\n\"}]},{\"title\":\"代码2.8.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <cstdlib>\\n#include <cmath>\\n#include <string>\\n#include <map>\\nusing namespace std;\\n\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n  string fractionToDecimal(ll numerator,\\n      ll denominator) {\\n    string res(\\\"\\\");\\n    if (double(numerator) / double(denominator) < 0.0) res += \\\"-\\\";\\n    numerator = llabs(numerator);\\n    denominator = llabs(denominator);\\n    ll n = numerator / denominator;\\n    ll remainder = numerator % denominator;\\n    res += to_string(n);\\n    if (!remainder) return res;\\n    res += \\\".\\\";\\n    int idx = res.size();\\n    map<ll, int> seen;\\n    while (remainder && !seen.count(remainder)) {\\n      seen[remainder] = idx++;\\n      n = (remainder * 10LL) / denominator;\\n      remainder = (remainder * 10LL) % denominator;\\n      res += to_string(n);\\n    }\\n    if (remainder) {\\n      res.insert(seen[remainder], 1, '(');\\n      res += \\\")\\\";\\n    }\\n    return res;\\n  }\\n};\\n\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\nimport java.lang.Math;\\n\\npublic class Solution {\\n  public String fractionToDecimal(long numerator,\\n      long denominator) {\\n    String res = \\\"\\\";\\n    if ((double)numerator / (double)denominator < 0.0) res = res + \\\"-\\\";\\n    numerator = Math.abs(numerator);\\n    denominator = Math.abs(denominator);\\n    long n = numerator / denominator;\\n    long remainder = numerator % denominator;\\n    res = res + String.valueOf(n);\\n    if (remainder == 0) return res;\\n    res = res + \\\".\\\";\\n    int idx = res.length();\\n    Map<Long, Integer> seen = new HashMap<Long,\\n      Integer>();\\n    while (remainder != 0 && seen.get(remainder) == null) {\\n      seen.put(remainder, idx);\\n      idx = idx + 1;\\n      n = (remainder * 10) / denominator;\\n      remainder = (remainder * 10) % denominator;\\n      res = res + String.valueOf(n);\\n    }\\n    if (remainder != 0) {\\n      StringBuffer ano_str =  new StringBuffer(res);\\n      ano_str.insert(seen.get(remainder), \\\"(\\\");\\n      res = ano_str.toString();\\n      res += \\\")\\\";\\n    }\\n    return res;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # 最终结果由两部分组成， 符号和值\\n        # 简单起见，全部取绝对值，计算出最终结果的值\\n        # 符号我们可以通过除是否大于0来判断\\n\\n        # 长除法\\n        n, remainder = divmod(abs(numerator), abs(denominator))\\n        sign = \\\"\\\"\\n        if numerator // denominator < 0:\\n            sign = \\\"-\\\"\\n\\n        res = [str(n), \\\".\\\"]\\n        seen = []\\n        while remainder not in seen:\\n            seen.append(remainder)\\n            n, remainder = divmod(remainder * 10, abs(denominator))\\n            res.append(str(n))\\n        # 处理循环节的格式\\n        index = seen.index(remainder)\\n        res.insert(index + 2, \\\"(\\\")\\n        res.append(\\\")\\\")\\n\\n        return sign + \\\"\\\".join(res).replace(\\\"(0)\\\", \\\"\\\").rstrip(\\\".\\\")\\n\\n\"}]},{\"title\":\"代码2.9.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\n#include <set>\\n#include <map>\\n#include <algorithm>\\nusing namespace std;\\n\\nstruct node {\\n  set<int> s;\\n  node() {\\n    s.clear();\\n  }\\n  bool operator < (const node& rhs) const {\\n    return s.size() > rhs.s.size();\\n  }\\n  void operator = (const node& rhs) {\\n    s = rhs.s;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  vector<int> largestDivisibleSubset(\\n      vector<int>& nums\\n      ) {\\n    map<int, node> S;\\n    S[-1] = node();\\n    sort(nums.begin(), nums.end());\\n    for (int i = 0; i < nums.size(); i++) {\\n      int x = nums[i];\\n      vector<node> temp;\\n      for (map<int, node>::iterator it = S.begin();\\n          it != S.end(); it++) {\\n        int d = it->first;\\n        if (x % d == 0) {\\n          S[d].s.insert(x);\\n          temp.push_back(S[d]);\\n          S[d].s.erase(x);\\n        }\\n      }\\n      node buf = node();\\n      for (int j = 0; j < temp.size(); j++)\\n        if (temp[j] < buf) buf = temp[j];\\n      if (!buf.s.count(x)) buf.s.insert(x);\\n      S[x] = buf;\\n    }\\n    vector<int> ans;\\n    node buf = node();\\n    for (map<int, node>::iterator it = S.begin();\\n        it != S.end(); it++)\\n      if (it->second < buf) buf = it->second;\\n    for (set<int>::iterator it = buf.s.begin();\\n        it != buf.s.end(); it++)\\n      ans.push_back(*it);\\n    return ans;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\n\\npublic class Solution {\\n  public class node {\\n    Set<Integer> s;\\n    node() {\\n      this.s = new HashSet<Integer>();\\n    }\\n    boolean less (node rhs) {\\n      return this.s.size() > rhs.s.size();\\n    }\\n  }\\n  public List<Integer> largestDivisibleSubset(int[] nums) {\\n    Map<Integer, node> S = new HashMap<Integer, node>();\\n    S.put(-1, new node());\\n    Arrays.sort(nums);\\n    for (int i = 0; i < nums.length; i++) {\\n      int x = nums[i];\\n      List<node> temp = new ArrayList<>();\\n      Set<Map.Entry<Integer, node> > key_set = S.entrySet();\\n      Iterator<Map.Entry<Integer, node> > it = key_set.iterator();\\n      while (it.hasNext()) {\\n        Map.Entry<Integer, node> entry = it.next();\\n        int d = entry.getKey();\\n        if (x % d == 0) {\\n          entry.getValue().s.add(x);\\n          temp.add(S.get(d));\\n          S.get(d).s.remove(x);\\n        }\\n      }\\n      node buf = new node();\\n      for (int j = 0; j < temp.size(); j++)\\n        if (temp.get(j).less(buf)) {\\n          buf.s = new HashSet<Integer>();\\n          Iterator<Integer> copy_it = temp.get(j).s.iterator();\\n          while (copy_it.hasNext()) {\\n            Integer buf_val = copy_it.next();\\n            buf.s.add(buf_val);\\n          }\\n        }\\n      if (!buf.s.contains(x)) buf.s.add(x);\\n      S.put(x, buf);\\n    }\\n    List<Integer> ans = new ArrayList<>();\\n    node buf = new node();\\n    Set<Map.Entry<Integer, node> > key_set = S.entrySet();\\n    Iterator<Map.Entry<Integer, node> > it = key_set.iterator();\\n    while (it.hasNext()) {\\n      Map.Entry<Integer, node> entry = it.next();\\n      node mid = entry.getValue();\\n      if (mid.less(buf)) buf.s = mid.s;\\n    }\\n    Iterator<Integer> ano_it = buf.s.iterator();\\n    while (ano_it.hasNext()) {\\n      Integer val = ano_it.next();\\n      ans.add(val);\\n    }\\n    return ans;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        # base case for simplicity\\n        S = {-1: set()}\\n        nums.sort()\\n        for x in nums:\\n            temp = []\\n            for d in S:\\n                if x % d == 0:\\n                    S[d].add(x)\\n                    temp.append(S[d])\\n                    S[d].remove(x)\\n            S[x] = max(temp, key=len) | {x}\\n        return list(max(S.values(), key=len))\\n\\n\"}]},{\"title\":\"代码2.9.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"// reference 2.9.1.largestDivisibleSubset.cpp\\n\\n\\n\"},{\"language\":\"Java\",\"content\":\"// reference 2.9.1.largestDivisibleSubset.java\\n\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        S = {-1: set()}\\n        for x in sorted(nums):\\n            S[x] = max((S[d] for d in S if x % d == 0), key=len) | {x}\\n        return list(max(S.values(), key=len))\\n\\n\"}]},{\"title\":\"代码2.10.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"typedef long long ll;\\n\\nconst ll magic = 1000000007LL;\\n\\nclass Solution {\\npublic:\\n  ll factorial(ll n) {\\n    return (n <= 1LL) ? 1LL : n % magic * (factorial(n - 1) % magic) % magic;\\n  }\\n  ll numPrimeArrangements(ll n) {\\n    ll primes[] = {\\n            2,\\n            3,\\n            5,\\n            7,\\n            11,\\n            13,\\n            17,\\n            19,\\n            23,\\n            29,\\n            31,\\n            37,\\n            41,\\n            43,\\n            47,\\n            53,\\n            59,\\n            61,\\n            67,\\n            71,\\n            73,\\n            79,\\n            83,\\n            89,\\n            97,\\n            101,\\n    };\\n    int primeCount = 0;\\n    while (primes[primeCount] <= n)\\n      primeCount += 1;\\n    return factorial(primeCount) % magic * \\\\\\n      (factorial(n - primeCount) % magic) % magic;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Solution {\\n  public final long magic = (long)1000000007;\\n  public long factorial(long n) {\\n    return (n <= 1) ? 1 : n % magic * (factorial(n - 1) % magic) % magic;\\n  }\\n  public int numPrimeArrangements(int n) {\\n    int[] primes = {\\n            2,\\n            3,\\n            5,\\n            7,\\n            11,\\n            13,\\n            17,\\n            19,\\n            23,\\n            29,\\n            31,\\n            37,\\n            41,\\n            43,\\n            47,\\n            53,\\n            59,\\n            61,\\n            67,\\n            71,\\n            73,\\n            79,\\n            83,\\n            89,\\n            97,\\n            101\\n    };\\n    int primeCount = 0;\\n    while (primes[primeCount] <= n)\\n      primeCount += 1;\\n    return (int)(factorial((long)primeCount) % magic *\\n      (factorial((long)n - (long)primeCount) % magic) % magic);\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def numPrimeArrangements(self, n: int) -> int:\\n        def factorial(n) -> int:\\n            if n <= 1:\\n                return 1\\n            return n * factorial(n - 1)\\n\\n        primes = [\\n            2,\\n            3,\\n            5,\\n            7,\\n            11,\\n            13,\\n            17,\\n            19,\\n            23,\\n            29,\\n            31,\\n            37,\\n            41,\\n            43,\\n            47,\\n            53,\\n            59,\\n            61,\\n            67,\\n            71,\\n            73,\\n            79,\\n            83,\\n            89,\\n            97,\\n            101,\\n        ]\\n\\n        primeCount = 0\\n        while primes[primeCount] <= n:\\n            primeCount += 1\\n        return factorial(primeCount) * factorial(n - primeCount) % (10 ** 9 + 7)\\n\\n\"}]}]},{\"id\":\"03\",\"name\":\"第三章\",\"list\":[{\"title\":\"代码3.1.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <iostream>\\n#include <string>\\n\\nbool isPalindrome(std::string s, int n) {\\n  int l = 0;\\n  int r = n - 1;\\n  while (l < r) {\\n    if (s[l] != s[r])\\n      return false;\\n    l += 1;\\n    r -= 1;\\n  }\\n  return true;\\n}\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  public boolean isPalindrome(String s, int n) {\\n    int l = 0;\\n    int r = n - 1;\\n    while (l < r) {\\n      if (s.charAt(l) != s.charAt(r)) return false;\\n      l += 1;\\n      r -= 1;\\n    }\\n    return true;\\n  }\\n}\\n\\n\"},{\"language\":\"Js\",\"content\":\"function isPalindrome(s, n) {\\n  let l = 0\\n  let r = n - 1\\n  while (l < r) {\\n    if (s[l] !== s[r]) return false\\n    l += 1\\n    r -= 1\\n  }\\n  return true\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"def isPalindrome(s: str, n: int) -> bool:\\n    l = 0\\n    r = n - 1\\n    while l < r:\\n        if s[l] != s[r]:\\n            return False\\n        l += 1\\n        r -= 1\\n\\n    return True\\n\\n\"}]},{\"title\":\"代码3.1.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n  bool isPalindrome(string s, int i, int n) {\\n    int l = 0;\\n    int r = n - 1;\\n    while (l < r) {\\n      if (l == i)\\n        l += 1;\\n      else if (r == i)\\n        r -= 1;\\n      if (s[l] != s[r])\\n        return false;\\n      l += 1;\\n      r -= 1;\\n    }\\n    return true;\\n  }\\n  bool validPalindrome(string s) {\\n    int n = s.length();\\n    int l = 0;\\n    int r = n - 1;\\n    while (l < r) {\\n      if (s[l] != s[r]) {\\n        return isPalindrome(s, l, n) || isPalindrome(s, r, n);\\n      }\\n      l += 1;\\n      r -= 1;\\n    }\\n    return true;\\n  }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  private boolean isPalindrome(String s, int i, int n) {\\n    int l = 0;\\n    int r = n - 1;\\n    while (l < r) {\\n      if (l == i) l += 1;\\n      else if (r == i) r -= 1;\\n      if (s.charAt(l) != s.charAt(r)) return false;\\n      l += 1;\\n      r -= 1;\\n    }\\n    return true;\\n  }\\n\\n  public boolean validPalindrome(String s) {\\n    int n = s.length();\\n    int l = 0;\\n    int r = n - 1;\\n    while (l < r) {\\n      if (s.charAt(l) != s.charAt(r)) {\\n        return isPalindrome(s, l, n) || isPalindrome(s, r, n);\\n      }\\n      l += 1;\\n      r -= 1;\\n    }\\n    return true;\\n  }\\n}\\n\\n\"},{\"language\":\"Js\",\"content\":\"/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nconst validPalindrome = function(s) {\\n  function isPalindrome(s, i, n) {\\n    let l = 0\\n    let r = n - 1\\n    while (l < r) {\\n      if (l == i) l += 1\\n      else if (r == i) r -= 1\\n      if (s.charAt(l) != s.charAt(r)) return false\\n      l += 1\\n      r -= 1\\n    }\\n    return true\\n  }\\n\\n  const n = s.length\\n  let l = 0\\n  let r = n - 1\\n  while (l < r) {\\n    if (s.charAt(l) != s.charAt(r)) {\\n      return isPalindrome(s, l, n) || isPalindrome(s, r, n)\\n    }\\n    l += 1\\n    r -= 1\\n  }\\n  return true\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        n = len(s)\\n\\n        def isPalindrome(s: str, i: int, n: int) -> bool:\\n            l = 0\\n            r = n - 1\\n            while l < r:\\n                if l == i:\\n                    l += 1\\n                elif r == i:\\n                    r -= 1\\n                if s[l] != s[r]:\\n                    return False\\n                l += 1\\n                r -= 1\\n\\n            return True\\n\\n        l = 0\\n        r = n - 1\\n\\n        while l < r:\\n            if s[l] != s[r]:\\n                return isPalindrome(s, l, n) or isPalindrome(s, r, n)\\n            l += 1\\n            r -= 1\\n        return True\\n\\n\"}]},{\"title\":\"代码3.2.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <cstdio>\\n#include <cstdlib>\\n\\nclass Solution {\\npublic:\\n  ListNode *reverseList(ListNode *head) {\\n    if (!head) return NULL;\\n    ListNode *prev = NULL, *cur = head;\\n    while (cur) {\\n      cur->next = prev;\\n      prev = cur;\\n      cur = cur->next;\\n    }\\n    return prev;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Solution {\\n  public ListNode reverseList(ListNode head) {\\n    if (!head) return null;\\n    ListNode prev = null, cur = head;\\n    while (cur) {\\n      cur.next = prev;\\n      prev = cur;\\n      cur = cur.next;\\n    }\\n    return prev;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        if not head:\\n            return None\\n        prev = None\\n        cur = head\\n        while cur:\\n            cur.next, prev, cur = prev, cur, cur.next\\n        return prev\\n\\n\"}]},{\"title\":\"代码3.2.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <cstdio>\\n#include <cstdlib>\\n\\nclass Solution {\\npublic:\\n  bool isPalindrome(ListNode *head) {\\n    ListNode *pre = NULL;\\n    ListNode *slow = head, *fast = head;\\n    while (fast && fast->next) {\\n      fast = fast->next->next;\\n      ListNode *next = slow->next;\\n      slow->next = pre;\\n      pre = slow;\\n      slow = next;\\n    }\\n    if (fast) slow = slow->next;\\n    while (slow) {\\n      if (slow->val != pre->val) return false;\\n      pre = pre->next;\\n      slow = slow->next;\\n    }\\n    return true;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Solution {\\n  public boolean isPalindrome(ListNode head) {\\n    ListNode pre = null;\\n    ListNode slow = head, fast = head;\\n    while (fast != null && fast.next != null) {\\n      fast = fast.next.next;\\n      ListNode next = slow.next;\\n      slow.next = pre;\\n      pre = slow;\\n      slow = next;\\n    }\\n    if (fast != null) slow = slow.next;\\n    while (slow != null) {\\n      if (slow.val != pre.val) return false;\\n      pre = pre.next;\\n      slow = slow.next;\\n    }\\n    return true;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def isPalindrome(self, head: ListNode) -> bool:\\n        pre = None\\n        slow = fast = head\\n\\n        # 一边反转前半部分，一边找中点\\n        while fast and fast.next:\\n            # 先更新fast指针\\n            fast = fast.next.next\\n            # 再反转和更新slow指针\\n            next = slow.next\\n            slow.next = pre\\n            pre = slow\\n            slow = next\\n        # 处理奇数个节点的情况\\n        if fast:\\n            slow = slow.next\\n        # 从中点开始分别向前和后遍历，逐个比较是否相同即可\\n        while slow:\\n            if slow.val != pre.val:\\n                return False\\n            pre = pre.next\\n            slow = slow.next\\n        return True\\n\\n\"}]},{\"title\":\"代码3.3.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n  bool isPalindrome(int x) {\\n    if (x < 0) return false;\\n    if (x == 0) return true;\\n    if (x % 10 == 0) return false;\\n    int res = 0, copy = x;\\n    while (x > 0) {\\n      res = res * 10 + (x % 10);\\n      x /= 10;\\n    }\\n    return copy == res;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Solution {\\n  public boolean isPalindrome(int x) {\\n    if (x < 0) return false;\\n    if (x == 0) return true;\\n    if (x % 10 == 0) return false;\\n    int res = 0, copy = x;\\n    while (x  > 0) {\\n      res = res * 10 + (x % 10);\\n      x = x / 10;\\n    }\\n    return copy == res;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x < 0:\\n            return False\\n        if x == 0:\\n            return True\\n        if x % 10 == 0:\\n            return False\\n\\n        res = 0\\n        copy = x\\n        while x > 0:\\n            res = res * 10 + (x % 10)\\n            x = x // 10\\n\\n        return copy == res\\n\\n\"}]},{\"title\":\"代码3.4.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <string>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  string extend(int i, int j, string s) {\\n    while (i >= 0 && j < s.length() && s[i] == s[j]) {\\n      i -= 1;\\n      j += 1;\\n    }\\n    return s.substr(i + 1, j - i - 1);\\n  }\\n  string longestPalindrome(string s) {\\n    int n = s.length();\\n    if (n == 0) return \\\"\\\";\\n    string res = s.substr(0, 1);\\n    for (int i = 0; i < n - 1; i++) {\\n      string e1 = extend(i, i, s);\\n      string e2 = extend(i, i + 1, s);\\n      if (max(e1.length(), e2.length()) > res.length())\\n        res = ((e1.length() > e2.length()) ? e1 : e2);\\n    }\\n    return res;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\nimport java.lang.Math;\\n\\npublic class Solution {\\n  public String extend(int i, int j, String s) {\\n    while (i >= 0 && j < s.length() && s.charAt(i) ==\\n        s.charAt(j)) {\\n      i -= 1;\\n      j += 1;\\n    }\\n    return s.substring(i + 1, j);\\n  }\\n  public String longestPalindrome(String s) {\\n    int n = s.length();\\n    if (n == 0) return \\\"\\\";\\n    String res = s.substring(0, 1);\\n    for (int i = 0; i < n - 1; i++) {\\n      String e1 = extend(i, i, s);\\n      String e2 = extend(i, i + 1, s);\\n      if (Math.max(e1.length(), e2.length()) > res.length())\\n        res = ((e1.length() > e2.length()) ? e1 : e2);\\n    }\\n    return res;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        if n == 0:\\n            return \\\"\\\"\\n        res = s[0]\\n\\n        def extend(i: int, j: int, s: str) -> str:\\n            while i >= 0 and j < len(s) and s[i] == s[j]:\\n                i -= 1\\n                j += 1\\n            return s[i + 1 : j]\\n\\n        for i in range(n - 1):\\n            # 以自身为中心点\\n            e1 = extend(i, i, s)\\n            # 以自身和自身的下一个元素为中心点\\n            e2 = extend(i, i + 1, s)\\n            if max(len(e1), len(e2)) > len(res):\\n                res = e1 if len(e1) > len(e2) else e2\\n        return res\\n\\n\"}]},{\"title\":\"代码3.5.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <cstdlib>\\n#include <string>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int longestPalindromeSubseq(string s) {\\n    int n = s.length();\\n    int **dp = (int **)malloc(n * sizeof(int *));\\n    for (int i = 0; i < n; i++) {\\n      dp[i] = (int *)malloc(n * sizeof(int));\\n      for (int j = 0; j < n; j++) dp[i][j] = 0;\\n    }\\n    for (int i = n - 1; i >= 0; i--)\\n      for (int j = i; j < n; j++) {\\n        if (i == j) dp[i][j] = 1;\\n        else if (s[i] == s[j])\\n          dp[i][j] = dp[i + 1][j - 1] + 2;\\n        else\\n          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\\n      }\\n    int ans = dp[0][n - 1];\\n    for (int i = 0; i < n; i++) free(dp[i]);\\n    free(dp);\\n    return ans;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.lang.Math;\\n\\npublic class Solution {\\n  public int longestPalindromeSubseq(String s) {\\n    int n = s.length();\\n    int[][] dp = new int[n][n];\\n    for (int i = 0; i < n; i++)\\n      for (int j = 0; j < n; j++) dp[i][j] = 0;\\n    for (int i = n - 1; i >= 0; i--)\\n      for (int j = i; j < n; j++) {\\n        if (i == j) dp[i][j] = 1;\\n        else if (s.charAt(i) == s.charAt(j))\\n          dp[i][j] = dp[i + 1][j - 1] + 2;\\n        else\\n          dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\\n      }\\n    return dp[0][n - 1];\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def longestPalindromeSubseq(self, s: str) -> int:\\n        n = len(s)\\n        dp = [[0] * n for i in range(n)]\\n\\n        for i in reversed(range(n)):\\n            for j in range(i, n):\\n                if i == j:\\n                    dp[i][j] = 1\\n                elif s[i] == s[j]:\\n                    dp[i][j] = dp[i + 1][j - 1] + 2\\n                else:\\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\\n        return dp[0][n - 1]\\n\\n\"}]},{\"title\":\"代码3.5.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <cstdlib>\\n#include <string>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int longestPalindromeSubseq(string s) {\\n    int n = s.length();\\n    int *pre = (int *)malloc(n * sizeof(int));\\n    int *cur = (int *)malloc(n * sizeof(int));\\n    for (int i = 0; i < n; i++)\\n      pre[i] = cur[i] = 0;\\n    for (int i = n - 1; i >= 0; i--) {\\n      for (int j = i; j < n; j++) {\\n        if (i == j) cur[j] = 1;\\n        else if (s[i] == s[j])\\n          cur[j] = pre[j - 1] + 2;\\n        else\\n          cur[j] = max(pre[j], cur[j - 1]);\\n      }\\n      for (int j = 0; j < n; j++) pre[j] = cur[j];\\n    }\\n    int ans = pre[n - 1];\\n    free(pre);\\n    free(cur);\\n    return ans;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.lang.Math;\\n\\npublic class Solution {\\n  public int longestPalindromeSubseq(String s) {\\n    int n = s.length();\\n    int[] pre = new int[n];\\n    int[] cur = new int[n];\\n    for (int i = 0; i < n; i++) pre[i] = cur[i] = 0;\\n    for (int i = n - 1; i >= 0; i--) {\\n      for (int j = i; j < n; j++) {\\n        if (i == j) cur[j] = 1;\\n        else if (s.charAt(i) == s.charAt(j))\\n          cur[j] = pre[j - 1] + 2;\\n        else\\n          cur[j] = Math.max(pre[j], cur[j - 1]);\\n      }\\n      for (int j = 0; j < n; j++) pre[j] = cur[j];\\n    }\\n    return pre[n - 1];\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def longestPalindromeSubseq(self, s: str) -> int:\\n        n = len(s)\\n        pre = [0] * n\\n        cur = [0] * n\\n\\n        for i in reversed(range(n)):\\n            for j in range(i, n):\\n                if i == j:\\n                    cur[j] = 1\\n                elif s[i] == s[j]:\\n                    cur[j] = pre[j - 1] + 2\\n                else:\\n                    cur[j] = max(pre[j], cur[j - 1])\\n            pre = cur.copy()\\n        return pre[-1]\\n\\n\"}]},{\"title\":\"代码3.6.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <cmath>\\n#include <cstdlib>\\n#include <string>\\nusing namespace std;\\n\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n  bool validPalindrome(string s) {\\n    int l = 0, r = s.length() - 1;\\n    while (l < r) {\\n      if (s[l] != s[r]) return false;\\n      l += 1;\\n      r -= 1;\\n    }\\n    return true;\\n  }\\n  int superpalindromesInRange(string L, string R) {\\n    int cnt = 0;\\n    ll l_num = 0LL, r_num = 0LL;\\n    for (int i = 0; i < L.length(); i++)\\n      l_num = (l_num * 10LL) + ll(L[i] - '0');\\n    for (int i = 0; i < R.length(); i++)\\n      r_num = (r_num * 10LL) + ll(R[i] - '0');\\n    for (ll i = ll(floor(sqrt(double(l_num))));\\n        i < ll(ceil(sqrt(double(r_num)))); i += 1LL)\\n      if (validPalindrome(to_string(i)) && \\\\\\n          validPalindrome(to_string(i * i))) cnt += 1;\\n    return cnt;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.lang.Math;\\n\\npublic class Solution {\\n  public boolean validPalindrome(String s) {\\n    int l = 0, r = s.length() - 1;\\n    while (l < r) {\\n      if (s.charAt(l) != s.charAt(r)) return false;\\n      l += 1;\\n      r -= 1;\\n    }\\n    return true;\\n  }\\n  public int superpalindromesInRange(String L, String R) {\\n    int cnt = 0;\\n    long lbound = (long)Math.floor(Math.sqrt(Long.parseLong(L)));\\n    long rbound = (long)Math.ceil(Math.sqrt(Long.parseLong(R)));\\n    for (long i = lbound; i < rbound; i += (long)1)\\n      if (validPalindrome(String.valueOf(i)) &&\\n          validPalindrome(String.valueOf(i * i)))\\n        cnt = cnt + 1;\\n    return cnt;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"import math\\n\\n\\nclass Solution:\\n    def superpalindromesInRange(self, L: str, R: str) -> int:\\n        cnt = 0\\n\\n        def validPalindrome(s: str) -> bool:\\n            l = 0\\n            r = len(s) - 1\\n            while l < r:\\n                if s[l] != s[r]:\\n                    return False\\n                l += 1\\n                r -= 1\\n            return True\\n\\n        for i in range(math.floor(int(L) ** 0.5), math.ceil(int(R) ** 0.5)):\\n            if validPalindrome(str(i)) and validPalindrome(str(i ** 2)):\\n                cnt += 1\\n        return cnt\\n\\n\"}]},{\"title\":\"代码3.6.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <map>\\n#include <string>\\n#include <cmath>\\n#include <cstdlib>\\n#include <iostream>\\n#include <limits.h>\\nusing namespace std;\\n\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n  bool validPalindrome(string s) {\\n    int l = 0, r = s.length() - 1;\\n    while (l < r) {\\n      if (s[l] != s[r]) return false;\\n      l += 1;\\n      r -= 1;\\n    }\\n    return true;\\n  }\\n  int superpalindromesInRange(string L, string R) {\\n    int cnt = 0;\\n    ll i = 1;\\n    map<ll, bool> seen;\\n    seen.clear();\\n    while (i < 100000LL) {\\n      ll power = ll(floor(log(i) / log(10.0) + 0.5));\\n      ll x = i, r = 0;\\n      while (x > 0LL) {\\n        r = r * 10LL + (x % 10LL);\\n        x /= 10LL;\\n      }\\n      ll Q = ll(i * pow(10, power) + \\\\\\n          r % ll(pow(10, power)));\\n      if (LLONG_MAX / Q < Q) return cnt;\\n      Q = Q * Q;\\n      ll l_num = 0LL, r_num = 0LL;\\n      for (int ww = 0; ww < L.size(); ww++)\\n        l_num = (l_num * 10LL) + ll(L[ww] - '0');\\n      for (int ww = 0; ww < R.size(); ww++)\\n        r_num = (r_num * 10LL) + ll(R[ww] - '0');\\n      if (Q > r_num) return cnt;\\n      if (Q >= l_num && validPalindrome(to_string(Q)))\\n        if (!seen.count(Q)) {\\n          cnt += 1;\\n          seen[Q] = true;\\n        }\\n      Q = i * pow(10, power + 1LL) + r;\\n      if (LLONG_MAX / Q < Q) return cnt;\\n      Q = Q * Q;\\n      if (Q >= l_num && Q <= r_num && validPalindrome(to_string(Q)))\\n        if (!seen.count(Q)) {\\n          cnt += 1;\\n          seen[Q] = true;\\n        }\\n      i += 1LL;\\n    }\\n    return cnt;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\nimport java.lang.Math;\\n\\npublic class Solution {\\n  public boolean validPalindrome(String s) {\\n    int l = 0, r = s.length() - 1;\\n    while (l < r) {\\n      if (s.charAt(l) != s.charAt(r)) return false;\\n      l += 1;\\n      r -= 1;\\n    }\\n    return true;\\n  }\\n  public int superpalindromesInRange(String L, String R) {\\n    int cnt = 0;\\n    long i = 1;\\n    Set<Long> seen = new HashSet<Long>();\\n    while (i < (long)100000) {\\n      long power = (long)Math.floor(Math.log(i) / Math.log(10.0) + 0.5);\\n      long x = i, r = 0;\\n      while (x > 0) {\\n        r = r * (long)10 + (x % (long)10);\\n        x /= (long)10;\\n      }\\n      long Q = (long)(i * Math.pow(10, power) +\\n          r % (long)Math.pow(10, power));\\n      if (Long.MAX_VALUE / Q < Q) return cnt;\\n      Q = Q * Q;\\n      if (Q > Long.parseLong(R)) return cnt;\\n      if (Q >= Long.parseLong(L) &&\\n          validPalindrome(String.valueOf(Q)))\\n        if (!seen.contains(Q)) {\\n          cnt = cnt + 1;\\n          seen.add(Q);\\n        }\\n      Q = (long)(i * Math.pow(10, power + 1) + r);\\n      if (Long.MAX_VALUE / Q < Q) return cnt;\\n      Q = Q * Q;\\n      if (Q >= Long.parseLong(L) && Q <= Long.parseLong(R) &&\\n          validPalindrome(String.valueOf(Q)))\\n        if (!seen.contains(Q)) {\\n          cnt = cnt + 1;\\n          seen.add(Q);\\n        }\\n      i = i + 1;\\n    }\\n    return cnt;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"import math\\n\\n\\nclass Solution:\\n    def superpalindromesInRange(self, L: str, R: str) -> int:\\n        cnt = 0\\n        i = 1\\n        # 防止重复的数据\\n        seen = {}\\n\\n        def validPalindrome(s: str) -> bool:\\n            l = 0\\n            r = len(s) - 1\\n            while l < r:\\n                if s[l] != s[r]:\\n                    return False\\n                l += 1\\n                r -= 1\\n            return True\\n\\n        while i < 10 ** 5:\\n            # log10 防止精度丢失问题\\n            power = math.floor(math.log10(i))\\n            x = i\\n            r = 0\\n            while x > 0:\\n                r = r * 10 + (x % 10)\\n                x = x // 10\\n            # 如果i等于123\\n            # 那么Q就是12321\\n            Q = (i * 10 ** power + r % 10 ** power) ** 2\\n\\n            if Q > int(R):\\n                return cnt\\n            if Q >= int(L) and validPalindrome(str(Q)):\\n                if Q not in seen:\\n                    cnt += 1\\n                    seen[Q] = True\\n            # 那么就是123321\\n            Q = (i * 10 ** (power + 1) + r) ** 2\\n            if Q >= int(L) and Q <= int(R) and validPalindrome(str(Q)):\\n                if Q not in seen:\\n                    cnt += 1\\n                    seen[Q] = True\\n            i += 1\\n\\n        return cnt\\n\\n\"}]}]},{\"id\":\"04\",\"name\":\"第四章\",\"list\":[{\"title\":\"代码4.1.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    string countAndSay(int n) {\\n        string res = \\\"1\\\";\\n        \\n        for (int i = 1; i < n; i++) {\\n            string tmp = \\\"\\\";\\n            char current_char = res[0];\\n            int  char_count   = 0;\\n            \\n            for (int j = 0; j < res.size(); j++) {\\n                if (res[j] != current_char) {\\n                    tmp += itoa(char_count) + current_char;\\n                    current_char = res[j];\\n                    char_count = 1;\\n                } else {\\n                    char_count += 1;\\n                }\\n            }\\n            \\n            tmp += itoa(char_count) + current_char;\\n            res = tmp;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class CountAndSay {\\n    public String countAndSay(int n) {\\n        String ans = \\\"1\\\";\\n        for (int i = 1; i < n; i++) {\\n            StringBuffer stringBuffer = new StringBuffer();\\n            char currentChar = ans.charAt(0);\\n            int charCount = 0;\\n\\n            for (int j = 0; j < ans.length(); j++) {\\n                if (ans.charAt(j) != currentChar) {\\n                    stringBuffer.append(charCount);\\n                    stringBuffer.append(currentChar);\\n                    currentChar = ans.charAt(j);\\n                    charCount = 1;\\n                } else {\\n                    charCount++;\\n                }\\n            }\\n            stringBuffer.append(charCount);\\n            stringBuffer.append(currentChar);\\n            ans = stringBuffer.toString();\\n        }\\n        return ans;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def countAndSay(self, n: int) -> str:\\n        ans = \\\"1\\\"\\n        for i in range(1, n):\\n            tmp = \\\"\\\"\\n            current_char, char_count = ans[0], 0\\n            for j in range(len(ans)):\\n                if ans[j] != current_char:\\n                    tmp += str(char_count) + current_char\\n                    current_char, char_count = ans[j], 1\\n                else:\\n                    char_count += 1\\n            tmp += str(char_count) + current_char\\n            ans = tmp\\n        return ans\\n\\n\\n\"}]},{\"title\":\"代码4.1.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if (n == 1) return \\\"1\\\";\\n        \\n        string pre_str = countAndSay(n - 1);\\n        \\n        int char_index = 0, char_count = 1;\\n        string cur_str = \\\"\\\";\\n        \\n        for (int i = 0; i < pre_str.length() - 1; i++) {\\n            if (pre_str[char_index] == pre_str[i + 1])\\n                char_count += 1;\\n            else {\\n                cur_str += to_string(char_count) + pre_str[char_index];\\n                char_index = i + 1;\\n                char_count = 1;\\n            }\\n        }\\n        \\n        cur_str += to_string(char_count) + pre_str[char_index];\\n        \\n        return cur_str;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class CountAndSay {\\n    public String countAndSay(int n) {\\n        String ans = \\\"1\\\";\\n        for (int i = 1; i < n; i++) {\\n            String tmp = \\\"\\\";\\n            char currentChar = ans.charAt(0);\\n            int charCount = 0;\\n\\n            for (int j = 0; j < ans.length(); j++) {\\n                if (ans.charAt(j) != currentChar) {\\n                    tmp += (charCount + \\\"\\\" + currentChar);\\n                    currentChar = ans.charAt(j);\\n                    charCount = 1;\\n                } else {\\n                    charCount++;\\n                }\\n            }\\n            tmp += (charCount + \\\"\\\" + currentChar);\\n            ans = tmp;\\n        }\\n        return ans;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n == 1:\\n            return \\\"1\\\"\\n        else:\\n            previous_string = self.countAndSay(n - 1)\\n            char_index, char_count = 0, 1\\n            current_string = \\\"\\\"\\n            for i in range(len(previous_string)):\\n                if (\\n                    i + 1 < len(previous_string)\\n                    and previous_string[char_index] == previous_string[i + 1]\\n                ):\\n                    char_count += 1\\n                else:\\n                    current_string += str(char_count) + previous_string[char_index]\\n                    char_index, char_count = i + 1, 1\\n\\n            return current_string\\n\\n\"}]},{\"title\":\"代码4.2.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\nprivate:\\n    bool compute(double a) {\\n        return fabs(24 - a) < 1e-8;\\n    }\\n    bool compute(double a, double b) {\\n        return compute(a + b) || compute(a - b) || compute(a * b) || (b && compute(a / b));\\n    }\\n    bool compute(double a, double b, double c) {\\n        return compute(a + b, c) || compute(a - b, c) || compute(a * b, c) || (b && compute(a / b, c)) ||\\n               compute(a, b + c) || compute(a, b - c) || compute(a, b * c) || (c && compute(a, b / c));\\n    }\\n    bool compute(double a, double b, double c, double d) {\\n        bool res = compute(a + b, c, d) || compute(a - b, c, d) || compute(a * b, c, d) || (b && compute(a / b, c, d)) ||\\n                   compute(a, b + c, d) || compute(a, b - c, d) || compute(a, b * c, d) || (c && compute(a, b / c, d)) ||\\n                   compute(a, b, c + d) || compute(a, b, c - d) || compute(a, b, c * d) || (d && compute(a, b, c / d));\\n        \\n        return res;\\n    }\\npublic:\\n    bool judgePoint24(vector<int>& nums) {\\n        sort (nums.begin(), nums.end());\\n        \\n        do {\\n            if (compute(nums[0], nums[1], nums[2], nums[3]))\\n                return true;\\n        } while (next_permutation(nums.begin(), nums.end()));\\n\\n        return false;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"package ch04.code;\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\npublic class TwentyFourGame {\\n    List<List<Double>> permutationList = new ArrayList<>();\\n\\n    // 9ms at best\\n    public boolean judgePoint24(int[] nums) {\\n        permuteUnique(nums);\\n        for (List<Double> permutation : permutationList) {\\n            if (compute(permutation))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean compute(List<Double> nums) {\\n        if (nums.size() == 1)\\n            return Math.abs(nums.get(0) - 24) <= 1e-6;\\n\\n        for (int i = 0; i < nums.size() - 1; i++) {\\n            // compute possible result from + - * /\\n            List<Double> tmpResultList = new ArrayList<>();\\n            tmpResultList.add(nums.get(i) + nums.get(i + 1));\\n            tmpResultList.add(nums.get(i) - nums.get(i + 1));\\n            tmpResultList.add(nums.get(i) * nums.get(i + 1));\\n            if (nums.get(i + 1) != 0) {\\n                tmpResultList.add(nums.get(i) / nums.get(i + 1));\\n            }\\n\\n            // replace nums[i] and nums[i+1] with the result\\n            // continue with the new list\\n            for (Double newNum : tmpResultList) {\\n                List<Double> newList = new ArrayList<>(nums);\\n                newList.set(i, newNum);\\n                newList.remove(i + 1);\\n                if (compute(newList))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n    public void permuteUnique(int[] nums) {\\n        boolean[] visited = new boolean[nums.length];\\n        Arrays.sort(nums);\\n        backtracking(nums, new ArrayList<>(), visited);\\n    }\\n\\n    private void backtracking(int[] nums, List<Double> tmp, boolean[] visited) {\\n        if (tmp.size() == nums.length) {\\n            permutationList.add(new ArrayList<>(tmp));\\n            return;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (visited[i])\\n                continue;\\n            // !visited[i - 1] 说明已经遍历完被撤销了状态记录\\n            if (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])\\n                continue;\\n            visited[i] = true;\\n            tmp.add((double) nums[i]);\\n            backtracking(nums, tmp, visited);\\n\\n            visited[i] = false;\\n            tmp.remove(tmp.size() - 1);\\n        }\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def judgePoint24(self, nums: List[int]) -> bool:\\n        permutations = self.permuteUnique(nums)\\n        for permutation in permutations:\\n            if self.compute(permutation):\\n                return True\\n        return False\\n\\n    def compute(self, nums: List[float]) -> bool:\\n        if len(nums) == 1:\\n            return abs(nums[0] - 24) <= 0.00001\\n        for i in range(len(nums) - 1):\\n            # compute possible result from + - * /\\n            tmp = []\\n            tmp.append(nums[i] + nums[i + 1])\\n            tmp.append(nums[i] - nums[i + 1])\\n            tmp.append(nums[i] * nums[i + 1])\\n            if nums[i + 1] != 0:\\n                tmp.append(nums[i] / nums[i + 1])\\n\\n            for num in tmp:\\n                new_list = nums[:]\\n                new_list[i] = num\\n                new_list.pop(i + 1)\\n                if self.compute(new_list):\\n                    return True\\n        return False\\n\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        permutations = []\\n        nums.sort()\\n        tmp = []\\n        visited = [False] * len(nums)\\n\\n        self.backtracking(nums, tmp, visited, permutations)\\n        return permutations\\n\\n    def backtracking(\\n        self, nums: List[int], tmp: List[float], visited: List[bool], perm: List[int],\\n    ) -> None:\\n        if len(nums) == len(tmp):\\n            perm.append(tmp[:])\\n            return\\n        for i in range(len(nums)):\\n            if visited[i]:\\n                continue\\n            if i > 0 and nums[i] == nums[i - 1] and not visited[i - 1]:\\n                continue\\n            visited[i] = True\\n            tmp.append(nums[i])\\n            self.backtracking(nums, tmp, visited, perm)\\n            visited[i] = False\\n            tmp.pop()\\n\\n\"}]},{\"title\":\"代码4.2.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\nprivate:\\n    bool compute(vector<double>& nums) {\\n        if (nums.size() == 1)\\n            return fabs(nums[0] - 24.0) < 1e-8;\\n        \\n        for (int left = 0; left < nums.size() - 1; left++) {\\n            for (int right = left + 1; right < nums.size(); right++) {\\n                vector<double> tmp;\\n                for (int k = 0; k < nums.size(); k++)\\n                    if (k != left && k != right) tmp.push_back(nums[k]);\\n                \\n                tmp.push_back(nums[left] + nums[right]);\\n                if (compute(tmp))\\n                    return  true;\\n                \\n                tmp.back() = nums[left] * nums[right];\\n                if (compute(tmp))\\n                    return true;\\n                \\n                tmp.back() = nums[left] - nums[right];\\n                if (compute(tmp))\\n                    return true;\\n                \\n                tmp.back() = nums[left] / nums[right];\\n                if (compute(tmp))\\n                    return true;\\n                \\n                tmp.back() = nums[right] - nums[left];\\n                if (compute(tmp))\\n                    return true;\\n                \\n                tmp.back() = nums[right] / nums[left];\\n                if (compute(tmp))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\npublic:\\n    bool judgePoint24(vector<int>& nums) {\\n        vector<double> tmp(nums.begin(), nums.end());\\n        return compute(tmp);\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"package ch04.code;\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\npublic class TwentyFourGame {\\n    public boolean judgePoint24(int[] nums) {\\n        double[] nums1 = new double[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            nums1[i] = nums[i];\\n        }\\n        return helper(nums1, 4);\\n    }\\n\\n    private boolean helper(double[] nums, int n) {\\n        if (n == 1)\\n            return Math.abs(nums[0] - 24) <= 1e-6;\\n\\n        double newNums[] = new double[4];\\n\\n        for (int left = 0; left < n - 1; left++) {\\n            for (int right = left + 1; right < n; right++) {\\n                int m = 0;\\n                // put all other num at the beginning first\\n                for (int k = 0; k < n; k++) {\\n                    if (k != left && k != right)\\n                        newNums[m++] = nums[k];\\n                }\\n                // put newNum in after + = * /\\n                newNums[m] = nums[left] + nums[right];\\n                if (helper(newNums, m + 1))\\n                    return true;\\n                newNums[m] = nums[left] - nums[right];\\n                if (helper(newNums, m + 1))\\n                    return true;\\n                newNums[m] = nums[right] - nums[left];\\n                if (helper(newNums, m + 1))\\n                    return true;\\n                newNums[m] = nums[left] * nums[right];\\n                if (helper(newNums, m + 1))\\n                    return true;\\n                if (nums[right] != 0) {\\n                    newNums[m] = nums[left] / nums[right];\\n                    if (helper(newNums, m + 1))\\n                        return true;\\n                }\\n                if (nums[left] != 0) {\\n                    newNums[m] = nums[right] / nums[left];\\n                    if (helper(newNums, m + 1))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def judgePoint24(self, nums: List[int]) -> bool:\\n        return self.compute([float(i) for i in nums], 4)\\n\\n    def compute(self, nums: List[int], n: int) -> bool:\\n        if n == 1:\\n            return abs(nums[0] - 24) < 0.000001\\n        new_nums = [0] * 4\\n\\n        for left in range(n - 1):\\n            for right in range(left + 1, n):\\n                index = 0\\n                for i in range(n):\\n                    if i != left and i != right:\\n                        new_nums[index] = nums[i]\\n                        index += 1\\n\\n                new_nums[index] = nums[left] + nums[right]\\n                if self.compute(new_nums, index + 1):\\n                    return True\\n                new_nums[index] = nums[left] - nums[right]\\n                if self.compute(new_nums, index + 1):\\n                    return True\\n                new_nums[index] = nums[right] - nums[left]\\n                if self.compute(new_nums, index + 1):\\n                    return True\\n                new_nums[index] = nums[right] * nums[left]\\n                if self.compute(new_nums, index + 1):\\n                    return True\\n                if nums[left] != 0:\\n                    new_nums[index] = nums[right] / nums[left]\\n                    if self.compute(new_nums, index + 1):\\n                        return True\\n                if nums[right] != 0:\\n                    new_nums[index] = nums[left] / nums[right]\\n                    if self.compute(new_nums, index + 1):\\n                        return True\\n        return False\\n\\n\"}]},{\"title\":\"代码4.3.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\nprivate:\\n    vector<vector<bool>> row_state;\\n    vector<vector<bool>> column_state;\\n    vector<vector<bool>> box_state;\\n    \\nprivate:\\n    void placeNumber(vector<vector<char>>& board, int row, int column, char d) {\\n        board[row][column] = d;\\n        row_state[row][d - '1']    = true;\\n        column_state[column][d - '1'] = true;\\n        box_state[((row / 3) * 3) + (column / 3)][d - '1'] = true;\\n    }\\n\\n    void undoNumberPlace(vector<vector<char>>& board, int row, int column, char d) {\\n        board[row][column] = '.';\\n        row_state[row][d - '1'] = false;\\n        column_state[column][d - '1'] = false;\\n        box_state[((row / 3) * 3) + (column / 3)][d - '1'] = false;\\n    }\\n\\n    void initialState(vector<vector<char>>& board) {\\n        for (int i = 0; i < 9; i++)\\n            for (int j = 0; j < 9; j++)\\n                if (board[i][j] != '.')\\n                    placeNumber(board, i, j, board[i][j]);\\n    }\\n    \\n    bool recursivePlaceNumber(vector<vector<char>>& board, int row, int column) {\\n        if (row == 9) return true;\\n        if (column == 9) return recursivePlaceNumber(board, row + 1, 0);\\n        if (board[row][column] != '.') return recursivePlaceNumber(board, row, column + 1);\\n        \\n        for (int i = '1'; i <= '9'; i++) {\\n            if (!(row_state[row][i - '1'] \\n                  || column_state[column][i - '1'] \\n                  || box_state[((row / 3) * 3) + (column / 3)][i - '1'])) {\\n                placeNumber(board, row, column, i);\\n                if (recursivePlaceNumber(board, row, column + 1) == true)\\n                    return true;\\n                undoNumberPlace(board, row, column, i);\\n            }\\n        }\\n        \\n        return false;\\n    }\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        row_state    = vector<vector<bool>>(9, vector<bool>(9, false));\\n        column_state = vector<vector<bool>>(9, vector<bool>(9, false));\\n        box_state    = vector<vector<bool>>(9, vector<bool>(9, false));\\n        \\n        initialState(board);\\n        \\n        recursivePlaceNumber(board, 0, 0);\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class SudokuSolver {\\n    public void solveSudoku(char[][] board) {\\n        boolean rowState[][] = new boolean[9][10];\\n        boolean columnState[][] = new boolean[9][10];\\n        boolean boxState[][] = new boolean[9][10];\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != '.') {\\n                    int index = board[i][j] - '0';\\n                    rowState[i][index] = true;\\n                    columnState[j][index] = true;\\n                    boxState[(i / 3) * 3 + j / 3][index] = true;\\n                }\\n            }\\n        }\\n        recursivePlaceNumber(board, rowState, columnState, boxState, 0, 0);\\n    }\\n\\n    private boolean recursivePlaceNumber(char[][] board, boolean[][] rowState, boolean[][] columnState, boolean[][] boxState, int row, int column) {\\n        if (column == 9) {\\n            column = 0;\\n            row++;\\n            if (row == 9) {\\n                // game complete\\n                return true;\\n            }\\n        }\\n\\n        if (board[row][column] != '.') {\\n            return recursivePlaceNumber(board, rowState, columnState, boxState, row, column + 1);\\n        } else {\\n            for (int i = 1; i < 10; i++) {\\n                if (rowState[row][i] || columnState[column][i] || boxState[(row / 3) * 3 + column / 3][i]) {\\n                    continue;\\n                } else {\\n                    placeNumber(board, rowState, columnState, boxState, row, column, i);\\n                    if (recursivePlaceNumber(board, rowState, columnState, boxState, row, column + 1)) {\\n                        return true;\\n                    }\\n                    undoNumberPlacement(board, rowState, columnState, boxState, row, column, i);\\n                }\\n            }\\n        }\\n        // failed to get an answer\\n        return false;\\n    }\\n\\n    private void placeNumber(char[][] board, boolean[][] rowState, boolean[][] columnState, boolean[][] boxState, int row, int column, int i) {\\n        rowState[row][i] = true;\\n        columnState[column][i] = true;\\n        boxState[(row / 3) * 3 + column / 3][i] = true;\\n        board[row][column] = (char) ('0' + i);\\n    }\\n\\n    private void undoNumberPlacement(char[][] board, boolean[][] rowState, boolean[][] columnState, boolean[][] boxState, int row, int column, int i) {\\n        rowState[row][i] = false;\\n        columnState[column][i] = false;\\n        boxState[(row / 3) * 3 + column / 3][i] = false;\\n        board[row][column] = '.';\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    row_state = [[False for i in range(10)] for _ in range(9)]\\n    column_state = [[False for i in range(10)] for _ in range(9)]\\n    box_state = [[False for i in range(10)] for _ in range(9)]\\n    board = []\\n\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        # leetcode 判定时会重复调用函数，因此需要反复初始化状态表\\n        self.row_state = [[False for i in range(10)] for _ in range(9)]\\n        self.column_state = [[False for i in range(10)] for _ in range(9)]\\n        self.box_state = [[False for i in range(10)] for _ in range(9)]\\n        self.board = board\\n        for i in range(9):\\n            for j in range(9):\\n                if self.board[i][j] != \\\".\\\":\\n                    num = int(self.board[i][j])\\n                    self.row_state[i][num] = True\\n                    self.column_state[j][num] = True\\n                    self.box_state[(i // 3) * 3 + j // 3][num] = True\\n\\n        def recursive_place_number(self, row: int, column: int,) -> bool:\\n            if column == 9:\\n                row += 1\\n                column = 0\\n                if row == 9:\\n                    return True\\n\\n            if self.board[row][column] != \\\".\\\":\\n                return recursive_place_number(self, row, column + 1)\\n            else:\\n                for i in range(1, 10):\\n                    if (\\n                        self.row_state[row][i]\\n                        or self.column_state[column][i]\\n                        or self.box_state[(row // 3) * 3 + column // 3][i]\\n                    ):\\n                        continue\\n                    else:\\n                        self.place_number(row, column, i)\\n                        if recursive_place_number(self, row, column + 1,):\\n                            return True\\n                        self.undo_number_placement(row, column, i)\\n            return False\\n\\n        recursive_place_number(self, 0, 0)\\n\\n    def place_number(self, row: int, column: int, i: int,) -> bool:\\n        self.row_state[row][i] = True\\n        self.column_state[column][i] = True\\n        self.box_state[(row // 3) * 3 + column // 3][i] = True\\n        self.board[row][column] = str(i)\\n\\n    def undo_number_placement(self, row: int, column: int, i: int,) -> bool:\\n        self.row_state[row][i] = False\\n        self.column_state[column][i] = False\\n        self.box_state[(row // 3) * 3 + column // 3][i] = False\\n        self.board[row][column] = \\\".\\\"\\n\\n\"}]},{\"title\":\"代码4.3.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\nprivate:\\n    vector<vector<bool>> row_state;\\n    vector<vector<bool>> column_state;\\n    vector<vector<bool>> box_state;\\n\\nprivate:\\n    pair<int, int> getMaxPossibleCoordinate(vector<vector<char>>& board) {\\n        int x = -1, y = -1, min_count = 9;\\n        for (int i = 0; i < 9; i++)\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != '.') continue;\\n                int tmp_count = 9;\\n                for (int k = 0; k < 9; k++) {\\n                    if (row_state[i][k] || column_state[j][k] || box_state[(i / 3) * 3 + j / 3][k])\\n                        tmp_count -= 1;\\n                }\\n                \\n                if (tmp_count == 1) return make_pair(i, j);\\n                if (min_count > tmp_count) {\\n                    min_count = tmp_count;\\n                    x = i;\\n                    y = j;\\n                }\\n            }\\n        \\n        return make_pair(x, y);\\n    }\\n\\n    void placeNumber(vector<vector<char>>& board, int row, int column, int i) {\\n        board[row][column] = i + '0';\\n        row_state[row][i]    = true;\\n        column_state[column][i] = true;\\n        box_state[((row / 3) * 3) + (column / 3)][i] = true;\\n    }\\n\\n    void undoNumberPlace(vector<vector<char>>& board, int row, int column, int i) {\\n        board[row][column] = '.';\\n        row_state[row][i] = false;\\n        column_state[column][i] = false;\\n        box_state[((row / 3) * 3) + (column / 3)][i] = false;\\n    }\\n\\n    void initialState(vector<vector<char>>& board) {\\n        for (int i = 0; i < 9; i++)\\n            for (int j = 0; j < 9; j++)\\n                if (board[i][j] != '.') {\\n                    row_state[i][board[i][j] - '0']     = true;\\n                    column_state[j][board[i][j] - '0']  = true;\\n                    box_state[(i / 3) * 3 + j / 3][board[i][j] - '0'] = true;\\n                }\\n    }\\n\\n    bool recursivePlaceNumber(vector<vector<char>>& board, int row, int column) {\\n        if (row == -1 and column == -1) return true;\\n        if (board[row][column] != '.') return false;\\n\\n        for (int i = 1; i < 10; i ++) {\\n            if (row_state[row][i] ||\\n                column_state[column][i] ||\\n                box_state[(row / 3) * 3 + column / 3][i]) {\\n                continue;\\n            } else {\\n                placeNumber(board, row, column, i);\\n                pair<int, int> coordinate = getMaxPossibleCoordinate(board);\\n                if (recursivePlaceNumber(board, coordinate.first, coordinate.second))\\n                    return true;\\n                undoNumberPlace(board, row, column, i);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        row_state    = vector<vector<bool>>(9, vector<bool>(10, false));\\n        column_state = vector<vector<bool>>(9, vector<bool>(10, false));\\n        box_state    = vector<vector<bool>>(9, vector<bool>(10, false));\\n        \\n        initialState(board);\\n\\n        pair<int, int> coor = getMaxPossibleCoordinate(board);\\n        \\n        recursivePlaceNumber(board, coor.first, coor.second);\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class SudokuSolver {\\n    public void solveSudoku(char[][] board) {\\n        boolean rowState[][] = new boolean[9][10];\\n        boolean columnState[][] = new boolean[9][10];\\n        boolean boxState[][] = new boolean[9][10];\\n\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != '.') {\\n                    int index = board[i][j] - '0';\\n                    rowState[i][index] = true;\\n                    columnState[j][index] = true;\\n                    boxState[(i / 3) * 3 + j / 3][index] = true;\\n                }\\n            }\\n        }\\n        int[] coordinate = getMaxPossibleCoordinate(board, rowState, columnState, boxState);\\n\\n        recursivePlaceNumber2(board, rowState, columnState, boxState, coordinate[0], coordinate[1]);\\n    }\\n\\n    private int[] getMaxPossibleCoordinate(char[][] board, boolean[][] rowState, boolean[][] columnState, boolean[][] boxState) {\\n        int x = -1, y = -1, minCount = 9;\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != '.') {\\n                    continue;\\n                }\\n                int tmpCount = 9;\\n                for (int k = 0; k < 9; k++) {\\n                    if (rowState[i][k] || columnState[j][k] || boxState[(i / 3) * 3 + j / 3][k])\\n                        tmpCount--;\\n                }\\n                if (tmpCount == 1)\\n                    return new int[]{i, j};\\n\\n                if (minCount > tmpCount) {\\n                    minCount = tmpCount;\\n                    x = i;\\n                    y = j;\\n                }\\n            }\\n        }\\n        return new int[]{x, y};\\n    }\\n\\n    private boolean recursivePlaceNumber2(char[][] board, boolean[][] rowState, boolean[][] columnState, boolean[][] boxState, int row, int column) {\\n        if (row == -1 && column == -1)\\n            return true;\\n        if (board[row][column] != '.')\\n            return false;\\n\\n        for (int i = 1; i < 10; i++) {\\n            if (rowState[row][i] || columnState[column][i] || boxState[(row / 3) * 3 + column / 3][i]) {\\n                continue;\\n            } else {\\n                placeNumber(board, rowState, columnState, boxState, row, column, i);\\n                int[] coordinate = getMaxPossibleCoordinate(board, rowState, columnState, boxState);\\n                if (recursivePlaceNumber2(board, rowState, columnState, boxState, coordinate[0], coordinate[1])) {\\n                    return true;\\n                }\\n                undoNumberPlacement(board, rowState, columnState, boxState, row, column, i);\\n            }\\n        }\\n        // failed to get an answer\\n        return false;\\n    }\\n\\n    private void placeNumber(char[][] board, boolean[][] rowState, boolean[][] columnState, boolean[][] boxState, int row, int column, int i) {\\n        rowState[row][i] = true;\\n        columnState[column][i] = true;\\n        boxState[(row / 3) * 3 + column / 3][i] = true;\\n        board[row][column] = (char) ('0' + i);\\n    }\\n\\n    private void undoNumberPlacement(char[][] board, boolean[][] rowState, boolean[][] columnState, boolean[][] boxState, int row, int column, int i) {\\n        rowState[row][i] = false;\\n        columnState[column][i] = false;\\n        boxState[(row / 3) * 3 + column / 3][i] = false;\\n        board[row][column] = '.';\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    row_state = [[False for i in range(10)] for _ in range(9)]\\n    column_state = [[False for i in range(10)] for _ in range(9)]\\n    box_state = [[False for i in range(10)] for _ in range(9)]\\n    board = []\\n\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n\\n        self.row_state = [[False for i in range(10)] for _ in range(9)]\\n        self.column_state = [[False for i in range(10)] for _ in range(9)]\\n        self.box_state = [[False for i in range(10)] for _ in range(9)]\\n        self.board = board\\n        for i in range(9):\\n            for j in range(9):\\n                if self.board[i][j] != \\\".\\\":\\n                    num = int(self.board[i][j])\\n                    self.row_state[i][num] = True\\n                    self.column_state[j][num] = True\\n                    self.box_state[(i // 3) * 3 + j // 3][num] = True\\n\\n        def recursive_place_number(self, row: int, column: int,) -> bool:\\n            if row == -1 and column == -1:\\n                return True\\n            if board[row][column] != \\\".\\\":\\n                return False\\n\\n            for i in range(1, 10):\\n                if (\\n                    self.row_state[row][i]\\n                    or self.column_state[column][i]\\n                    or self.box_state[(row // 3) * 3 + column // 3][i]\\n                ):\\n                    continue\\n                else:\\n                    self.place_number(row, column, i)\\n                    x, y = self.get_max_possible_coordinate()\\n                    if recursive_place_number(self, x, y,):\\n                        return True\\n                    self.undo_number_placement(row, column, i)\\n            return False\\n\\n        x, y = self.get_max_possible_coordinate()\\n        recursive_place_number(self, x, y)\\n\\n    def place_number(self, row: int, column: int, i: int,) -> bool:\\n        self.row_state[row][i] = True\\n        self.column_state[column][i] = True\\n        self.box_state[(row // 3) * 3 + column // 3][i] = True\\n        self.board[row][column] = str(i)\\n\\n    def undo_number_placement(self, row: int, column: int, i: int,) -> bool:\\n        self.row_state[row][i] = False\\n        self.column_state[column][i] = False\\n        self.box_state[(row // 3) * 3 + column // 3][i] = False\\n        self.board[row][column] = \\\".\\\"\\n\\n    def get_max_possible_coordinate(self) -> (int, int):\\n        x, y, min_count = -1, -1, 9\\n        for i in range(9):\\n            for j in range(9):\\n                if self.board[i][j] != \\\".\\\":\\n                    continue\\n                tmp_count = 9\\n                for k in range(9):\\n                    if (\\n                        self.row_state[i][k]\\n                        or self.column_state[j][k]\\n                        or self.box_state[(i // 3) * 3 + j // 3][k]\\n                    ):\\n                        tmp_count -= 1\\n                if tmp_count == 1:\\n                    return i, j\\n                if min_count > tmp_count:\\n                    min_count = tmp_count\\n                    x = i\\n                    y = j\\n        return x, y\\n\\n\"}]},{\"title\":\"代码4.4.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\nprivate:\\n    int get_neighbor_count(int i, int j, vector<vector<int>>& board) {\\n        int top = std::max(0, i - 1);\\n        int bottom = std::min<int>(board.size() - 1, i + 1);\\n        int left = std::max(0, j - 1);\\n        int right = std::min<int>(board[0].size() - 1, j + 1);\\n        \\n        int count = 0;\\n        for (int x = top; x < bottom + 1; x++)\\n            for (int y = left; y < right + 1; y++)\\n                if (board[x][y] == 1 || board[x][y] == -1)\\n                    count += 1;\\n        \\n        return count;\\n    }\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                int res = get_neighbor_count(i, j, board);\\n                if (board[i][j] == 1 && (res == 3 || res == 4))\\n                    board[i][j] = 1;\\n                else if (board[i][j] == 1)\\n                    board[i][j] = -1;\\n                else if (board[i][j] == 0 && res == 3)\\n                    board[i][j] = -2;\\n            }\\n        }\\n        \\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                if (board[i][j] == -2)\\n                    board[i][j] = 1;\\n                else if (board[i][j] == -1)\\n                    board[i][j] = 0;\\n            }\\n        }\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class GameOfLife {\\n    public void gameOfLife(int[][] board) {\\n        // do in place life check\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[i].length; j++) {\\n                board[i][j] = checkLifeInPlace(board, board[i][j], i, j);\\n            }\\n        }\\n        // translate\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[i].length; j++) {\\n                if (board[i][j] == 2)\\n                    board[i][j] = 1;\\n                else if (board[i][j] == -1)\\n                    board[i][j] = 0;\\n            }\\n        }\\n    }\\n\\n    private int checkLifeInPlace(int[][] board, int preState, int i, int j) {\\n        int neighborCount = getNeighborCountForInPlace(board, preState, i, j);\\n        if (neighborCount < 2 || neighborCount > 3)\\n            return preState == 0 ? 0 : -1;\\n        else if (neighborCount == 3)\\n            return preState == 1 ? 1 : 2;\\n        else\\n            return preState;\\n    }\\n\\n    //      -1 as for 1 to 0;\\n    //      2 as for 0 to 1;\\n    private int getNeighborCountForInPlace(int[][] board, int preState, int i, int j) {\\n        int count = 0;\\n        int maxRow = board.length - 1, maxColumn = board[0].length - 1;\\n\\n        if (i != 0) {\\n            count += board[i - 1][j] == 1 || board[i - 1][j] == -1 ? 1 : 0;\\n            if (j != 0) {\\n                count += board[i - 1][j - 1] == 1 || board[i - 1][j - 1] == -1 ? 1 : 0;\\n            }\\n            if (j != maxColumn) {\\n                count += board[i - 1][j + 1] == 1 || board[i - 1][j + 1] == -1 ? 1 : 0;\\n            }\\n\\n        }\\n\\n        if (i != maxRow) {\\n            count += board[i + 1][j] == 1 || board[i + 1][j] == -1 ? 1 : 0;\\n            if (j != 0) {\\n                count += board[i + 1][j - 1] == 1 || board[i + 1][j - 1] == -1 ? 1 : 0;\\n            }\\n            if (j != maxColumn) {\\n                count += board[i + 1][j + 1] == 1 || board[i + 1][j + 1] == -1 ? 1 : 0;\\n            }\\n        }\\n\\n        if (j != 0) {\\n            count += board[i][j - 1] == 1 || board[i][j - 1] == -1 ? 1 : 0;\\n        }\\n        if (j != maxColumn) {\\n            count += board[i][j + 1] == 1 || board[i][j + 1] == -1 ? 1 : 0;\\n        }\\n        return count;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        def get_neighbor_count(i, j, board):\\n            top = max(0, i - 1)\\n            bottom = min(len(board) - 1, i + 1)\\n            left = max(0, j - 1)\\n            right = min(len(board[0]) - 1, j + 1)\\n\\n            count = 0\\n            for x in range(top, bottom + 1):\\n                for y in range(left, right + 1):\\n                    if board[x][y] == 1 or board[x][y] == -1:\\n                        count += 1\\n            return count\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                res = get_neighbor_count(i, j, board)\\n                if board[i][j] == 1 and res in [3, 4]:\\n                    board[i][j] = 1\\n                elif board[i][j] == 1:\\n                    board[i][j] = -1\\n                elif board[i][j] == 0 and res == 3:\\n                    board[i][j] = -2\\n\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == -2:\\n                    board[i][j] = 1\\n                elif board[i][j] == -1:\\n                    board[i][j] = 0\\n\\n\"}]}]},{\"id\":\"05\",\"name\":\"第五章\",\"list\":[{\"title\":\"代码5.1.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\" struct TreeNode {\\n    int val;\\n    TreeNode *left;\\n    TreeNode *right;\\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n};\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(root == NULL) return false;\\n\\n        if(root->left == NULL && root->right == NULL) {\\n            if(root->val == sum) return true;\\n        \\n            return false;\\n        }\\n\\n        return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root.val);\\n    }\\n\\n};\\n\"},{\"language\":\"Java\",\"content\":\"public class TreeNode {\\n  int val;\\n  TreeNode left;\\n  TreeNode right;\\n\\n  TreeNode(int x) {\\n    val = x;\\n  }\\n}\\n\\nclass Solution {\\n  public boolean hasPathSum(TreeNode root, int sum) {\\n    if (root == null) return false;\\n\\n    sum -= root.val;\\n\\n    if ((root.left == null) && (root.right == null)) return (sum == 0);\\n\\n    return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);\\n  }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class TreeNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.left = None\\n        self.right = None\\n\\n\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if not root:\\n            return False\\n\\n        if root.left is None and root.right is None:\\n            if root.val == sum:\\n                return True\\n            return False\\n\\n        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(\\n            root.right, sum - root.val\\n        )\\n\\n\"}]},{\"title\":\"代码5.1.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n struct TreeNode {\\n    int val;\\n    TreeNode *left;\\n    TreeNode *right;\\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n };\\n \\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int sum) {\\n        if(root == NULL) return false;\\n\\n        if(root->left == NULL && root->right == NULL) {\\n            if(root->val == sum) return true;\\n        \\n            return false;\\n        }\\n\\n        return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root.val);\\n    }\\n\\n};\\n\"},{\"language\":\"Java\",\"content\":\"public class TreeNode {\\n  int val;\\n  TreeNode left;\\n  TreeNode right;\\n\\n  TreeNode(int x) {\\n    val = x;\\n  }\\n}\\n\\nclass Solution {\\n  public boolean hasPathSum(TreeNode root, int sum) {\\n    if (root == null) return false;\\n\\n    Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque<Pair<TreeNode, Integer>>();\\n    stack.addLast(new Pair<TreeNode, Integer>(root, sum - root.val));\\n\\n    while (!stack.isEmpty()) {\\n      Pair<TreeNode, Integer> top = stack.removeLast();\\n      TreeNode node = top.getKey();\\n      int remain = top.getValue();\\n\\n      if ((node.right == null) && (node.left == null) && (remain == 0)) return true;\\n      if (node.right != null) {\\n        stack.addLast(new Pair<TreeNode, Integer>(node.right, remain - node.right.val));\\n      }\\n      if (node.left != null) {\\n        stack.addLast(new Pair<TreeNode, Integer>(node.left, remain - node.left.val));\\n      }\\n    }\\n\\n    return false;\\n  }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class TreeNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.left = None\\n        self.right = None\\n\\n\\nclass Solution:\\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\\n        if root is None:\\n            return False\\n\\n        stack = [(root, sum - root.val)]\\n        while stack:\\n            node, remain = stack.pop()\\n            if not node.left and not node.right and remain == 0:\\n                return True\\n            if node.right:\\n                stack.append((node.right, remain - node.right.val))\\n            if node.left:\\n                stack.append((node.left, remain - node.left.val))\\n        return False\\n\\n\"}]},{\"title\":\"代码5.1.3\",\"codes\":[{\"language\":\"Java\",\"content\":\"class TreeNode {\\n    int val;\\n    TreeNode left;\\n    TreeNode right;\\n\\n    TreeNode(int x) {\\n        val = x;\\n    }\\n}\\n\\npublic class Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n        List<List<Integer>> res = new ArrayList<>();\\n\\n        if(root == null) return res;\\n\\n        Deque<Integer> path = new ArrayDeque<>();\\n        pathSum(root, sum, path, res);\\n\\n        return res;\\n    }\\n\\n    public void pathSum(TreeNode node, int sum, Deque<Integer> path, List<List<Integer>> res) {\\n        if (node == null)  return;\\n\\n        // 沿途结点必须选择，这个时候要做两件事：1、sum 减去这个结点的值；2、添加到 path 里\\n        sum -= node.val;\\n        path.addLast(node.val);\\n\\n        if (sum == 0 && node.left == null && node.right == null) {\\n            // path 全局只有一份，必须做拷贝\\n            res.add(new ArrayList<>(path));\\n            // 注意：这里 return 之前必须重置\\n            path.removeLast();\\n            return;\\n        }\\n\\n        pathSum(node.left, sum, path, res);\\n        pathSum(node.right, sum, path, res);\\n        // 递归完成以后，必须重置变量\\n        path.removeLast();      \\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass TreeNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.left = None\\n        self.right = None\\n\\n\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:\\n        def helper(root: TreeNode, sum: int, path: List):\\n            if not root:\\n                return\\n            if not root.left and not root.right and sum - root.val == 0:\\n                path += [root.val]\\n                ans.append(path)\\n            helper(root.left, sum - root.val, path + [root.val])\\n            helper(root.right, sum - root.val, path + [root.val])\\n\\n        ans = []\\n        helper(root, sum, [])\\n        return ans\\n\\n\"}]},{\"title\":\"代码5.1.4\",\"codes\":[{\"language\":\"Java\",\"content\":\"class TreeNode {\\n    int val;\\n    TreeNode left;\\n    TreeNode right;\\n\\n    TreeNode(int x) {\\n        val = x;\\n    }\\n}\\n\\npublic class Solution {\\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\\n        List<List<Integer>> res = new ArrayList<>();\\n\\n        if(root == null) return res;\\n\\n        Deque<Integer> path = new ArrayDeque<>();\\n        Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque<>();\\n\\n        stack.addLast(new Pair<TreeNode, Integer>(root, root.val));\\n        path.addLast(root.val)\\n\\n        while (!stack.isEmpty()) {\\n            Pair<TreeNode, Integer> top = stack.removeLast();\\n            TreeNode node = top.getKey();\\n            int total = top.getValue();\\n\\n            if ((node.right == null) && (node.left == null) && (total == sum)) {\\n                res.add(new ArrayList<>(path));\\n            }\\n            if (node.right != null) {\\n                stack.addLast(new Pair<TreeNode, Integer>(node.right, total + node.right.val));\\n                path.addLast(node.right.val);\\n            }\\n            if (node.left != null) {\\n                stack.addLast(new Pair<TreeNode, Integer>(node.left, total + node.left.val));\\n                path.addLast(node.left.val);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass TreeNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.left = None\\n        self.right = None\\n\\n\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:\\n        if not root:\\n            return []\\n        stack = [(root, [root.val], root.val)]\\n        ans = []\\n        while stack:\\n            node, path, total = stack.pop()\\n            if not node.right and not node.left and total == sum:\\n                ans.append(path)\\n            if node.right:\\n                stack.append((node.right, path + [node.right.val], total + node.right.val))\\n            if node.left:\\n                stack.append((node.left, path + [node.left.val], total + node.left.val))\\n        return ans\\n\\n\"}]},{\"title\":\"代码5.1.5\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\nprivate:\\n    int maxSum = INT_MIN;\\n\\npublic:\\n    int helper(TreeNode* node) {\\n        if (node == nullptr) {\\n            return 0;\\n        }\\n        \\n        // 递归计算左右子节点的最大贡献值\\n        // 只有在最大贡献值大于 0 时，才会选取对应子节点\\n        int leftGain = max(helper(node->left), 0);\\n        int rightGain = max(helper(node->right), 0);\\n\\n        // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值\\n        int priceNewpath = node->val + leftGain + rightGain;\\n\\n        // 更新答案\\n        maxSum = max(maxSum, priceNewpath);\\n\\n        // 返回节点的最大贡献值\\n        return node->val + max(leftGain, rightGain);\\n    }\\n\\n    int maxPathSum(TreeNode* root) {\\n        helper(root);\\n        return maxSum;\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode node) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        \\n        // 递归计算左右子节点的最大贡献值\\n        // 只有在最大贡献值大于 0 时，才会选取对应子节点\\n        int leftGain = Math.max(helper(node.left), 0);\\n        int rightGain = Math.max(helper(node.right), 0);\\n\\n        // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值\\n        int priceNewpath = node.val + leftGain + rightGain;\\n\\n        // 更新答案\\n        maxSum = Math.max(maxSum, priceNewpath);\\n\\n        // 返回节点的最大贡献值\\n        return node.val + Math.max(leftGain, rightGain);\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass TreeNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.left = None\\n        self.right = None\\n\\n\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        self.maxSum = float(\\\"-inf\\\")\\n\\n        def helper(root: TreeNode):\\n            if not root:\\n                return 0\\n\\n            maxLeft = max(helper(root.left), 0)\\n            maxRight = max(helper(root.right), 0)\\n            self.maxSum = max(self.maxSum, maxLeft + maxRight + root.val)\\n\\n            return root.val + max(maxLeft, maxRight)\\n\\n        helper(root)\\n        return self.maxSum\\n\\n\"}]},{\"title\":\"代码5.2.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\nprivate:\\n    void dfs(vector<vector<char>>& grid, int r, int c) {\\n        int nr = grid.size();\\n        int nc = grid[0].size();\\n\\n        grid[r][c] = '0';\\n        if (r - 1 >= 0 && grid[r-1][c] == '1') dfs(grid, r - 1, c);\\n        if (r + 1 < nr && grid[r+1][c] == '1') dfs(grid, r + 1, c);\\n        if (c - 1 >= 0 && grid[r][c-1] == '1') dfs(grid, r, c - 1);\\n        if (c + 1 < nc && grid[r][c+1] == '1') dfs(grid, r, c + 1);\\n    }\\n\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int nr = grid.size();\\n        if (!nr) return 0;\\n        int nc = grid[0].size();\\n\\n        int num_islands = 0;\\n        for (int r = 0; r < nr; ++r) {\\n            for (int c = 0; c < nc; ++c) {\\n                if (grid[r][c] == '1') {\\n                    ++num_islands;\\n                    dfs(grid, r, c);\\n                }\\n            }\\n        }\\n\\n        return num_islands;\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    void dfs(char[][] grid, int r, int c) {\\n        int nr = grid.length;\\n        int nc = grid[0].length;\\n\\n        if (r < 0 || c < 0 || r >= nr || c >= nc || grid[r][c] == '0') {\\n            return;\\n        }\\n\\n        grid[r][c] = '0';\\n        dfs(grid, r - 1, c);\\n        dfs(grid, r + 1, c);\\n        dfs(grid, r, c - 1);\\n        dfs(grid, r, c + 1);\\n    }\\n\\n    public int numIslands(char[][] grid) {\\n        if (grid == null || grid.length == 0) {\\n            return 0;\\n        }\\n\\n        int nr = grid.length;\\n        int nc = grid[0].length;\\n        int num_islands = 0;\\n        for (int r = 0; r < nr; ++r) {\\n            for (int c = 0; c < nc; ++c) {\\n                if (grid[r][c] == '1') {\\n                    ++num_islands;\\n                    dfs(grid, r, c);\\n                }\\n            }\\n        }\\n\\n        return num_islands;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid or not grid[0]:\\n            return 0\\n\\n        m = len(grid)\\n        n = len(grid[0])\\n        ans = 0\\n\\n        def dfs(r, c):\\n            grid[r][c] = \\\"0\\\"\\n\\n            if r - 1 >= 0 and grid[r - 1][c] == \\\"1\\\":\\n                dfs(r - 1, c)\\n            if r + 1 < m and grid[r + 1][c] == \\\"1\\\":\\n                dfs(r + 1, c)\\n            if c - 1 >= 0 and grid[r][c - 1] == \\\"1\\\":\\n                dfs(r, c - 1)\\n            if c + 1 < n and grid[r][c + 1] == \\\"1\\\":\\n                dfs(r, c + 1)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\\"1\\\":\\n                    ans += 1\\n                    dfs(i, j)\\n\\n        return ans\\n\\n\"}]},{\"title\":\"代码5.2.2\",\"codes\":[{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid or not grid[0]:\\n            return 0\\n\\n        m = len(grid)\\n        n = len(grid[0])\\n        ans = 0\\n\\n        def dfs(row, col):\\n            grid[row][col] = \\\"0\\\"\\n            stack = [[row, col]]\\n            while stack:\\n                r, c = stack[-1]\\n                if r - 1 >= 0 and grid[r - 1][c] == \\\"1\\\":\\n                    stack.append([r - 1, c])\\n                    grid[r - 1][c] = \\\"0\\\"\\n                    continue\\n                if r + 1 < m and grid[r + 1][c] == \\\"1\\\":\\n                    stack.append([r + 1, c])\\n                    grid[r + 1][c] = \\\"0\\\"\\n                    continue\\n                if c - 1 >= 0 and grid[r][c - 1] == \\\"1\\\":\\n                    stack.append([r, c - 1])\\n                    grid[r][c - 1] = \\\"0\\\"\\n                    continue\\n                if c + 1 < n and grid[r][c + 1] == \\\"1\\\":\\n                    stack.append([r, c + 1])\\n                    grid[r][c + 1] = \\\"0\\\"\\n                    continue\\n                stack.pop()\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\\"1\\\":\\n                    ans += 1\\n                    dfs(i, j)\\n\\n        return ans\\n\\n\"}]},{\"title\":\"代码5.2.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int nr = grid.size();\\n        if (!nr) return 0;\\n        int nc = grid[0].size();\\n\\n        int num_islands = 0;\\n        for (int r = 0; r < nr; ++r) {\\n            for (int c = 0; c < nc; ++c) {\\n                if (grid[r][c] == '1') {\\n                    ++num_islands;\\n                    grid[r][c] = '0';\\n                    queue<pair<int, int>> neighbors;\\n                    neighbors.push({r, c});\\n                    while (!neighbors.empty()) {\\n                        auto rc = neighbors.front();\\n                        neighbors.pop();\\n                        int row = rc.first, col = rc.second;\\n                        if (row - 1 >= 0 && grid[row-1][col] == '1') {\\n                            neighbors.push({row-1, col});\\n                            grid[row-1][col] = '0';\\n                        }\\n                        if (row + 1 < nr && grid[row+1][col] == '1') {\\n                            neighbors.push({row+1, col});\\n                            grid[row+1][col] = '0';\\n                        }\\n                        if (col - 1 >= 0 && grid[row][col-1] == '1') {\\n                            neighbors.push({row, col-1});\\n                            grid[row][col-1] = '0';\\n                        }\\n                        if (col + 1 < nc && grid[row][col+1] == '1') {\\n                            neighbors.push({row, col+1});\\n                            grid[row][col+1] = '0';\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return num_islands;\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int numIslands(char[][] grid) {\\n        if (grid == null || grid.length == 0) {\\n            return 0;\\n        }\\n\\n        int nr = grid.length;\\n        int nc = grid[0].length;\\n        int num_islands = 0;\\n\\n        for (int r = 0; r < nr; ++r) {\\n            for (int c = 0; c < nc; ++c) {\\n                if (grid[r][c] == '1') {\\n                    ++num_islands;\\n                    grid[r][c] = '0';\\n                    Queue<Integer> neighbors = new LinkedList<>();\\n                    neighbors.add(r * nc + c);\\n                    while (!neighbors.isEmpty()) {\\n                        int id = neighbors.remove();\\n                        int row = id / nc;\\n                        int col = id % nc;\\n                        if (row - 1 >= 0 && grid[row-1][col] == '1') {\\n                            neighbors.add((row-1) * nc + col);\\n                            grid[row-1][col] = '0';\\n                        }\\n                        if (row + 1 < nr && grid[row+1][col] == '1') {\\n                            neighbors.add((row+1) * nc + col);\\n                            grid[row+1][col] = '0';\\n                        }\\n                        if (col - 1 >= 0 && grid[row][col-1] == '1') {\\n                            neighbors.add(row * nc + col-1);\\n                            grid[row][col-1] = '0';\\n                        }\\n                        if (col + 1 < nc && grid[row][col+1] == '1') {\\n                            neighbors.add(row * nc + col+1);\\n                            grid[row][col+1] = '0';\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return num_islands;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        from collections import deque\\n\\n        if not grid or not grid[0]:\\n            return 0\\n\\n        m = len(grid)\\n        n = len(grid[0])\\n        ans = 0\\n        queue = deque()\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\\"1\\\":\\n                    ans += 1\\n                    grid[i][j] = \\\"0\\\"\\n                    queue.append((i, j))\\n                    while len(queue) > 0:\\n                        top = queue.popleft()\\n                        r = top[0]\\n                        c = top[1]\\n                        if r - 1 >= 0 and grid[r - 1][c] == \\\"1\\\":\\n                            grid[r - 1][c] = \\\"0\\\"\\n                            queue.append((r - 1, c))\\n                        if r + 1 < m and grid[r + 1][c] == \\\"1\\\":\\n                            grid[r + 1][c] = \\\"0\\\"\\n                            queue.append((r + 1, c))\\n                        if c - 1 >= 0 and grid[r][c - 1] == \\\"1\\\":\\n                            grid[r][c - 1] = \\\"0\\\"\\n                            queue.append((r, c - 1))\\n                        if c + 1 < n and grid[r][c + 1] == \\\"1\\\":\\n                            grid[r][c + 1] = \\\"0\\\"\\n                            queue.append((r, c + 1))\\n\\n        return ans\\n\\n\"}]},{\"title\":\"代码5.2.4\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class UnionFind {\\npublic:\\n    UnionFind(vector<vector<char>>& grid) {\\n        count = 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == '1') {\\n                    parent.push_back(i * n + j);\\n                    ++count;\\n                }\\n                else {\\n                    parent.push_back(-1);\\n                }\\n                rank.push_back(0);\\n            }\\n        }\\n    }\\n\\n    int find(int i) {\\n        if (parent[i] != i) {\\n            parent[i] = find(parent[i]);\\n        }\\n        return parent[i];\\n    }\\n\\n    void union(int x, int y) {\\n        int rootx = find(x);\\n        int rooty = find(y);\\n        if (rootx != rooty) {\\n            if (rank[rootx] < rank[rooty]) {\\n                swap(rootx, rooty);\\n            }\\n            parent[rooty] = rootx;\\n            if (rank[rootx] == rank[rooty]) rank[rootx] += 1;\\n            --count;\\n        }\\n    }\\n\\n    int getCount() const {\\n        return count;\\n    }\\n\\nprivate:\\n    vector<int> parent;\\n    vector<int> rank;\\n    int count;\\n};\\n\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int nr = grid.size();\\n        if (!nr) return 0;\\n        int nc = grid[0].size();\\n\\n        UnionFind uf(grid);\\n        int num_islands = 0;\\n        for (int r = 0; r < nr; ++r) {\\n            for (int c = 0; c < nc; ++c) {\\n                if (grid[r][c] == '1') {\\n                    grid[r][c] = '0';\\n                    if (r - 1 >= 0 && grid[r-1][c] == '1') uf.union(r * nc + c, (r-1) * nc + c);\\n                    if (r + 1 < nr && grid[r+1][c] == '1') uf.union(r * nc + c, (r+1) * nc + c);\\n                    if (c - 1 >= 0 && grid[r][c-1] == '1') uf.union(r * nc + c, r * nc + c - 1);\\n                    if (c + 1 < nc && grid[r][c+1] == '1') uf.union(r * nc + c, r * nc + c + 1);\\n                }\\n            }\\n        }\\n\\n        return uf.getCount();\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    class UnionFind {\\n        int count;\\n        int[] parent;\\n        int[] rank;\\n\\n        public UnionFind(char[][] grid) {\\n            count = 0;\\n            int m = grid.length;\\n            int n = grid[0].length;\\n            parent = new int[m * n];\\n            rank = new int[m * n];\\n            for (int i = 0; i < m; ++i) {\\n                for (int j = 0; j < n; ++j) {\\n                    if (grid[i][j] == '1') {\\n                        parent[i * n + j] = i * n + j;\\n                        ++count;\\n                    }\\n                    rank[i * n + j] = 0;\\n                }\\n            }\\n        }\\n\\n        public int find(int i) {\\n            if (parent[i] != i) parent[i] = find(parent[i]);\\n            return parent[i];\\n        }\\n\\n        public void union(int x, int y) {\\n            int rootx = find(x);\\n            int rooty = find(y);\\n            if (rootx != rooty) {\\n                if (rank[rootx] > rank[rooty]) {\\n                    parent[rooty] = rootx;\\n                } else if (rank[rootx] < rank[rooty]) {\\n                    parent[rootx] = rooty;\\n                } else {\\n                    parent[rooty] = rootx;\\n                    rank[rootx] += 1;\\n                }\\n                --count;\\n            }\\n        }\\n\\n        public int getCount() {\\n            return count;\\n        }\\n    }\\n\\n    public int numIslands(char[][] grid) {\\n        if (grid == null || grid.length == 0) {\\n            return 0;\\n        }\\n\\n        int nr = grid.length;\\n        int nc = grid[0].length;\\n        int num_islands = 0;\\n        UnionFind uf = new UnionFind(grid);\\n        for (int r = 0; r < nr; ++r) {\\n            for (int c = 0; c < nc; ++c) {\\n                if (grid[r][c] == '1') {\\n                    grid[r][c] = '0';\\n                    if (r - 1 >= 0 && grid[r-1][c] == '1') {\\n                        uf.union(r * nc + c, (r-1) * nc + c);\\n                    }\\n                    if (r + 1 < nr && grid[r+1][c] == '1') {\\n                        uf.union(r * nc + c, (r+1) * nc + c);\\n                    }\\n                    if (c - 1 >= 0 && grid[r][c-1] == '1') {\\n                        uf.union(r * nc + c, r * nc + c - 1);\\n                    }\\n                    if (c + 1 < nc && grid[r][c+1] == '1') {\\n                        uf.union(r * nc + c, r * nc + c + 1);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return uf.getCount();\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    class UnionFind:\\n        def __init__(self, grid):\\n            self.count = 0\\n            m = len(grid)\\n            n = len(grid[0])\\n            self.parent = [0 for _ in range(m * n)]\\n            self.rank = [0 for _ in range(m * n)]\\n            for i in range(m): # 这里我们进行初始化的工作\\n                for j in range(n):\\n                    if grid[i][j] == \\\"1\\\":\\n                        self.parent[i * n + j] = i * n + j\\n                        self.count += 1\\n\\n        def find(self, i):\\n            if self.parent[i] != i:\\n                self.parent[i] = self.find(self.parent[i])\\n            return self.parent[i]\\n\\n        def union(self, x, y):\\n            rootx = self.find(x)\\n            rooty = self.find(y)\\n            if rootx != rooty:\\n                if self.rank[rootx] > self.rank[rooty]:\\n                    self.parent[rooty] = rootx\\n                elif self.rank[rootx] < self.rank[rooty]:\\n                    self.parent[rootx] = rooty\\n                else:\\n                    self.parent[rooty] = rootx\\n                    self.rank[rootx] += 1\\n\\n                self.count -= 1\\n\\n        def getCount(self):\\n            return self.count\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid or not grid[0]:\\n            return 0\\n\\n        # ans = 0\\n        nr = len(grid)\\n        nc = len(grid[0])\\n        uf = self.UnionFind(grid)\\n\\n        for i in range(nr):\\n            for j in range(nc):\\n                if grid[i][j] == \\\"1\\\":\\n                    grid[i][j] = \\\"0\\\"\\n                    if i - 1 >= 0 and grid[i - 1][j] == \\\"1\\\":\\n                        uf.union(i * nc + j, (i - 1) * nc + j)\\n                    if i + 1 < nr and grid[i + 1][j] == \\\"1\\\":\\n                        uf.union(i * nc + j, (i + 1) * nc + j)\\n                    if j - 1 >= 0 and grid[i][j - 1] == \\\"1\\\":\\n                        uf.union(i * nc + j, i * nc + j - 1)\\n                    if j + 1 < nc and grid[i][j + 1] == \\\"1\\\":\\n                        uf.union(i * nc + j, i * nc + j + 1)\\n        return uf.getCount()\\n\\n\"}]},{\"title\":\"代码5.2.5\",\"codes\":[{\"language\":\"Py\",\"content\":\"class Solution:\\n    class UnionFind:\\n        def __init__(self, grid):\\n            self.count = 0\\n            m = len(grid)\\n            n = len(grid[0])\\n            self.parent = [0 for _ in range(m * n)]\\n            self.rank = [0 for _ in range(m * n)]\\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j] == \\\"1\\\":\\n                        self.parent[i * n + j] = i * n + j\\n                        self.count += 1\\n\\n        def find(self, i):\\n            if self.parent[i] != i:\\n                self.parent[i] = self.find(self.parent[i])\\n            return self.parent[i]\\n\\n        def union(self, x, y):\\n            rootx = self.find(x)\\n            rooty = self.find(y)\\n            if rootx != rooty:\\n                if self.rank[rootx] > self.rank[rooty]:\\n                    self.parent[rooty] = rootx\\n                elif self.rank[rootx] < self.rank[rooty]:\\n                    self.parent[rootx] = rooty\\n                else:\\n                    self.parent[rooty] = rootx\\n                    self.rank[rootx] += 1\\n\\n                self.count -= 1\\n\\n        def getCount(self):\\n            return self.count\\n\\n        def setCount(self, count):\\n            self.count = count\\n\\n        def setParent(self, i, val):\\n            self.parent[i] = val\\n\\n    def numIslands(self, m, n, positions):\\n        if m <= 0 or n <= 0:\\n            return []\\n\\n        ans = []\\n        grid = [[0 for _ in range(n)] for _ in range(m)]\\n\\n        uf = self.UnionFind(grid)\\n\\n        for i in range(len(positions)):\\n            position = positions[i]\\n            uf.setCount(uf.getCount() + 1)\\n            uf.setParent(position[0] * n + position[1], position[0] * n + position[1])\\n            grid[position[0]][position[1]] = \\\"1\\\"\\n            if position[0] - 1 >= 0 and grid[position[0] - 1][position[1]] == \\\"1\\\":\\n                uf.union(\\n                    position[0] * n + position[1], (position[0] - 1) * n + position[1]\\n                )\\n            if position[0] + 1 < m and grid[position[0] + 1][position[1]] == \\\"1\\\":\\n                uf.union(\\n                    position[0] * n + position[1], (position[0] + 1) * n + position[1]\\n                )\\n            if position[1] - 1 >= 0 and grid[position[0]][position[1] - 1] == \\\"1\\\":\\n                uf.union(\\n                    position[0] * n + position[1], position[0] * n + position[1] - 1\\n                )\\n            if position[1] + 1 < n and grid[position[0]][position[1] + 1] == \\\"1\\\":\\n                uf.union(\\n                    position[0] * n + position[1], position[0] * n + position[1] + 1\\n                )\\n            ans.append(uf.getCount())\\n\\n        return ans\\n\\n\"}]}]},{\"id\":\"06\",\"name\":\"第六章\",\"list\":[{\"title\":\"代码6.1.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\r\\npublic:\\r\\n    int search(vector<int>& nums, int target) {\\r\\n        int n = nums.size();\\r\\n        int l = 0, h = n - 1;\\r\\n        while (l <= h) {\\r\\n            int mid = l + (h - l) / 2;\\r\\n            if (nums[mid] == target) {\\r\\n                return mid;\\r\\n            } else if (nums[mid] < target) {\\r\\n                l = mid + 1;\\r\\n            } else {\\r\\n                h = mid - 1;\\r\\n            }\\r\\n        }\\r\\n        return -1;\\r\\n    }\\r\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\r\\n    public int search(int[] nums, int target) {\\r\\n        int n = nums.length;\\r\\n        int l = 0, h = n - 1;\\r\\n        while (l <= h) {\\r\\n            int mid = l + (h - l) / 2;\\r\\n            if (nums[mid] == target) {\\r\\n                return mid;\\r\\n            } else if (nums[mid] < target) {\\r\\n                l = mid + 1;\\r\\n            } else {\\r\\n                h = mid - 1;\\r\\n            }\\r\\n        }\\r\\n        return -1;\\r\\n    }\\r\\n}\\r\\n\\n\"},{\"language\":\"Py\",\"content\":\"# 查找 nums 数组中元素值为 target 的下标，如果不存在则返回 -1\\ndef binary_search(nums: [], target: int) -> int:\\n    n = len(nums)\\n    l, h = 0, n - 1\\n    while l <= h:\\n        mid = l + (h - l) // 2\\n        if nums[mid] == target:\\n            return mid\\n        elif nums[mid] < target:\\n            l = mid + 1\\n        else:\\n            h = mid - 1\\n    return -1\\n\\n\"}]},{\"title\":\"代码6.2.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\r\\npublic:\\r\\n    int findMin(vector<int>& nums) {\\r\\n        int l = 0, h = nums.size() - 1;\\r\\n        while (l <= h) {\\r\\n            int mid = l + (h - l) / 2;\\r\\n            if (l == h) {\\r\\n                return nums[l];\\r\\n            } else if (nums[mid] > nums[h]) {\\r\\n                l = mid + 1;\\r\\n            } else {\\r\\n                h = mid;\\r\\n            }\\r\\n        }\\r\\n        return -1;\\r\\n    }\\r\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\r\\n    public int findMin(int[] nums) {\\r\\n        int l = 0, h = nums.length - 1;\\r\\n        while (l <= h) {\\r\\n            int mid = l + (h - l) / 2;\\r\\n            if (l == h) {\\r\\n                return nums[l];\\r\\n            } else if (nums[mid] > nums[h]) {\\r\\n                l = mid + 1;\\r\\n            } else {\\r\\n                h = mid;\\r\\n            }\\r\\n        }\\r\\n        return -1;\\r\\n    }\\r\\n}\\r\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        l, h = 0, len(nums) - 1\\n        while l <= h:\\n            mid = l + (h - l) // 2\\n            if l == h:\\n                return nums[l]\\n            elif nums[mid] > nums[h]:\\n                l = mid + 1\\n            elif nums[mid] < nums[h]:\\n                h = mid\\n        return -1\\n\\n\"}]},{\"title\":\"代码6.3.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\r\\npublic:\\r\\n    int minEatingSpeed(vector<int>& piles, int H) {\\r\\n        int maxPile = piles[0];\\r\\n        for (int pile : piles) {\\r\\n            if (pile > maxPile) {\\r\\n                maxPile = pile;\\r\\n            }\\r\\n        }\\r\\n        int l = 1, h = maxPile;\\r\\n        while (l <= h) {\\r\\n            int mid = l + (h - l) / 2;\\r\\n            if (l == h) {\\r\\n                return l;\\r\\n            } else if (help(piles, mid, H)) {\\r\\n                h = mid;\\r\\n            } else {\\r\\n                l = mid + 1;\\r\\n            }\\r\\n        }\\r\\n        return -1;\\r\\n    }\\r\\n    // 判断速度 k 是否满足条件\\r\\n    bool help(vector<int>& piles, int k, int H) {\\r\\n        int cnt = 0;\\r\\n        for (int pile : piles) {\\r\\n            cnt += (pile - 1) / k + 1;\\r\\n        }\\r\\n        return cnt <= H;\\r\\n    }\\r\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\r\\n    public int minEatingSpeed(int[] piles, int H) {\\r\\n        int maxPile = piles[0];\\r\\n        for (int pile : piles) {\\r\\n            maxPile = Math.max(pile, maxPile);\\r\\n        }\\r\\n        int l = 1, h = maxPile;\\r\\n        while (l <= h) {\\r\\n            int mid = l + (h - l) / 2;\\r\\n            if (l == h) {\\r\\n                return l;\\r\\n            } else if (help(piles, mid, H)) {\\r\\n                h = mid;\\r\\n            } else {\\r\\n                l = mid + 1;\\r\\n            }\\r\\n        }\\r\\n        return -1;\\r\\n    }\\r\\n    // 判断速度 k 是否满足条件\\r\\n    public boolean help(int[] piles, int k, int H) {\\r\\n        int cnt = 0;\\r\\n        for (int pile : piles) {\\r\\n            cnt += (pile - 1) / k + 1;\\r\\n        }\\r\\n        return cnt <= H;\\r\\n    }\\r\\n}\\r\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def minEatingSpeed(self, piles: List[int], H: int) -> int:\\n        # 判断速度 k 是否满足条件\\n        def help(k: int) -> boolean:\\n            cnt = 0\\n            for pile in piles:\\n                cnt += (pile - 1) // k + 1\\n            return cnt <= H\\n\\n        l, h = 1, max(piles)\\n        while l <= h:\\n            mid = l + (h - l) // 2\\n            if l == h:\\n                return l\\n            if help(mid):\\n                h = mid\\n            else:\\n                l = mid + 1\\n        return -1\\n\\n\"}]},{\"title\":\"代码6.4.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\r\\npublic:\\r\\n    int mySqrt(int x) {\\r\\n        long l = 0, h = x;\\r\\n        while (l <= h) {\\r\\n            long mid = l + (h - l) / 2;\\r\\n            if (l == h || l + 1 == h) {\\r\\n                break;\\r\\n            } else if (mid * mid > x) {\\r\\n                h = mid - 1;\\r\\n            } else {\\r\\n                l = mid;\\r\\n            }\\r\\n        }\\r\\n        if (h * h <= x) {\\r\\n            return (int)h;\\r\\n        } else {\\r\\n            return (int)l;\\r\\n        }\\r\\n    }\\r\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\r\\n    public int mySqrt(int x) {\\r\\n        long l = 0, h = x;\\r\\n        while (l <= h) {\\r\\n            long mid = l + (h - l) / 2;\\r\\n            if (l == h || l + 1 == h) {\\r\\n                break;\\r\\n            } else if (mid * mid > x) {\\r\\n                h = mid - 1;\\r\\n            } else {\\r\\n                l = mid;\\r\\n            }\\r\\n        }\\r\\n        if (h * h <= x) {\\r\\n            return (int) h;\\r\\n        } else {\\r\\n            return (int) l;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        l, h = 0, x\\n        while l <= h:\\n            mid = l + (h - l) // 2\\n            if l == h or l + 1 == h:\\n                break\\n            elif mid * mid > x:\\n                h = mid - 1\\n            else:\\n                l = mid\\n        if h * h <= x:\\n            return h\\n        else:\\n            return l\\n\\n\"}]},{\"title\":\"代码6.4.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"int bs(vector<int>& nums, int x) {\\r\\n    int l = 0, h = nums.size() - 1;\\r\\n    while (l <= h) {\\r\\n        int mid = l + (h - l) / 2;\\r\\n        if (l == h) {\\r\\n            break;\\r\\n        } else if (nums[mid] >= x) {\\r\\n            h = mid;\\r\\n        } else {\\r\\n            l = mid + 1;\\r\\n        }\\r\\n    }\\r\\n    return nums[l];\\r\\n}\\n\"},{\"language\":\"Java\",\"content\":\"public int bs(int[] nums, int x) {\\r\\n\\tint l = 0, h = nums.length - 1;\\r\\n\\twhile (l <= h) {\\r\\n\\t\\tint mid = l + (h - l) / 2;\\r\\n\\t\\tif (l == h) {\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\t} else if (nums[mid] >= x) {\\r\\n\\t\\t\\th = mid;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tl = mid + 1;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn nums[l];\\r\\n}\\r\\n\\r\\n\\n\"},{\"language\":\"Py\",\"content\":\"# 查找第一个大于等于 x 的元素\\ndef bs(nums: List[int], x: int) -> int:\\n    l, h = 0, len(nums) - 1\\n    while l <= h:\\n        mid = l + (h - l) // 2\\n        if l == h:\\n            break\\n        elif nums[mid] >= x:\\n            h = mid\\n        else:\\n            l = mid + 1\\n    return nums[l]\\n\\n\"}]},{\"title\":\"代码6.4.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"int bs(vector<int>& nums, int x) {\\r\\n    int l = 0, h = nums.size() - 1;\\r\\n    while (l <= h) {\\r\\n        int mid = l + (h - l) / 2;\\r\\n        if (l == h || l + 1 == h) {\\r\\n            break;\\r\\n        } else if (nums[mid] <= x) {\\r\\n            l = mid;\\r\\n        } else {\\r\\n            h = mid - 1;\\r\\n        }\\r\\n    }\\r\\n    if (nums[h] <= x) {\\r\\n        return nums[h];\\r\\n    } else {\\r\\n        return nums[l];\\r\\n    }\\r\\n}\\n\"},{\"language\":\"Java\",\"content\":\"public int bs(int[] nums, int x) {\\r\\n    int l = 0, h = nums.length - 1;\\r\\n    while (l <= h) {\\r\\n        int mid = l + (h - l) / 2;\\r\\n        if (l == h || l + 1 == h) {\\r\\n            break;\\r\\n        } else if (nums[mid] <= x) {\\r\\n            l = mid;\\r\\n        } else {\\r\\n            h = mid - 1;\\r\\n        }\\r\\n    }\\r\\n    if (nums[h] <= x) {\\r\\n        return nums[h];\\r\\n    } else {\\r\\n        return nums[l];\\r\\n    }\\r\\n}\\n\"},{\"language\":\"Py\",\"content\":\"# 查找最后一个小于等于 x 的元素\\ndef bs(nums: List[int], x: int) -> int:\\n    l, h = 0, len(nums) - 1\\n    while l <= h:\\n        mid = l + (h - l) // 2\\n        if l == h or l + 1 == h:\\n            break\\n        elif nums[mid] <= x:\\n            l = mid\\n        else:\\n            h = mid - 1\\n    if nums[h] <= x:\\n        return nums[h]\\n    else:\\n        return nums[l]\\n\\n\"}]},{\"title\":\"代码6.5.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\r\\npublic:\\r\\n    int findPeakElement(vector<int>& nums) {\\r\\n        int n = nums.size();\\r\\n        int l = 0, h = n - 1;\\r\\n        while (l <= h) {\\r\\n            int mid = l + (h - l) / 2;\\r\\n            if (mid + 1 < n && nums[mid] < nums[mid + 1]) {\\r\\n                l = mid + 1;\\r\\n            } else if (mid - 1 >= 0 && nums[mid] < nums[mid - 1]) {\\r\\n                h = mid - 1;\\r\\n            } else {\\r\\n                return mid;\\r\\n            }\\r\\n        }\\r\\n        return -1;\\r\\n    }\\r\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\r\\n    public int findPeakElement(int[] nums) {\\r\\n        int n = nums.length;\\r\\n        int l = 0, h = n - 1;\\r\\n        while (l <= h) {\\r\\n            int mid = l + (h - l) / 2;\\r\\n            if (mid + 1 < n && nums[mid] < nums[mid + 1]) {\\r\\n                l = mid + 1;\\r\\n            } else if (mid - 1 >= 0 && nums[mid] < nums[mid - 1]) {\\r\\n                h = mid - 1;\\r\\n            } else {\\r\\n                return mid;\\r\\n            }\\r\\n        }\\r\\n        return -1;\\r\\n    }\\r\\n}\\r\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l, h = 0, n - 1\\n        while l <= h:\\n            mid = l + (h - l) // 2\\n            if mid + 1 < n and nums[mid] < nums[mid + 1]:\\n                l = mid + 1\\n            elif mid - 1 >= 0 and nums[mid] < nums[mid - 1]:\\n                h = mid - 1\\n            else:\\n                return mid\\n        return -1\\n\\n\"}]},{\"title\":\"代码6.6.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\r\\npublic:\\r\\n    int splitArray(vector<int>& nums, int m) {\\r\\n        long maxNum = nums[0], sumNum = 0;\\r\\n        for (long num : nums) {\\r\\n            if (num > maxNum) {\\r\\n                maxNum = num;\\r\\n            }\\r\\n            sumNum += num;\\r\\n        }\\r\\n        long l = maxNum, h = sumNum;\\r\\n        while (l <= h) {\\r\\n            long mid = l + (h - l) / 2;\\r\\n            if (l == h) {\\r\\n                return (int)l;\\r\\n            } else if (help(nums, mid, m)) {\\r\\n                h = mid;\\r\\n            } else {\\r\\n                l = mid + 1;\\r\\n            }\\r\\n        }\\r\\n        return -1;\\r\\n    }\\r\\n    bool help(vector<int>& nums, long ans, int m) {\\r\\n        long cnt = 1, cur = 0;\\r\\n        for (long num : nums) {\\r\\n            if (cur + num > ans) {\\r\\n                cur = num;\\r\\n                cnt += 1;\\r\\n            } else {\\r\\n                cur += num;\\r\\n            }\\r\\n        }\\r\\n        return cnt <= m;\\r\\n    }\\r\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\r\\n    public int splitArray(int[] nums, int m) {\\r\\n        long maxNum = nums[0], sumNum = 0;\\r\\n        for (long num : nums) {\\r\\n            maxNum = Math.max(maxNum, num);\\r\\n            sumNum += num;\\r\\n        }\\r\\n        long l = maxNum, h = sumNum;\\r\\n        while (l <= h) {\\r\\n            long mid = l + (h - l) / 2;\\r\\n            if (l == h) {\\r\\n                return (int) l;\\r\\n            } else if (help(nums, mid, m)) {\\r\\n                h = mid;\\r\\n            } else {\\r\\n                l = mid + 1;\\r\\n            }\\r\\n        }\\r\\n        return -1;\\r\\n    }\\r\\n\\r\\n    public boolean help(int[] nums, long ans, int m) {\\r\\n        long cnt = 1, cur = 0;\\r\\n        for (long num : nums) {\\r\\n            if (cur + num > ans) {\\r\\n                cur = num;\\r\\n                cnt += 1;\\r\\n            } else {\\r\\n                cur += num;\\r\\n            }\\r\\n        }\\r\\n        return cnt <= m;\\r\\n    }\\r\\n}\\r\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        # 判断 ans 是否可行\\n        def help(ans: int) -> boolean:\\n            cnt, cur = 1, 0\\n            for num in nums:\\n                if (cur + num) > ans:\\n                    cur = num\\n                    cnt += 1\\n                else:\\n                    cur += num\\n            return cnt <= m\\n\\n        l, h = max(nums), sum(nums)\\n        while l <= h:\\n            mid = l + (h - l) // 2\\n            if l == h:\\n                return l\\n            elif help(mid):\\n                h = mid\\n            else:\\n                l = mid + 1\\n        return -1\\n\\n\"}]}]},{\"id\":\"07\",\"name\":\"第七章\",\"list\":[{\"title\":\"代码7.1.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int num = 0;\\n        for (int i = 0; i < 32; i++){\\n            if (n & (1 << i))\\n                num++;                        \\n        }\\n        \\n        return num;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight(int n) {\\n        int retVal = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++) {\\n            if ((n & mask) != 0) {\\n                retVal++;\\n            }\\n            mask <<= 1;\\n        }\\n        return retVal;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def hammingWeight(self, n:int)->int:\\n        retval = 0\\n        for i in range(32):\\n            if n & (1 << i):\\n                retval = retval + 1\\n                \\n        return retval\\n\\n\"}]},{\"title\":\"代码7.1.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int hammingWeight(uint32_t n) {\\n        int ret = 0;\\n        \\n        while (n) {\\n            ret = ret + 1;\\n            n &= (n - 1);\\n        }\\n        return ret;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Solution {\\n    // you need to treat n as an unsigned value\\n    public int hammingWeight2(int n) {\\n        int retVal = 0;\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            retVal++;\\n        }\\n        return retVal;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def hammingWeight(self, n:int)->int:\\n        retval = 0\\n        while n:\\n            retval = retval + 1\\n            n &= (n - 1)\\n            \\n        return retval\\n\\n\"}]},{\"title\":\"代码7.2.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int getSum(int a, int b) {\\n        int ans = a ^ b;\\n        int c = a & b;\\n        while(c != 0) {\\n            c = (c & 0xffffffff) << 1;\\n            int ans_prim = ans ^ c;\\n            c = ans & c;\\n            ans = ans_prim;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int getSum(int a, int b) {\\n        while (b != 0) {\\n            int carry = (a & b) << 1;\\n            int temp = a ^ b;\\n\\n            a = temp;\\n            b = carry;\\n        }\\n        return a;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def getSum(self, a:int, b:int)->int:\\n        carry = 0\\n        mask  = 0xFFFFFFFF\\n        \\n        while b & mask != 0:\\n            carry = (a & b) << 1\\n            a = a ^ b\\n            b = carry\\n            \\n        if b > mask:\\n            return a & mask\\n        else:\\n            return a\\n\\n\"}]},{\"title\":\"代码7.3.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\nprivate:\\n    unordered_map<int, int> visited;\\npublic:\\n    int integerReplacement(int n) {\\n        if (n == 1) return 0;\\n        \\n        if (visited.count(n) == 0) {\\n            if (n & 1 == 1)\\n                visited[n] = 2 + min(integerReplacement(n >> 1), integerReplacement((n >> 1) + 1));\\n            else\\n                visited[n] = 1 + integerReplacement(n >> 1);\\n        }\\n        \\n        return visited[n];\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int integerReplacement(int n) {\\n        if (n == 1)\\n            return 0;\\n        if (n == Integer.MAX_VALUE)\\n            return 32;\\n        if (n % 2 == 0)\\n            return integerReplacement(n / 2) + 1;\\n        else\\n            return Math.min(integerReplacement(n + 1), integerReplacement(n - 1)) + 1;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def integerReplacement(self, n:int)->int:\\n        if n == 1:\\n            return 0\\n        elif n % 2 == 0:\\n            return 1 + self.integerReplacement(n // 2)\\n        else:\\n            return min(self.integerReplacement(n + 1), self.integerReplacement(n - 1)) + 1\\n\\n\"}]},{\"title\":\"代码7.3.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int integerReplacement(int n) {\\n        long int tmp_num = n;\\n        int count = 0;\\n        \\n        while (tmp_num > 1) {\\n            if (tmp_num % 2 == 0)\\n                tmp_num >>= 1;\\n            else if (((tmp_num + 1) % 4 == 0) && (tmp_num != 3))\\n                tmp_num += 1;\\n            else\\n                tmp_num -= 1;\\n            \\n            count += 1;\\n        }\\n        \\n        return count;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int integerReplacement(int n) {\\n        if (n == 1)\\n            return 0;\\n        if (n == Integer.MAX_VALUE)\\n            return 32;\\n        int count = 0;\\n        while (n > 3) {\\n            if (n % 2 == 0)\\n                n >>= 1;\\n            else if ((n + 1) % 4 == 0) \\n                n += 1;\\n            else\\n                n -= 1;\\n            count++;\\n        }\\n\\n        return n == 3 ? count + 2 : count + 1; // 处理 n==3 的特殊情况\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def integerReplacement(self, n:int)->int:\\n        count = 0\\n        while n > 1:\\n            if n & 1 == 0:\\n                n >>= 1\\n            elif (n + 1) % 4 == 0 and n != 3:\\n                n += 1\\n            else:\\n                n -= 1\\n            count += 1\\n\\n        return count\\n\\n\"}]},{\"title\":\"代码7.3.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int integerReplacement(int n) {\\n        long int tmp_num = n;\\n        int count = 0;\\n        \\n        while (tmp_num != 1) {\\n            if (tmp_num % 2 == 0) {\\n                tmp_num >>= 1;\\n            } else {\\n                if (((tmp_num & 2) == 0) || (tmp_num == 3))\\n                    tmp_num -= 1;\\n                else\\n                    tmp_num += 1;\\n            }\\n            \\n            count += 1;\\n        }\\n        \\n        return count;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int integerReplacement(int n) {\\n        if (n == 1)\\n            return 0;\\n        if (n == Integer.MAX_VALUE)\\n            return 32;\\n        int count = 0;\\n        while (n > 3) {\\n            if ((n & 1) == 0) //判断是 0 或 1\\n                n >>= 1;\\n            else if ((n & 2) == 0) // 已经确定最后一位是1，判断是01 还是11\\n                n -= 1;\\n            else\\n                n += 1;\\n            count++;\\n        }\\n        return n == 3 ? count + 2 : count + 1; // 处理 n==3 的特殊情况\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def integerReplacement(self, n:int)->int:\\n        count = 0\\n        while n != 1:\\n            if n & 1 == 0：\\n                n >>= 1\\n            else:\\n                if (n & 2) == 0 or n == 3:\\n                    n += -1\\n                else:\\n                    n += 1\\n            count += 1\\n\\n        return count\\n\\n\"}]},{\"title\":\"代码7.4.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            m[nums[i]]++;\\n        }\\n\\n        for (auto it = m.begin(); it != m.end(); it++)\\n            if (it->second == 1)\\n                return it->first;\\n\\n        return 0;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int singleNumber(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums)\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        for (int num : map.keySet())\\n            if (map.get(num) == 1)\\n                return num;\\n        return 0;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def singleNumber(self, nums:List[int])->int:\\n        ret = 0\\n        \\n        for i in range(len(nums)):\\n            ret ^= nums[i]\\n            \\n        return ret\\n\\n\"}]},{\"title\":\"代码7.4.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int result = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            result ^= nums[i];\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            res ^= nums[i];\\n        }\\n        return res;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def singleNumber(self, nums:List[int])->int:\\n        hash_tab = defaultdict(int)\\n        \\n        for i in nums:\\n            hash_tab[i] += 1\\n            \\n        for i in hash_tab:\\n            if hash_tab[i] == 1:\\n                return i\\n\\n\"}]},{\"title\":\"代码7.4.3\",\"codes\":[{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int singleNumber(int[] nums) {\\n        int distinctSum = Arrays.stream(nums).distinct().sum();\\n        int sum = Arrays.stream(nums).sum();\\n        return distinctSum * 2 - sum;\\n    }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def singleNumber(self, nums:List[int])->int:\\n        return 2 * sum(set(nums)) - sum(nums)\\n\\n\"}]},{\"title\":\"代码7.4.4\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        vector<int> t(32);\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            int num = nums[i];\\n            for (int j = 31; j >= 0; j--) {\\n                t[j] += num & 1;\\n                num >>= 1;\\n                if (!num) break;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int j = 31; j >= 0; j--) {\\n            int num = t[j] % 3;\\n            if (num) res += 1 << (31 - j);\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int singleNumber(int[] nums) {\\n        int[] counts = new int[32];\\n        for (int num : nums) {\\n            for (int i = 0; i < 32; i++) {\\n                counts[i] += num & 1;\\n                num >>= 1;\\n            }\\n        }\\n        int res = 0;\\n        for (int i = 0; i < 32; i++) {\\n            res <<= 1;\\n            res |= counts[31 - i] % 3;\\n        }\\n        return res;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        counts = [0] * 32\\n        # 统计 nums 中每个元素的二进制中，对应位上的 1 的个数\\n        for num in nums:\\n            for j in range(32):\\n                counts[j] += num & 1\\n                num >>= 1\\n        res, m = 0, 3\\n        # 对每一位上，统计的 1 的个数取余\\n        for i in range(32):\\n            res <<= 1\\n            res |= counts[31 - i] % m\\n            \\n        return res if counts[31] % m == 0 else ~(res ^ 0xffffffff)\\n\\n\\n\"}]},{\"title\":\"代码7.4.5\",\"codes\":[{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int singleNumber(int[] nums) {\\n        int[] counts = new int[32];\\n        for (int num : nums) {\\n            for (int i = 0; i < 32; i++) {\\n                counts[i] += num & 1;\\n                num >>= 1;\\n            }\\n        }\\n        int res = 0;\\n        for (int i = 0; i < 32; i++) {\\n            res <<= 1;\\n            res |= counts[31 - i] % 3;\\n        }\\n        return res;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def singleNumber(self, nums: List[int]) -> List[int]:\\n        ret = 0  # 所有数字异或的结果\\n        a = 0\\n        b = 0\\n        for n in nums:\\n            ret ^= n\\n        # 找到第一位不是 0 的\\n        h = 1\\n        while ret & h == 0:\\n            h <<= 1\\n        for n in nums:\\n            # 根据该位是否为 0 将其分为两组\\n            if h & n == 0:\\n                a ^= n\\n            else:\\n                b ^= n\\n\\n        return [a, b]\\n\\n\"}]}]},{\"id\":\"08\",\"name\":\"第八章\",\"list\":[{\"title\":\"代码8.1.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class MinStack {\\n    stack<int> x_stack;\\n    stack<int> min_stack;\\npublic:\\n    MinStack() {\\n        min_stack.push(INT_MAX);\\n    }\\n    \\n    void push(int x) {\\n        x_stack.push(x);\\n        min_stack.push(min(min_stack.top(), x));\\n    }\\n    \\n    void pop() {\\n        x_stack.pop();\\n        min_stack.pop();\\n    }\\n    \\n    int top() {\\n        return x_stack.top();\\n    }\\n    \\n    int getMin() {\\n        return min_stack.top();\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.Stack;\\n\\npublic class MinStack {\\n\\n    // 数据栈\\n    private Stack<Integer> data;\\n    // 辅助栈\\n    private Stack<Integer> helper;\\n\\n    /**\\n     * initialize your data structure here.\\n     */\\n    public MinStack() {\\n        data = new Stack<>();\\n        helper = new Stack<>();\\n    }\\n\\n    public void push(int x) {\\n        // 数据栈和辅助栈一定会增加元素\\n        data.add(x);\\n        if (helper.isEmpty() || helper.peek() >= x) {\\n            helper.add(x);\\n        } else {\\n            helper.add(helper.peek());\\n        }\\n    }\\n\\n    public void pop() {\\n        // 两个栈都得 pop\\n        if (!data.isEmpty()) {\\n            helper.pop();\\n            data.pop();\\n        }\\n    }\\n\\n    public int top() {\\n        if(!data.isEmpty()){\\n            return data.peek();\\n        }\\n        throw new RuntimeException(\\\"栈中元素为空，此操作非法\\\");\\n    }\\n\\n    public int getMin() {\\n        if(!helper.isEmpty()){\\n            return helper.peek();\\n        }\\n        throw new RuntimeException(\\\"栈中元素为空，此操作非法\\\");\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class MinStack:\\n    def __init__(self):\\n        \\\"\\\"\\\"\\n        initialize your data structure here.\\n        \\\"\\\"\\\"\\n        self.stack = []\\n        self.helper = []\\n\\n    def push(self, x: int) -> None:\\n        self.stack.append(x)\\n        if not self.helper or x <= self.helper[-1]:\\n            self.helper.append(x)\\n        else:\\n            self.helper.append(self.helper[-1])\\n\\n    def pop(self) -> None:\\n        self.helper.pop()\\n        return self.stack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.helper[-1]\\n\\n\\n# Your MinStack object will be instantiated and called as such:\\n# obj = MinStack()\\n# obj.push(x)\\n# obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.getMin()\\n\\n\"}]},{\"title\":\"代码8.1.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class MinStack {\\n    stack<int> x_stack;\\n    stack<int> min_stack;\\npublic:\\n    MinStack() {\\n        min_stack.push(INT_MAX);\\n    }\\n    \\n    void push(int x) {\\n        x_stack.push(x);\\n        min_stack.push(min(min_stack.top(), x));\\n    }\\n    \\n    void pop() {\\n        x_stack.pop();\\n        min_stack.pop();\\n    }\\n    \\n    int top() {\\n        return x_stack.top();\\n    }\\n    \\n    int getMin() {\\n        return min_stack.top();\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.Stack;\\n\\npublic class MinStack {\\n\\n    // 数据栈\\n    private Stack<Integer> data;\\n    // 辅助栈\\n    private Stack<Integer> helper;\\n\\n    /**\\n     * initialize your data structure here.\\n     */\\n    public MinStack() {\\n        data = new Stack<>();\\n        helper = new Stack<>();\\n    }\\n\\n    public void push(int x) {\\n        // 数据栈和辅助栈一定会增加元素\\n        data.add(x);\\n        if (helper.isEmpty() || helper.peek() >= x) {\\n            helper.add(x);\\n        } else {\\n            helper.add(helper.peek());\\n        }\\n    }\\n\\n    public void pop() {\\n        // 两个栈都得 pop\\n        if (!data.isEmpty()) {\\n            helper.pop();\\n            data.pop();\\n        }\\n    }\\n\\n    public int top() {\\n        if(!data.isEmpty()){\\n            return data.peek();\\n        }\\n        throw new RuntimeException(\\\"栈中元素为空，此操作非法\\\");\\n    }\\n\\n    public int getMin() {\\n        if(!helper.isEmpty()){\\n            return helper.peek();\\n        }\\n        throw new RuntimeException(\\\"栈中元素为空，此操作非法\\\");\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class MinStack:\\n    def __init__(self):\\n        \\\"\\\"\\\"\\n        initialize your data structure here.\\n        \\\"\\\"\\\"\\n        self.stack = []\\n        self.helper = []\\n\\n    def push(self, x: int) -> None:\\n        self.stack.append(x)\\n        if not self.helper or x < self.helper[-1][0]:\\n            self.helper.append([x, 1])\\n        else:\\n            self.helper[-1] = [self.helper[-1][0], self.helper[-1][1] + 1]\\n\\n    def pop(self) -> None:\\n        if self.helper[-1][1] > 1:\\n            self.helper[-1] = [self.helper[-1][0], self.helper[-1][1] - 1]\\n        else:\\n            self.helper.pop()\\n        return self.stack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.helper[-1][0]\\n\\n\\n# Your MinStack object will be instantiated and called as such:\\nobj = MinStack()\\nobj.push(1)\\nobj.pop()\\nparam_3 = obj.top()\\nparam_4 = obj.getMin()\\n\\n\"}]},{\"title\":\"代码8.1.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class MinStack {\\n    stack<int> x_stack;\\n    stack<int> min_stack;\\npublic:\\n    MinStack() {\\n        min_stack.push(INT_MAX);\\n    }\\n    \\n    void push(int x) {\\n        x_stack.push(x);\\n        min_stack.push(min(min_stack.top(), x));\\n    }\\n    \\n    void pop() {\\n        x_stack.pop();\\n        min_stack.pop();\\n    }\\n    \\n    int top() {\\n        return x_stack.top();\\n    }\\n    \\n    int getMin() {\\n        return min_stack.top();\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.Stack;\\n\\npublic class MinStack {\\n\\n    // 数据栈\\n    private Stack<Integer> data;\\n    // 辅助栈\\n    private Stack<Integer> helper;\\n\\n    /**\\n     * initialize your data structure here.\\n     */\\n    public MinStack() {\\n        data = new Stack<>();\\n        helper = new Stack<>();\\n    }\\n\\n    public void push(int x) {\\n        data.add(x);\\n        if (helper.isEmpty() || helper.peek() >= x) {\\n            helper.add(x);\\n        }\\n    }\\n\\n    public void pop() {\\n        if (!data.isEmpty()) {\\n            int top = data.pop();\\n            if(top == helper.peek()){\\n                helper.pop();\\n            }\\n        }\\n    }\\n\\n    public int top() {\\n        if(!data.isEmpty()){\\n            return data.peek();\\n        }\\n        throw new RuntimeException(\\\"栈中元素为空，此操作非法\\\");\\n    }\\n\\n    public int getMin() {\\n        if(!helper.isEmpty()){\\n            return helper.peek();\\n        }\\n        throw new RuntimeException(\\\"栈中元素为空，此操作非法\\\");\\n    }\\n\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class MinStack:\\n    def __init__(self):\\n        \\\"\\\"\\\"\\n        initialize your data structure here.\\n        \\\"\\\"\\\"\\n        self.stack = []\\n        self.helper = []\\n\\n    def push(self, x: int) -> None:\\n        self.stack.append(x)\\n        if not self.helper or x <= self.helper[-1]:\\n            self.helper.append(x)\\n\\n    def pop(self) -> None:\\n        top = self.stack.pop()\\n        if self.helper and top == self.helper[-1]:\\n            self.helper.pop()\\n        return top\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.helper[-1]\\n\\n\"}]},{\"title\":\"代码8.1.4\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class MinStack {\\n    typedef long long ll;\\npublic:\\n    ll topElem; \\n    /** initialize your data structure here. */\\n    MinStack() {\\n    }\\n\\n    void push(int x) {\\n        if(s.empty()) {\\n            minn = x;\\n            s.push(x-minn);  //(当前值x-最小值minn)进栈\\n        }\\n        else {\\n            s.push(x-minn);\\n            minn = x < minn ? x : minn;  //值得注意的是当栈顶元素<0,则说明栈顶元素就是minn\\n        }\\n    }\\n    \\n    void pop() {\\n        if(!s.empty()) {\\n            topElem = s.top();\\n            s.pop();\\n            //原来的值x-最小值minn = topElem\\n            //topElem<0,说明原来值x更小(原来的值就是现在的minn)，则现在的minn应该被更新minn-topElem\\n            if(topElem < 0) minn -= topElem;\\n        }\\n        return;\\n    }\\n    \\n    int top() {\\n        if(!s.empty()) {\\n            topElem = s.top();\\n        }\\n        if(topElem < 0) return minn; //说明topElem <0, 说明 x<minn, minn已经被更新为当栈顶x，栈顶元素就是minn\\n        return topElem+minn;\\n    }\\n    \\n    int getMin() {\\n        return minn;\\n    }\\n    private:\\n        ll minn;\\n        stack<ll>s;\\n};\\n\"},{\"language\":\"Java\",\"content\":\"public class MinStack {\\n  long min;\\n  Stack<Long> stack;\\n\\n  public MinStack(){\\n        stack=new Stack<>();\\n    }\\n\\n  public void push(int x) {\\n    if (stack.isEmpty()) {\\n      min = x;\\n      stack.push(x - min);\\n    } else {\\n      stack.push(x - min);\\n      if (x < min){\\n        min = x; // 更新最小值\\n      }\\n        \\n    }\\n  }\\n\\n  public void pop() {\\n    if (stack.isEmpty())\\n      return;\\n\\n    long pop = stack.pop();\\n    \\n    //弹出的是负值，要更新 min\\n    if (pop < 0) {\\n      min = min - pop;\\n    }\\n\\n  }\\n\\n  public int top() {\\n    long top = stack.peek();\\n    //负数的话，出栈的值保存在 min 中\\n    if (top < 0) {\\n      return (int) (min);\\n        //出栈元素加上最小值即可\\n    } else {\\n      return (int) (top + min);\\n    }\\n  }\\n\\n  public int getMin() {\\n    return (int) min;\\n  }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class MinStack:\\n    def __init__(self):\\n        \\\"\\\"\\\"\\n        initialize your data structure here.\\n        \\\"\\\"\\\"\\n        self.stack = []\\n        self.min = float('inf')\\n\\n    def push(self, x: int) -> None:\\n        if not self.stack:\\n            self.min = x\\n            self.stack.append(0)\\n        else:\\n            self.stack.append(x - self.min)\\n            if x < self.min: self.min = x\\n\\n    def pop(self) -> None:\\n        if not self.stack: return\\n\\n        top = self.stack.pop()\\n        if top < 0:\\n            self.min = self.min - top\\n\\n    def top(self) -> int:\\n        top = self.stack[-1]\\n        if top < 0: return self.min\\n        \\n        return top + self.min\\n\\n    def getMin(self) -> int:\\n        return self.min\\n\\n\"}]},{\"title\":\"代码8.2.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Trie {\\nprivate:\\n    bool isEnd;\\n    Trie* next[26];\\npublic:\\n    Trie() {\\n        isEnd = false;\\n        memset(next, 0, sizeof(next));\\n    }\\n    \\n    void insert(string word) {\\n        Trie* node = this;\\n        for (char c : word) {\\n            if (node->next[c-'a'] == NULL) {\\n                node->next[c-'a'] = new Trie();\\n            }\\n            node = node->next[c-'a'];\\n        }\\n        node->isEnd = true;\\n    }\\n    \\n    bool search(string word) {\\n        Trie* node = this;\\n        for (char c : word) {\\n            node = node->next[c - 'a'];\\n            if (node == NULL) {\\n                return false;\\n            }\\n        }\\n        return node->isEnd;\\n    }\\n    \\n    bool startsWith(string prefix) {\\n        Trie* node = this;\\n        for (char c : prefix) {\\n            node = node->next[c-'a'];\\n            if (node == NULL) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class TrieNode {\\n\\n  // R links to node children\\n  private TrieNode[] links;\\n\\n  private final int R = 26;\\n\\n  private boolean isEnd;\\n\\n  public TrieNode() {\\n      links = new TrieNode[R];\\n  }\\n\\n  public boolean containsKey(char ch) {\\n      return links[ch -'a'] != null;\\n  }\\n  public TrieNode get(char ch) {\\n      return links[ch -'a'];\\n  }\\n  public void put(char ch, TrieNode node) {\\n      links[ch -'a'] = node;\\n  }\\n  public void setEnd() {\\n      isEnd = true;\\n  }\\n  public boolean isEnd() {\\n      return isEnd;\\n  }\\n}\\n\\nclass Trie {\\n  private TrieNode root;\\n\\n  public Trie() {\\n      root = new TrieNode();\\n  }\\n\\n  public void insert(String word) {\\n      TrieNode node = root;\\n      for (int i = 0; i < word.length(); i++) {\\n          char currentChar = word.charAt(i);\\n          if (!node.containsKey(currentChar)) {\\n              node.put(currentChar, new TrieNode());\\n          }\\n          node = node.get(currentChar);\\n      }\\n      node.setEnd();\\n  }\\n\\n  private TrieNode searchPrefix(String word) {\\n    TrieNode node = root;\\n    for (int i = 0; i < word.length(); i++) {\\n       char curLetter = word.charAt(i);\\n       if (node.containsKey(curLetter)) {\\n           node = node.get(curLetter);\\n       } else {\\n           return null;\\n       }\\n    }\\n    return node;\\n  }\\n\\n  public boolean search(String word) {\\n    TrieNode node = searchPrefix(word);\\n    return node != null && node.isEnd();\\n  }\\n\\n  public boolean startsWith(String prefix) {\\n    TrieNode node = searchPrefix(prefix);\\n    return node != null;\\n  }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class TrieNode:\\n    def __init__(self):\\n        self.isEnd = False\\n        self.children = {}\\n\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word: str) -> None:\\n        cur = self.root\\n        for ch in word:\\n            if ch not in cur.children:\\n                node = TrieNode()\\n                cur.children[ch] = node\\n            cur = cur.children[ch]\\n\\n        cur.isEnd = True\\n\\n    def search(self, word: str) -> bool:\\n        cur = self.root\\n        for ch in word:\\n            if ch not in cur.children:\\n                return False\\n            cur = cur.children[ch]\\n\\n        if cur.isEnd:\\n            return True\\n\\n        return False\\n\\n    def startsWith(self, prefix: str) -> bool:\\n        cur = self.root\\n        for ch in prefix:\\n            if ch not in cur.children:\\n                return False\\n            cur = cur.children[ch]\\n\\n        return True\\n\\n\"}]},{\"title\":\"代码8.3.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"struct DLinkedNode {\\n    int key, value;\\n    DLinkedNode* prev;\\n    DLinkedNode* next;\\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\\n};\\n\\nclass LRUCache {\\nprivate:\\n    unordered_map<int, DLinkedNode*> cache;\\n    DLinkedNode* head;\\n    DLinkedNode* tail;\\n    int size;\\n    int capacity;\\n\\npublic:\\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\\n        // 使用伪头部和伪尾部节点\\n        head = new DLinkedNode();\\n        tail = new DLinkedNode();\\n        head->next = tail;\\n        tail->prev = head;\\n    }\\n    \\n    int get(int key) {\\n        if (!cache.count(key)) {\\n            return -1;\\n        }\\n        // 如果 key 存在，先通过哈希表定位，再移到头部\\n        DLinkedNode* node = cache[key];\\n        moveToHead(node);\\n        return node->value;\\n    }\\n    \\n    void put(int key, int value) {\\n        if (!cache.count(key)) {\\n            // 如果 key 不存在，创建一个新的节点\\n            DLinkedNode* node = new DLinkedNode(key, value);\\n            // 添加进哈希表\\n            cache[key] = node;\\n            // 添加至双向链表的头部\\n            addToHead(node);\\n            ++size;\\n            if (size > capacity) {\\n                // 如果超出容量，删除双向链表的尾部节点\\n                DLinkedNode* removed = removeTail();\\n                // 删除哈希表中对应的项\\n                cache.erase(removed->key);\\n                // 防止内存泄漏\\n                delete removed;\\n                --size;\\n            }\\n        }\\n        else {\\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\\n            DLinkedNode* node = cache[key];\\n            node->value = value;\\n            moveToHead(node);\\n        }\\n    }\\n\\n    void addToHead(DLinkedNode* node) {\\n        node->prev = head;\\n        node->next = head->next;\\n        head->next->prev = node;\\n        head->next = node;\\n    }\\n    \\n    void removeNode(DLinkedNode* node) {\\n        node->prev->next = node->next;\\n        node->next->prev = node->prev;\\n    }\\n\\n    void moveToHead(DLinkedNode* node) {\\n        removeNode(node);\\n        addToHead(node);\\n    }\\n\\n    DLinkedNode* removeTail() {\\n        DLinkedNode* node = tail->prev;\\n        removeNode(node);\\n        return node;\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"public class LRUCache {\\n  class DLinkedNode {\\n      int key;\\n      int value;\\n      DLinkedNode prev;\\n      DLinkedNode next;\\n      public DLinkedNode() {}\\n      public DLinkedNode(int _key, int _value) {key = _key; value = _value;}\\n  }\\n\\n  private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\\n  private int size;\\n  private int capacity;\\n  private DLinkedNode head, tail;\\n\\n  public LRUCache(int capacity) {\\n      this.size = 0;\\n      this.capacity = capacity;\\n      // 使用伪头部和伪尾部节点\\n      head = new DLinkedNode();\\n      tail = new DLinkedNode();\\n      head.next = tail;\\n      tail.prev = head;\\n  }\\n\\n  public int get(int key) {\\n      DLinkedNode node = cache.get(key);\\n      if (node == null) {\\n          return -1;\\n      }\\n      // 如果 key 存在，先通过哈希表定位，再移到头部\\n      moveToHead(node);\\n      return node.value;\\n  }\\n\\n  public void put(int key, int value) {\\n      DLinkedNode node = cache.get(key);\\n      if (node == null) {\\n          // 如果 key 不存在，创建一个新的节点\\n          DLinkedNode newNode = new DLinkedNode(key, value);\\n          // 添加进哈希表\\n          cache.put(key, newNode);\\n          // 添加至双向链表的头部\\n          addToHead(newNode);\\n          ++size;\\n          if (size > capacity) {\\n              // 如果超出容量，删除双向链表的尾部节点\\n              DLinkedNode tail = removeTail();\\n              // 删除哈希表中对应的项\\n              cache.remove(tail.key);\\n              --size;\\n          }\\n      }\\n      else {\\n          // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\\n          node.value = value;\\n          moveToHead(node);\\n      }\\n  }\\n\\n  private void addToHead(DLinkedNode node) {\\n      node.prev = head;\\n      node.next = head.next;\\n      head.next.prev = node;\\n      head.next = node;\\n  }\\n\\n  private void removeNode(DLinkedNode node) {\\n      node.prev.next = node.next;\\n      node.next.prev = node.prev;\\n  }\\n\\n  private void moveToHead(DLinkedNode node) {\\n      removeNode(node);\\n      addToHead(node);\\n  }\\n\\n  private DLinkedNode removeTail() {\\n      DLinkedNode res = tail.prev;\\n      removeNode(res);\\n      return res;\\n  }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class ListNode:\\n    def __init__(self, key=None, value=None):\\n        self.key = key\\n        self.value = value\\n        self.prev = None\\n        self.next = None\\n\\n\\nclass LRUCache:\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.hashmap = {}\\n        # 新建两个节点 head 和 tail\\n        self.head = ListNode()\\n        self.tail = ListNode()\\n        # 初始化链表为 head <-> tail\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n    # get 和 put 操作可能都会调用move_to_tail方法\\n    def move_to_tail(self, key: int) -> int:\\n        node = self.hashmap[key]\\n        # 将 node 结点的前置结点和后置结点相连\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        # 将node插入到尾节点前\\n        node.prev = self.tail.prev\\n        node.next = self.tail\\n        self.tail.prev.next = node\\n        self.tail.prev = node\\n\\n    def get(self, key: int) -> int:\\n        if key in self.hashmap:\\n            # 如果已经在链表中了久把它移到末尾（变成最新访问的）\\n            self.move_to_tail(key)\\n            return self.hashmap.get(key).value\\n\\n        return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.hashmap:\\n            # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点\\n            # 但是需要更新字典该值对应节点的value\\n            self.hashmap[key].value = value\\n            # 之后将该节点移到末尾\\n            self.move_to_tail(key)\\n        else:\\n            if len(self.hashmap) == self.capacity:\\n                # 去掉哈希表对应项\\n                self.hashmap.pop(self.head.next.key)\\n                # 去掉最久没有被访问过的节点，即头节点之后的节点\\n                self.head.next = self.head.next.next\\n                self.head.next.prev = self.head\\n            # 将新结点插入到尾节点前\\n            newNode = ListNode(key, value)\\n            self.hashmap[key] = newNode\\n            newNode.prev = self.tail.prev\\n            newNode.next = self.tail\\n            self.tail.prev.next = newNode\\n            self.tail.prev = newNode\\n\\n\"}]},{\"title\":\"代码8.4.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"// 缓存的节点信息\\nstruct Node {\\n    int key, val, freq;\\n    Node(int _key,int _val,int _freq): key(_key), val(_val), freq(_freq){}\\n};\\nclass LFUCache {\\n    int minfreq, capacity;\\n    unordered_map<int, list<Node>::iterator> key_table;\\n    unordered_map<int, list<Node>> freq_table;\\npublic:\\n    LFUCache(int _capacity) {\\n        minfreq = 0;\\n        capacity = _capacity;\\n        key_table.clear();\\n        freq_table.clear();\\n    }\\n    \\n    int get(int key) {\\n        if (capacity == 0) return -1;\\n        auto it = key_table.find(key);\\n        if (it == key_table.end()) return -1;\\n        list<Node>::iterator node = it -> second;\\n        int val = node -> val, freq = node -> freq;\\n        freq_table[freq].erase(node);\\n        // 如果当前链表为空，我们需要在哈希表中删除，且更新minFreq\\n        if (freq_table[freq].size() == 0) {\\n            freq_table.erase(freq);\\n            if (minfreq == freq) minfreq += 1;\\n        }\\n        // 插入到 freq + 1 中\\n        freq_table[freq + 1].push_front(Node(key, val, freq + 1));\\n        key_table[key] = freq_table[freq + 1].begin();\\n        return val;\\n    }\\n    \\n    void put(int key, int value) {\\n        if (capacity == 0) return;\\n        auto it = key_table.find(key);\\n        if (it == key_table.end()) {\\n            // 缓存已满，需要进行删除操作\\n            if (key_table.size() == capacity) {\\n                // 通过 minFreq 拿到 freq_table[minFreq] 链表的末尾节点\\n                auto it2 = freq_table[minfreq].back();\\n                key_table.erase(it2.key);\\n                freq_table[minfreq].pop_back();\\n                if (freq_table[minfreq].size() == 0) {\\n                    freq_table.erase(minfreq);\\n                }\\n            } \\n            freq_table[1].push_front(Node(key, value, 1));\\n            key_table[key] = freq_table[1].begin();\\n            minfreq = 1;\\n        } else {\\n            // 与 get 操作基本一致，除了需要更新缓存的值\\n            list<Node>::iterator node = it -> second;\\n            int freq = node -> freq;\\n            freq_table[freq].erase(node);\\n            if (freq_table[freq].size() == 0) {\\n                freq_table.erase(freq);\\n                if (minfreq == freq) minfreq += 1;\\n            }\\n            freq_table[freq + 1].push_front(Node(key, value, freq + 1));\\n            key_table[key] = freq_table[freq + 1].begin();\\n        }\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class LFUCache {\\n  Map<Integer, Node> cache; // 存储缓存的内容\\n  Map<Integer, DoublyLinkedList> freqMap; // 存储每个频次对应的双向链表\\n  int size;\\n  int capacity;\\n  int min; // 存储当前最小频次\\n\\n  public LFUCache(int capacity) {\\n      cache = new HashMap<> (capacity);\\n      freqMap = new HashMap<>();\\n      this.capacity = capacity;\\n  }\\n  \\n  public int get(int key) {\\n      Node node = cache.get(key);\\n      if (node == null) {\\n          return -1;\\n      }\\n      freqInc(node);\\n      return node.value;\\n  }\\n  \\n  public void put(int key, int value) {\\n      if (capacity == 0) {\\n          return;\\n      }\\n      Node node = cache.get(key);\\n      if (node != null) {\\n          node.value = value;\\n          freqInc(node);\\n      } else {\\n          if (size == capacity) {\\n              DoublyLinkedList minFreqLinkedList = freqMap.get(min);\\n              cache.remove(minFreqLinkedList.tail.pre.key);\\n              minFreqLinkedList.removeNode(minFreqLinkedList.tail.pre); // 这里不需要维护min, 因为下面add了newNode后min肯定是1.\\n              size--;\\n          }\\n          Node newNode = new Node(key, value);\\n          cache.put(key, newNode);\\n          DoublyLinkedList linkedList = freqMap.get(1);\\n          if (linkedList == null) {\\n              linkedList = new DoublyLinkedList();\\n              freqMap.put(1, linkedList);\\n          }\\n          linkedList.addNode(newNode);\\n          size++;  \\n          min = 1;   \\n      }\\n  }\\n\\n  void freqInc(Node node) {\\n      // 从原freq对应的链表里移除, 并更新min\\n      int freq = node.freq;\\n      DoublyLinkedList linkedList = freqMap.get(freq);\\n      linkedList.removeNode(node);\\n      if (freq == min && linkedList.head.post == linkedList.tail) { \\n          min = freq + 1;\\n      }\\n      // 加入新freq对应的链表\\n      node.freq++;\\n      linkedList = freqMap.get(freq + 1);\\n      if (linkedList == null) {\\n          linkedList = new DoublyLinkedList();\\n          freqMap.put(freq + 1, linkedList);\\n      }\\n      linkedList.addNode(node);\\n  }\\n}\\n\\nclass Node {\\n  int key;\\n  int value;\\n  int freq = 1;\\n  Node pre;\\n  Node post;\\n\\n  public Node() {}\\n  \\n  public Node(int key, int value) {\\n      this.key = key;\\n      this.value = value;\\n  }\\n}\\n\\nclass DoublyLinkedList {\\n  Node head;\\n  Node tail;\\n\\n  public DoublyLinkedList() {\\n      head = new Node();\\n      tail = new Node();\\n      head.post = tail;\\n      tail.pre = head;\\n  }\\n\\n  void removeNode(Node node) {\\n      node.pre.post = node.post;\\n      node.post.pre = node.pre;\\n  }\\n\\n  void addNode(Node node) {\\n      node.post = head.post;\\n      head.post.pre = node;\\n      head.post = node;\\n      node.pre = head;\\n  }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"import collections\\n\\n\\nclass Node:\\n    def __init__(self, key: int, val: int):\\n        self.key = key\\n        self.val = val\\n        self.freq = 1\\n        self.prev = self.next = None\\n\\n\\nclass DLinkedList:\\n    def __init__(self):\\n        self._sentinel = Node(None, None)\\n        self._sentinel.next = self._sentinel.prev = self._sentinel\\n        self._size = 0\\n\\n    def __len__(self):\\n        return self._size\\n\\n    def append(self, node: Node):\\n        node.next = self._sentinel.next\\n        node.prev = self._sentinel\\n        node.next.prev = node\\n        self._sentinel.next = node\\n        self._size += 1\\n\\n    def pop(self, node=None):\\n        if self._size == 0:\\n            return\\n\\n        if not node:\\n            node = self._sentinel.prev\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        self._size -= 1\\n\\n        return node\\n\\n\\nclass LFUCache:\\n    def __init__(self, capacity: int):\\n        self._size = 0\\n        self._capacity = capacity\\n        self._node = dict()\\n        self._freq = collections.defaultdict(DLinkedList)\\n        self._minfreq = 0\\n\\n    def _update(self, node: Node):\\n        freq = node.freq\\n\\n        self._freq[freq].pop(node)\\n\\n        if self._minfreq == freq and not self._freq[freq]:\\n            self._minfreq += 1\\n\\n        node.freq += 1\\n        freq = node.freq\\n        self._freq[freq].append(node)\\n\\n    def get(self, key: int) -> int:\\n        if key not in self._node:\\n            return -1\\n\\n        node = self._node[key]\\n        self._update(node)\\n        return node.val\\n\\n    def put(self, key: int, value: int) -> None:\\n        if self._capacity == 0:\\n            return\\n\\n        if key in self._node:\\n            node = self._node[key]\\n            self._update(node)\\n            node.val = value\\n        else:\\n            if self._size == self._capacity:\\n                node = self._freq[self._minfreq].pop()\\n                del self._node[node.key]\\n                self._size -= 1\\n\\n            node = Node(key, value)\\n            self._node[key] = node\\n            self._freq[1].append(node)\\n            self._minfreq = 1\\n            self._size += 1\\n\\n\"}]},{\"title\":\"代码8.5.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"const int MAX_LEVEL=10;\\nclass SkipNode{\\npublic:\\n    int val;\\n    int level;\\n    SkipNode** next;\\n    SkipNode(int v,int l){\\n        val=v;\\n        level=l;\\n        next=new SkipNode*[l+1]();\\n    }\\n};\\n\\nclass Skiplist {\\nprivate:\\n\\npublic:\\n    SkipNode* head;\\n    int Listlevel;\\n    Skiplist() {\\n        head=new SkipNode(INT_MIN,MAX_LEVEL);\\n        Listlevel=0;\\n    }\\n    int getlevel(){\\n        int lev=0;\\n        while(lev<MAX_LEVEL && lev<=Listlevel && rand()<RAND_MAX/2){\\n            ++lev;                      //等级为lev的节点出现的概率为1/2^lev\\n        }\\n        if(Listlevel<lev)++Listlevel;   //如果新节点等级高于跳表等级，则跳表等级加一\\n        return lev;\\n    }\\n    bool search(int target) {\\n        SkipNode* sn=head;\\n        int ll=Listlevel;\\n        while(ll>=0){\\n            while(sn->next[ll]!=nullptr && sn->next[ll]->val<=target)sn=sn->next[ll];\\n            --ll;\\n        }\\n        if(sn->val==target)return true;\\n        return false;\\n    }\\n    \\n    void add(int num) {\\n        //if(search(num))return; //一开始我没注意可以增删重复数字，所以加了这一行\\n        SkipNode* sn=head;\\n        int lev=getlevel();\\n        int ll=Listlevel;\\n        SkipNode* nsn=new SkipNode(num,lev);\\n        while(ll>=0){\\n            while(sn->next[ll]!=nullptr && sn->next[ll]->val<num)sn=sn->next[ll];\\n            if(ll<=lev){\\n                nsn->next[ll]=sn->next[ll];\\n                sn->next[ll]=nsn;\\n            }\\n            --ll;\\n        }\\n    }\\n    \\n    bool erase(int num) {\\n        if(!search(num))return false;\\n        SkipNode* sn=head;\\n        SkipNode* dsn;\\n        int ll=Listlevel;\\n        while(ll>=0){\\n            while(sn->next[ll]!=nullptr && sn->next[ll]->val<num)sn=sn->next[ll];\\n            if(ll==0)dsn=sn->next[ll];\\n            if(sn->next[ll]!=nullptr && sn->next[ll]->val==num){\\n                sn->next[ll]=sn->next[ll]->next[ll];\\n            }\\n            --ll;\\n        }\\n        if(dsn->level==Listlevel){              //如果删除的节点等级为最高等级节点，\\n                                                //则检查是否为唯一最高等级节点,\\n                                                //如果是，那么跳表等级减一。\\n            if(head->next[Listlevel]==nullptr)--Listlevel;\\n        }\\n        return true;\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Skiplist {\\n  class SkipListNode {\\n      int val;\\n      int cnt;  // 当前val出现的次数\\n      SkipListNode[] levels;  // start from 0\\n      SkipListNode() {\\n          levels = new SkipListNode[MAX_LEVEL];\\n      }\\n  }\\n\\n  private double p = 0.5;\\n  private int MAX_LEVEL = 16;\\n  private SkipListNode head;  // 头结点\\n  private int level;  // \\n  private Random random;\\n\\n  public Skiplist() {\\n\\n      level = 0;  \\n      head = new SkipListNode();\\n      random = new Random();\\n  }\\n\\n  public boolean search(int target) {\\n      SkipListNode curNode = head;\\n      for (int i = level-1; i >= 0; i--) {\\n          while (curNode.levels[i] != null && curNode.levels[i].val < target) {\\n              curNode = curNode.levels[i];\\n          }\\n      }\\n      curNode = curNode.levels[0];\\n      return (curNode != null && curNode.val == target);\\n  }\\n\\n  public void add(int num) {\\n      SkipListNode curNode = head;\\n      // 记录每层能访问的最右节点\\n      SkipListNode[] levelTails = new SkipListNode[MAX_LEVEL];\\n      for (int i = level-1; i >= 0; i--) {\\n          while (curNode.levels[i] != null && curNode.levels[i].val < num) {\\n              curNode = curNode.levels[i];\\n          }\\n          levelTails[i] = curNode;\\n      }\\n      curNode = curNode.levels[0];\\n      if (curNode != null && curNode.val == num) {\\n          // 已存在，cnt 加1\\n          curNode.cnt++;\\n      } else {\\n          // 插入\\n          int newLevel = randomLevel();\\n          if (newLevel > level) {\\n              for (int i = level; i < newLevel; i++) {\\n                  levelTails[i] = head;\\n              }\\n              level = newLevel;\\n          }\\n          SkipListNode newNode = new SkipListNode();\\n          newNode.val = num;\\n          newNode.cnt = 1;\\n          for (int i = 0; i < level; i++) {\\n              newNode.levels[i] = levelTails[i].levels[i];\\n              levelTails[i].levels[i] = newNode;\\n              \\n          }\\n      }\\n  }\\n\\n  private int randomLevel() {\\n      int level = 1;  \\n      while (random.nextDouble() < p && level < MAX_LEVEL) {\\n          level++;\\n      }\\n      return level > MAX_LEVEL ? MAX_LEVEL : level;\\n  }\\n  public boolean erase(int num) {\\n      SkipListNode curNode = head;\\n      // 记录每层能访问的最右节点\\n      SkipListNode[] levelTails = new SkipListNode[MAX_LEVEL];\\n\\n      for (int i = level-1; i >= 0; i--) {\\n          while (curNode.levels[i] != null && curNode.levels[i].val < num) {\\n              curNode = curNode.levels[i];\\n          }\\n          levelTails[i] = curNode;\\n      }\\n      curNode = curNode.levels[0];\\n      if (curNode != null && curNode.val == num) {\\n          if (curNode.cnt > 1) {\\n              curNode.cnt--;\\n              return true;\\n          }\\n          for (int i = 0; i < level; i++) {\\n              if (levelTails[i].levels[i] != curNode) {\\n                  break;\\n              }\\n              levelTails[i].levels[i] = curNode.levels[i];\\n          }\\n          while (level > 0 && head.levels[level-1] == null) {\\n              level--;\\n          }\\n          return true;\\n      } \\n      return false;\\n  }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import Optional\\nimport random\\n\\n\\nclass ListNode:\\n    def __init__(self, data: Optional[int] = None):\\n        self._data = data\\n        self._forwards = []\\n\\n\\nclass Skiplist:\\n\\n    _MAX_LEVEL = 16\\n\\n    def __init__(self):\\n        self._level_count = 1\\n        self._head = ListNode()\\n        self._head._forwards = [None] * self._MAX_LEVEL\\n\\n    def search(self, target: int) -> bool:\\n        p = self._head\\n        for i in range(self._level_count - 1, -1, -1):\\n            while p._forwards[i] and p._forwards[i]._data < target:\\n                p = p._forwards[i]\\n\\n        if p._forwards[0] and p._forwards[0]._data == target:\\n            return True\\n\\n        return False\\n\\n    def add(self, num: int) -> None:\\n        level = self._random_level()\\n        if self._level_count < level:\\n            self._level_count = level\\n        new_node = ListNode(num)\\n        new_node._forwards = [None] * level\\n        update = [self._head] * self._level_count\\n\\n        p = self._head\\n        for i in range(self._level_count - 1, -1, -1):\\n            while p._forwards[i] and p._forwards[i]._data < num:\\n                p = p._forwards[i]\\n\\n            update[i] = p\\n\\n        for i in range(level):\\n            new_node._forwards[i] = update[i]._forwards[i]\\n            update[i]._forwards[i] = new_node\\n\\n    def erase(self, num: int) -> bool:\\n        update = [None] * self._level_count\\n        p = self._head\\n        for i in range(self._level_count - 1, -1, -1):\\n            while p._forwards[i] and p._forwards[i]._data < num:\\n                p = p._forwards[i]\\n            update[i] = p\\n\\n        if p._forwards[0] and p._forwards[0]._data == num:\\n            for i in range(self._level_count - 1, -1, -1):\\n                if update[i]._forwards[i] and update[i]._forwards[i]._data == num:\\n                    update[i]._forwards[i] = update[i]._forwards[i]._forwards[i]\\n            return True\\n\\n        while self._level_count > 1 and not self._head._forwards[self._level_count]:\\n            self._level_count -= 1\\n\\n        return False\\n\\n    def _random_level(self, p: float = 0.5) -> int:\\n        level = 1\\n        while random.random() < p and level < self._MAX_LEVEL:\\n            level += 1\\n        return level\\n\\n\\n# Your Skiplist object will be instantiated and called as such:\\n# obj = Skiplist()\\n# param_1 = obj.search(target)\\n# obj.add(num)\\n# param_3 = obj.erase(num)\\n\\n\"}]}]},{\"id\":\"09\",\"name\":\"第九章\",\"list\":[{\"title\":\"代码9.1.1.2.two\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        for (int left = 0, right = numbers.size() - 1; left < right; ){\\n            if (numbers[left] + numbers[right] == target)\\n                return vector<int>{left + 1, right + 1};\\n            else if (numbers[left] + numbers[right] < target)\\n                left++;\\n            else\\n                right--;\\n        }\\n        return vector<int>{};\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int[] twoSum(int[] nums, int target) {\\n        int left = 0, right = nums.length - 1;\\n        while (left < right) {\\n            if (nums[left] + nums[right] == target)\\n                return new int[]{left + 1, right + 1};\\n            else if (nums[left] + nums[right] < target)\\n                left++;\\n            else\\n                right--;\\n        }\\n        return null;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def twoSum(self, number:List[int], target:int)->List[int]:\\n        left, right = 0, len(numbers) - 1\\n        while left < right:\\n            if (numbers[left] + numbers[right] == target):\\n                return [left + 1, right + 1]\\n            elif (numbers[left] + numbers[right] < target):\\n                left += 1\\n            elif:\\n                right -= 1\\n\\n        return []\\n\\n\"}]},{\"title\":\"代码9.1.1.two\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ret;\\n        for (int i = 0; i <= numbers.size() - 1 - 1; i++) {\\n            for (int j = i + 1; j <= numbers.size() - 1; j++) {\\n                if (numbers[i] + numbers[j] == target) {\\n                    ret.push_back(i + 1);\\n                    ret.push_back(j + 1);\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int[] twoSum(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[j] == target - nums[i])\\n                    return new int[]{i+1, j+1};\\n            }\\n        }\\n        return null;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def twoSum(self, numbers:List[int], target:int)->List[int]:\\n        for i in range(0, len(numbers), 1):\\n            for j in range(i + 1, len(numbers), 1):\\n                if numbers[i] + numbers[j] == target:\\n                    return [i + 1, j + 1]\\n\\n        return []\\n\"}]},{\"title\":\"代码9.1.2.1.container\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int res = 0;\\n        int area = 0;\\n        for (int i = 0; i < height.size() - 1; i++)\\n            for (int j = i + 1; j < height.size(); j++) {\\n                area = (j - i) * min(height[i], height[j]);\\n                if (area > res)\\n                    res = area;\\n            }\\n        \\n        return res;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int maxArea(int[] height) {  \\n        int res = 0, area = 0;\\n        for (int i = 0; i < height.length; i++) {\\n            for (int j = i + 1; j < height.length; j++) {\\n                area = Math.min(height[i], height[j]) * (j - i);\\n                res = Math.max(res, area);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution :\\n    def maxArea(self, height:List[int])->int:\\n        res, area = 0, 0\\n        for i in range(0, len(height), 1):\\n            fo j in range(i + 1, len(height), 1):\\n                area = (j - i) * min(height[i], height[j])\\n                if area > res:\\n                    res = area\\n\\n        return res\\n    \\n\\n\"}]},{\"title\":\"代码9.1.2.2.container\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        int res = 0;\\n        int area = 0;\\n        int left = 0, right = height.size() - 1;\\n        \\n        while(left < right) {\\n            area = (right - left) * min(height[right], height[left]);\\n            res  = max(res, area);\\n            if (height[left] < height[right])\\n                left++;\\n            else\\n                right--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int maxArea(int[] height) {\\n        int left = 0, right = height.length - 1, res = 0, area = 0;\\n\\n        while (left < right) {\\n            area = Math.min(height[left], height[right]) * (right - left);\\n            res = Math.max(res, area);\\n            if (height[left] < height[right])\\n                left++;\\n            else\\n                right++;\\n        }\\n        return res;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def maxArea(self, height:List[int])->int:\\n        #init the param\\n        left, right, width, res = 0, len(height) - 1, len(height - 1, 0)\\n\\n        for w in range(width, 0, -1):\\n            if height[left] < height[right]:\\n                res, left = max(res, height[left] * w), left + 1\\n            else:\\n                res, right = max(res, height[right] * w), right - 1\\n\\n        return res\\n\\n\"}]},{\"title\":\"代码9.2.1.1.linked\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        unordered_set<ListNode *> seenNode;\\n        while (head) {\\n            if (seenNode.find(head) != seenNode.end())\\n                return true;\\n            seenNode.insert(head);\\n            head = head->next;\\n        }\\n        return false;  \\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null || head.next == null)\\n            return false;\\n        Set<ListNode> set = new HashSet<>();\\n        ListNode node = head;\\n        while (node.next != null) {\\n            node = node.next;\\n            if (set.contains(node))\\n                return true;\\n            else\\n                set.add(node);\\n        }\\n        return false;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def hasCycle(self, head:ListNode)->bool:\\n        if head is None:\\n            return False\\n\\n        node_set = {}\\n        while head.next:\\n            node_set[head] = True\\n\\n            if head.next in node_set:\\n                return True\\n\\n            head = head.next\\n\\n        return False\\n\\n\"}]},{\"title\":\"代码9.2.1.2.linked\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head == NULL || head->next == NULL)\\n            return false;\\n        \\n        ListNode *p1List = head;\\n        ListNode *p2List = head;\\n        \\n        while(p2List != NULL && p2List->next != NULL){\\n            p1List = p1List->next;\\n            p2List = p2List->next->next;\\n            \\n            if (p1List == p2List)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean hasCycle(ListNode head) {\\n        if (head == null || head.next == null)\\n            return false;\\n\\n        ListNode fast = head, slow = head;\\n        while (fast.next != null) {\\n            fast = fast.next;\\n            if (fast == slow)\\n                return true;\\n            else {\\n                if (fast.next == null)\\n                    return false;\\n                fast = fast.next;\\n                slow = slow.next;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def hasCycle(self, head:ListNode)->bool:\\n        if head == None or head.next == None:\\n            return False\\n\\n        pslow = pfast = head\\n        while pfast != None and pfast.next != None:\\n            pslow = pslow.next\\n            pfast = pfast.next.next\\n            if pfast == pslow:\\n                break\\n\\n        if pfast == None or pfast.next == None:\\n            return False\\n        elif pfast == pslow:\\n            return True\\n\\n        return False\\n\\n\"}]},{\"title\":\"代码9.2.2.1.long\",\"codes\":[{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int lengthOfLongestSubstring(String s) {\\n        int res = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = i; j < s.length(); j++) {\\n                String tmp = s.substring(i, j + 1);\\n                if (allUnique(tmp))\\n                    res = Math.max(res, 1 + j - i);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean allUnique(String s) {\\n        Set<Character> set = new HashSet<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (set.contains(s.charAt(i)))\\n                return false;\\n            else\\n                set.add(s.charAt(i));\\n        }\\n        return true;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def allUnique(self, s:str)->bool:\\n        dic = {}\\n        for i in range(0, len(s), 1):\\n            if s[i] in dic:\\n                return False\\n            else:\\n                dic[s[i]] = 1\\n\\n        return True\\n\\n    def lengthOfLongestSubstring(self, s:str)->int:\\n        res = 0\\n\\n        for i in range(0, len(s), 1):\\n            for j in range(0, len(s), 1):\\n                if self.allUnique(s[i : j + 1]):\\n                    res = max(res, j - i + 1)\\n                else:\\n                    break\\n\\n        return res\\n\\n\"}]},{\"title\":\"代码9.2.2.2.long\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int lengthOfLongestSubstring(string s) {\\n            int res = 0, left = 0, right = 0;\\n            unordered_set<char> setting;\\n\\n            for (left = 0; left < s.size(); left++) {\\n                right = left;\\n                while (right < s.size()) {\\n                    if (setting.find(s[right]) != setting.end()) { //has the char\\n                        break;\\n                    } else { // donnot has the char\\n                        setting.insert(s[right]);\\n                        res = max(res, right - left + 1);\\n                        right++;\\n                    }\\n                }\\n                setting.clear();\\n            }\\n\\n            return res;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int lengthOfLongestSubstring(String s) {\\n        int res = 0;\\n        for (int left = 0; left < s.length(); left++) {\\n            Set<Character> set = new HashSet<>();\\n            int right = left;\\n            while (right < s.length()) {\\n                if (set.contains(s.charAt(right)))\\n                    break;\\n                else {\\n                    set.add(s.charAt(right));\\n                    res = Math.max(res, right - left + 1);\\n                    right++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def lengthofLongestSubstring(self, s:str)->int:\\n        res, left, right = 0, 0, 0\\n        settings = set()\\n\\n        for left in range(0, len(s), 1):\\n            right = left\\n            while (right < len(s)):\\n                if (s[right] in settings):\\n                    break\\n                else:\\n                    settings.add(s[right])\\n                    res = max(res, right - left + 1)\\n                    right = right + 1\\n\\n            settings.clear()\\n\\n        return res\\n\\n\"}]},{\"title\":\"代码9.2.2.3.long\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int lengthOfLongestSubstring(string s) {\\n            int res = 0, left = 0, right = 0;\\n            unordered_set<char> setting;\\n\\n            while (right < s.size()) {\\n                if (setting.find(s[right]) != setting.end()) {\\n                    while(left < right) {\\n                        if (s[left] == s[right]) {\\n                            setting.erase(s[left]);\\n                            left++;\\n                            break;\\n                        } else {\\n                            setting.erase(s[left]);\\n                            left++;\\n                        }\\n                    }\\n                }\\n                setting.insert(s[right]);\\n                res = max(res, right - left + 1);\\n                right++;\\n            }\\n            return res;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int lengthOfLongestSubstring(String s) {\\n        int res = 0, left = 0, right = 0;\\n        Set<Character> set = new HashSet<>();\\n        while (right < s.length()) {\\n            if (set.contains(s.charAt(right)))\\n                while (left < right) {\\n                    if (s.charAt(left) == s.charAt(right)) {\\n                        set.remove(s.charAt(left));\\n                        left++;\\n                        break;\\n                    }\\n                    set.remove(s.charAt(left));\\n                    left++;\\n                }\\n\\n            set.add(s.charAt(right));\\n            res = Math.max(res, right - left + 1);\\n            right++;\\n        }\\n\\n        return res;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def lengthOflongestSubstring(self, s:str)->int:\\n        res, left, right = 0, 0, 0\\n        settings = set()\\n\\n        while right < len(s):\\n            if s[right] in settings:\\n                while left < right:\\n                    if s[left] == s[right]:\\n                        settings.discar(s[left])\\n                        left = left + 1\\n                        break\\n                    else:\\n                        settings.discard(s[left])\\n                        left = left + 1\\n\\n            settings.add(s[right])\\n            res = max(res, right - left + 1)\\n            right = right + 1\\n\\n        return res\\n\\n\"}]},{\"title\":\"代码9.2.2.4.long\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int lengthOfLongestSubstring(string s) {\\n            int res = 0, left = 0, right = 0;\\n            int charset[256] = {-1};\\n\\n            while (right < s.size() && left + res < s.size()) {\\n                left = max(left, charset[s[right]]);\\n                res  = max(res, right - left + 1);\\n                charset[s[right]] = right + 1;\\n                right++;\\n            }\\n\\n            return res;\\n        }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int lengthOfLongestSubstring(String s) {\\n        int res = 0, left = 0, right = 0;\\n        Map<Character, Integer> map = new HashMap<>();\\n        while (right < s.length() && left < s.length() - res) {\\n            if (map.containsKey(s.charAt(right)))\\n                left = Math.max(left, map.get(s.charAt(right)) + 1);\\n\\n            map.put(s.charAt(right), right);\\n            res = Math.max(res, right - left + 1);\\n            right++;\\n        }\\n\\n        return res;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def lengthOfLongestSubstring(self, s:str)->int:\\n        res, left, right = 0, 0, 0\\n        dic = {}\\n\\n        while right < len(s) and left + res < len(s):\\n            if s[right] in dic:\\n                left = max(left, dic[s[right]] + 1)\\n\\n            dic[s[right]] = right\\n            res = max(res, right - left + 1)\\n            right = right + 1\\n\\n        return res\\n\\n\"}]}]},{\"id\":\"10\",\"name\":\"第十章\",\"list\":[{\"title\":\"代码10.1.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\n    public:\\n        int climbStairs(int n) {\\n            if (n == 1) return 1;\\n\\n            int dp[n + 1];\\n            dp[1] = 1;\\n            dp[2] = 2;\\n\\n            for (int i = 3; i <= n; i++)\\n                dp[i] = dp[i - 1] + dp[i - 2];\\n\\n            return dp[n];\\n        }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"package ch10.code;\\n\\npublic class ClimbingStairs {\\n    public int climbStairs(int n) {\\n        if (n < 3)\\n            return n;\\n\\n        int first = 1,second = 2;\\n\\n        for (int i = 3; i < n + 1; i++) {\\n            second = first + second;\\n            first = second - first;\\n        }\\n        return second;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n < 2:\\n            return n\\n        dp = [0] * (n + 1)\\n        dp[1], dp[2] = 1, 2\\n        for i in range(3, n + 1):\\n            dp[i] = dp[i - 1] + dp[i - 2]\\n        return dp[n]\\n\\n\"}]},{\"title\":\"代码10.1.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\n    public:\\n        int climbStairs(int n) {\\n            if (n < 2) return n;\\n            \\n            int first  = 1;\\n            int second = 2;\\n\\n            for (int i = 3; i < n + 1; i++) {\\n                second = first + second;\\n                first  = second - first;\\n            }\\n\\n            return second;\\n        }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"package ch10.code;\\n\\npublic class ClimbingStairs {\\n    public int climbStairs(int n) {\\n        if (n < 3)\\n            return n;\\n\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for (int i = 3; i < n+1; i++) {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n        return dp[n];\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n < 2:\\n            return n\\n        first, second = 1, 2\\n        for i in range(3, n + 1):\\n            # third = first + second\\n            # first = second\\n            # second = third\\n            second = first + second\\n            first = second - first\\n        return second\\n\\n\"}]},{\"title\":\"代码10.2.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include<iostream>\\n#include<vector>\\n#include<algorithm>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int start) {\\n        if(start >= nums.size()) return 0;\\n\\n        return max(helper(nums, start+1), nums[start] + helper(nums, start+2));\\n    }\\n    int rob(vector<int>& nums) {\\n        return helper(nums, 0);\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int helper(int[] nums, int start) {\\n        if(start >= nums.length) return 0;\\n\\n        return Math.max(helper(nums, start+1), nums[start] + helper(nums, start+2));\\n    }\\n    public int rob(int[] nums) {\\n        return helper(nums, 0);\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 0:\\n            return 0\\n        return max(self.rob(nums[1:]), nums[0] + self.rob(nums[2:]))\\n\\n\"}]},{\"title\":\"代码10.2.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include<iostream>\\n#include<vector>\\n#include<algorithm>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, vector<int>&memo, int start) {\\n        if(start >= nums.size()) return 0;\\n        if(memo[start] != -1) return memo[start];\\n\\n        memo[start] = max(helper(nums, memo, start+1), nums[start] + helper(nums, memo, start+2));\\n\\n        return memo[start];\\n    }\\n    int rob(vector<int>& nums) {\\n        vector<int> memo(nums.size(), -1);\\n        return helper(nums, memo, 0);\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int helper(int[] nums, int[] memo, int start) {\\n        if(start >= nums.length) return 0;\\n        if(memo[start] != -1) return memo[start];\\n\\n        memo[start] = Math.max(helper(nums, memo, start+1), nums[start] + helper(nums,memo,  start+2));\\n\\n        return memo[start];\\n    }\\n    public int rob(int[] nums) {\\n        int[] memo = new int[nums.length];\\n\\n        for (int i = 0; i < nums.length; i++) memo[i] = -1;\\n        return helper(nums, memo, 0);\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        memo = [-1 for x in range(len(nums) + 1)]\\n        memo[-1] = 0\\n\\n        return self.helper(0, nums, memo)\\n\\n    def helper(self, n: int, nums: List[int], memo: List[int]) -> int:\\n        if n >= len(nums):\\n            return 0\\n        if memo[n] != -1:\\n            return memo[n]\\n\\n        memo[n] = max(\\n            self.helper(n + 1, nums, memo), self.helper(n + 2, nums, memo) + nums[n],\\n        )\\n        return memo[n]\\n\\n\"}]},{\"title\":\"代码10.2.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include<iostream>\\n#include<vector>\\n#include<algorithm>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size() <= 0) return 0;\\n\\n        vector<int> memo(nums.size()+1);\\n\\n        memo[nums.size()-1] = nums[nums.size()-1];\\n\\n        for(int i = nums.size()-2; i >= 0; i--) {\\n            memo[i] = max(memo[i+1], memo[i+2] + nums[i]);\\n        }\\n        return memo[0];\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n\\n    public int rob(int[] nums) {\\n        if(nums.length <= 0) return 0;\\n\\n        int[] memo = new int[nums.length+1];\\n        memo[nums.length-1] = nums[nums.length-1];\\n\\n        for (int i = nums.length-2; i >= 0; i--) {\\n            memo[i] = Math.max(memo[i+1], memo[i+2]+nums[i]);\\n        }\\n        return memo[0];\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        memo = [0 for x in range(len(nums) + 1)]\\n        memo[-2] = nums[-1]\\n\\n        for i in range(len(nums) - 2, -1, -1):\\n            memo[i] = max(memo[i + 1], memo[i + 2] + nums[i])\\n\\n        return memo[0]\\n\\n\"}]},{\"title\":\"代码10.2.4\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include<iostream>\\n#include<vector>\\n#include<algorithm>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size() <= 0) return 0;\\n\\n        int prev, curr;\\n\\n        for(int i = nums.size()-1; i >= 0; i--) {\\n            int tmp = curr;\\n            curr = max(curr, nums[i] + prev);\\n            prev = tmp;\\n        }\\n        return curr;\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n\\n    public int rob(int[] nums) {\\n        if(nums.length <= 0) return 0;\\n\\n        int prev = 0, curr = 0;\\n\\n        for (int i = nums.length-1; i >= 0; i--) {\\n            int tmp = curr;\\n            curr = Math.max(curr, nums[i] + prev);\\n            prev = tmp;\\n        }\\n        return curr;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n\\n        prev = 0\\n        curr = 0\\n\\n        for i in range(len(nums) - 1, -1, -1):\\n            temp = curr\\n            curr = max(curr, nums[i] + prev)\\n            prev = temp\\n\\n        return curr\\n\\n\"}]},{\"title\":\"代码10.2.5\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include<iostream>\\n#include<vector>\\n#include<algorithm>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n\\n        int prev = 0, curr = 0;\\n\\n        for(int i = 0; i < nums.size()-1; i++) {\\n            int tmp = curr;\\n            curr = max(curr, nums[i] + prev);\\n            prev = tmp;\\n        } \\n        int res = curr;\\n\\n        prev = 0;\\n        curr = 0;\\n\\n        for(int i = 1; i < nums.size(); i++) {\\n            int tmp = curr;\\n            curr = max(curr, nums[i] + prev);\\n            prev = tmp;\\n        }\\n\\n        return max(res, curr);\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 1) return nums[0];\\n\\n        int prev = 0, curr = 0;\\n\\n        for(int i = 0; i < nums.length - 1; i++) {\\n            int tmp = curr;\\n            curr = Math.max(curr, nums[i] + prev);\\n            prev = tmp;\\n        }\\n\\n        int res = curr;\\n\\n        prev = 0;\\n        curr = 0;\\n\\n        for(int i = 1; i < nums.length; i++) {\\n            int tmp = curr;\\n            curr = Math.max(curr, nums[i] + prev);\\n            prev = tmp;\\n        }\\n\\n        return Math.max(res, curr);\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        prev = 0\\n        curr = 0\\n\\n        for i in range(len(nums) - 1):\\n            temp = curr\\n            curr = max(curr, nums[i] + prev)\\n            prev = temp\\n\\n        res = curr\\n\\n        prev = 0\\n        curr = 0\\n\\n        for i in range(1, len(nums)):\\n            temp = curr\\n            curr = max(curr, nums[i] + prev)\\n            prev = temp\\n\\n        return max(res, curr)\\n\\n\"}]},{\"title\":\"代码10.3.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <cstdlib>\\n\\nclass Solution {\\npublic:\\n  int uniquePaths(int m, int n) {\\n    int **d = (int **)malloc(m * sizeof(int *));\\n    for (int i = 0; i < m; i++) {\\n      d[i] = (int *)malloc(n * sizeof(int));\\n      for (int j = 0; j < n; j++) d[i][j] = 1;\\n    }\\n    for (int col = 1; col < m; col++)\\n      for (int row = 1; row < n; row++)\\n        d[col][row] = d[col - 1][row] + d[col][row - 1];\\n    int ans = d[m - 1][n - 1];\\n    for (int i = 0; i < m; i++) free(d[i]);\\n    free(d);\\n    return ans;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Solution {\\n  public int uniquePaths(int m, int n) {\\n    int[][] d = new int[m][n];\\n    for (int i = 0; i < m; i++)\\n      for (int j = 0; j < n; j++) d[i][j] = 1;\\n    for (int col = 1; col < m; col++)\\n      for (int row = 1; row < n; row++)\\n        d[col][row] = d[col - 1][row] + d[col][row - 1];\\n    return d[m - 1][n - 1];\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        d = [[1] * n for _ in range(m)]\\n\\n        for col in range(1, m):\\n            for row in range(1, n):\\n                d[col][row] = d[col - 1][row] + d[col][row - 1]\\n\\n        return d[m - 1][n - 1]\\n\\n\"}]},{\"title\":\"代码10.3.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <cstdlib>\\n\\nclass Solution {\\npublic:\\n  int uniquePaths(int m, int n) {\\n    int *dp = (int *)malloc(n * sizeof(int));\\n    for (int i = 0; i < n; i++) dp[i] = 1;\\n    for (int i = 1; i < m; i++)\\n      for (int j = 1; j < n; j++)\\n        dp[j] += dp[j - 1];\\n    int ans = dp[n - 1];\\n    free(dp);\\n    return ans;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Solution {\\n  public int uniquePaths(int m, int n) {\\n    int[] dp = new int[n];\\n    for (int i = 0; i < n; i++) dp[i] = 1;\\n    for (int i = 1; i < m; i++)\\n      for (int j = 1; j < n; j++)\\n        dp[j] += dp[j - 1];\\n    return dp[n - 1];\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [1] * n\\n        for _ in range(1, m):\\n            for j in range(1, n):\\n                dp[j] += dp[j - 1]\\n        return dp[n - 1]\\n\\n\"}]},{\"title\":\"代码10.3.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <utility>\\n#include <map>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  map<pair<int, int>, int> visited;\\n  int uniquePaths(int m, int n) {\\n    if (visited.count(make_pair(m, n)))\\n      return visited[make_pair(m, n)];\\n    if (m == 1 || n == 1) return 1;\\n    int cnt = uniquePaths(m - 1, n) + \\\\\\n              uniquePaths(m, n - 1);\\n    return visited[make_pair(m, n)] = cnt;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\n\\npublic class Solution {\\n  public class Pair {\\n    public final int first;\\n    public final int second;\\n    public Pair(int x, int y) {\\n      this.first = x;\\n      this.second = y;\\n    }\\n  }\\n  public Pair make_pair(int x, int y) {\\n    Pair buf = new Pair(x, y);\\n    return buf;\\n  }\\n  public Map<Pair, Integer> visited;\\n  public Solution() {\\n    this.visited = new HashMap<Pair, Integer>();\\n  }\\n  int uniquePaths(int m, int n) {\\n    if (visited.get(make_pair(m, n)) != null)\\n      return visited.get(make_pair(m, n));\\n    if (m == 1 || n == 1) return 1;\\n    int cnt = uniquePaths(m - 1, n) +\\n      uniquePaths(m, n - 1);\\n    visited.put(make_pair(m, n), cnt);\\n    return cnt;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    visited = dict()\\n\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        if (m, n) in self.visited:\\n            return self.visited[(m, n)]\\n        if m == 1 or n == 1:\\n            return 1\\n        cnt = self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1)\\n        self.visited[(m, n)] = cnt\\n        return cnt\\n\\n\"}]},{\"title\":\"代码10.4.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int coinChange(vector<int>& coins, int amount) {\\n        int Max = amount + 1;\\n        vector<int> dp(amount + 1, Max);\\n        dp[0] = 0;\\n        \\n        for (int i = 1; i <= amount; i++) {\\n            for (int j = 0; j < coins.size(); j++) {\\n                if (coins[j] <= i) {\\n                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);\\n                }\\n            }\\n        }\\n        \\n        return dp[amount] > amount ? -1 : dp[amount];\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.Arrays;\\npublic class CoinChange {\\n    public int coinChange(int[] coins, int amount) {\\n        if (amount == 0)\\n            return 0;\\n\\n        int[] dp = new int[amount + 1];\\n        Arrays.fill(dp, amount + 1);\\n        dp[0] = 0;\\n\\n        for (int i = 1; i < amount + 1; i++) {\\n            for (int coin : coins) {\\n                if (coin <= i) {\\n                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);\\n                }\\n            }\\n        }\\n        return dp[amount] == amount + 1 ? -1 : dp[amount];\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def coinChange(self, coins: List[int], amount: int) -> int:\\n        if amount == 0:\\n            return 0\\n        # use amount + 1 to indicate bigger than any\\n        dp = [amount + 1] * (amount + 1)\\n        dp[0] = 0\\n        for i in range(1, amount + 1):\\n            for coin in coins:\\n                if coin <= i:\\n                    dp[i] = min(dp[i], dp[i - coin] + 1)\\n        return -1 if dp[amount] == (amount + 1) else dp[amount]\\n\\n\"}]},{\"title\":\"代码10.4.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int change(int amount, vector<int>& coins) {\\n        vector<int> dp(amount + 1, 0);\\n        dp[0]  = 1;\\n        \\n        for (int coin: coins) {\\n            for (int i = coin; i < amount + 1; i++)\\n                dp[i] += dp[i - coin];\\n        }\\n        \\n        return dp[amount];\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.Arrays;\\n\\npublic class CoinChange2 {\\n    public int change(int amount, int[] coins) {\\n        int[] dp = new int[amount + 1];\\n        dp[0] = 1;\\n        for (int coin : coins) {\\n            if (coin > amount)\\n                continue;\\n            for (int i = coin; i < amount + 1; i++) {\\n                dp[i] += dp[i - coin];\\n            }\\n        }\\n        return dp[amount];\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def change(self, amount: int, coins: List[int]) -> int:\\n        dp = [0] * (amount + 1)\\n        dp[0] = 1\\n        for coin in coins:\\n            for x in range(coin, amount + 1):\\n                dp[x] += dp[x - coin]\\n        return dp[amount]\\n\\n\"}]}]},{\"id\":\"11\",\"name\":\"第十一章\",\"list\":[{\"title\":\"代码11.1.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> res = {};\\n        \\n        int length = nums.size();\\n        if (length * k == 0)\\n            return res;\\n        \\n        for (int i = 0; i < length - k + 1; i++) {\\n            int max_val = INT_MIN;\\n            \\n            for (int j = i; j < i + k; j++) {\\n                max_val = max(max_val, nums[j]);\\n            }\\n            \\n            res.push_back(max_val);\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        if (k == 1)\\n            return nums;\\n        int turn = nums.length - k + 1;\\n        int[] res = new int[turn];\\n        for (int i = 0; i < turn; i++) {\\n            res[i] = getMax(nums, i, k);\\n        }\\n        return res;\\n    }\\n\\n    private int getMax(int[] nums, int left, int k) {\\n        int max = nums[left];\\n        for (int i = 0; i < k-1; i++) {\\n            left++;\\n            max = Math.max(max, nums[left]);\\n        }\\n        return max;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def maxSlidingWindow(self, nums:List[int], k:int)->List[int]:\\n        length = len(nums)\\n        if length * k == 0:\\n            return []\\n            \\n        output = []\\n        # 遍历所有可能的窗口\\n        for i in range(length - k + 1):\\n            max_val = -sys.maxsize - 1\\n            # 找到一个窗口中的最大值\\n            for j in range(i, i + k):\\n                max_val = max(max_val, nums[j])\\n                \\n            # 将最大值放到数组列表里\\n            output.append(max_val)\\n            \\n        return output\\n\\n\"}]},{\"title\":\"代码11.1.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> res;\\n        multiset<int> mysetting;\\n        for (int i = 0; i < nums.size(); i++) {\\n            mysetting.insert(nums[i]);\\n            if (i >= k - 1) {\\n                res.push_back(*mysetting.rbegin());\\n                mysetting.erase(mysetting.find(nums[i - k + 1]));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        if (k == 1)\\n            return nums;\\n        int[] res = new int[nums.length - k + 1];\\n\\n        Deque<Integer> queue = new LinkedList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            // 从尾部开始移除比新加入元素小的元素\\n            while (!queue.isEmpty() && nums[queue.getLast()] < nums[i])\\n                queue.removeLast();\\n            // 将新加入元素添加到双端队列的尾部\\n            queue.addLast(i);\\n            // 如过窗口外的元素仍然在双端队列中，将其移除\\n            if (queue.getFirst() == i - k)\\n                queue.removeFirst();\\n            // 将头部元素即当前最大元素对应的数字放入结果数组\\n            if (i - k + 1 >= 0)\\n                res[i - k + 1] = nums[queue.getFirst()];\\n        }\\n\\n        return res;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        d = collections.deque()\\n        out = []\\n        \\n        for i, n in enumerate(nums):\\n            # 移除所有比当前元素小的元素\\n            while d and nums[d[-1]] < n:\\n                d.pop()\\n            d += i,\\n            if d[0] == i - k:\\n                d.popleft()\\n            if i >= k - 1:\\n                out.append(nums[d[0]])\\n\\n        return out\\n\\n\"}]},{\"title\":\"代码11.2.1\",\"codes\":[{\"language\":\"Java\",\"content\":\"class Solution {\\n    public String minWindow(String s, String t) {\\n        if (s.length() == 0 || t.length() == 0)\\n            return \\\"\\\";\\n        int left = 0, right = 0;\\n        Map<Character, Integer> tMap = new HashMap<>();\\n        for (char c : t.toCharArray()) {\\n            tMap.put(c, tMap.getOrDefault(c, 0) + 1);\\n        }\\n\\n        int required = tMap.keySet().size(), formed = 0;\\n        Map<Character, Integer> windowMap = new HashMap<>();\\n\\n        // ans[0] 存放字符长度，ans[1]和ans[2]分别存放左右索引\\n        int[] ans = new int[3];\\n        ans[0] = Integer.MAX_VALUE;\\n\\n        while (right < s.length()) {\\n            char character = s.charAt(right);\\n            windowMap.put(character, windowMap.getOrDefault(character, 0) + 1);\\n\\n            if (tMap.containsKey(character) && windowMap.get(character).intValue() == tMap.get(character).intValue())\\n                formed++;\\n\\n            while (left <= right && (formed == required)) {\\n                character = s.charAt(left);\\n\\n                if (right - left + 1 < ans[0]) {\\n                    ans = new int[]{right - left + 1, left, right};\\n                }\\n                windowMap.put(character, windowMap.getOrDefault(character, 1) - 1);\\n\\n                if (tMap.containsKey(character) && windowMap.get(character) < tMap.get(character))\\n                    formed -= 1;\\n\\n                left++;\\n            }\\n            right++;\\n        }\\n\\n        return ans[0] == Integer.MAX_VALUE ? \\\"\\\" : s.substring(ans[1], ans[2] + 1);\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def minWindow(self, s:str, t:str)->str:\\n        if not t or not s:\\n            return \\\"\\\"\\n            \\n        dict_t = Counter(t)\\n        \\n        required = len(dict_t)\\n        \\n        #初始化滑动窗口\\n        left, right = 0, 0\\n        \\n        formed = 0\\n        \\n        window_counts = {}\\n        \\n        ans = float(\\\"inf\\\"), None, None\\n        \\n        while right < len(s):\\n            character = s[right]\\n            window_counts[character] = window_counts.get(character, 0) + 1\\n            \\n            if character in dict_t and window_counts[character] == dict_t[character]:\\n                formed += 1\\n                \\n            while left <= right and formed == required:\\n                character = s[left]\\n                \\n                if right - left + 1 < ans[0]:\\n                    ans = (right - left + 1, left, right)\\n                    \\n                window_counts[character] -= 1\\n                if character in dict_t and window_counts[character] < dict_t[character]:\\n                    formed -= 1\\n                    \\n                left += 1\\n            right += 1\\n                \\n        if ans[0] == float(\\\"inf\\\"):\\n            return \\\"\\\"\\n        else:\\n            return s[ans[1]: ans[2] + 1]\\n\\n\"}]},{\"title\":\"代码11.2.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\n    public:\\n        string minWindow(string s, string t) {\\n            if (s.size() == 0 || t.size() == 0 || t.size() > s.size())\\n                return \\\"\\\";\\n\\n            vector<int> remaining(128, 0);\\n            int required = t.size();\\n\\n            for (int i = 0; i < required; i++)\\n                remaining[t[i]]++;\\n\\n            int min = INT_MAX, start = 0, left = 0, i = 0;\\n            while (i <= s.size() && start < s.size()) {\\n                if (required) {\\n                    if (i == s.size())\\n                        break;\\n                    remaining[s[i]]--;\\n                    if (remaining[s[i]] >= 0)\\n                        required--;\\n                    i++;\\n                } else {\\n                    if (i - start < min) {\\n                        min = i - start;\\n                        left = start;\\n                    }\\n                    remaining[s[start]]++;\\n                    if (remaining[s[start]] > 0)\\n                        required++;\\n                    start++;\\n                }\\n            }\\n\\n            return min == INT_MAX ? \\\"\\\" : s.substr(left, min);\\n        }\\n};\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def minWindow(self, s, t):\\n        if not t or not s:\\n            return \\\"\\\"\\n            \\n        dict_t = Counter(t)\\n        \\n        required = len(dict_t)\\n        \\n        for i, char in enumerate(s):\\n            if char in dict_t:\\n                filtered_s.append((i, char))\\n                \\n        left, right = 0, 0\\n        formed = 0\\n        window_counts = {}\\n        \\n        ans = float(\\\"inf\\\"), None, None\\n        \\n        while right < len(filtered_s):\\n            character = filtered_s[r][1]\\n            window_counts[character] = window_counts.get(character, 0) + 1\\n\\n            if window_counts[character] == dict_t[character]:\\n                formed += 1\\n                \\n            while left <= right and formed == required:\\n                character = filtered_s[l][1]\\n                \\n                end   = filtered_s[right][0]\\n                start = filtered_s[left][0]\\n                if end - start + 1 < ans[0]:\\n                    ans = (end - start + 1, start, end)\\n                    \\n                window_counts[character] -= 1\\n                if window_counts[character] < dict_t[character]:\\n                    formed -= 1\\n                left += 1\\n                \\n            right += 1\\n            \\n        if ans[0] == float(\\\"inf\\\"):\\n            return \\\"\\\"\\n        else:\\n            return s[ans[1]:ans[2] + 1]\\n\\n\"}]},{\"title\":\"代码11.3.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\n    public:\\n        int characterReplacement(string s, int k) {\\n            int res = 0, left = 0, right = 0, size = s.size(), localMaxFreq = 0;\\n\\n            vector<int> count(26, 0);\\n            for (; right < size; right++) {\\n                count[s[right] - 'A'] += 1;\\n                localMaxFreq = max(localMaxFreq, count[s[right] - 'A']);\\n\\n                if ((right - left + 1) - localMaxFreq > k) {\\n                    res = max(res, (right - left));\\n                    count[s[left] - 'A'] -= 1;\\n                    left += 1;\\n                    localMaxFreq = *(max_element(count.begin(), count.end()));\\n                }\\n            }\\n\\n            return max(res, right - left);\\n        }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int characterReplacement(String s, int k) {\\n        int res = 0, left = 0, right = 0;\\n        int[] counts = new int[26];\\n\\n        while( right < s.length()) {\\n            counts[s.charAt(right) - 'A']++;\\n            int maxCharCount = getMostCharCount(counts);\\n            right++;\\n            if (right - left - maxCharCount > k) {\\n                counts[s.charAt(left) - 'A']--;\\n                left++;\\n            }\\n        }\\n        return right - left;\\n    }\\n\\n    private int getMostCharCount(int[] counts) {\\n        int ans = 0;\\n        for (int n : counts)\\n            ans = Math.max(ans, n);\\n        return ans;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        res = low = high = 0\\n        counts = collections.Counter()\\n        \\n        for high in range(1, len(s) + 1):\\n            counts[s[high - 1]] += 1\\n            max_char_n = counts.most_common(1)[0][1]\\n            \\n            if high - low - max_char_n > k:\\n                counts[s[low]] -= 1\\n                low += 1\\n        \\n        return high -low\\n\\n\"}]},{\"title\":\"代码11.3.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\n    public:\\n        int characterReplacement(string s, int k) {\\n            int res = 0;\\n            int maxf = 0;\\n            vector<int> count(26, 0);\\n            \\n            for (int i = 0; i < s.size(); i++) {\\n                count[s[i] - 'A'] += 1;\\n                maxf = max(maxf, count[s[i] - 'A']);\\n                \\n                if (res - maxf < k)\\n                    res += 1;\\n                else\\n                    count[s[i - res] - 'A'] -= 1;\\n            }\\n\\n            return res;\\n        }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public int characterReplacement(String s, int k) {\\n        int res = 0, tmpMax = 0;\\n        int[] counts = new int[26];\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            counts[s.charAt(i) - 'A']++;\\n            tmpMax = Math.max(tmpMax, counts[s.charAt(i) - 'A']);\\n\\n            if (res - tmpMax < k)\\n                res++;\\n            else\\n                counts[s.charAt(i - res) - 'A']--;\\n        }\\n        return res;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        max_char_n = res = 0\\n        count = collections.Counter()\\n        for i in range(len(s)):\\n            count[s[i]] += 1\\n            max_char_n = max(max_char_n, count[s[i]])\\n\\n            if res - max_char_n < k:\\n                res += 1\\n            else:\\n                count[s[i - res]] -= 1\\n\\n        return res\\n\\n\"}]},{\"title\":\"代码11.4.1\",\"codes\":[{\"language\":\"Py\",\"content\":\"class Solution:\\n    #生成可能的子字符串\\n    def perm(self, s:str)->str:\\n        if len(s) <= 1:\\n            return [s]\\n        \\n        s1 = []\\n        for i in range(len(s)):\\n            for j in self.perm(s[0:i] + s[i + 1:]):\\n                s1.append(s[i] + j)\\n                \\n        return s1\\n\\n    def checkInclusion(self, s1: str, s2: str) -> bool:\\n        if (len(s1) > len(s2)):\\n            return False\\n        \\n        s1_perm = list(set(self.perm(s1)))\\n        #检测字符串S1的排列是否是字符串S2的子串\\n        for i in s1_perm:\\n            idx = s2.find(i)\\n            if idx != -1:\\n                return True\\n            \\n        return False\\n\\n\"}]},{\"title\":\"代码11.4.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\n    public:\\n        bool checkInclusion(string s1, string s2) {\\n            vector<int> cnts(256, 0);\\n            for (char ch: s1)\\n                cnts[ch]++;\\n\\n            int left = s1.size();\\n            for (int i = 0, j = 0; j < s2.size(); j++) {\\n                if (cnts[s2[j]]-- > 0)\\n                    left--;\\n\\n                while (left == 0) {\\n                    if (j + 1 - i == s1.size())\\n                        return true;\\n                    if (++cnts[s2[i++]] > 0)\\n                        left++;\\n                }\\n            }\\n\\n            return false;\\n        }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public boolean checkInclusion(String s1, String s2) {\\n        if (s1.length() > s2.length())\\n            return false;\\n        int[] arrayS1 = new int[26], arrayS2 = new int[26];\\n        int count = 0;\\n\\n        for (int i = 0; i < s1.length(); i++) {\\n            arrayS1[s1.charAt(i) - 'a']++;\\n            arrayS2[s2.charAt(i) - 'a']++;\\n        }\\n\\n        for (int i = 0; i < 26; i++) {\\n            if (arrayS1[i] == arrayS2[i])\\n                count++;\\n        }\\n\\n        for (int i = 0; i < s2.length() - s1.length(); i++) {\\n            if (count == 26)\\n                return true;\\n            int left = s2.charAt(i) - 'a', right = s2.charAt(i + s1.length()) - 'a';\\n\\n            arrayS2[right]++;\\n            if (arrayS2[right] == arrayS1[right])\\n                count++;\\n            else if (arrayS2[right] == arrayS1[right] + 1)\\n                count--;\\n\\n            arrayS2[left]--;\\n            if (arrayS2[left] == arrayS1[left])\\n                count++;\\n            else if (arrayS2[left] == arrayS1[left] - 1)\\n                count--;\\n        }\\n\\n        return count == 26;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def checkInclusion(self, s1: str, s2: str) -> bool:\\n        if (len(s1) > len(s2)):\\n            return False\\n        \\n        list1 = [0 for i in range(26)]\\n        list2 = [0 for i in range(26)]\\n        \\n        for i in range(len(s1)):\\n            list1[ord(s1[i]) - ord('a')] += 1\\n            list2[ord(s2[i]) - ord('a')] += 1\\n            \\n        count = 0\\n        for i in range(26):\\n            if list1[i] == list2[i]:\\n                count += 1\\n                \\n        for i in range(len(s2) - len(s1)):\\n            right = ord(s2[i + len(s1)]) - ord('a')\\n            left = ord(s2[i]) - ord('a')\\n            if count == 26:\\n                return True\\n            \\n            list2[right] += 1\\n            if list2[right] == list1[right]:\\n                count += 1\\n            elif list2[right] == list1[right] + 1:\\n                count -= 1\\n                \\n            list2[left] -= 1\\n            if list2[left] == list1[left]:\\n                count += 1\\n            elif list2[left] == list1[left] - 1:\\n                count -= 1\\n                \\n        return count == 26\\n\\n\"}]}]},{\"id\":\"12\",\"name\":\"第十二章\",\"list\":[{\"title\":\"代码12.1.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\n    plublic:\\n        bool stoneGame(vector<int>& piles) {\\n            return true;\\n        }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"package ch12.code;\\n\\npublic class 12.1.1.StoneGame {\\n    public boolean stoneGame(int[] piles) {\\n        return true;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n\\n\"}]},{\"title\":\"代码12.1.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\nprivate:\\n    int find_max(int left, int right, vector<int>& piles, vector<vector<int>>& mem) {\\n        if (left < 0 || right < 0 || left > right) return 0;\\n\\n        if (mem[left][right] != 0)\\n            return mem[left][right];\\n        \\n        if (left == right) {\\n            mem[left][right] = piles[left];\\n            return piles[left];\\n        }\\n\\n        int max_stone = max(piles[left]  + min(find_max(left + 2, right, piles, mem), find_max(left + 1, right - 1, piles, mem)),\\n                            piles[right] + min(find_max(left + 1, right - 1, piles, mem), find_max(left, right - 2, piles, mem)));\\n        mem[left][right] = max_stone;\\n        \\n        return max_stone;\\n    }\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int sum = 0;\\n\\n        for (int i = 0; i < piles.size(); i++)\\n            sum += piles[i];\\n        \\n        vector<vector<int>> mem;\\n        for (int i = 0; i < piles.size(); i++)\\n            mem.push_back(vector<int>(piles.size(), 0));\\n\\n        return 2 * find_max(0, piles.size() - 1, piles, mem) > sum;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"package ch12.code;\\n\\npublic class 12.1.2.StoneGame {\\n    public boolean stoneGame(int[] piles) {\\n        int sum = 0;\\n        for (int i : piles) {\\n            sum += i;\\n        }\\n        int[][] mem = new int[piles.length][piles.length];\\n        return 2 * findMax(0, piles.length - 1, piles, mem) >= sum;\\n    }\\n\\n    private int findMax(int left, int right, int[] piles, int[][] mem) {\\n        if (left < 0 || left > right)\\n            return 0;\\n        if (mem[left][right] != 0)\\n            return mem[left][right];\\n        if (left == right) {\\n            mem[left][right] = piles[left];\\n            return piles[left];\\n        }\\n\\n        int max = Math.max(\\n                piles[left] +\\n                        Math.min(findMax(left + 2, right, piles, mem),\\n                                findMax(left + 1, right - 1, piles, mem)),\\n                piles[right] +\\n                        Math.min(findMax(left + 1, right - 1, piles, mem),\\n                                findMax(left, right - 2, piles, mem)));\\n\\n        mem[left][right] = max;\\n        return max;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        sum = 0\\n        for i in piles:\\n            sum += i\\n        mem = []\\n        for i in range(len(piles)):\\n            mem.append([0] * len(piles))\\n\\n        return 2 * self.find_max(0, len(piles) - 1, piles, mem) > sum\\n\\n    def find_max(\\n        self, left: int, right: int, piles: List[int], mem: List[List[int]]\\n    ) -> int:\\n        if left < 0 or right < 0 or left > right:\\n            return 0\\n        if mem[left][right] != 0:\\n            return mem[left][right]\\n        if left == right:\\n            mem[left][right] = piles[left]\\n            return piles[left]\\n        max_stone = max(\\n            piles[left] + min(\\n                self.find_max(left + 2, right, piles, mem),\\n                self.find_max(left + 1, right - 1, piles, mem),\\n            ),\\n            piles[right] + min(\\n                self.find_max(left + 1, right - 1, piles, mem),\\n                self.find_max(left, right - 2, piles, mem),\\n            ),  # black formatter added trailing comma\\n        )\\n        mem[left][right] = max_stone\\n        return max_stone\\n\\n\\n\"}]},{\"title\":\"代码12.2.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\nprivate:\\n    int find_max(int left, int right, vector<int>& nums, vector<vector<int>>& mem) {\\n        if (left < 0 || right < 0 || left > right)\\n            return 0;\\n        \\n        if (mem[left][right] != 0)\\n            return mem[left][right];\\n        \\n        if (left == right) {\\n            mem[left][right] = nums[left];\\n            return nums[left];\\n        }\\n        \\n        int max_num = max(nums[left]  + min(find_max(left + 2, right, nums, mem), find_max(left + 1, right - 1, nums, mem)),\\n                          nums[right] + min(find_max(left + 1, right - 1, nums, mem), find_max(left, right - 2, nums, mem)));\\n        mem[left][right] = max_num;\\n        \\n        return max_num;\\n    }\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int sum = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n            sum += nums[i];\\n        \\n        vector<vector<int>> mem;\\n        for (int i = 0; i < nums.size(); i++)\\n            mem.push_back(vector<int>(nums.size(), 0));\\n        \\n        return 2 * find_max(0, nums.size() - 1, nums, mem) >= sum;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"package ch12.code;\\n\\npublic class 12.2.1.PredictTheWinner {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int sum = 0;\\n        for (int i : nums)\\n            sum += i;\\n        int[][] mem = new int[nums.length][nums.length];\\n        return sum <= findMax(0, nums.length - 1, nums, mem) * 2;\\n    }\\n\\n    private int findMax(int l, int r, int[] nums, int[][] mem) {\\n        if (l < 0 || l > r)\\n            return 0;\\n        if (mem[l][r] != 0)\\n            return mem[l][r];\\n\\n        if (l == r) {\\n            mem[l][r] = nums[l];\\n            return nums[l];\\n        }\\n        mem[l][r] = Math.max(nums[l] + Math.min(findMax(l + 1, r - 1, nums, mem), findMax(l + 2, r, nums, mem)),\\n                nums[r] + Math.min(findMax(l + 1, r - 1, nums, mem), findMax(l, r - 2, nums, mem)));\\n        return mem[l][r];\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        sum = 0\\n        for i in nums:\\n            sum += i\\n        mem = []\\n        for i in range(len(nums)):\\n            mem.append([0] * len(nums))\\n\\n        return 2 * self.find_max(0, len(nums) - 1, nums, mem) >= sum\\n\\n    def find_max(\\n        self, left: int, right: int, nums: List[int], mem: List[List[int]]\\n    ) -> int:\\n        if left < 0 or right < 0 or left > right:\\n            return 0\\n        if mem[left][right] != 0:\\n            return mem[left][right]\\n        if left == right:\\n            mem[left][right] = nums[left]\\n            return nums[left]\\n        max_num = max(\\n            nums[left]\\n            + min(\\n                self.find_max(left + 2, right, nums, mem),\\n                self.find_max(left + 1, right - 1, nums, mem),\\n            ),\\n            nums[right]\\n            + min(\\n                self.find_max(left + 1, right - 1, nums, mem),\\n                self.find_max(left, right - 2, nums, mem),\\n            ),  # black formatter added trailing comma\\n        )\\n        mem[left][right] = max_num\\n        return max_num\\n\\n\"}]},{\"title\":\"代码12.2.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int len = nums.size();\\n        \\n        vector<vector<int>> dp;\\n        for (int i = 0; i < nums.size(); i++)\\n            dp.push_back(vector<int>(nums.size(), 0));\\n        \\n        for (int i = 0;i < nums.size(); i++)\\n            dp[i][i] = nums[i];\\n        \\n        for (int i = len - 1; i > -1; i--)\\n            for (int j = i + 1; j < len; j++)\\n                dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\\n        \\n        return dp[0][len - 1] >= 0;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"package ch12.code;\\n\\npublic class 12.2.2.PredictTheWinner {\\n    public boolean PredictTheWinner(int[] nums) {\\n        int[][] dp = new int[nums.length][nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            dp[i][i] = nums[i];\\n        }\\n\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            for (int j = i + 1; j < nums.length; j++)\\n                dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\\n        }\\n        return dp[0][nums.length - 1] >= 0;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n\\n        dp = [[0] * n for _ in range(n)]\\n\\n        for i in range(n):\\n            dp[i][i] = nums[i]\\n\\n        for i in range(n - 1, -1, -1):\\n            for j in range(i + 1, n):\\n                dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\\n        return dp[0][n - 1] >= 0\\n\\n\\n\"}]},{\"title\":\"代码12.2.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    bool PredictTheWinner(vector<int>& nums) {\\n        int len = nums.size();\\n        \\n        if (len % 2 == 0 || len == 1) return true;\\n        \\n        vector<int> dp(len, 0);\\n        \\n        for (int i = len - 1; i > -1; i--) {\\n            dp[i] = nums[i];\\n            for (int j = i + 1; j < len; j++) {\\n                dp[j] = max(nums[i] - dp[j], nums[j] - dp[j - 1]);\\n            }\\n        }\\n        \\n        return dp[len - 1] >= 0; \\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"package ch12.code;\\n\\npublic class 12.2.3.PredictTheWinner {\\n    public boolean PredictTheWinner(int[] nums) {\\n        if (nums.length == 1 || nums.length % 2 == 0)\\n            return true;\\n\\n        int[] dp = new int[nums.length];\\n\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            dp[i] = nums[i];\\n            for (int j = i + 1; j < nums.length; j++)\\n                dp[j] = Math.max(nums[i] - dp[j], nums[j] - dp[j - 1]);\\n        }\\n        return dp[nums.length - 1] >= 0;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def PredictTheWinner(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n % 2 == 0 or n == 1:\\n            return True\\n        dp = [0] * n\\n\\n        for i in range(n - 1, -1, -1):\\n            dp[i] = nums[i]\\n            for j in range(i + 1, n):\\n                dp[j] = max(nums[i] - dp[j], nums[j] - dp[j - 1])\\n        return dp[-1] >= 0\\n\\n\\n\"}]},{\"title\":\"代码12.3.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"//TLE\\nclass Solution {\\npublic:\\n    bool canWinNim(int n) {\\n\\tbool res = false;\\n        bool *mem = (bool *)malloc((n + 1) * sizeof(bool));\\n        memset(mem, true, (n + 1) * sizeof(bool));\\n        \\n        for (int i = 4; i < n + 1; i++) {\\n            if (!(mem[i - 1] && mem[i - 2] && mem[i - 3]))\\n                mem[i] = true;\\n            else\\n                mem[i] = false;\\n        }\\n        \\n\\tres = mem[n];\\n\\tfree(mem);\\n        return res;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"package ch12.code;\\n\\npublic class NimGame {\\n    public boolean canWinNim(int n) {\\n        boolean[] mem = new boolean[n + 1];\\n        mem[1] = true;\\n        mem[2] = true;\\n        mem[3] = true;\\n\\n        for (int i = 4; i < n + 1; i++) {\\n            if (!(mem[i - 1] && mem[i - 2] && mem[i - 3]))\\n                mem[i] = true;\\n        }\\n        return mem[n];\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        mem = [True] * (n + 1)\\n        for i in range(4, n + 1):\\n            if not (mem[i - 1] and mem[i - 2] and mem[i - 3]):\\n                mem[i] = True\\n            else:\\n                mem[i] = False\\n        return mem[n]\\n\"}]},{\"title\":\"代码12.3.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    bool canWinNim(int n) {\\n        if (n < 4) return true;\\n        \\n        int a = true, b = true, c = true;\\n        \\n        for (int i = 4; i < n + 1; i++) {\\n            int current = !(a && b && c);\\n            a = b;\\n            b = c;\\n            c = current;\\n        }\\n        \\n        return c;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"package ch12.code;\\n\\npublic class NimGame {\\n    public boolean canWinNim(int n) {\\n        if (n < 4)\\n            return true;\\n\\n        boolean a = true, b = true, c = true;\\n\\n        for (int i = 4; i < n + 1; i++) {\\n            boolean current = a && b && c ? false : true;\\n            a = b;\\n            b = c;\\n            c = current;\\n        }\\n\\n        return c;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        if n < 4:\\n            return True\\n        a, b, c = True, True, True\\n        for i in range(4, n + 1):\\n            current = not (a and b and c)\\n            a, b, c = b, c, current\\n        return c\\n\\n\"}]},{\"title\":\"代码12.3.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    bool canWinNim(int n) {\\n       return n % 4 != 0;\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"package ch12.code;\\n\\npublic class NimGame {\\n    public boolean canWinNim(int n) {\\n        if (n <= 0) {\\n            return false;\\n        }\\n        return 0 != n % 4;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def canWinNim3(self, n: int) -> bool:\\n        return n % 4 != 0\\n\\n\\n\"}]},{\"title\":\"代码12.4.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\nprivate:\\n    int cost(int low, int high) {\\n        if (low >= high) return 0;\\n        \\n        int res = INT_MAX;\\n        for (int i = low; i < high + 1; i++) {\\n            int tmp = i + max(cost(low, i - 1), cost(i + 1, high));\\n            res = min(res, tmp);\\n        }\\n        \\n        return res;\\n    }\\npublic:\\n    int getMoneyAmount(int n) {\\n        return cost(1, n);\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class GetMoneyAmount {\\n\\n    public int cost(int low, int high) {\\n        if (low >= high)\\n            return 0;\\n        int res = Integer.MAX_VALUE;\\n        for (int i = low; i <= high; i++) {\\n            int tmp = i + Math.max(cost(i + 1, high), cost(low, i - 1));\\n            res = Math.min(tmp, res);\\n        }\\n\\n        return res;\\n    }\\n    public int getMoneyAmount(int n) {\\n        return cost(1, n);\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"import sys\\n\\n\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        def cost(low: int, high: int) -> int:\\n            if low >= high:\\n                return 0\\n            res = sys.maxsize\\n            for i in range(low, high + 1):\\n                tmp = i + max(\\n                    cost(low, i - 1), cost(i + 1, high)\\n                )\\n                res = min(res, tmp)\\n            return res\\n\\n        return cost(1, n)\\n\\n\"}]},{\"title\":\"代码12.4.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\nprivate:\\n    int cost(int low, int high, vector<vector<int>> mem) {\\n        if (low >= high)\\n            return 0;\\n        \\n        if (mem[low][high])\\n            return mem[low][high];\\n        \\n        int res = INT_MAX;\\n        for (int i = (low + high) / 2; i < high + 1; i++) {\\n            int tmp = i + max(cost(low, i - 1, mem), cost(i + 1, high, mem));\\n            res = min(res, tmp);\\n        }\\n        mem[low][high] = res;\\n        \\n        return res;\\n    }\\npublic:\\n    int getMoneyAmount(int n) {\\n        if (n == 1) return 0;\\n\\n        vector<vector<int>> mem(n + 1, vector<int>(n + 1, 0));\\n        return cost(1, n, mem);\\n    }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class GetMoneyAmount {\\n\\n    public int getMoneyAmount (int n){\\n        if (n == 1) return 0;\\n        int[][] mem = new int[n + 1][n + 1];\\n        return cost(1, n, mem);\\n\\n    }\\n\\n    private int cost(int low, int high, int[][] mem) {\\n        if (low >= high)\\n            return 0;\\n        if (mem[low][high] != 0)\\n            return mem[low][high];\\n        int minRes = Integer.MAX_VALUE;\\n        for (int i = (low + high) / 2; i <= high; i++) {\\n            int res = i + Math.max(cost(i + 1, high, mem), cost(low, i - 1, mem));\\n            minRes = Math.min(res, minRes);\\n        }\\n        mem[low][high] = minRes;\\n        return minRes;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"import sys\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        def cost(low: int, high: int, mem: List[List[int]]) -> int:\\n\\n            if low >= high:\\n                return 0\\n            if mem[low][high] != 0:\\n                return mem[low][high]\\n\\n            res = sys.maxsize\\n            for i in range((low + high) // 2, high + 1):\\n                tmp = i + max(\\n                    cost(low, i - 1, mem),\\n                    cost(i + 1, high, mem),\\n                )\\n                res = min(res, tmp)\\n            mem[low][high] = res\\n            return res\\n\\n        if n == 1:\\n            return 0\\n        mem = [[0] * (n + 1) for _ in range(n + 1)]\\n\\n        return cost(1, n, mem)\\n\\n\"}]}]},{\"id\":\"13\",\"name\":\"第十三章\",\"list\":[{\"title\":\"代码13.1.1\",\"codes\":[{\"language\":\"Java\",\"content\":\"package ch13.code;\\npublic class Solution {\\n\\n    public int maxProfitOrigin(int[] prices) {\\n        int max = 0;\\n        for (int i = prices.length - 1; i > 0; i--) {\\n            for (int j = i - 1; j >= 0; j--) {\\n                if (prices[i] - prices[j] > max)\\n                    max = prices[i] - prices[j];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\"}]},{\"title\":\"代码13.1.1.best\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            int maxprofit = 0;\\n\\n            for (int i = 0; i < prices.size(); i++) {\\n                for (int j = i + 1; j < prices.size(); j++) {\\n                    if (prices[j] - prices[i] > maxprofit)\\n                        maxprofit = prices[j] - prices[i];\\n                }\\n            }\\n\\n            return maxprofit;\\n        }\\n};\\n\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_diff = 0\\n        for i in range(1, len(prices)):\\n            for j in range(0, i):\\n                if prices[i] - prices[j] > max_diff:\\n                    max_diff = prices[i] - prices[j]\\n        return max_diff\\n\\n\"}]},{\"title\":\"代码13.1.2\",\"codes\":[{\"language\":\"Java\",\"content\":\"package ch13.code;\\npublic class Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length <= 1) \\n            return 0;\\n\\n        int min = prices[0];\\n        int max = 0;\\n\\n        for (int i = 1; i < prices.length; i++) {\\n            max = Math.max(prices[i] - min, max);\\n            min = Math.min(min, prices[i]);\\n        }\\n        return max;\\n    }\\n}\\n\"}]},{\"title\":\"代码13.1.2.best\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() == 0)\\n            return 0;\\n\\n        int max_diff = 0;\\n        int min_price = prices[0];\\n        \\n        for (int i = 1; i < prices.size(); i++) {\\n            if (min_price > prices[i])\\n                min_price = prices[i];\\n            max_diff = max(max_diff, prices[i] - min_price);\\n        }\\n        \\n        return max_diff;\\n    }\\n};\\n\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\nimport sys\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_diff = 0\\n        min_price = sys.maxsize\\n        for i in range(len(prices)):\\n            if min_price > prices[i]:\\n                min_price = prices[i]\\n            max_diff = max(max_diff, prices[i] - min_price)\\n        return max_diff\\n\\n\"}]},{\"title\":\"代码13.2.1\",\"codes\":[{\"language\":\"Java\",\"content\":\"package ch13.code;\\npublic class Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length < 2)\\n            return 0;\\n\\n        int ans = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i] - prices[i - 1] > 0)\\n                ans += prices[i] - prices[i - 1];\\n        }\\n        return ans;\\n    }\\n}\\n\"}]},{\"title\":\"代码13.2.best\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int maxprofit = 0;\\n        int size = prices.size();\\n\\n        for (int i = 1; i < size; i++) {\\n            if (prices[i] > prices[i - 1])\\n                maxprofit += prices[i] - prices[i - 1];\\n        }\\n        \\n        return maxprofit;\\n    }\\n};\\n\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) <= 1:\\n            return 0\\n        max_profit = 0\\n        for i in range(1, len(prices)):\\n            if prices[i] - prices[i - 1] > 0:\\n                max_profit += prices[i] - prices[i - 1]\\n        return max_profit\\n\\n\"}]},{\"title\":\"代码13.3.1\",\"codes\":[{\"language\":\"Java\",\"content\":\"package ch13.code;\\n\\npublic class Solution {\\n    public int maxProfitOrigin(int[] prices, int fee) {\\n        if (prices == null || prices.length < 2)\\n            return 0;\\n\\n        int[] buy = new int[prices.length], sell = new int[prices.length];\\n        buy[0] = -prices[0];\\n        sell[0] = 0;\\n\\n        for (int i = 1; i < prices.length; i++) {\\n            buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i]);\\n            sell[i] = Math.max(buy[i - 1] + prices[i] - fee, sell[i - 1]);\\n        }\\n\\n        return sell[prices.length - 1];\\n    }\\n}\\n\"}]},{\"title\":\"代码13.3.1.best\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        if (prices.size() <= 1)\\n            return 0;\\n        \\n\\tint res = 0;\\n        int *buy  = new int[prices.size() + 1]();\\n        int *sell = new int[prices.size() + 1]();\\n        \\n        buy[0] = -prices[0];\\n        \\n        for (int i = 1; i < prices.size(); i++) {\\n            buy[i]  = max(buy[i - 1], sell[i - 1] - prices[i]);\\n            sell[i] = max(buy[i - 1] + prices[i] - fee, sell[i - 1]);\\n        }\\n\\n\\tres = sell[prices.size() - 1];\\n\\tdelete [] buy;\\n\\tdelete [] sell;\\n        \\n        return res;\\n    }\\n};\\n\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        if len(prices) <= 1:\\n            return 0\\n        # buy = [0 for i in range(len(prices))]\\n        # sell = [0 for i in range(len(prices))]\\n        buy, sell = [0] * len(prices), [0] * len(prices)\\n        buy[0] = -prices[0]\\n        for i in range(1, len(prices)):\\n            buy[i] = max(buy[i - 1], sell[i - 1] - prices[i])\\n            sell[i] = max(buy[i - 1] + prices[i] - fee, sell[i - 1])\\n        return sell[-1]\\n\\n\"}]},{\"title\":\"代码13.3.2\",\"codes\":[{\"language\":\"Java\",\"content\":\"package ch13.code;\\n\\npublic class Solution {\\n    public int maxProfit(int[] prices, int fee) {\\n        if (prices == null || prices.length < 2)\\n            return 0;\\n\\n        int preBuy = -prices[0];\\n        int preSell = 0;\\n\\n        for (int i = 1; i < prices.length; i++) {\\n            int buy = Math.max(preBuy, preSell - prices[i]);\\n            int sell = Math.max(preBuy + prices[i] - fee, preSell);\\n\\n            preBuy = buy;\\n            preSell = sell;\\n        }\\n        return preSell;\\n    }\\n}\\n\"}]},{\"title\":\"代码13.3.2.best\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        if (prices.size() <= 1)\\n            return 0;\\n        \\n        int pre_buy  = -prices[0];\\n        int pre_sell = 0;\\n        \\n        for (int i = 1; i < prices.size(); i++) {\\n            int buy  = max(pre_buy, pre_sell - prices[i]);\\n            int sell = max(pre_buy + prices[i] - fee, pre_sell);\\n            pre_buy  = buy;\\n            pre_sell = sell;\\n        }\\n        \\n        return pre_sell;\\n    }\\n};\\n\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        if len(prices) <= 1:\\n            return 0\\n        pre_buy = -prices[0]\\n        pre_sell = 0\\n        for i in range(1, len(prices)):\\n            buy = max(pre_buy, pre_sell - prices[i])\\n            sell = max(pre_buy + prices[i] - fee, pre_sell)\\n            pre_buy = buy\\n            pre_sell = sell\\n        return pre_sell\\n\\n\"}]},{\"title\":\"代码13.4.1\",\"codes\":[{\"language\":\"Java\",\"content\":\"package ch13.code;\\npublic class Solution {\\n    public int maxProfitOrigin(int[] prices) {\\n        if (prices == null || prices.length < 2)\\n            return 0;\\n\\n        int[] buy = new int[prices.length], sell = new int[prices.length];\\n        buy[0] = -prices[0];\\n        sell[0] = 0;\\n\\n        buy[1] = Math.max((0 - prices[1]), buy[0]);\\n        sell[1] = Math.max((buy[0] + prices[1]), sell[0]);\\n\\n        for (int i = 2; i < prices.length; i++) {\\n            buy[i] = Math.max((sell[i - 2] - prices[i]), buy[i - 1]);\\n            sell[i] = Math.max((buy[i - 1] + prices[i]), sell[i - 1]);\\n        }\\n\\n        return sell[prices.length - 1];\\n    }\\n}\\n\"}]},{\"title\":\"代码13.4.1.best\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() <= 1)\\n            return 0;\\n        \\n        int res = 0;\\n        int *buy  = new int[prices.size()]();\\n        int *sell = new int[prices.size()]();\\n        buy[0]  = -prices[0];\\n        buy[1]  = max((0 - prices[1]), buy[0]);\\n        sell[1] = max((buy[0] + prices[1]), sell[0]);\\n        \\n        for (int i = 2; i < prices.size(); i++) {\\n            buy[i]  = max((sell[i - 2] - prices[i]), buy[i - 1]);\\n            sell[i] = max((buy[i - 1] + prices[i]), sell[i - 1]); \\n        }\\n        \\n        res = sell[prices.size() - 1];\\n        \\n        delete [] buy;\\n        delete [] sell;\\n        \\n        return res;\\n    }\\n};\\n\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) <= 1:\\n            return 0\\n        buy, sell = [0] * len(prices), [0] * len(prices)\\n        buy[0] = -prices[0]\\n        buy[1] = max((0 - prices[1]), buy[0])\\n        sell[1] = max((buy[0] + prices[1]), sell[0])\\n        for i in range(2, len(prices)):\\n            buy[i] = max((sell[i - 2] - prices[i]), buy[i - 1])\\n            sell[i] = max((buy[i - 1] + prices[i]), sell[i - 1])\\n        return sell[-1]\\n\\n\"}]},{\"title\":\"代码13.4.2\",\"codes\":[{\"language\":\"Java\",\"content\":\"package ch13.code;\\n\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length < 2)\\n            return 0;\\n\\n        int b0 = -prices[0];\\n        int b1 = b0;\\n\\n        int s0 = 0;\\n        int s1 = 0;\\n        int s2 = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            b0 = Math.max(b1, s2 - prices[i]);\\n            s0 = Math.max(s1, b0 + prices[i]);\\n\\n            s2 = s1;\\n            s1 = s0;\\n            b1 = b0;\\n        }\\n        return s0;\\n    }\\n}\\n\"}]},{\"title\":\"代码13.4.2.best\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() <= 1)\\n            return 0;\\n        \\n        int b0 = -prices[0];\\n        int b1 = b0;\\n        int s0 = 0, s1 = 0, s2 = 0;\\n        \\n        for (int i = 0; i < prices.size(); i++) {\\n            b0 = max(b1, s2 - prices[i]);\\n            s0 = max(s1, b0 + prices[i]);\\n            s2 = s1;\\n            s1 = s0;\\n            b1 = b0;\\n        }\\n        \\n        return s0;\\n    }\\n};\\n\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) <= 1:\\n            return 0\\n        b0 = -prices[0]\\n        b1 = b0\\n        s0, s1, s2 = 0, 0, 0\\n        for i in range(0, len(prices)):\\n            b0 = max(b1, s2 - prices[i])\\n            s0 = max(s1, b0 + prices[i])\\n            s2 = s1\\n            s1 = s0\\n            b1 = b0\\n        return s0\\n\\n\"}]},{\"title\":\"代码13.5.1\",\"codes\":[{\"language\":\"Java\",\"content\":\"package ch13.code;\\npublic class Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        if (prices == null || prices.length < 2)\\n            return 0;\\n\\n        int[][] dp = new int[k + 1][prices.length];\\n\\n        for (int i = 1; i <= k; i++) {\\n            int minPrice = prices[0];\\n            for (int j = 1; j < prices.length; j++) {\\n                minPrice = Math.min(minPrice, prices[j] - dp[i - 1][j - 1]);\\n                dp[i][j] = Math.max(dp[i][j - 1], prices[j] - minPrice);\\n            }\\n        }\\n        return dp[k][prices.length - 1];\\n    }\\n}\\n\"}]},{\"title\":\"代码13.5.1.best\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"//This solution maybe Runtime Error\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        if (prices.size() <= 1) return 0;\\n        \\n        vector<vector<int>> dp(k + 1, vector<int>(prices.size() + 1, 0));\\n\\n        for (int i = 1; i < k + 1; i++) {\\n            int min_price = prices[0];\\n            for (int j = 1; j < prices.size(); j++) {\\n                min_price = min(min_price, prices[j] - dp[i - 1][j - 1]);\\n                dp[i][j]  = max(dp[i][j - 1], prices[j] - min_price);\\n            }\\n        }\\n        \\n        return dp[k][prices.size() - 1];\\n    }\\n};\\n\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if len(prices) <= 1:\\n            return 0\\n        if k > len(prices) / 2 + 1:\\n            max_profit = 0\\n            for i in range(1, len(prices)):\\n                if prices[i] - prices[i - 1] > 0:\\n                    max_profit += prices[i] - prices[i - 1]\\n            return max_profit\\n        dp = []\\n        for i in range(0, k + 1):\\n            dp.append([0] * len(prices))\\n        for i in range(1, k + 1):\\n            min_price = prices[0]\\n            for j in range(1, len(prices)):\\n                min_price = min(min_price, prices[j] - dp[i - 1][j - 1])\\n                dp[i][j] = max(dp[i][j - 1], prices[j] - min_price)\\n        return dp[-1][-1]\\n\\n\"}]},{\"title\":\"代码13.5.2\",\"codes\":[{\"language\":\"Java\",\"content\":\"package ch13.code;\\n\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int maxProfit(int k, int[] prices) {\\n        if (prices == null || prices.length < 2)\\n            return 0;\\n\\n        if (k > prices.length / 2 + 1) {\\n            int ans = 0;\\n            for (int i = 1; i < prices.length; i++) {\\n                if (prices[i] - prices[i - 1] > 0)\\n                    ans += prices[i] - prices[i - 1];\\n            }\\n            return ans;\\n        }\\n\\n        int[] minPrice = new int[k + 1];\\n        Arrays.fill(minPrice, prices[0]);\\n\\n        int[] dp = new int[k + 1];\\n\\n        for (int i = 1; i < prices.length; i++) {\\n            for (int j = 1; j <= k; j++) {\\n                minPrice[j] = Math.min(minPrice[j], prices[i] - dp[j - 1]);\\n                dp[j] = Math.max(dp[j], prices[i] - minPrice[j]);\\n            }\\n        }\\n        return dp[k];\\n    }\\n}\\n\"}]},{\"title\":\"代码13.5.2.best\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        if (prices.size() <= 1)\\n            return 0;\\n        \\n        if (k > (prices.size() / 2 + 1)) {\\n            int max_profit = 0;\\n            for (int i = 1; i < prices.size(); i++) {\\n                if (prices[i] - prices[i - 1] > 0)\\n                    max_profit += prices[i] - prices[i - 1];\\n            }\\n            \\n            return max_profit;\\n        }\\n        \\n        int *min_price = new int[k + 1]();\\n        for (int i = 0; i < k + 1; i++)\\n            min_price[i] = prices[0];\\n        \\n        int *dp        = new int[k + 1]();\\n        \\n        for (int i = 1; i < prices.size(); i++) {\\n            for (int j = 1; j < k + 1; j++) {\\n                min_price[j] = min(min_price[j], prices[i] - dp[j - 1]);\\n                dp[j] = max(dp[j], prices[i] - min_price[j]);\\n            }\\n        }\\n        \\n        int res = dp[k];\\n        delete [] min_price;\\n        delete [] dp;\\n        return res;\\n    }\\n};\\n\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def maxProfit(self, k: int, prices: List[int]) -> int:\\n        if len(prices) <= 1:\\n            return 0\\n        if k > len(prices) / 2 + 1:\\n            max_profit = 0\\n            for i in range(1, len(prices)):\\n                if prices[i] - prices[i - 1] > 0:\\n                    max_profit += prices[i] - prices[i - 1]\\n            return max_profit\\n        min_price, dp = [prices[0]] * (k + 1), [0] * (k + 1)\\n        for i in range(1, len(prices)):\\n            for j in range(1, k + 1):\\n                min_price[j] = min(min_price[j], prices[i] - dp[j - 1])\\n                dp[j] = max(dp[j], prices[i] - min_price[j])\\n        return dp[k]\\n\\n\"}]},{\"title\":\"代码13.6.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"int maxProfit(int k, vector<int>& prices) {\\n    if (prices.size() <= 1)\\n        return 0;\\n\\n    int *dp = new int[prices.size() + 1]();\\n    min_prices = prices[0];\\n\\n    for (int i = 1; i < prices.size(); i++) {\\n        min_price = min(min_price, prices[i] - dp[i - 1]);\\n        dp[i + 1] = max(dp[i], prices[i] - min_price);\\n    }\\n\\n    int res = dp[prices.size() - 1];\\n\\n    delete [] dp;\\n\\n    return res;\\n}\\n\\n\"},{\"language\":\"Java\",\"content\":\"package ch13.code;\\n\\npublic class Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length < 2)\\n            return 0;\\n        int[] dp = new int[prices.length + 1];\\n        int min = prices[0];\\n\\n        for (int i = 1; i < prices.length; i++) {\\n            min = Math.min(min, prices[i] - dp[i - 1]);\\n            dp[i + 1] = Math.max(dp[i], prices[i] - min);\\n        }\\n        return dp[dp.length - 1];\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) <= 1:\\n            return 0\\n        dp = [0] * (len(prices)+1)\\n        min_price = prices[0]\\n\\n        for i in range(1, len(prices)):\\n            min_price = min(min_price, prices[i] - dp[i - 1])\\n            dp[i + 1] = max(dp[i], prices[i] - min_price)\\n        return dp[-1]\\n\"}]}]},{\"id\":\"14\",\"name\":\"第十四章\",\"list\":[{\"title\":\"代码14.1.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\\n        if (l1 == nullptr) {\\n            return l2;\\n        } else if (l2 == nullptr) {\\n            return l1;\\n        } else if (l1->val < l2->val) {\\n            l1->next = mergeTwoLists(l1->next, l2);\\n            return l1;\\n        } else {\\n            l2->next = mergeTwoLists(l1, l2->next);\\n            return l2;\\n        }\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\\n        if (l1 == null) {\\n            return l2;\\n        }\\n        else if (l2 == null) {\\n            return l1;\\n        }\\n        else if (l1.val < l2.val) {\\n            l1.next = mergeTwoLists(l1.next, l2);\\n            return l1;\\n        }\\n        else {\\n            l2.next = mergeTwoLists(l1, l2.next);\\n            return l2;\\n        }\\n\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\nclass Solution:\\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        if l1 is None:\\n            return l2\\n        if l2 is None:\\n            return l1\\n        if l1.val < l2.val:\\n            l1.next = self.mergeTwoLists(l1.next, l2)\\n            return l1\\n        l2.next = self.mergeTwoLists(l1, l2.next)\\n        return l2\\n\"}]},{\"title\":\"代码14.1.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\\n        ListNode* preHead = new ListNode(-1);\\n\\n        ListNode* prev = preHead;\\n        while (l1 != nullptr && l2 != nullptr) {\\n            if (l1->val < l2->val) {\\n                prev->next = l1;\\n                l1 = l1->next;\\n            } else {\\n                prev->next = l2;\\n                l2 = l2->next;\\n            }\\n            prev = prev->next;\\n        }\\n\\n        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可\\n        prev->next = l1 == nullptr ? l2 : l1;\\n\\n        return preHead->next;\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\\n        ListNode prehead = new ListNode(-1);\\n\\n        ListNode prev = prehead;\\n        while (l1 != null && l2 != null) {\\n            if (l1.val <= l2.val) {\\n                prev.next = l1;\\n                l1 = l1.next;\\n            } else {\\n                prev.next = l2;\\n                l2 = l2.next;\\n            }\\n            prev = prev.next;\\n        }\\n\\n        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可\\n        prev.next = l1 == null ? l2 : l1;\\n\\n        return prehead.next;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\nclass Solution:\\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        \\n        sentinel = ListNode(-1) # 哨兵结点\\n\\n        curr = sentinel\\n        while l1 and l2:\\n            if l1.val <= l2.val:\\n                curr.next = l1\\n                l1 = l1.next\\n            else:\\n                curr.next = l2\\n                l2 = l2.next            \\n            curr = curr.next\\n\\n        curr.next = l1 if l1 is not None else l2\\n\\n        return sentinel.next\\n\"}]},{\"title\":\"代码14.1.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {\\n        if ((!a) || (!b)) return a ? a : b;\\n        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;\\n        while (aPtr && bPtr) {\\n            if (aPtr->val < bPtr->val) {\\n                tail->next = aPtr; aPtr = aPtr->next;\\n            } else {\\n                tail->next = bPtr; bPtr = bPtr->next;\\n            }\\n            tail = tail->next;\\n        }\\n        tail->next = (aPtr ? aPtr : bPtr);\\n        return head.next;\\n    }\\n\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode *ans = nullptr;\\n        for (size_t i = 0; i < lists.size(); ++i) {\\n            ans = mergeTwoLists(ans, lists[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\\n        if (l1 == null) {\\n            return l2;\\n        }\\n        else if (l2 == null) {\\n            return l1;\\n        }\\n        else if (l1.val < l2.val) {\\n            l1.next = mergeTwoLists(l1.next, l2);\\n            return l1;\\n        }\\n        else {\\n            l2.next = mergeTwoLists(l1, l2.next);\\n            return l2;\\n        }\\n\\n    }\\n    \\n    public ListNode mergeKLists(ListNode[] lists) {\\n        ListNode res = null;\\n        for (ListNode list: lists) {\\n            res = mergeTwoLists(res, list);\\n        }\\n        return res;\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode:\\n\\n            sentinel = ListNode(-1)  # 哨兵结点\\n\\n            curr = sentinel\\n            while l1 and l2:\\n                if l1.val <= l2.val:\\n                    curr.next = l1\\n                    l1 = l1.next\\n                else:\\n                    curr.next = l2\\n                    l2 = l2.next\\n                curr = curr.next\\n\\n            curr.next = l1 if l1 is not None else l2\\n\\n            return sentinel.next\\n\\n        if not lists:\\n            return None\\n        l = lists[0]\\n\\n        for i in range(1, len(lists)):\\n            l = mergeTwoLists(l, lists[i])\\n\\n        return l\\n\\n\"}]},{\"title\":\"代码14.1.4\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {\\n        if ((!a) || (!b)) return a ? a : b;\\n        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;\\n        while (aPtr && bPtr) {\\n            if (aPtr->val < bPtr->val) {\\n                tail->next = aPtr; aPtr = aPtr->next;\\n            } else {\\n                tail->next = bPtr; bPtr = bPtr->next;\\n            }\\n            tail = tail->next;\\n        }\\n        tail->next = (aPtr ? aPtr : bPtr);\\n        return head.next;\\n    }\\n\\n    ListNode* merge(vector <ListNode*> &lists, int l, int r) {\\n        if (l == r) return lists[l];\\n        if (l > r) return nullptr;\\n        int mid = (l + r) >> 1;\\n        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));\\n    }\\n\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        return merge(lists, 0, lists.size() - 1);\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n   public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists == null || lists.length == 0) return null;\\n        return merge(lists, 0, lists.length - 1);\\n    }\\n\\n    private ListNode merge(ListNode[] lists, int left, int right) {\\n        if (left == right) return lists[left];\\n        int mid = left + (right - left) / 2;\\n        ListNode l1 = merge(lists, left, mid);\\n        ListNode l2 = merge(lists, mid + 1, right);\\n        return mergeTwoLists(l1, l2);\\n    }\\n\\n    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {\\n        if (l1 == null) return l2;\\n        if (l2 == null) return l1;\\n        if (l1.val < l2.val) {\\n            l1.next = mergeTwoLists(l1.next, l2);\\n            return l1;\\n        } else {\\n            l2.next = mergeTwoLists(l1,l2.next);\\n            return l2;\\n        }\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode:\\n\\n            sentinel = ListNode(-1)  # 哨兵结点\\n\\n            curr = sentinel\\n            while l1 and l2:\\n                if l1.val <= l2.val:\\n                    curr.next = l1\\n                    l1 = l1.next\\n                else:\\n                    curr.next = l2\\n                    l2 = l2.next\\n                curr = curr.next\\n\\n            curr.next = l1 if l1 is not None else l2\\n\\n            return sentinel.next\\n\\n        amount = len(lists)\\n        interval = 1\\n        while interval < amount:\\n            for i in range(0, amount - interval, interval * 2):\\n                lists[i] = mergeTwoLists(lists[i], lists[i + interval])\\n            interval *= 2\\n        return lists[0] if amount > 0 else lists\\n\\n\"}]},{\"title\":\"代码14.1.5\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    struct Status {\\n        int val;\\n        ListNode *ptr;\\n        bool operator < (const Status &rhs) const {\\n            return val > rhs.val;\\n        }\\n    };\\n\\n    priority_queue <Status> q;\\n\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        for (auto node: lists) {\\n            if (node) q.push({node->val, node});\\n        }\\n        ListNode head, *tail = &head;\\n        while (!q.empty()) {\\n            auto f = q.top(); q.pop();\\n            tail->next = f.ptr; \\n            tail = tail->next;\\n            if (f.ptr->next) q.push({f.ptr->next->val, f.ptr->next});\\n        }\\n        return head.next;\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n   public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists == null || lists.length == 0) return null;\\n        PriorityQueue<ListNode> queue = new PriorityQueue<>(lists.length, new Comparator<ListNode>() {\\n            @Override\\n            public int compare(ListNode o1, ListNode o2) {\\n                if (o1.val < o2.val) return -1;\\n                else if (o1.val == o2.val) return 0;\\n                else return 1;\\n            }\\n        });\\n        ListNode dummy = new ListNode(0);\\n        ListNode p = dummy;\\n        for (ListNode node : lists) {\\n            if (node != null) queue.add(node);\\n        }\\n        while (!queue.isEmpty()) {\\n            p.next = queue.poll();\\n            p = p.next;\\n            if (p.next != null) queue.add(p.next);\\n        }\\n        return dummy.next;\\n    }\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n# Definition for singly-linked list.\\nclass ListNode(object):\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        import heapq\\n\\n        l = []\\n\\n        for head in lists:\\n            if head:\\n                heapq.heappush(l, (head.val, head))\\n\\n        dummy = ListNode(-1)\\n        cur = dummy\\n\\n        while l:\\n            _, node = heapq.heappop(l)\\n            cur.next = node\\n            cur = cur.next\\n            node = node.next\\n            if node:\\n                heapq.heappush(l, (node.val, node))\\n\\n        return dummy.next\\n\\n\"}]},{\"title\":\"代码14.2.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int findKthLargest(vector<int> &nums, int k) {\\n        int size = nums.size();\\n        sort(begin(nums), end(nums));\\n        return nums[size - k];\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.Arrays;\\n\\npublic class Solution {\\n\\n    public int findKthLargest(int[] nums, int k) {\\n        int len = nums.length;\\n        Arrays.sort(nums);\\n        return nums[len - k];\\n    }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        return nums[-k]\\n\\n\"}]},{\"title\":\"代码14.2.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    void maxHeapify(vector<int>& a, int i, int heapSize) {\\n        int l = i * 2 + 1, r = i * 2 + 2, largest = i;\\n        if (l < heapSize && a[l] > a[largest]) {\\n            largest = l;\\n        } \\n        if (r < heapSize && a[r] > a[largest]) {\\n            largest = r;\\n        }\\n        if (largest != i) {\\n            swap(a[i], a[largest]);\\n            maxHeapify(a, largest, heapSize);\\n        }\\n    }\\n\\n    void buildMaxHeap(vector<int>& a, int heapSize) {\\n        for (int i = heapSize / 2; i >= 0; --i) {\\n            maxHeapify(a, i, heapSize);\\n        } \\n    }\\n\\n    int findKthLargest(vector<int>& nums, int k) {\\n        int heapSize = nums.size();\\n        buildMaxHeap(nums, heapSize);\\n        for (int i = nums.size() - 1; i >= nums.size() - k + 1; --i) {\\n            swap(nums[0], nums[i]);\\n            --heapSize;\\n            maxHeapify(nums, 0, heapSize);\\n        }\\n        return nums[0];\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  public int findKthLargest(int[] nums, int k) {\\n      int heapSize = nums.length;\\n      buildMaxHeap(nums, heapSize);\\n      for (int i = nums.length - 1; i >= nums.length - k + 1; --i) {\\n          swap(nums, 0, i);\\n          --heapSize;\\n          maxHeapify(nums, 0, heapSize);\\n      }\\n      return nums[0];\\n  }\\n\\n  public void buildMaxHeap(int[] a, int heapSize) {\\n      for (int i = heapSize / 2; i >= 0; --i) {\\n          maxHeapify(a, i, heapSize);\\n      } \\n  }\\n\\n  public void maxHeapify(int[] a, int i, int heapSize) {\\n      int l = i * 2 + 1, r = i * 2 + 2, largest = i;\\n      if (l < heapSize && a[l] > a[largest]) {\\n          largest = l;\\n      } \\n      if (r < heapSize && a[r] > a[largest]) {\\n          largest = r;\\n      }\\n      if (largest != i) {\\n          swap(a, i, largest);\\n          maxHeapify(a, largest, heapSize);\\n      }\\n  }\\n\\n  public void swap(int[] a, int i, int j) {\\n      int temp = a[i];\\n      a[i] = a[j];\\n      a[j] = temp;\\n  }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        import heapq\\n\\n        heap = []\\n\\n        for i in range(k):\\n            heap.append(nums[i])\\n\\n        heapq.heapify(heap)\\n\\n        for i in range(k, len(nums)):\\n            if nums[i] > heap[0]:\\n                heapq.heappop(heap)\\n                heapq.heappush(heap, nums[i])\\n\\n        return heap[0]\\n\\n\"}]},{\"title\":\"代码14.2.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    void maxHeapify(vector<int>& a, int i, int heapSize) {\\n        int l = i * 2 + 1, r = i * 2 + 2, largest = i;\\n        if (l < heapSize && a[l] > a[largest]) {\\n            largest = l;\\n        } \\n        if (r < heapSize && a[r] > a[largest]) {\\n            largest = r;\\n        }\\n        if (largest != i) {\\n            swap(a[i], a[largest]);\\n            maxHeapify(a, largest, heapSize);\\n        }\\n    }\\n\\n    void buildMaxHeap(vector<int>& a, int heapSize) {\\n        for (int i = heapSize / 2; i >= 0; --i) {\\n            maxHeapify(a, i, heapSize);\\n        } \\n    }\\n\\n    int findKthLargest(vector<int>& nums, int k) {\\n        int heapSize = nums.size();\\n        buildMaxHeap(nums, heapSize);\\n        for (int i = nums.size() - 1; i >= nums.size() - k + 1; --i) {\\n            swap(nums[0], nums[i]);\\n            --heapSize;\\n            maxHeapify(nums, 0, heapSize);\\n        }\\n        return nums[0];\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  public int findKthLargest(int[] nums, int k) {\\n      int heapSize = nums.length;\\n      buildMaxHeap(nums, heapSize);\\n      for (int i = nums.length - 1; i >= nums.length - k + 1; --i) {\\n          swap(nums, 0, i);\\n          --heapSize;\\n          maxHeapify(nums, 0, heapSize);\\n      }\\n      return nums[0];\\n  }\\n\\n  public void buildMaxHeap(int[] a, int heapSize) {\\n      for (int i = heapSize / 2; i >= 0; --i) {\\n          maxHeapify(a, i, heapSize);\\n      } \\n  }\\n\\n  public void maxHeapify(int[] a, int i, int heapSize) {\\n      int l = i * 2 + 1, r = i * 2 + 2, largest = i;\\n      if (l < heapSize && a[l] > a[largest]) {\\n          largest = l;\\n      } \\n      if (r < heapSize && a[r] > a[largest]) {\\n          largest = r;\\n      }\\n      if (largest != i) {\\n          swap(a, i, largest);\\n          maxHeapify(a, largest, heapSize);\\n      }\\n  }\\n\\n  public void swap(int[] a, int i, int j) {\\n      int temp = a[i];\\n      a[i] = a[j];\\n      a[j] = temp;\\n  }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\n\\n\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        import heapq\\n\\n        return heapq.nlargest(k, nums)[-1]\\n\\n\"}]},{\"title\":\"代码14.2.4\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int quickSelect(vector<int>& a, int l, int r, int index) {\\n        int q = randomPartition(a, l, r);\\n        if (q == index) {\\n            return a[q];\\n        } else {\\n            return q < index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);\\n        }\\n    }\\n\\n    inline int randomPartition(vector<int>& a, int l, int r) {\\n        int i = rand() % (r - l + 1) + l;\\n        swap(a[i], a[r]);\\n        return partition(a, l, r);\\n    }\\n\\n    inline int partition(vector<int>& a, int l, int r) {\\n        int x = a[r], i = l - 1;\\n        for (int j = l; j < r; ++j) {\\n            if (a[j] <= x) {\\n                swap(a[++i], a[j]);\\n            }\\n        }\\n        swap(a[i + 1], a[r]);\\n        return i + 1;\\n    }\\n\\n    int findKthLargest(vector<int>& nums, int k) {\\n        srand(time(0));\\n        return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  Random random = new Random();\\n\\n  public int findKthLargest(int[] nums, int k) {\\n      return quickSelect(nums, 0, nums.length - 1, nums.length - k);\\n  }\\n\\n  public int quickSelect(int[] a, int l, int r, int index) {\\n      int q = randomPartition(a, l, r);\\n      if (q == index) {\\n          return a[q];\\n      } else {\\n          return q < index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);\\n      }\\n  }\\n\\n  public int randomPartition(int[] a, int l, int r) {\\n      int i = random.nextInt(r - l + 1) + l;\\n      swap(a, i, r);\\n      return partition(a, l, r);\\n  }\\n\\n  public int partition(int[] a, int l, int r) {\\n      int x = a[r], i = l - 1;\\n      for (int j = l; j < r; ++j) {\\n          if (a[j] <= x) {\\n              swap(a, ++i, j);\\n          }\\n      }\\n      swap(a, i + 1, r);\\n      return i + 1;\\n  }\\n\\n  public void swap(int[] a, int i, int j) {\\n      int temp = a[i];\\n      a[i] = a[j];\\n      a[j] = temp;\\n  }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\nimport random\\n\\n\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return self.select(nums, 0, len(nums) - 1, len(nums) - k)\\n\\n    def select(self, nums: List[int], left: int, right: int, k_smallest: int) -> int:\\n        if left == right:\\n            # 如果只有一个元素，则最左边的元素即是答案\\n            return nums[left]\\n        # 随机获取一个 [left, right] 范围的整数\\n        pivot_index = random.randint(left, right)\\n        # 根据 pivot = nums[pivot_index] 进行划分，得到新的 pivot_index，此时 pivot_index 左边的都小于等于 pivot，右边的都大于等于 pivot\\n        pivot_index = self.partition(nums, left, right, pivot_index)\\n        if k_smallest == pivot_index:\\n            # 如果此时 N - K == pivot_index，表示我们已经找到第 N-K+1 小元素，即第 K 大元素。这也就是我们前面所说的可以直接解决的子问题\\n            return nums[k_smallest]\\n        elif k_smallest < pivot_index:\\n            return self.select(nums, left, pivot_index - 1, k_smallest)\\n        else:\\n            return self.select(nums, pivot_index + 1, right, k_smallest)\\n\\n    def partition(self, nums: List[int], left: int, right: int, pivot_index: int):\\n        i = left\\n        j = right + 1\\n        pivot = nums[pivot_index]\\n        nums[pivot_index], nums[left] = nums[left], nums[pivot_index]\\n\\n        while True:\\n            while True:\\n                i += 1\\n                if i == right or nums[i] >= pivot:\\n                    break\\n            while True:\\n                j -= 1\\n                if j == left or nums[j] <= pivot:\\n                    break\\n            if i >= j:\\n                break\\n            nums[i], nums[j] = nums[j], nums[i]\\n        nums[left], nums[j] = nums[j], nums[left]\\n        return j\\n\\n\"}]},{\"title\":\"代码14.2.5\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int quickSelect(vector<int>& a, int l, int r, int index) {\\n        int q = randomPartition(a, l, r);\\n        if (q == index) {\\n            return a[q];\\n        } else {\\n            return q < index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);\\n        }\\n    }\\n\\n    inline int randomPartition(vector<int>& a, int l, int r) {\\n        int i = rand() % (r - l + 1) + l;\\n        swap(a[i], a[r]);\\n        return partition(a, l, r);\\n    }\\n\\n    inline int partition(vector<int>& a, int l, int r) {\\n        int x = a[r], i = l - 1;\\n        for (int j = l; j < r; ++j) {\\n            if (a[j] <= x) {\\n                swap(a[++i], a[j]);\\n            }\\n        }\\n        swap(a[i + 1], a[r]);\\n        return i + 1;\\n    }\\n\\n    int findKthLargest(vector<int>& nums, int k) {\\n        srand(time(0));\\n        return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  Random random = new Random();\\n\\n  public int findKthLargest(int[] nums, int k) {\\n      return quickSelect(nums, 0, nums.length - 1, nums.length - k);\\n  }\\n\\n  public int quickSelect(int[] a, int l, int r, int index) {\\n      int q = randomPartition(a, l, r);\\n      if (q == index) {\\n          return a[q];\\n      } else {\\n          return q < index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);\\n      }\\n  }\\n\\n  public int randomPartition(int[] a, int l, int r) {\\n      int i = random.nextInt(r - l + 1) + l;\\n      swap(a, i, r);\\n      return partition(a, l, r);\\n  }\\n\\n  public int partition(int[] a, int l, int r) {\\n      int x = a[r], i = l - 1;\\n      for (int j = l; j < r; ++j) {\\n          if (a[j] <= x) {\\n              swap(a, ++i, j);\\n          }\\n      }\\n      swap(a, i + 1, r);\\n      return i + 1;\\n  }\\n\\n  public void swap(int[] a, int i, int j) {\\n      int temp = a[i];\\n      a[i] = a[j];\\n      a[j] = temp;\\n  }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\nimport random\\n\\n\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return self.select(nums, 0, len(nums) - 1, len(nums) - k)\\n\\n    def select(self, nums: List[int], left: int, right: int, k_smallest: int) -> int:\\n        while left < right:\\n            pivot_index = random.randint(left, right)\\n            pivot_index = self.partition(nums, left, right, pivot_index)\\n            if k_smallest == pivot_index:\\n                return nums[k_smallest]\\n            elif k_smallest < pivot_index:\\n                right = pivot_index - 1\\n            else:\\n                left = pivot_index + 1\\n\\n        if left == right:\\n            return nums[left]\\n\\n    def partition(self, nums: List[int], left: int, right: int, pivot_index: int):\\n        i = left\\n        j = right + 1\\n        pivot = nums[pivot_index]\\n        nums[pivot_index], nums[left] = nums[left], nums[pivot_index]\\n\\n        while True:\\n            while True:\\n                i += 1\\n                if i == right or nums[i] >= pivot:\\n                    break\\n            while True:\\n                j -= 1\\n                if j == left or nums[j] <= pivot:\\n                    break\\n            if i >= j:\\n                break\\n            nums[i], nums[j] = nums[j], nums[i]\\n        nums[left], nums[j] = nums[j], nums[left]\\n        return j\\n\\n\"}]},{\"title\":\"代码14.3.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for(int i = 0; i < matrix.size(); i++)\\n            for(int j = 0; j < matrix[0].size(); j++) {\\n                if(matrix[i][j] == target) return true;\\n            }\\n        return false;\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  public boolean searchMatrix(int[][] matrix, int target) {\\n      for (int i = 0; i < matrix.length; i++) {\\n          for (int j = 0; j < matrix[0].length; j++) {\\n              if (matrix[i][j] == target) {\\n                  return true;\\n              }\\n          }\\n      }\\n\\n      return false;\\n  }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        \\\"\\\"\\\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        if not matrix or not matrix[0]:\\n            return False\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == target:\\n                    return True\\n\\n        return False\\n\\n\"}]},{\"title\":\"代码14.3.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for(int i = 0; i < matrix.size(); i++)\\n            for(int j = 0; j < matrix[0].size(); j++) {\\n                if(matrix[i][j] == target) return true;\\n            }\\n        return false;\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  public boolean searchMatrix(int[][] matrix, int target) {\\n      for (int i = 0; i < matrix.length; i++) {\\n          for (int j = 0; j < matrix[0].length; j++) {\\n              if (matrix[i][j] == target) {\\n                  return true;\\n              }\\n          }\\n      }\\n\\n      return false;\\n  }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        \\\"\\\"\\\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n\\n        def binarySearch(arr: List[List[int]], target: int) -> bool:\\n            lo = 0\\n            hi = len(arr) - 1\\n            while lo <= hi:\\n                mid = lo + (hi - lo) // 2\\n                if arr[mid] == target:\\n                    return True\\n                elif arr[mid] < target:\\n                    lo = mid + 1\\n                else:\\n                    hi = mid - 1\\n\\n            return False\\n\\n        if not matrix or not matrix[0]:\\n            return False\\n\\n        m = len(matrix)\\n\\n        for i in range(m):\\n            if binarySearch(matrix[i], target):\\n                return True\\n\\n        return False\\n\\n\"}]},{\"title\":\"代码14.3.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.size() == 0 || matrix[0].size() == 0) return false;\\n        int i = matrix.size() - 1;\\n        int j = 0;\\n        while(i >= 0 && j < matrix[0].size()){\\n            if(matrix[i][j] > target)\\n                --i;\\n            else if(matrix[i][j] < target)\\n                ++j;\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  private boolean binarySearch(int[][] matrix, int target, int start, boolean vertical) {\\n      int lo = start;\\n      int hi = vertical ? matrix[0].length-1 : matrix.length-1;\\n\\n      while (hi >= lo) {\\n          int mid = (lo + hi)/2;\\n          if (vertical) { // searching a column\\n              if (matrix[start][mid] < target) {\\n                  lo = mid + 1;\\n              } else if (matrix[start][mid] > target) {\\n                  hi = mid - 1;\\n              } else {\\n                  return true;\\n              }\\n          } else { // searching a row\\n              if (matrix[mid][start] < target) {\\n                  lo = mid + 1;\\n              } else if (matrix[mid][start] > target) {\\n                  hi = mid - 1;\\n              } else {\\n                  return true;\\n              }\\n          }\\n      }\\n\\n      return false;\\n  }\\n\\n  public boolean searchMatrix(int[][] matrix, int target) {\\n      // an empty matrix obviously does not contain `target`\\n      if (matrix == null || matrix.length == 0) {\\n          return false;\\n      }\\n\\n      // iterate over matrix diagonals\\n      int shorterDim = Math.min(matrix.length, matrix[0].length);\\n      for (int i = 0; i < shorterDim; i++) {\\n          boolean verticalFound = binarySearch(matrix, target, i, true);\\n          boolean horizontalFound = binarySearch(matrix, target, i, false);\\n          if (verticalFound || horizontalFound) {\\n              return true;\\n          }\\n      }\\n      \\n      return false; \\n  }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\nclass Solution:\\n    def binary_search(self, matrix: List[List[int]], target: int, start: int, vertical: bool) -> bool:\\n        lo = start\\n        hi = len(matrix[0]) - 1 if vertical else len(matrix) - 1\\n\\n        while lo <= hi:\\n            mid = lo + (hi - lo) // 2\\n            if vertical:\\n                if matrix[start][mid] < target:\\n                    lo = mid + 1\\n                elif matrix[start][mid] > target:\\n                    hi = mid - 1\\n                else:\\n                    return True\\n            else:\\n                if matrix[mid][start] < target:\\n                    lo = mid + 1\\n                elif matrix[mid][start] > target:\\n                    hi = mid - 1\\n                else:\\n                    return True\\n\\n        return False\\n\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix:\\n            return False\\n\\n        minLen = min(len(matrix), len(matrix[0]))\\n        for i in range(minLen):\\n            vertical_found = self.binary_search(matrix, target, i, True)\\n            horizontal_found = self.binary_search(matrix, target, i, False)\\n            if vertical_found or horizontal_found:\\n                return True\\n\\n        return False\\n\\n\"}]},{\"title\":\"代码14.3.4\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.size() == 0 || matrix[0].size() == 0) return false;\\n        int i = matrix.size() - 1;\\n        int j = 0;\\n        while(i >= 0 && j < matrix[0].size()){\\n            if(matrix[i][j] > target)\\n                --i;\\n            else if(matrix[i][j] < target)\\n                ++j;\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  private int[][] matrix;\\n  private int target;\\n\\n  private boolean searchRec(int left, int up, int right, int down) {\\n      // this submatrix has no height or no width.\\n      if (left > right || up > down) {\\n          return false;\\n      // `target` is already larger than the largest element or smaller\\n      // than the smallest element in this submatrix.\\n      } else if (target < matrix[up][left] || target > matrix[down][right]) {\\n          return false;\\n      }\\n\\n      int mid = left + (right-left)/2;\\n\\n      // Locate `row` such that matrix[row-1][mid] < target < matrix[row][mid]\\n      int row = up;\\n      while (row <= down && matrix[row][mid] <= target) {\\n          if (matrix[row][mid] == target) {\\n              return true;\\n          }\\n          row++;\\n      }\\n\\n      return searchRec(left, row, mid-1, down) || searchRec(mid+1, up, right, row-1);\\n  }\\n\\n  public boolean searchMatrix(int[][] mat, int targ) {\\n      // cache input values in object to avoid passing them unnecessarily\\n      // to `searchRec`\\n      matrix = mat;\\n      target = targ;\\n\\n      // an empty matrix obviously does not contain `target`\\n      if (matrix == null || matrix.length == 0) {\\n          return false;\\n      }\\n\\n      return searchRec(0, 0, matrix[0].length-1, matrix.length-1);\\n  }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix:\\n            return False\\n\\n        def search_rec(left, up, right, down):\\n            # 空矩阵\\n            if left > right or up > down:\\n                return False\\n            # 目标值大于矩阵右下角元素或者小于左上角元素\\n            elif target < matrix[up][left] or target > matrix[down][right]:\\n                return False\\n\\n            mid = left + (right - left) // 2\\n\\n            # 定位 row，来使 matrix[row-1][mid] < target < matrix[row][mid]\\n            row = up\\n            while row <= down and matrix[row][mid] <= target:\\n                if matrix[row][mid] == target:\\n                    return True\\n                row += 1\\n\\n            return search_rec(left, row, mid - 1, down) or search_rec(\\n                mid + 1, up, right, row - 1\\n            )\\n\\n        return search_rec(0, 0, len(matrix[0]) - 1, len(matrix) - 1)\\n\\n\"}]},{\"title\":\"代码14.3.5\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.size() == 0 || matrix[0].size() == 0) return false;\\n        int i = matrix.size() - 1;\\n        int j = 0;\\n        while(i >= 0 && j < matrix[0].size()){\\n            if(matrix[i][j] > target)\\n                --i;\\n            else if(matrix[i][j] < target)\\n                ++j;\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  public boolean searchMatrix(int[][] matrix, int target) {\\n      // start our \\\"pointer\\\" in the bottom-left\\n      int row = matrix.length-1;\\n      int col = 0;\\n\\n      while (row >= 0 && col < matrix[0].length) {\\n          if (matrix[row][col] > target) {\\n              row--;\\n          } else if (matrix[row][col] < target) {\\n              col++;\\n          } else { // found it\\n              return true;\\n          }\\n      }\\n\\n      return false;\\n  }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if not matrix:\\n            return False\\n\\n        # 也就是找到第一个大于target的位置\\n        def binarySearch(matrix: List[List[int]], up: int, down: int, col: int, target: int) -> List:\\n            lo = up\\n            hi = down + 1\\n            while lo < hi:\\n                mid = lo + (hi - lo) // 2\\n                if matrix[mid][col] == target:\\n                    return [True, mid]\\n                elif matrix[mid][col] < target:\\n                    lo = mid + 1\\n                else:\\n                    hi = mid\\n\\n            return [False, lo]\\n\\n        def search_rec(left: int, up: int, right: int, down: int) -> bool:\\n            # 空矩阵\\n            if left > right or up > down:\\n                return False\\n            # 目标值大于矩阵右下角元素或者小于左上角元素\\n            elif target < matrix[up][left] or target > matrix[down][right]:\\n                return False\\n\\n            mid = left + (right - left) // 2\\n\\n            # 定位 row，来使 matrix[row-1][mid] < target < matrix[row][mid]\\n            find, row = binarySearch(matrix, up, down, mid, target)\\n\\n            return (\\n                find\\n                or search_rec(left, row, mid - 1, down)\\n                or search_rec(mid + 1, up, right, row - 1)\\n            )\\n\\n        return search_rec(0, 0, len(matrix[0]) - 1, len(matrix) - 1)\\n\\n\"}]},{\"title\":\"代码14.3.6\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.size() == 0 || matrix[0].size() == 0) return false;\\n        int i = matrix.size() - 1;\\n        int j = 0;\\n        while(i >= 0 && j < matrix[0].size()){\\n            if(matrix[i][j] > target)\\n                --i;\\n            else if(matrix[i][j] < target)\\n                ++j;\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  public boolean searchMatrix(int[][] matrix, int target) {\\n      // start our \\\"pointer\\\" in the bottom-left\\n      int row = matrix.length-1;\\n      int col = 0;\\n\\n      while (row >= 0 && col < matrix[0].length) {\\n          if (matrix[row][col] > target) {\\n              row--;\\n          } else if (matrix[row][col] < target) {\\n              col++;\\n          } else { // found it\\n              return true;\\n          }\\n      }\\n\\n      return false;\\n  }\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from typing import List\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int):\\n        if len(matrix) == 0 or len(matrix[0]) == 0:\\n            return False\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        row = m - 1\\n        col = 0\\n\\n        while col < n and row >= 0:\\n            if matrix[row][col] > target:\\n                row -= 1\\n            elif matrix[row][col] < target:\\n                col += 1\\n            else:\\n                return True\\n\\n        return False\\n\\n\"}]}]},{\"id\":\"15\",\"name\":\"第十五章\",\"list\":[{\"title\":\"代码15.1.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\r\\npublic:\\r\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\r\\n        // 对孩子胃口以及饼干排序\\r\\n        sort(g.begin(), g.end());\\r\\n        sort(s.begin(), s.end());\\r\\n        int ans = 0;\\r\\n        // 饼干下标\\r\\n        int idx = 0;\\r\\n        // 遍历每个孩子\\r\\n        for (int i = 0; i < g.size(); i++) {\\r\\n            // 遍历剩余的饼干\\r\\n            while (idx < s.size()) {\\r\\n                if (s[idx] >= g[i]) {\\r\\n                    ans += 1;\\r\\n                    idx += 1;\\r\\n                    break;\\r\\n                } else {\\r\\n                    idx += 1;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\r\\n    public int findContentChildren(int[] g, int[] s) {\\r\\n        // 对孩子胃口以及饼干排序\\r\\n        Arrays.sort(g);\\r\\n        Arrays.sort(s);\\r\\n        int ans = 0;\\r\\n        // 饼干下标\\r\\n        int idx = 0;\\r\\n        // 遍历每个孩子\\r\\n        for (int i = 0; i < g.length; i++) {\\r\\n            // 遍历剩余的饼干\\r\\n            while (idx < s.length) {\\r\\n                if (s[idx] >= g[i]) {\\r\\n                    ans += 1;\\r\\n                    idx += 1;\\r\\n                    break;\\r\\n                } else {\\r\\n                    idx += 1;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        # 对孩子胃口以及饼干排序\\n        g.sort()\\n        s.sort()\\n        ans = 0\\n        # 饼干下标\\n        idx = 0\\n        # 遍历每个孩子\\n        for i in range(len(g)):\\n            # 遍历剩余的饼干\\n            while idx < len(s):\\n                if s[idx] >= g[i]:\\n                    ans += 1\\n                    idx += 1\\n                    break\\n                else:\\n                    idx += 1\\n        return ans\\n\\n\"}]},{\"title\":\"代码15.2.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\r\\npublic:\\r\\n    bool canJump(vector<int>& nums) {\\r\\n        bool dp[nums.size()];\\r\\n        memset(dp, false, sizeof(dp));\\r\\n        dp[0] = true;\\r\\n        for (int i = 1; i < nums.size(); i++) {\\r\\n            for (int j = 0; j < i; j++) {\\r\\n                if (j + nums[j] >= i) {\\r\\n                    dp[i] = dp[i] | dp[j];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return dp[nums.size() - 1];\\r\\n    }\\r\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\r\\n    public boolean canJump(int[] nums) {\\r\\n        boolean[] dp = new boolean[nums.length];\\r\\n        dp[0] = true;\\r\\n        for (int i = 1; i < nums.length; i++) {\\r\\n            for (int j = 0; j < i; j++) {\\r\\n                if (j + nums[j] >= i) {\\r\\n                    dp[i] = dp[i] | dp[j];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return dp[nums.length - 1];\\r\\n    }\\r\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        dp = [False] * len(nums)\\n        dp[0] = True\\n        for i in range(1, len(nums)):\\n            for j in range(0, i):\\n                if j + nums[j] >= i:\\n                    dp[i] = dp[i] | dp[j]\\n        return dp[len(nums) - 1]\\n\\n\"}]},{\"title\":\"代码15.2.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\r\\npublic:\\r\\n    bool canJump(vector<int>& nums) {\\r\\n        int n = nums.size();\\r\\n        int dp[n];\\r\\n        memset(dp, 0, sizeof(dp));\\r\\n        dp[0] = nums[0];\\r\\n        for (int i = 1; i < n; i++) {\\r\\n            if (dp[i - 1] < i) {\\r\\n                dp[i] = dp[i - 1];\\r\\n            } else {\\r\\n                if (dp[i - 1] > i + nums[i]) {\\r\\n                    dp[i] = dp[i - 1];\\r\\n                } else {\\r\\n                    dp[i] = i + nums[i];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return dp[n - 1] >= n - 1;\\r\\n    }\\r\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\r\\n    public boolean canJump(int[] nums) {\\r\\n        int n = nums.length;\\r\\n        int[] dp = new int[n];\\r\\n        dp[0] = nums[0];\\r\\n        for (int i = 1; i < n; i++) {\\r\\n            if (dp[i - 1] < i) {\\r\\n                dp[i] = dp[i - 1];\\r\\n            } else {\\r\\n                dp[i] = Math.max(dp[i - 1], i + nums[i]);\\r\\n            }\\r\\n        }\\r\\n        return dp[n - 1] >= n - 1;\\r\\n    }\\r\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\r\\n    def canJump(self, nums: List[int]) -> bool:\\r\\n        n = len(nums)\\r\\n        dp = [0] * n\\r\\n        dp[0] = nums[0]\\r\\n        for i in range(1, n):\\r\\n            if dp[i - 1] < i:\\r\\n                dp[i] = dp[i - 1]\\r\\n            else:\\r\\n                dp[i] = max(dp[i - 1], i + nums[i])\\r\\n        return dp[n - 1] >= n - 1\\r\\n\\n\"}]},{\"title\":\"代码15.2.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\r\\npublic:\\r\\n    bool canJump(vector<int>& nums) {\\r\\n        int begin = 0, end = 0;\\r\\n        while (true) {\\r\\n            // 下次考虑的最远位置\\r\\n            int next_end = end;\\r\\n            // min(end + 1, len(nums)) 防止越界\\r\\n            int limit = end + 1;\\r\\n            if (nums.size() < limit) {\\r\\n                limit = nums.size();\\r\\n            }\\r\\n            for (int i = begin; i < limit; i++) {\\r\\n                if (next_end > i + nums[i]) {\\r\\n                    next_end = next_end;\\r\\n                } else {\\r\\n                    next_end = i + nums[i];\\r\\n                }\\r\\n            }\\r\\n            if (next_end == end) {\\r\\n                break;\\r\\n            }\\r\\n            begin = end + 1;\\r\\n            end = next_end;\\r\\n        }\\r\\n        return end >= nums.size() - 1;\\r\\n    }\\r\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\r\\n    public boolean canJump(int[] nums) {\\r\\n        int begin = 0, end = 0;\\r\\n        while (true) {\\r\\n            // 下次考虑的最远位置\\r\\n            int next_end = end;\\r\\n            // min(end + 1, len(nums)) 防止越界\\r\\n            for (int i = begin; i < Math.min(end + 1, nums.length); i++) {\\r\\n                next_end = Math.max(next_end, i + nums[i]);\\r\\n            }\\r\\n            if (next_end == end) {\\r\\n                break;\\r\\n            }\\r\\n            begin = end + 1;\\r\\n            end = next_end;\\r\\n        }\\r\\n        return end >= nums.length - 1;\\r\\n    }\\r\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        # 可跳跃范围\\n        begin, end = 0, 0\\n        # 下次考虑的最远位置，终点位置\\n        next_end = end, target = len(nums) - 1\\n        while next_end < target:\\n            # min(end + 1, len(nums)) 防止越界\\n            for i in range(begin, min(end + 1, len(nums))):\\n                next_end = max(next_end, i + nums[i])\\n            # 范围不发生变化，终点不可达\\n            if next_end == end:\\n                return False\\n            begin, end = end + 1, next_end\\n        return True\\n\\n\"}]},{\"title\":\"代码15.3.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\r\\npublic\\r\\n    int candy(int[] ratings) {\\r\\n        int n = ratings.length;\\r\\n        int[] left_ans = new int[n];\\r\\n        int[] right_ans = new int[n];\\r\\n        Arrays.fill(left_ans, 1);\\r\\n        Arrays.fill(right_ans, 1);\\r\\n        int ans = 0;\\r\\n        // 考虑左相邻孩子条件\\r\\n        for (int i = 1; i < n; i++) {\\r\\n            if (ratings[i] > ratings[i - 1]) {\\r\\n                left_ans[i] = left_ans[i - 1] + 1;\\r\\n            }\\r\\n        }\\r\\n        // 考虑右相邻孩子条件\\r\\n        for (int i = n - 2; i >= 0; i--) {\\r\\n            if (ratings[i] > ratings[i + 1]) {\\r\\n                right_ans[i] = right_ans[i + 1] + 1;\\r\\n            }\\r\\n        }\\r\\n        // 合并两个条件结果\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            ans += Math.max(left_ans[i], right_ans[i]);\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n}\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\r\\n    public int candy(int[] ratings) {\\r\\n        int n = ratings.length;\\r\\n        int[] left_ans = new int[n];\\r\\n        int[] right_ans = new int[n];\\r\\n        Arrays.fill(left_ans, 1);\\r\\n        Arrays.fill(right_ans, 1);\\r\\n        int ans = 0;\\r\\n        // 考虑左相邻孩子条件\\r\\n        for (int i = 1; i < n; i++) {\\r\\n            if (ratings[i] > ratings[i - 1]) {\\r\\n                left_ans[i] = left_ans[i - 1] + 1;\\r\\n            }\\r\\n        }\\r\\n        // 考虑右相邻孩子条件\\r\\n        for (int i = n - 2; i >= 0; i--) {\\r\\n            if (ratings[i] > ratings[i + 1]) {\\r\\n                right_ans[i] = right_ans[i + 1] + 1;\\r\\n            }\\r\\n        }\\r\\n        // 合并两个条件结果\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            ans += Math.max(left_ans[i], right_ans[i]);\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def leastInterval(self, tasks: List[str], n: int) -> int:\\n        t_map = [0] * 26\\n        for t in tasks:\\n            t_map[ord(t) - ord(\\\"A\\\")] += 1\\n        t_map.sort()\\n        # max_num 为最高次数，cnt 为最高次数的任务种类\\n        max_num, cnt = t_map[25], 0\\n        for i in range(26):\\n            if t_map[i] == max_num:\\n                cnt += 1\\n        return max((max_num - 1) * (n + 1) + cnt, len(tasks))\\n\\n\"}]},{\"title\":\"代码15.4.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\npublic:\\n    int candy(vector<int>& ratings) {\\n        int n = ratings.size();\\n        vector<int> left_ans(n, 1);\\n        vector<int> right_ans(n, 1);\\n        int ans = 0;\\n        // 考虑左相邻孩子条件\\n        for (int i = 1; i < n; i++) {\\n            if (ratings[i] > ratings[i - 1]) {\\n                left_ans[i] = left_ans[i - 1] + 1;\\n            }\\n        }\\n        // 考虑右相邻孩子条件\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (ratings[i] > ratings[i + 1]) {\\n                right_ans[i] = right_ans[i + 1] + 1;\\n            }\\n        }\\n        // 合并两个条件结果\\n        for (int i = 0; i < n; i++) {\\n            cout << left_ans[i] << \\\":\\\" << right_ans[i] << endl;\\n            if (left_ans[i] > right_ans[i]) {\\n                ans += left_ans[i];\\n            } else {\\n                ans += right_ans[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\r\\n    public int candy(int[] ratings) {\\r\\n        int n = ratings.length;\\r\\n        int[] left_ans = new int[n];\\r\\n        int[] right_ans = new int[n];\\r\\n        Arrays.fill(left_ans, 1);\\r\\n        Arrays.fill(right_ans, 1);\\r\\n        int ans = 0;\\r\\n        // 考虑左相邻孩子条件\\r\\n        for (int i = 1; i < n; i++) {\\r\\n            if (ratings[i] > ratings[i - 1]) {\\r\\n                left_ans[i] = left_ans[i - 1] + 1;\\r\\n            }\\r\\n        }\\r\\n        // 考虑右相邻孩子条件\\r\\n        for (int i = n - 2; i >= 0; i--) {\\r\\n            if (ratings[i] > ratings[i + 1]) {\\r\\n                right_ans[i] = right_ans[i + 1] + 1;\\r\\n            }\\r\\n        }\\r\\n        // 合并两个条件结果\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            ans += Math.max(left_ans[i], right_ans[i]);\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        left_ans, right_ans = [1] * len(ratings), [1] * len(ratings)\\n        ans = 0\\n        # 考虑左相邻孩子条件\\n        for i in range(1, len(ratings)):\\n            if ratings[i] > ratings[i - 1]:\\n                left_ans[i] = left_ans[i - 1] + 1\\n        # 考虑右相邻孩子条件\\n        for i in range(len(ratings) - 2, -1, -1):\\n            if ratings[i] > ratings[i + 1]:\\n                right_ans[i] = right_ans[i + 1] + 1\\n        # 合并两个条件结果\\n        for i in range(0, len(ratings)):\\n            ans += max(left_ans[i], right_ans[i])\\n        return ans\\n\\n\"}]}]},{\"id\":\"16\",\"name\":\"第十六章\",\"list\":[{\"title\":\"代码16.1.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\r\\npublic:\\r\\n    vector<vector<int>> ans;\\r\\n    vector<int> path;\\r\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\r\\n        dfs(candidates, 0, target);\\r\\n        return ans;\\r\\n    }\\r\\n    void dfs(vector<int>& candidates, int idx, int cur) {\\r\\n        // 递归结束\\r\\n        if (cur == 0) {\\r\\n            // 克隆 path 并添加到 ans\\r\\n            ans.push_back(vector<int>(path));\\r\\n            return;\\r\\n        } else if (idx == candidates.size()) {\\r\\n            return;\\r\\n        }\\r\\n        // 1.加入这个数字\\r\\n        if (candidates[idx] <= cur) {\\r\\n            path.push_back(candidates[idx]);\\r\\n            // idx 不变，继续考虑当前数字\\r\\n            dfs(candidates, idx, cur - candidates[idx]);\\r\\n            // 消除影响\\r\\n            path.pop_back();\\r\\n        }\\r\\n        // 2.不加入这个数字，考虑下一个数字\\r\\n        dfs(candidates, idx + 1, cur);\\r\\n    }\\r\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\r\\n    List<List<Integer>> ans = new ArrayList<>();\\r\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\r\\n        dfs(candidates, 0, target, new ArrayList<>());\\r\\n        return ans;\\r\\n    }\\r\\n    public void dfs(int[] candidates, int idx, int cur, List<Integer> path) {\\r\\n        // 递归结束\\r\\n        if (cur == 0) {\\r\\n            // 克隆 path 并添加到 ans\\r\\n            ans.add(new ArrayList<>(path));\\r\\n            return;\\r\\n        } else if (idx == candidates.length) {\\r\\n            return;\\r\\n        }\\r\\n        // 1.加入这个数字\\r\\n        if (candidates[idx] <= cur) {\\r\\n            path.add(candidates[idx]);\\r\\n            // idx 不变，继续考虑当前数字\\r\\n            dfs(candidates, idx, cur - candidates[idx], path);\\r\\n            // 消除影响\\r\\n            path.remove(path.size() - 1);\\r\\n        }\\r\\n        // 2.不加入这个数字，考虑下一个数字\\r\\n        dfs(candidates, idx + 1, cur, path);\\r\\n    }\\r\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans = []\\n        n = len(candidates)\\n\\n        def dfs(idx: int, cur: int, path: List[int]):\\n            # 递归结束\\n            if cur == 0:\\n                # 克隆 path 并添加到 ans\\n                ans.append(path[:])\\n                return\\n            elif idx == n:\\n                return\\n            # 1.加入这个数字\\n            if candidates[idx] <= cur:\\n                path.append(candidates[idx])\\n                # idx 不变，继续考虑当前数字\\n                dfs(idx, cur - candidates[idx], path)\\n                # 消除影响\\n                path.pop()\\n            # 2.不加入这个数字，考虑下一个数字\\n            dfs(idx + 1, cur, path)\\n\\n        dfs(0, target, [])\\n        return ans\\n\\n\"}]},{\"title\":\"代码16.2.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\r\\npublic:\\r\\n    vector<vector<int>> ans;\\r\\n    set<int> visited;\\r\\n    vector<int> path;\\r\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\r\\n        sort(candidates.begin(), candidates.end());\\r\\n        dfs(candidates, 0, target);\\r\\n        return ans;\\r\\n    }\\r\\n    void dfs(vector<int>& candidates, int idx, int cur) {\\r\\n        if (cur == 0) {\\r\\n            ans.push_back(vector<int>(path));\\r\\n            return;\\r\\n        } else if (idx == candidates.size()) {\\r\\n            return;\\r\\n        }\\r\\n        // 当前数字与前面数字相同并且前面数字没有在路径中，则忽略这个数字\\r\\n        if (idx != 0 && candidates[idx] == candidates[idx - 1] && !visited.count(idx - 1)) {\\r\\n            dfs(candidates, idx + 1, cur);\\r\\n            return;\\r\\n        }\\r\\n        // 1.加入这个数字\\r\\n        if (candidates[idx] <= cur) {\\r\\n            path.push_back(candidates[idx]);\\r\\n            visited.insert(idx);\\r\\n            // 向下递归时考虑下一个数字\\r\\n            dfs(candidates, idx + 1, cur - candidates[idx]);\\r\\n            // 消除影响\\r\\n            path.pop_back();\\r\\n            visited.erase(idx);\\r\\n        }\\r\\n        // 2.不加入这个数字\\r\\n        dfs(candidates, idx + 1, cur);\\r\\n    }\\r\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\r\\n    List<List<Integer>> ans = new ArrayList<>();\\r\\n    Set<Integer> visited = new HashSet<>();\\r\\n    List<Integer> path = new ArrayList<>();\\r\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\r\\n        Arrays.sort(candidates);\\r\\n        dfs(candidates, 0, target);\\r\\n        return ans;\\r\\n    }\\r\\n    public void dfs(int[] candidates, int idx, int cur) {\\r\\n        if (cur == 0) {\\r\\n            ans.add(new ArrayList<>(path));\\r\\n            return;\\r\\n        } else if (idx == candidates.length) {\\r\\n            return;\\r\\n        }\\r\\n        // 当前数字与前面数字相同并且前面数字没有在路径中，则忽略这个数字\\r\\n        if (idx != 0 && candidates[idx] == candidates[idx - 1] && !visited.contains(idx - 1)) {\\r\\n            dfs(candidates, idx + 1, cur);\\r\\n            return;\\r\\n        }\\r\\n        // 1.加入这个数字\\r\\n        if (candidates[idx] <= cur) {\\r\\n            path.add(candidates[idx]);\\r\\n            visited.add(idx);\\r\\n            // 向下递归时考虑下一个数字\\r\\n            dfs(candidates, idx + 1, cur - candidates[idx]);\\r\\n            // 消除影响\\r\\n            path.remove(path.size() - 1);\\r\\n            visited.remove(idx);\\r\\n        }\\r\\n        // 2.不加入这个数字\\r\\n        dfs(candidates, idx + 1, cur);\\r\\n    }\\r\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans = []\\n        n = len(candidates)\\n        visited = set()\\n        candidates.sort()\\n\\n        def dfs(idx: int, cur: int, path: List[int]):\\n            if cur == 0:\\n                ans.append(path[:])\\n                return\\n            elif idx == n:\\n                return\\n            # 当前数字与前面数字相同并且前面数字没有在路径中，则忽略这个数字\\n            if (\\n                idx != 0\\n                and candidates[idx] == candidates[idx - 1]\\n                and (idx - 1) not in visited\\n            ):\\n                dfs(idx + 1, cur, path)\\n                return\\n            # 1.加入这个数字\\n            if candidates[idx] <= cur:\\n                path.append(candidates[idx])\\n                visited.add(idx)\\n                # 向下递归时考虑下一个数字\\n                dfs(idx + 1, cur - candidates[idx], path)\\n                # 消除影响\\n                path.pop()\\n                visited.remove(idx)\\n            # 2.不加入这个数字\\n            dfs(idx + 1, cur, path)\\n\\n        dfs(0, target, [])\\n        return ans\\n\\n\"}]},{\"title\":\"代码16.3.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\r\\npublic:\\r\\n    vector<vector<int>> ans;\\r\\n    vector<int> path;\\r\\n    vector<vector<int>> subsets(vector<int>& nums) {\\r\\n        dfs(nums, 0);\\r\\n        return ans;\\r\\n    }\\r\\n    void dfs(vector<int>& nums, int idx) {\\r\\n        if (idx == nums.size()) {\\r\\n            ans.push_back(vector<int>(path));\\r\\n            return;\\r\\n        }\\r\\n        path.push_back(nums[idx]);\\r\\n        dfs(nums, idx + 1);\\r\\n        path.pop_back();\\r\\n        dfs(nums, idx + 1);\\r\\n    }\\r\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\r\\n    List<List<Integer>> ans = new ArrayList<>();\\r\\n    public List<List<Integer>> subsets(int[] nums) {\\r\\n        dfs(nums, 0, new ArrayList<>());\\r\\n        return ans;\\r\\n    }\\r\\n    public void dfs(int[] nums, int idx, List<Integer> path) {\\r\\n        if (idx == nums.length) {\\r\\n            ans.add(new ArrayList<>(path));\\r\\n            return;\\r\\n        }\\r\\n        path.add(nums[idx]);\\r\\n        dfs(nums, idx + 1, path);\\r\\n        path.remove(path.size() - 1);\\r\\n        dfs(nums, idx + 1, path);\\r\\n    }\\r\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        n = len(nums)\\n\\n        def dfs(idx: int, path: List[int]):\\n            if idx == n:\\n                ans.append(path[:])\\n                return\\n            path.append(nums[idx])\\n            dfs(idx + 1, path)\\n            path.pop()\\n            dfs(idx + 1, path)\\n\\n        dfs(0, [])\\n        return ans\\n\\n\"}]},{\"title\":\"代码16.4.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\r\\npublic:\\r\\n    vector<vector<int>> ans;\\r\\n    vector<int> path;\\r\\n    set<int> visited;\\r\\n    vector<vector<int>> permute(vector<int>& nums) {\\r\\n        dfs(nums);\\r\\n        return ans;\\r\\n    }\\r\\n    void dfs(vector<int>& nums) {\\r\\n        if (path.size() == nums.size()) {\\r\\n            ans.push_back(vector<int>(path));\\r\\n            return;\\r\\n        }\\r\\n        for (int i = 0; i < nums.size(); i++) {\\r\\n            if (!visited.count(i)) {\\r\\n                visited.insert(i);\\r\\n                path.push_back(nums[i]);\\r\\n                dfs(nums);\\r\\n                path.pop_back();\\r\\n                visited.erase(i);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\r\\n    List<List<Integer>> ans = new ArrayList<>();\\r\\n    Set<Integer> visited = new HashSet<>();\\r\\n    public List<List<Integer>> permute(int[] nums) {\\r\\n        dfs(new ArrayList<>(), nums);\\r\\n        return ans;\\r\\n    }\\r\\n    public void dfs(List<Integer> path, int[] nums) {\\r\\n        if (path.size() == nums.length) {\\r\\n            ans.add(new ArrayList<>(path));\\r\\n            return;\\r\\n        }\\r\\n        for (int i = 0; i < nums.length; i++) {\\r\\n            if (!visited.contains(i)) {\\r\\n                visited.add(i);\\r\\n                path.add(nums[i]);\\r\\n                dfs(path, nums);\\r\\n                path.remove(path.size() - 1);\\r\\n                visited.remove(i);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        n = len(nums)\\n        visited = set()\\n\\n        def dfs(path: List[int]):\\n            if len(path) == n:\\n                ans.append(path[:])\\n                return\\n            for i in range(n):\\n                if i not in visited:\\n                    visited.add(i)\\n                    path.append(nums[i])\\n                    dfs(path)\\n                    path.pop()\\n                    visited.remove(i)\\n\\n        dfs([])\\n        return ans\\n\\n\"}]},{\"title\":\"代码16.5.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class Solution {\\r\\npublic:\\r\\n    bool col[9][9];\\r\\n    bool row[9][9];\\r\\n    bool place[9][9];\\r\\n\\r\\n    void solveSudoku(vector<vector<char>>& board) {\\r\\n        memset(col, false, sizeof(col));\\r\\n        memset(row, false, sizeof(row));\\r\\n        memset(place, false, sizeof(place));\\r\\n\\r\\n        for (int i = 0; i < 9; i++) {\\r\\n            for (int j = 0; j < 9; j++) {\\r\\n                if (board[i][j] == '.') {\\r\\n                    continue;\\r\\n                }\\r\\n                int num = board[i][j] - '1';\\r\\n                row[i][num] = true;\\r\\n                col[j][num] = true;\\r\\n                place[i / 3 * 3 + j / 3][num] = true;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        dfs(board, 0, 0);\\r\\n    }\\r\\n\\r\\n    bool dfs(vector<vector<char>>& board, int i, int j) {\\r\\n        if (j == 9) {\\r\\n            return dfs(board, i + 1, 0);\\r\\n        } else if (i == 9) {\\r\\n            return true;\\r\\n        } else if (board[i][j] != '.') {\\r\\n            return dfs(board, i, j + 1);\\r\\n        }\\r\\n\\r\\n        for (int k = 0; k < 9; k++) {\\r\\n            if (col[j][k] || row[i][k] || place[i / 3 * 3 + j / 3][k]) {\\r\\n                continue;\\r\\n            }\\r\\n            board[i][j] = '1' + k;\\r\\n            col[j][k] = true;\\r\\n            row[i][k] = true;\\r\\n            place[i / 3 * 3 + j / 3][k] = true;\\r\\n            if (dfs(board, i, j + 1)) {\\r\\n                return true;\\r\\n            }\\r\\n            board[i][j] = '.';\\r\\n            col[j][k] = false;\\r\\n            row[i][k] = false;\\r\\n            place[i / 3 * 3 + j / 3][k] = false;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\r\\n    \\r\\n    boolean[][] col = new boolean[9][9];\\r\\n    boolean[][] row = new boolean[9][9];\\r\\n    boolean[][] place = new boolean[9][9];\\r\\n    \\r\\n    public void solveSudoku(char[][] board) {\\r\\n        for (int i = 0; i < 9; i++) {\\r\\n            for (int j = 0; j < 9; j++) {\\r\\n                if (board[i][j] == '.') {\\r\\n                    continue;\\r\\n                }\\r\\n                int num = board[i][j] - '1';\\r\\n                row[i][num] = true;\\r\\n                col[j][num] = true;\\r\\n                place[i / 3 * 3 + j / 3][num] = true;\\r\\n            }\\r\\n        }\\r\\n        dfs(board, 0, 0);\\r\\n    }\\r\\n    \\r\\n    public boolean dfs(char[][] board, int i, int j) {\\r\\n        if (j == 9) {\\r\\n            return dfs(board, i + 1, 0);\\r\\n        } else if (i == 9) {\\r\\n            return true;\\r\\n        } else if (board[i][j] != '.') {\\r\\n            return dfs(board, i, j + 1);\\r\\n        }\\r\\n\\r\\n        for (int k = 0; k < 9; k++) {\\r\\n            if (col[j][k] || row[i][k] || place[i / 3 * 3 + j / 3][k]) {\\r\\n                continue;\\r\\n            }\\r\\n            board[i][j] = (char)('1' + k);\\r\\n            col[j][k] = true;\\r\\n            row[i][k] = true;\\r\\n            place[i / 3 * 3 + j / 3][k] = true;\\r\\n            if (dfs(board, i, j + 1)) {\\r\\n                return true;\\r\\n            }\\r\\n            board[i][j] = '.';\\r\\n            col[j][k] = false;\\r\\n            row[i][k] = false;\\r\\n            place[i / 3 * 3 + j / 3][k] = false;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n  \\r\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def solveSudoku(self, board: List[List[str]]) -> None:\\n        col = [[False] * 9 for i in range(9)]\\n        row = [[False] * 9 for i in range(9)]\\n        place = [[False] * 9 for i in range(9)]\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j] != \\\".\\\":\\n                    num = int(board[i][j]) - 1\\n                    col[j][num] = True\\n                    row[i][num] = True\\n                    place[i // 3 * 3 + j // 3][num] = True\\n\\n        def dfs(i: int, j: int) -> boolean:\\n            if j == 9:\\n                return dfs(i + 1, 0)\\n            if i == 9:\\n                return True\\n            if board[i][j] != \\\".\\\":\\n                return dfs(i, j + 1)\\n            for k in range(9):\\n                if (\\n                    col[j][k] == True\\n                    or row[i][k] == True\\n                    or place[i // 3 * 3 + j // 3][k] == True\\n                ):\\n                    continue\\n                board[i][j] = str(k + 1)\\n                col[j][k] = True\\n                row[i][k] = True\\n                place[i // 3 * 3 + j // 3][k] = True\\n                if dfs(i, j + 1) == True:\\n                    return True\\n                board[i][j] = \\\".\\\"\\n                col[j][k] = False\\n                row[i][k] = False\\n                place[i // 3 * 3 + j // 3][k] = False\\n            return False\\n\\n        dfs(0, 0)\\n\\n\"}]}]},{\"id\":\"17\",\"name\":\"第十七章\",\"list\":[{\"title\":\"代码17.1.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  vector<int> majorityElement(vector<int>& nums) {\\n    int n = nums.size();\\n    vector<int> res;\\n    int cnt1 = 0, cnt2 = 0, n1, n2;\\n    bool n1_init = false, n2_init = false;\\n    for (int i = 0; i < nums.size(); i++) {\\n      if (!n1_init) {\\n        n1 = nums[i];\\n        n1_init = true;\\n        cnt1 += 1;\\n      }\\n      else if (nums[i] == n1) cnt1 += 1;\\n      else if (!n2_init) {\\n        n2 = nums[i];\\n        n2_init = true;\\n        cnt2 += 1;\\n      }\\n      else if (nums[i] == n2) cnt2 += 1;\\n      else if (cnt1 == 0) {\\n        n1 = nums[i];\\n        cnt1 += 1;\\n      }\\n      else if (cnt2 == 0) {\\n        n2 = nums[i];\\n        cnt2 += 1;\\n      } else {\\n        cnt1 -= 1;\\n        cnt2 -= 1;\\n      }\\n    }\\n    cnt1 = 0;\\n    cnt2 = 0;\\n    for (int i = 0; i < nums.size(); i++) {\\n      if (nums[i] == n1) cnt1 += 1;\\n      if (nums[i] == n2) cnt2 += 1;\\n    }\\n    if (cnt1 > n / 3) res.push_back(n1);\\n    if (cnt2 > n / 3) res.push_back(n2);\\n    return res;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\n\\npublic class Solution {\\n  public List<Integer> majaorityElement(int[] nums) {\\n    int n = nums.length;\\n    List<Integer> res = new ArrayList<>();\\n    int cnt1 = 0, cnt2 = 0, n1, n2;\\n    boolean n1_init = false, n2_init = false;\\n    for (int i = 0; i < nums.length; i++) {\\n      if (!n1_init) {\\n        n1 = nums[i];\\n        n1_init = true;\\n        cnt1 += 1;\\n      }\\n      else if (nums[i] == n1) cnt1 += 1;\\n      else if (!n2_init) {\\n        n2 = nums[i];\\n        n2_init = true;\\n        cnt2 += 1;\\n      }\\n      else if (nums[i] == n2) cnt2 += 1;\\n      else if (cnt1 == 0) {\\n        n1 = nums[i];\\n        cnt1 += 1;\\n      }\\n      else if (cnt2 == 0) {\\n        n2 = nums[i];\\n        cnt2 += 1;\\n      } else {\\n        cnt1 -= 1;\\n        cnt2 -= 1;\\n      }\\n    }\\n    cnt1 = 0;\\n    cnt2 = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n      if (nums[i] == n1) cnt1 += 1;\\n      if (nums[i] == n2) cnt2 += 1;\\n    }\\n    if (cnt1 > n / 3) res.add(n1);\\n    if (cnt2 > n / 3) res.add(n2);\\n    return res;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        res = []\\n        cnt1 = 0\\n        cnt2 = 0\\n        n1 = None\\n        n2 = None\\n\\n        # 筛选出现次数最多的前两个\\n        for num in nums:\\n            if num == n1:\\n                cnt1 += 1\\n            elif num == n2:\\n                cnt2 += 1\\n            elif cnt1 == 0:\\n                n1 = num\\n                cnt1 += 1\\n            elif cnt2 == 0:\\n                n2 = num\\n                cnt2 += 1\\n            else:\\n                cnt1 -= 1\\n                cnt2 -= 1\\n        # 筛选出现次数超过三分之一的\\n        # 这里的cnt1和cnt2的含义已经变了\\n        # 这里的cnt1和cnt2表示的是出现次数， 而上面的则不是\\n        cnt1 = 0\\n        cnt2 = 0\\n        for num in nums:\\n            if num == n1:\\n                cnt1 += 1\\n            if num == n2:\\n                cnt2 += 1\\n        if cnt1 > n // 3:\\n            res.append(n1)\\n        if cnt2 > n // 3:\\n            res.append(n2)\\n        return res\\n\\n\"}]},{\"title\":\"代码17.2.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int largestRectangleArea(vector<int>& heights) {\\n    int n = heights.size(), ans = 0;\\n    if (n != 0) ans = heights[0];\\n    for (int i = 0; i < n; i++) {\\n      int height = heights[i];\\n      for (int j = i; j < n; j++) {\\n        height = min(height, heights[j]);\\n        ans = max(ans, (j - i + 1) * height);\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\nimport java.lang.Math;\\n\\npublic class Solution {\\n  public int largestRectangleArea(int[] heights) {\\n    int n = heights.length, ans = 0;\\n    if (n != 0) ans = heights[0];\\n    for (int i = 0; i < n; i++) {\\n      int height = heights[i];\\n      for (int j = i; j < n; j++) {\\n        height = Math.min(height, heights[j]);\\n        ans = Math.max(ans, (j - i + 1) * height);\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        n, ans = len(heights), 0\\n        if n != 0:\\n            ans = heights[0]\\n        for i in range(n):\\n            height = heights[i]\\n            for j in range(i, n):\\n                height = min(height, heights[j])\\n                ans = max(ans, (j - i + 1) * height)\\n        return ans\\n\\n\"}]},{\"title\":\"代码17.2.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int largestRectangleArea(vector<int>& heights) {\\n    int n = heights.size(), ans = 0;\\n    vector<int> l, r;\\n    for (int i = 0; i < n; i++) {\\n      l.push_back(-1);\\n      r.push_back(n);\\n    }\\n    for (int i = 1; i < n; i++) {\\n      int j = i - 1;\\n      while (j >= 0 && heights[j] >= heights[i])\\n        j -= 1;\\n      l[i] = j;\\n    }\\n    for (int i = n - 2; i >= 0; i--) {\\n      int j = i + 1;\\n      while (j < n && heights[j] >= heights[i])\\n        j += 1;\\n      r[i] = j;\\n    }\\n    for (int i = 0; i < n; i++)\\n      ans = max(ans, heights[i] * (r[i] - l[i] - 1));\\n    return ans;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\nimport java.lang.Math;\\n\\npublic class Solution {\\n  public int largestRectangleArea(int[] heights) {\\n    int n = heights.length, ans = 0;\\n    List<Integer> l = new ArrayList<>(),\\n      r = new ArrayList<>();\\n    for (int i = 0; i < n; i++) {\\n      l.add(-1);\\n      r.add(n);\\n    }\\n    for (int i = 1; i < n; i++) {\\n      int j = i - 1;\\n      while (j > 0 && heights[j] >= heights[i])\\n        j -= 1;\\n      l.set(i, j);\\n    }\\n    for (int i = n - 2; i >= 0; i--) {\\n      int j = i + 1;\\n      while (j < n && heights[j] >= heights[i])\\n        j += 1;\\n      r.set(i, j);\\n    }\\n    for (int i = 0; i < n; i++)\\n      ans = Math.max(ans, heights[i] * (r.get(i) - l.get(i) - 1));\\n    return ans;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        n = len(heights)\\n        l, r, ans = [-1] * n, [n] * n, 0\\n        for i in range(1, n):\\n            j = i - 1\\n            while j >= 0 and heights[j] >= heights[i]:\\n                j -= 1\\n            l[i] = j\\n        for i in range(n - 2, -1, -1):\\n            j = i + 1\\n            while j < n and heights[j] >= heights[i]:\\n                j += 1\\n            r[i] = j\\n        for i in range(n):\\n            ans = max(ans, heights[i] * (r[i] - l[i] - 1))\\n        return ans\\n\\n\"}]},{\"title\":\"代码17.2.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int largestRectangleArea(vector<int>& heights) {\\n    int n = heights.size(), ans = 0;\\n    vector<int> l, r;\\n    for (int i = 0; i < n; i++) {\\n      l.push_back(-1);\\n      r.push_back(n);\\n    }\\n    for (int i = 0; i < n; i++) {\\n      int j = i - 1;\\n      while (j >= 0 && heights[j] >= heights[i])\\n        j = l[j];\\n      l[i] = j;\\n    }\\n    for (int i = n - 2; i >= 0; i--) {\\n      int j = i + 1;\\n      while (j < n && heights[j] >= heights[i])\\n        j = r[j];\\n      r[i] = j;\\n    }\\n    for (int i = 0; i < n; i++)\\n      ans = max(ans, heights[i] * (r[i] - l[i] - 1));\\n    return ans;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\nimport java.lang.Math;\\n\\npublic class Solution {\\n  public int largetstRectangleArea(int[] heights) {\\n    int n = heights.length, ans = 0;\\n    List<Integer> l = new ArrayList<>(),\\n      r = new ArrayList<>();\\n    for (int i = 0; i < n; i++) {\\n      l.add(-1);\\n      r.add(n);\\n    }\\n    for (int i = 0; i < n; i++) {\\n      int j = i - 1;\\n      while (j >= 0 && heights[j] >= heights[i])\\n        j = l.get(j);\\n      l.set(i, j);\\n    }\\n    for (int i = n - 2; i >= 0; i--) {\\n      int j = i + 1;\\n      while (j < n && heights[j] >= heights[i])\\n        j = r.get(j);\\n      r.set(i, j);\\n    }\\n    for (int i = 0; i < n; i++)\\n      ans = Math.max(ans, heights[i] * (r.get(i) - l.get(i) - 1));\\n    return ans;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        n = len(heights)\\n        l, r, ans = [-1] * n, [n] * n, 0\\n\\n        for i in range(1, n):\\n            j = i - 1\\n            while j >= 0 and heights[j] >= heights[i]:\\n                j = l[j]\\n            l[i] = j\\n        for i in range(n - 2, -1, -1):\\n            j = i + 1\\n            while j < n and heights[j] >= heights[i]:\\n                j = r[j]\\n            r[i] = j\\n        for i in range(n):\\n            ans = max(ans, heights[i] * (r[i] - l[i] - 1))\\n        return ans\\n\\n\"}]},{\"title\":\"代码17.2.4\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int largestRectangleArea(vector<int>& heights) {\\n    int n = heights.size(), ans = 0;\\n    vector<int> st;\\n    heights.push_back(0);\\n    for (int i = heights.size(); i > 0; i--)\\n      swap(heights[i], heights[i - 1]);\\n    heights.push_back(0);\\n    for (int i = 0; i < n + 2; i++) {\\n      while (st.size() && heights[st.back()] > heights[i]) {\\n        int buf = st.back();\\n        st.pop_back();\\n        ans = max(ans, heights[buf] * (i - st.back() - 1));\\n      }\\n      st.push_back(i);\\n    }\\n    return ans;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\nimport java.lang.Math;\\n\\npublic class Solution {\\n  public int largestRectangleArea(List<Integer> heights) {\\n    int n = heights.size(), ans = 0;\\n    List<Integer> st = new ArrayList<>();\\n    heights.add(0);\\n    for (int i = heights.size(); i > 0; i--) {\\n      int tmp = heights.get(i);\\n      heights.set(i, heights.get(i - 1));\\n      heights.set(i - 1, tmp);\\n    }\\n    heights.add(0);\\n    for (int i = 0; i < n + 2; i ++) {\\n      while (st.size() != 0 &&\\n           heights.get(st.get(st.size() - 1)) > heights.get(i)) {\\n        int buf = st.get(st.size() - 1);\\n        st.remove(st.size() - 1);\\n        ans = Math.max(ans, heights.get(buf) * (i\\n              - st.get(st.size() - 1) - 1));\\n      }\\n      st.add(i);\\n    }\\n    return ans;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        n, heights, st, ans = len(heights), [0] + heights + [0], [], 0\\n        for i in range(n + 2):\\n            while st and heights[st[-1]] > heights[i]:\\n                ans = max(ans, heights[st.pop(-1)] * (i - st[-1] - 1))\\n            st.append(i)\\n        return ans\\n\\n\"}]},{\"title\":\"代码17.3.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <string>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  string dayOfTheWeek(int day, int month, int year) {\\n    int months[] = {31, 28, 31, 30, 31, 30, 31, 31,\\n                    30, 31, 30, 31};\\n    int leap_months[] = {31, 29, 31, 30, 31, 30, 31,\\n                        31, 30, 31, 30, 31};\\n    string days[] = {\\\"Friday\\\", \\\"Saturday\\\", \\\"Sunday\\\",\\n                    \\\"Monday\\\", \\\"Tuesday\\\",\\n                    \\\"Wednesday\\\", \\\"Thursday\\\"};\\n    int years = year - 1971, leaps = 0, i = 1972;\\n    while (i < year) {\\n      if (i % 400 == 0 || (i % 4 == 0 && i % 100))\\n        leaps += 1;\\n      i += 1;\\n    }\\n    int diff = (years * 365) + leaps;\\n    for (int m = 0; m < month - 1; m++) {\\n      if (i % 400 == 0 || (i % 4 == 0 && i % 100))\\n        diff += leap_months[m];\\n      else\\n        diff += months[m];\\n    }\\n    diff += day - 1;\\n    return days[diff % 7];\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\n\\npublic class Solution {\\n  public String dayOfTheWeek(int day, int month, int year) {\\n    int[] months = {31, 28, 31, 30, 31, 30, 31, 31,\\n    30, 31, 30, 31};\\n    int[] leap_months = {31, 29, 31, 30, 31, 30, 31,\\n    31, 30, 31, 30, 31};\\n    String[] days = {\\\"Friday\\\", \\\"Saturday\\\", \\\"Sunday\\\",\\n    \\\"Monday\\\", \\\"Tuesday\\\", \\\"Wednesday\\\", \\\"Thursday\\\"};\\n    int years = year - 1971, leaps = 0, i = 1972;\\n    while (i < year) {\\n      if (i % 400 == 0 || (i % 4 == 0 && i % 100 != 0))\\n        leaps += 1;\\n      i += 1;\\n    }\\n    int diff = (years * 365) + leaps;\\n    for (int m = 0; m < month - 1; m++) {\\n      if (i % 400 == 0 || (i % 4 == 0 && i % 100 != 0))\\n        diff += leap_months[m];\\n      else\\n        diff += months[m];\\n    }\\n    diff += day - 1;\\n    return days[diff % 7];\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def dayOfTheWeek(self, day: int, month: int, year: int) -> str:\\n        months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        leap_months = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        # 1971-01-01 作为基准日期\\n        # 1971-01-01 是周五\\n        days = [\\n            \\\"Friday\\\",\\n            \\\"Saturday\\\",\\n            \\\"Sunday\\\",\\n            \\\"Monday\\\",\\n            \\\"Tuesday\\\",\\n            \\\"Wednesday\\\",\\n            \\\"Thursday\\\",\\n        ]\\n        years = year - 1971\\n        leaps = 0\\n        i = 1972\\n        # 处理年\\n        while i < year:\\n            if i % 400 == 0 or (i % 4 == 0 and i % 100 != 0):\\n                leaps += 1\\n            i += 1\\n        diff = (years * 365) + leaps\\n        # 处理月\\n        for m in range(month - 1):\\n            if i % 400 == 0 or (i % 4 == 0 and i % 100 != 0):\\n                diff += leap_months[m]\\n            else:\\n                diff += months[m]\\n        # 处理日\\n        diff += day - 1\\n        return days[diff % 7]\\n\\n\"}]},{\"title\":\"代码17.3.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <string>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  string dayOfTheWeek(int day, int month, int year) {\\n    string list_of_days[] = {\\n      \\\"Saturday\\\", \\\"Sunday\\\", \\\"Monday\\\", \\\"Tuesday\\\",\\n      \\\"Wednesday\\\", \\\"Thursday\\\", \\\"Friday\\\"\\n    };\\n    if (month == 1 || month == 2) {\\n      year -= 1;\\n      month += 12;\\n    }\\n    int y = year % 100, c = year / 100;\\n    int weekday = (day + 13 * (month + 1) / 5 + y + \\\\\\n                  y / 4 + c / 4 + 5 * c) % 7;\\n    return list_of_days[weekday];\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\n\\npublic class Solution {\\n  public String dayOfTheWeek(int day, int month, int year) {\\n    String[] list_of_days = {\\n      \\\"Saturday\\\", \\\"Sunday\\\", \\\"Monday\\\", \\\"Tuesday\\\",\\n      \\\"Wednesday\\\", \\\"Thursday\\\", \\\"Friday\\\"\\n    };\\n    if (month == 1 || month == 2) {\\n      year -= 1;\\n      month += 12;\\n    }\\n    int y = year % 100, c = year / 100;\\n    int weekday = (day + 13 * (month + 1) / 5 + y\\n        + y / 4 + c / 4 + 5 * c) % 7;\\n    return list_of_days[weekday];\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def dayOfTheWeek(self, day: int, month: int, year: int) -> str:\\n        list_of_days = [\\n            \\\"Saturday\\\",\\n            \\\"Sunday\\\",\\n            \\\"Monday\\\",\\n            \\\"Tuesday\\\",\\n            \\\"Wednesday\\\",\\n            \\\"Thursday\\\",\\n            \\\"Friday\\\",\\n        ]\\n        if month == 1 or month == 2:\\n            year = year - 1\\n            month = month + 12\\n        y = year % 100\\n        c = year // 100\\n        weekday = int((day + 13 * (month + 1) // 5 + y + y // 4 + c // 4 + 5 * c) % 7)\\n        required_day = list_of_days[weekday]\\n        return required_day\\n\\n\"}]},{\"title\":\"代码17.4.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <utility>\\n#include <set>\\n#include <queue>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  bool canMeasureWater(int x, int y, int z) {\\n    if (x + y < z) return false;\\n    queue<pair<int, int> > q;\\n    q.push(make_pair(0, 0));\\n    set<pair<int, int> > seen;\\n    seen.insert(make_pair(0, 0));\\n    while (q.size()) {\\n      pair<int, int> buf = q.front();\\n      q.pop();\\n      int a = buf.first, b = buf.second;\\n      if (a == z || b == z || a + b == z) return true;\\n      set<pair<int, int> > states;\\n      states.insert(make_pair(x, b));\\n      states.insert(make_pair(a, y));\\n      states.insert(make_pair(0, b));\\n      states.insert(make_pair(a, 0));\\n      int val = ((b < x - a) ? 0 : (b - (x - a)));\\n      states.insert(make_pair(min(x, b + a), val));\\n      val = ((a + b < y) ? 0 : (a - (y - b)));\\n      states.insert(make_pair(val, min(b + a, y)));\\n      for (set<pair<int, int> >::iterator it = \\\\\\n          states.begin(); it != states.end(); it++) {\\n        if (seen.count(*it)) continue;\\n        q.push(*it);\\n        seen.insert(*it);\\n      }\\n    }\\n    return false;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\nimport java.lang.Math;\\n\\npublic class Solution {\\n  public class Pair {\\n    public final int first;\\n    public final int second;\\n    public Pair(int x, int y) {\\n      this.first = x;\\n      this.second = y;\\n    }\\n  }\\n  public Pair make_pair(int x, int y) {\\n    Pair buf = new Pair(x, y);\\n    return buf;\\n  }\\n  public boolean canMeasureWater(int x, int y, int z) {\\n    if (x + y < z) return false;\\n    Queue<Pair> q = new LinkedList<Pair>();\\n    q.offer(make_pair(0, 0));\\n    Set<Pair> seen = new HashSet<Pair>();\\n    seen.add(make_pair(0, 0));\\n    while (q.size() != 0) {\\n      Pair buf = q.poll();\\n      int a = buf.first, b = buf.second;\\n      if (a == z || b == z || a + b == z) return true;\\n      Set<Pair> states = new HashSet<Pair>();\\n      states.add(make_pair(x, b));\\n      states.add(make_pair(a, y));\\n      states.add(make_pair(0, b));\\n      states.add(make_pair(a, 0));\\n      int val = ((b < x - a) ? 0 : (b - (x - a)));\\n      states.add(make_pair(Math.min(x, b + a), val));\\n      val = ((a + b < y) ? 0 : (a - (y - b)));\\n      states.add(make_pair(val, Math.min(b + a, y)));\\n      Iterator<Pair> it = states.iterator();\\n      while (it.hasNext()) {\\n        Pair node = it.next();\\n        if (seen.contains(node)) continue;\\n        q.offer(node);\\n        seen.add(node);\\n      }\\n    }\\n    return false;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def canMeasureWater(self, x: int, y: int, z: int) -> bool:\\n        if x + y < z:\\n            return False\\n        queue = [(0, 0)]\\n        seen = set((0, 0))\\n\\n        while len(queue) > 0:\\n            a, b = queue.pop(0)\\n            if a == z or b == z or a + b == z:\\n                return True\\n            states = set()\\n\\n            states.add((x, b))\\n            states.add((a, y))\\n            states.add((0, b))\\n            states.add((a, 0))\\n            states.add((min(x, b + a), 0 if b < x - a else b - (x - a)))\\n            states.add((0 if a + b < y else a - (y - b), min(b + a, y)))\\n            for state in states:\\n                if state in seen:\\n                    continue\\n                queue.append(state)\\n                seen.add(state)\\n        return False\\n\\n\"}]},{\"title\":\"代码17.4.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int gcd(int a, int b) {\\n    int smaller = min(a, b);\\n    while (smaller) {\\n      if (a % smaller == 0 && b % smaller == 0)\\n        return smaller;\\n      smaller -= 1;\\n    }\\n  }\\n  bool canMeasureWater(int x, int y, int z) {\\n    if (x + y < z) return false;\\n    if (z == 0) return true;\\n    if (x == 0) return y == z;\\n    if (y == 0) return x == z;\\n    return z % gcd(x, y) == 0;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.lang.Math;\\n\\npublic class Solution {\\n  public int gcd(int a, int b) {\\n    int smaller = Math.min(a, b);\\n    while (smaller != 0) {\\n      if (a % smaller == 0 && b % smaller == 0)\\n        return smaller;\\n      smaller -= 1;\\n    }\\n  }\\n  boolean canMeasureWater(int x, int y, int z) {\\n    if (x + y < z) return false;\\n    if (z == 0) return true;\\n    if (x == 0) return y == z;\\n    if (y == 0) return x == z;\\n    return z % gcd(x, y) == 0;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def canMeasureWater(self, x: int, y: int, z: int) -> bool:\\n        if x + y < z:\\n            return False\\n\\n        if z == 0:\\n            return True\\n\\n        if x == 0:\\n            return y == z\\n\\n        if y == 0:\\n            return x == z\\n\\n        def GCD(a: int, b: int) -> int:\\n            smaller = min(a, b)\\n            while smaller:\\n                if a % smaller == 0 and b % smaller == 0:\\n                    return smaller\\n                smaller -= 1\\n\\n        return z % GCD(x, y) == 0\\n\\n\"}]},{\"title\":\"代码17.4.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"int gcd(int a, int b) {\\n  return (b == 0) ? a : gcd(b, a % b);\\n}\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Gcd {\\n  public int gcd(int a, int b) {\\n    return (b == 0) ? a : gcd(b, a % b);\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"def GCD(a: int, b: int) -> int:\\n    return a if b == 0 else GCD(b, a % b)\\n\\n\"}]},{\"title\":\"代码17.4.4\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"int gcd(int a, int b) {\\n  if (a == b) return a;\\n  if (a < b)\\n    return gcd(b - a, a);\\n  return gcd(a - b, b);\\n}\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Gcd {\\n  public int gcd(int a, int b) {\\n    if (a == b) return a;\\n    if (a < b)\\n      return gcd(b - a, a);\\n    return gcd(a - b, b);\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"def GCD(a: int, b: int) -> int:\\n    if a == b:\\n        return a\\n    if a < b:\\n        return GCD(b - a, a)\\n    return GCD(a - b, b)\\n\\n\"}]},{\"title\":\"代码17.5.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <cstdlib>\\n#include <cmath>\\n\\nclass Solution {\\npublic:\\n  int poorPigs(int buckets, int minutesToDie,\\n      int minutesToTest) {\\n    int cnt = 0;\\n    while (pow(minutesToTest / minutesToDie + 1, cnt) <\\\\\\n        buckets)\\n      cnt += 1;\\n    return cnt;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.lang.Math;\\n\\npublic class Solution {\\n  public int poorPigs(int buckets, int minutesToDie,\\n      int minutesToTest) {\\n    int cnt = 0;\\n    while (Math.pow(minutesToTest / minutesToDie + 1, cnt)\\n        < buckets)\\n      cnt += 1;\\n    return cnt;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\\n        cnt = 0\\n        while (minutesToTest / minutesToDie + 1) ** cnt < buckets:\\n            cnt += 1\\n        return cnt\\n\\n\"}]},{\"title\":\"代码17.5.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <cmath>\\n#include <cstdlib>\\n\\nclass Solution {\\npublic:\\n  int poorPigs(int buckets, int minutesToDie,\\n      int minutesToTest) {\\n    return ceil(log(buckets) / log(minutesToTest /\\\\\\n          minutesToDie + 1));\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.lang.Math;\\n\\npublic class Solution {\\n  public int poorPigs(int buckets, int minutesToDie,\\n      int minutesToTest) {\\n    return (int)Math.ceil(Math.log(buckets) / Math.log(\\n          minutesToTest / minutesToDie + 1\\n          ));\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"import math\\n\\n\\nclass Solution:\\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\\n        return math.ceil(math.log(buckets, minutesToTest / minutesToDie + 1))\\n\\n\"}]}]},{\"id\":\"18\",\"name\":\"第十八章\",\"list\":[{\"title\":\"代码18.1.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"int bs(vector<int>& nums, int target) {\\r\\n    int n = nums.size();\\r\\n    int l = 0, h = n - 1;\\r\\n    while (l <= h) {\\r\\n        int mid = l + (h - l) / 2;\\r\\n        if (nums[mid] == target) {\\r\\n            return mid;\\r\\n        } else if (nums[mid] < target) {\\r\\n            l = mid + 1;\\r\\n        } else {\\r\\n            h = mid - 1;\\r\\n        }\\r\\n    }\\r\\n    return -1;\\r\\n}\\n\"},{\"language\":\"Java\",\"content\":\"public int bs(int[] nums, int target) {\\r\\n\\tint n = nums.length;\\r\\n\\tint l = 0, h = n - 1;\\r\\n\\twhile (l <= h) {\\r\\n\\t\\tint mid = l + (h - l) / 2;\\r\\n\\t\\tif (nums[mid] == target) {\\r\\n\\t\\t\\treturn mid;\\r\\n\\t\\t} else if (nums[mid] < target) {\\r\\n\\t\\t\\tl = mid + 1;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\th = mid - 1;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn -1;\\r\\n}\\n\"},{\"language\":\"Py\",\"content\":\"# 查找 nums 数组中元素值为 target 的下标，如果不存在则返回 -1\\ndef bs(nums: [], target: int) -> int:\\n    n = len(nums)\\n    l, h = 0, n - 1\\n    while l <= h:\\n        mid = l + (h - l) // 2\\n        if nums[mid] == target:\\n            return mid\\n        elif nums[mid] < target:\\n            l = mid + 1\\n        else:\\n            h = mid - 1\\n    return -1\\n\\n\"}]},{\"title\":\"代码18.1.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#查找第一个大于等于 x 的元素\\r\\nint bs(vector<int>& nums, int x) {\\r\\n    int l = 0, h = nums.size() - 1;\\r\\n    while (l <= h) {\\r\\n        int mid = l + (h - l) / 2;\\r\\n        if (l == h) {\\r\\n            break;\\r\\n        } else if (nums[mid] >= x) {\\r\\n            h = mid;\\r\\n        } else {\\r\\n            l = mid + 1;\\r\\n        }\\r\\n    }\\r\\n    return nums[l];\\r\\n}\\n\"},{\"language\":\"Java\",\"content\":\"# 查找第一个大于等于 x 的元素\\r\\npublic int bs(int[] nums, int x) {\\r\\n\\tint l = 0, h = nums.length - 1;\\r\\n\\twhile (l <= h) {\\r\\n\\t\\tint mid = l + (h - l) / 2;\\r\\n\\t\\tif (l == h) {\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\t} else if (nums[mid] >= x) {\\r\\n\\t\\t\\th = mid;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tl = mid + 1;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn nums[l];\\r\\n}\\r\\n\\r\\n\\n\"},{\"language\":\"Py\",\"content\":\"# 查找第一个大于等于 x 的元素\\ndef bs(nums: List[int], x: int) -> int:\\n    l, h = 0, len(nums) - 1\\n    while l <= h:\\n        mid = l + (h - l) // 2\\n        if l == h:\\n            break\\n        elif nums[mid] >= x:\\n            h = mid\\n        else:\\n            l = mid + 1\\n    return nums[l]\\n\\n\"}]},{\"title\":\"代码18.1.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#查找最后一个小于等于 x 的元素\\r\\nint bs(vector<int>& nums, int x) {\\r\\n    int l = 0, h = nums.size() - 1;\\r\\n    while (l <= h) {\\r\\n        int mid = l + (h - l) / 2;\\r\\n        if (l == h || l + 1 == h) {\\r\\n            break;\\r\\n        } else if (nums[mid] <= x) {\\r\\n            l = mid;\\r\\n        } else {\\r\\n            h = mid - 1;\\r\\n        }\\r\\n    }\\r\\n    if (nums[h] <= x) {\\r\\n        return nums[h];\\r\\n    } else {\\r\\n        return nums[l];\\r\\n    }\\r\\n}\\n\"},{\"language\":\"Java\",\"content\":\"# 查找最后一个小于等于 x 的元素\\r\\npublic int bs(int[] nums, int x) {\\r\\n    int l = 0, h = nums.length - 1;\\r\\n    while (l <= h) {\\r\\n        int mid = l + (h - l) / 2;\\r\\n        if (l == h || l + 1 == h) {\\r\\n            break;\\r\\n        } else if (nums[mid] <= x) {\\r\\n            l = mid;\\r\\n        } else {\\r\\n            h = mid - 1;\\r\\n        }\\r\\n    }\\r\\n    if (nums[h] <= x) {\\r\\n        return nums[h];\\r\\n    } else {\\r\\n        return nums[l];\\r\\n    }\\r\\n}\\n\"},{\"language\":\"Py\",\"content\":\"# 查找最后一个小于等于 x 的元素\\ndef bs(nums: List[int], x: int) -> int:\\n    l, h = 0, len(nums) - 1\\n    while l <= h:\\n        mid = l + (h - l) // 2\\n        if l == h or l + 1 == h:\\n            break\\n        elif nums[mid] <= x:\\n            l = mid\\n        else:\\n            h = mid - 1\\n    if nums[h] <= x:\\n        return nums[h]\\n    else:\\n        return nums[l]\\n\\n\"}]},{\"title\":\"代码18.3.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class UnionFind {\\r\\npublic:\\r\\n    // 每个节点的父节点\\r\\n    int* parent;\\r\\n    // 以该节点为根的树权值（树高度）\\r\\n    int* rank;\\r\\n    // 连通区域数量\\r\\n    int cnt;\\r\\n\\r\\n    UnionFind(int n) {\\r\\n        parent = new int[n];\\r\\n        rank = new int[n];\\r\\n        cnt = n;\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            parent[i] = i;\\r\\n            rank[i] = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    int find(int p) {\\r\\n        while (p != parent[p]) {\\r\\n            p = parent[p];\\r\\n        }\\r\\n        return p;\\r\\n    }\\r\\n\\r\\n    void merge(int p, int q) {\\r\\n        int root_p = find(p), root_q = find(q);\\r\\n        if (root_p == root_q) {\\r\\n            return;\\r\\n        }\\r\\n        if (rank[root_p] > rank[root_q]) {\\r\\n            parent[root_q] = root_p;\\r\\n        } else if (rank[root_p] < rank[root_q]) {\\r\\n            parent[root_p] = root_q;\\r\\n        } else {\\r\\n            parent[root_p] = root_q;\\r\\n            rank[root_q] += 1;\\r\\n        }\\r\\n        cnt -= 1;\\r\\n    }\\r\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class UnionFind {\\r\\n    // 每个节点的父节点\\r\\n    int[] parent;\\r\\n    // 以该节点为根的树权值（树高度）\\r\\n    int[] rank;\\r\\n    // 连通区域数量\\r\\n    int cnt;\\r\\n    \\r\\n    public UnionFind(int n) {\\r\\n        this.parent = new int[n];\\r\\n        this.rank = new int[n];\\r\\n        this.cnt = n;\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            this.parent[i] = i;\\r\\n            this.rank[i] = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    public int find(int p) {\\r\\n        while (p != this.parent[p]) {\\r\\n            p = this.parent[p];\\r\\n        }\\r\\n        return p;\\r\\n    }\\r\\n\\r\\n    public void union(int p, int q) {\\r\\n        int root_p = this.find(p), root_q = this.find(q);\\r\\n        if (root_p == root_q) {\\r\\n            return;\\r\\n        }\\r\\n        if (this.rank[root_p] > this.rank[root_q]) {\\r\\n            this.parent[root_q] = root_p;\\r\\n        } else if (this.rank[root_p] < this.rank[root_q]) {\\r\\n            this.parent[root_p] = root_q;\\r\\n        } else {\\r\\n            this.parent[root_p] = root_q;\\r\\n            this.rank[root_q] += 1;\\r\\n        }\\r\\n        this.cnt -= 1;\\r\\n    }\\r\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class UnionFind:\\n    def __init__(self, n: int):\\n        # 每个节点的父节点\\n        self.parent = [i for i in range(n)]\\n        # 以该节点为根的树权值（树高度）\\n        self.rank = [0 for i in range(n)]\\n        # 连通区域数量\\n        self.cnt = n\\n\\n    def find(self, p: int) -> int:\\n        while p != self.parent[p]:\\n            p = self.parent[p]\\n        return p\\n\\n    def union(self, p: int, q: int):\\n        root_p, root_q = self.find(p), self.find(q)\\n        if root_p == root_q:\\n            return\\n        if self.rank[root_p] > self.rank[root_q]:\\n            self.parent[root_q] = root_p\\n        elif self.rank[root_p] < self.rank[root_q]:\\n            self.parent[root_p] = root_q\\n        else:\\n            self.parent[root_q] = root_p\\n            self.rank[root_p] += 1\\n        self.cnt -= 1\\n\\n\"}]},{\"title\":\"代码18.3.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"class UnionFind {\\npublic:\\n    // 每个节点的父节点\\n    int* parent;\\n    // 以该节点为根的树权值（树高度）\\n    int* rank;\\n    // 连通区域数量\\n    int cnt;\\n\\n    UnionFind(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        cnt = n;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            rank[i] = 0;\\n        }\\n    }\\n\\n    int find(int p) {\\n        if (p != parent[p]) {\\n            parent[p] = find(parent[p]);\\n        }\\n        return parent[p];\\n    }\\n\\n    void merge(int p, int q) {\\n        int root_p = find(p), root_q = find(q);\\n        if (root_p == root_q) {\\n            return;\\n        }\\n        if (rank[root_p] > rank[root_q]) {\\n            parent[root_q] = root_p;\\n        } else if (rank[root_p] < rank[root_q]) {\\n            parent[root_p] = root_q;\\n        } else {\\n            parent[root_p] = root_q;\\n            rank[root_q] += 1;\\n        }\\n        cnt -= 1;\\n    }\\n};\\n\"},{\"language\":\"Java\",\"content\":\"class UnionFind {\\r\\n    // 每个节点的父节点\\r\\n    int[] parent;\\r\\n    // 以该节点为根的树权值（树高度）\\r\\n    int[] rank;\\r\\n    // 连通区域数量\\r\\n    int cnt;\\r\\n    \\r\\n    public UnionFind(int n) {\\r\\n        this.parent = new int[n];\\r\\n        this.rank = new int[n];\\r\\n        this.cnt = n;\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            this.parent[i] = i;\\r\\n            this.rank[i] = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    public int find(int p) {\\r\\n        if (p != this.parent[p]) {\\r\\n            this.parent[p] = this.find(this.parent[p]);\\r\\n        }\\r\\n        return this.parent[p];\\r\\n    }\\r\\n\\r\\n    public void union(int p, int q) {\\r\\n        int root_p = this.find(p), root_q = this.find(q);\\r\\n        if (root_p == root_q) {\\r\\n            return;\\r\\n        }\\r\\n        if (this.rank[root_p] > this.rank[root_q]) {\\r\\n            this.parent[root_q] = root_p;\\r\\n        } else if (this.rank[root_p] < this.rank[root_q]) {\\r\\n            this.parent[root_p] = root_q;\\r\\n        } else {\\r\\n            this.parent[root_p] = root_q;\\r\\n            this.rank[root_q] += 1;\\r\\n        }\\r\\n        this.cnt -= 1;\\r\\n    }\\r\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class UnionFind:\\n    def __init__(self, n: int):\\n        # 每个节点的父节点\\n        self.parent = [i for i in range(n)]\\n        # 以该节点为根的树权值（树高度）\\n        self.rank = [0 for i in range(n)]\\n        # 连通区域数量\\n        self.cnt = n\\n\\n    def find(self, p: int) -> int:\\n        if p != self.parent[p]:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n\\n    def union(self, p: int, q: int):\\n        root_p, root_q = self.find(p), self.find(q)\\n        if root_p == root_q:\\n            return\\n        if self.rank[root_p] > self.rank[root_q]:\\n            self.parent[root_q] = root_p\\n        elif self.rank[root_p] < self.rank[root_q]:\\n            self.parent[root_p] = root_q\\n        else:\\n            self.parent[root_q] = root_p\\n            self.rank[root_p] += 1\\n        self.cnt -= 1\\n\\n\"}]},{\"title\":\"代码18.4.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"vector<vector<int>> grid(5, vector<int>(5, 0));\\n// n * m 大小的矩阵\\nint n = grid.size(), m = grid[0].size();\\n// 扩展方向\\nint direction[4][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n// 记录节点是否被访问\\nbool visited[n][m];\\nfor (int i = 0; i < n; i++) {\\n    memset(visited[i], false, m);\\n}\\nqueue<pair<int, int>> que;\\n// 深度\\nint level = 0;\\n// 加入初始节点\\nque.push(pair(0, 0));\\nvisited[0][0] = true;\\nwhile (que.size() > 0) {\\n    int cnt = que.size();\\n    for (int i = 0; i < cnt; i++) {\\n        pair<int, int> top = que.front();\\n        que.pop();\\n        int x = top.first, y = top.second;\\n        // 扩展节点\\n        for (int i = 0; i < 4; i++) {\\n            int next_x = x + direction[i][0];\\n            int next_y = y + direction[i][1];\\n            // 判断相邻节点是否有效\\n            if (next_x < 0 || next_x >= n || next_y < 0 || next_y >= m || visited[next_x][next_y]) {\\n                continue;\\n            }\\n            que.push(pair(next_x, next_y));\\n            visited[next_x][next_y] = true;\\n        }\\n    }\\n    // 深度增加\\n    level += 1;\\n}\\n\"},{\"language\":\"Java\",\"content\":\"int[][] grid = new int[5][5];\\n// n * m 大小的矩阵\\nint n = grid.length, m = grid[0].length;\\n// 扩展方向\\nint[][] direction = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n// 记录节点是否被访问\\nboolean[][] visited = new boolean[n][m];\\nQueue<int[]> queue = new LinkedList<>();\\n// 深度\\nint level = 0;\\n// 加入初始节点\\nqueue.offer(new int[]{0, 0});\\nvisited[0][0] = true;\\nwhile (queue.size() > 0) {\\n    int cnt = queue.size();\\n    System.out.println(\\\"---------------\\\");\\n    for (int i = 0; i < cnt; i++) {\\n        int[] top = queue.poll();\\n        int x = top[0], y = top[1];\\n        System.out.println(x + \\\":\\\" + y);\\n        // 扩展节点\\n        for (int[] d : direction) {\\n            int next_x = x + d[0];\\n            int next_y = y + d[1];\\n            // 判断相邻节点是否有效\\n            if (next_x < 0 || next_x >= n || next_y < 0 || next_y >= m || visited[next_x][next_y]) {\\n                continue;\\n            }\\n            queue.offer(new int[]{next_x, next_y});\\n            visited[next_x][next_y] = true;\\n        } \\n    }\\n    // 深度增加\\n    level += 1;\\n}\\n\"},{\"language\":\"Py\",\"content\":\"from collections import deque\\n\\ngrid = [[0] * 5 for _ in range(5)]\\n# n * m 大小的矩阵\\nn, m = len(grid), len(grid[0])\\n# 扩展方向\\ndirection = [[0, 1], [0, -1], [-1, 0], [1, 0]]\\n# 记录节点是否被访问\\nvisited = [[False for _ in range(m)] for _ in range(n)]\\nqueue = deque()\\n# 深度\\nlevel = 0\\n# 加入初始节点\\nqueue.append([0, 0])\\nvisited[0][0] = True\\nwhile len(queue) > 0:\\n    sz = len(queue)\\n    for _ in range(sz):\\n        top = queue.popleft()\\n        x, y = top[0], top[1]\\n        # 扩展节点\\n        for d in direction:\\n            next_x = x + d[0]\\n            next_y = y + d[1]\\n            # 判断相邻节点是否有效\\n            if (\\n                next_x < 0\\n                or next_x >= n\\n                or next_y < 0\\n                or next_y >= m\\n                or visited[next_x][next_y]\\n            ):\\n                continue\\n            queue.append([next_x, next_y])\\n            visited[next_x][next_y] = True\\n    # 深度增加\\n    level += 1\\n\\n\"}]},{\"title\":\"代码18.6.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"bool isPrime(int n) {\\r\\n    if (n <= 1) {\\r\\n        return false;\\r\\n    }\\r\\n    int i = 2;\\r\\n    while (i * i <= n) {\\r\\n        if (n % i == 0) {\\r\\n            return false;\\r\\n        }\\r\\n        i += 1;\\r\\n    }\\r\\n    return true;\\r\\n}\\n\"},{\"language\":\"Java\",\"content\":\"public boolean isPrime(int n) {\\n    if (n <= 1) {\\n        return false;\\n    }\\n    int i = 2;\\n    while (i * i <= n) {\\n        if (n % i == 0) {\\n            return false;\\n        }\\n        i += 1;\\n    }\\n    return true;\\n}\\n\"},{\"language\":\"Py\",\"content\":\"def isPrime(n: int) -> boolean:\\n    if n <= 1:\\n        return False\\n    i = 2\\n    while i * i <= n:\\n        if n % i == 0:\\n            return False\\n        i += 1\\n    return True\\n\\n\"}]},{\"title\":\"代码18.6.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"int countPrimes(int n) {\\r\\n    if (n <= 1) {\\r\\n        return 0;\\r\\n    }\\r\\n    vector<bool> tmp(n, true);\\r\\n    int ans = 0;\\r\\n    tmp[0] = false;\\r\\n    tmp[1] = false;\\r\\n    for (int i = 2; i < n; i++) {\\r\\n        if (!tmp[i]) {\\r\\n            continue;\\r\\n        }\\r\\n        // 查找 i 倍数的优化细节：i * i开始\\r\\n        for (int j = i * i; j < n; j += i) {\\r\\n            tmp[j] = false;\\r\\n        }\\r\\n    }\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        if (tmp[i]) {\\r\\n            ans += 1;\\r\\n        }\\r\\n    }\\r\\n    return ans;\\r\\n}\\n\"},{\"language\":\"Java\",\"content\":\"public int countPrimes(int n) {\\r\\n    if (n <= 1) {\\r\\n        return 0;\\r\\n    }\\r\\n    boolean[] tmp = new boolean[n];\\r\\n    Arrays.fill(tmp, true);\\r\\n    int ans = 0;\\r\\n    tmp[0] = false;\\r\\n    tmp[1] = false;\\r\\n    for (int i = 2; i < n; i++) {\\r\\n        if (!tmp[i]) {\\r\\n            continue;\\r\\n        }\\r\\n        // 查找 i 倍数的优化细节：i * i开始\\r\\n        for (int j = i * i; j < n; j += i) {\\r\\n            tmp[j] = false;\\r\\n        }\\r\\n    }\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        if (tmp[i]) {\\r\\n            ans += 1;\\r\\n        }\\r\\n    }\\r\\n    return ans;\\r\\n}\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def countPrimes(self, n: int) -> int:\\n        if n <= 1:\\n            return 0\\n        tmp = [True for i in range(n)]\\n        ans = 0\\n        tmp[0] = False\\n        tmp[1] = False\\n        for i in range(2, n):\\n            if not tmp[i]:\\n                continue\\n            # 查找 i 倍数的优化细节：i * i开始\\n            for j in range(i * i, n, i):\\n                tmp[j] = False\\n        for i in range(n):\\n            if tmp[i]:\\n                ans += 1\\n        return ans\\n\\n\"}]},{\"title\":\"代码18.6.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"int gcd(int a, int b) {\\r\\n    return b == 0 ? a : gcd(b, a % b);\\r\\n}\\n\"},{\"language\":\"Java\",\"content\":\"public int gcd(int a, int b) {\\r\\n    return b == 0 ? a : gcd(b, a % b);\\r\\n}\\n\"},{\"language\":\"Py\",\"content\":\"def gcd(a: int, b: int) -> int:\\n    return a if b == 0 else gcd(b, a % b)\\n\\n\"}]},{\"title\":\"代码18.6.4\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"int gcd(int a, int b) {\\r\\n    return b == 0 ? a : gcd(b, a % b);\\r\\n}\\r\\n\\r\\nint lcm(int a, int b) {\\r\\n    return a * b / gcd(a, b);\\r\\n}\\n\"},{\"language\":\"Java\",\"content\":\"public int gcd(int a, int b) {\\r\\n    return b == 0 ? a : gcd(b, a % b);\\r\\n}\\r\\n    \\r\\npublic int lcm(int a, int b) {\\r\\n    return a * b / gcd(a, b);\\r\\n}\\n\"},{\"language\":\"Py\",\"content\":\"def gcd(a: int, b: int) -> int:\\n    return a if b == 0 else gcd(b, a % b)\\n\\n\\ndef lcm(a: int, b: int) -> int:\\n    return a * b // gcd(a, b)\\n\\n\"}]}]},{\"id\":\"19\",\"name\":\"第十九章\",\"list\":[{\"title\":\"代码19.1.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  void rotate(vector<int>& nums, int k) {\\n    vector<int> copy = nums;\\n    int n = nums.size();\\n    for (int i = 0; i < n; i++)\\n      nums[(k + i) % n] = copy[i];\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Solution {\\n  public void rotate(int[] nums, int k) {\\n    int[] copy = new int[nums.length];\\n    int n = nums.length;\\n    for (int i = 0; i < n; i++) copy[i] = nums[i];\\n    for (int i = 0; i < n; i++)\\n      nums[(k + i) % n] = copy[i];\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        copy = nums.copy()\\n        n = len(nums)\\n\\n        for i in range(n):\\n            nums[(k + i) % n] = copy[i]\\n\\n\"}]},{\"title\":\"代码19.1.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  void rotate(vector<int>& nums, int k) {\\n    vector<int> copy = nums;\\n    int n = nums.size();\\n    if (k % n == 0) return;\\n    for (int i = 0; i < n; i++)\\n      nums[(k + i) % n] = copy[i];\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Solution {\\n  public void rotate(int[] nums, int k) {\\n    int[] copy = new int[nums.length];\\n    int n = nums.length;\\n    for (int i = 0; i < n; i++) copy[i] = nums[i];\\n    if (k % n == 0) return;\\n    for (int i = 0; i < n; i++)\\n      nums[(k + i) % n] = copy[i];\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        copy = nums.copy()\\n        n = len(nums)\\n        if k % n == 0:\\n            return\\n\\n        for i in range(n):\\n            nums[(k + i) % n] = copy[i]\\n\\n\"}]},{\"title\":\"代码19.1.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  void rotate(vector<int>& nums, int k) {\\n    int n = nums.size(), t, offset = n - k % n;\\n    if (offset == 0) return;\\n    while (offset) {\\n      t = nums[0];\\n      offset -= 1;\\n      for (int i = 0; i < n - 1; i++)\\n        nums[i] = nums[i + 1];\\n      nums[n - 1] = t;\\n    }\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Solution {\\n  public void rotate(int[] nums, int k) {\\n    int n = nums.length, t, offset = n - k % n;\\n    if (offset == 0) return;\\n    while (offset != 0) {\\n      t = nums[0];\\n      offset -= 1;\\n      for (int i = 0; i < n - 1; i++)\\n        nums[i] = nums[i + 1];\\n      nums[n - 1] = t;\\n    }\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \\\"\\\"\\\"\\n        Do not return anything, modify nums in-place instead.\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        t = None\\n        offset = n - k % n  # 右移变左移\\n        if offset == 0:\\n            return\\n        while offset:\\n            t = nums[0]\\n            offset -= 1\\n            for i in range(n - 1):\\n                nums[i] = nums[i + 1]\\n            nums[n - 1] = t\\n\\n\"}]},{\"title\":\"代码19.1.4\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  vector<int> rotate(vector<int>& nums, int k) {\\n    int n = nums.size(), offset = k % n;\\n    for (int i = 0; i < n; i++) nums.push_back(nums[i]);\\n    vector<int> ans;\\n    for (int i = n - offset; i < n * 2 - offset; i++)\\n      ans.push_back(nums[i]);\\n    return ans;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Solution {\\n  public int[] rotate(int[] nums, int k) {\\n    int n = nums.length, offset = k % n;\\n    int[] ano_nums = new int[2 * n];\\n    for (int i = 0; i < n; i++)\\n      ano_nums[i] = ano_nums[n + i] = nums[i];\\n    int[] ans = new int[n];\\n    for (int i = n - offset; i < n * 2 - offset; i++)\\n      ans[i - n + offset] = ano_nums[i];\\n    return ans;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \\\"\\\"\\\"\\n        Do not return anything, modify nums in-place instead.\\n        \\\"\\\"\\\"\\n        n = len(nums)\\n        offset = k % n\\n        nums = nums + nums.copy()\\n        return nums[n - offset : n * 2 - offset]\\n\\n\"}]},{\"title\":\"代码19.1.5\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  void reverse(vector<int>& arr, int start, int end) {\\n    while (start < end) {\\n      int t = arr[start];\\n      arr[start] = arr[end];\\n      arr[end] = t;\\n      start += 1;\\n      end -= 1;\\n    }\\n  }\\n  void rotate(vector<int>& nums, int k) {\\n    int n = nums.size(), offset = k % n;\\n    if (offset == 0) return;\\n    reverse(nums, 0, n - offset - 1);\\n    reverse(nums, n - offset, n - 1);\\n    reverse(nums, 0, n - 1);\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Solution {\\n  public void reverse(int[] arr, int start, int end) {\\n    while (start < end) {\\n      int t = arr[start];\\n      arr[start] = arr[end];\\n      arr[end] = t;\\n      start += 1;\\n      end -= 1;\\n    }\\n  }\\n  public void rotate(int[] nums, int k) {\\n    int n = nums.length, offset = k % n;\\n    if (offset == 0) return;\\n    reverse(nums, 0, n - offset - 1);\\n    reverse(nums, n - offset, n - 1);\\n    reverse(nums, 0, n - 1);\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \\\"\\\"\\\"\\n        Do not return anything, modify nums in-place instead.\\n        \\\"\\\"\\\"\\n        # 首尾交换法\\n        def reverse(list: List[int], start: int, end: int) -> None:\\n            while start < end:\\n                t = list[start]\\n                list[start] = list[end]\\n                list[end] = t\\n                start += 1\\n                end -= 1\\n\\n        n = len(nums)\\n        offset = k % n\\n        if offset == 0:\\n            return\\n        reverse(nums, 0, n - offset - 1)\\n        reverse(nums, n - offset, n - 1)\\n        reverse(nums, 0, n - 1)\\n\\n\"}]},{\"title\":\"代码19.2.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <cstdio>\\n\\nclass Solution {\\npublic:\\n  ListNode *rotateRight(ListNode *head, int k) {\\n    if (head == NULL || head->next == NULL) return head;\\n    ListNode *p1 = head, *res = NULL;\\n    int n = 1;\\n    while (p1 && p1->next) {\\n      p1 = p1->next;\\n      n += 1;\\n    }\\n    int cur = 1;\\n    ListNode *p2 = head;\\n    while (cur < n - k % n) {\\n      p2 = p2->next;\\n      cur += 1;\\n    }\\n    p1->next = head;\\n    res = p2->next;\\n    p2->next = NULL;\\n    return res;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Solution {\\n  public ListNode rotateRight(ListNode head, int k) {\\n    if (head == null || head.next == null) return head;\\n    ListNode p1 = head, res = null;\\n    int n = 1;\\n    while (p1 != null && p1.next != null) {\\n      p1 = p1.next;\\n      n += 1;\\n    }\\n    int cur = 1;\\n    ListNode p2 = head;\\n    while (cur < n - k % n) {\\n      p2 = p2.next;\\n      cur += 1;\\n    }\\n    p1.next = head;\\n    res = p2.next;\\n    p2.next = null;\\n    return res;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        if head == None or head.next == None:\\n            return head\\n        p1 = head\\n        res = None\\n        n = 1\\n\\n        while p1 and p1.next:\\n            p1 = p1.next\\n            n += 1\\n        cur = 1\\n        p2 = head\\n        while cur < n - k % n:\\n            p2 = p2.next\\n            cur += 1\\n        p1.next = head\\n        res = p2.next\\n        p2.next = None\\n\\n        return res\\n\\n\"}]},{\"title\":\"代码19.3.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <string>\\n#include <algorithm>\\n#include <map>\\n#include <utility>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int helper(string word1, int s1, int e1,\\n      string word2, int s2, int e2,\\n      map<pair<int, int>, int>& memo) {\\n    if (s1 > e1) return e2 - s2 + 1;\\n    else if (s2 > e2) return e1 - s1 + 1;\\n    char c1 = word1[s1], c2 = word2[s2];\\n    pair<int, int> key = make_pair(s1, s2);\\n    if (memo.count(key)) return memo[key];\\n    if (c1 == c2)\\n      return memo[key] = helper(word1, s1 + 1, e1, word2,\\n          s2 + 1, e2, memo);\\n    else\\n      return memo[key] = min(min(helper(word1, s1 + 1,\\n            e1, word2, s2, e2, memo), helper(word1,\\n              s1, e1, word2, s2 + 1, e2, memo)), helper(\\n              word1, s1 + 1, e1, word2, s2 + 1, e2, memo\\n              )) + 1;\\n  }\\n  int minDistance(string word1, string word2) {\\n    map<pair<int, int>, int> dict;\\n    return helper(word1, 0, word1.size() - 1,\\n        word2, 0, word2.size() - 1, dict);\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\nimport java.lang.Math;\\n\\npublic class Solution {\\n  public class Pair {\\n    public final int first;\\n    public final int second;\\n    public Pair(int x, int y) {\\n      this.first = x;\\n      this.second = y;\\n    }\\n  }\\n  public Pair make_pair(int x, int y) {\\n    Pair node = new Pair(x, y);\\n    return node;\\n  }\\n  public int helper(String word1, int s1, int e1,\\n      String word2, int s2, int e2,\\n      Map<Pair, Integer> memo) {\\n    if (s1 > e1) return e2 - s2 + 1;\\n    else if (s2 > e2) return e1 - s1 + 1;\\n    char c1 = word1.charAt(s1), c2 = word2.charAt(s2);\\n    Pair key = make_pair(s1, s2);\\n    if (memo.get(key) != null) return memo.get(key);\\n    if (c1 == c2) {\\n      int buf_val = helper(word1, s1 + 1, e1, word2,\\n          s2 + 1, e2, memo);\\n      memo.put(key, buf_val);\\n      return buf_val;\\n    } else {\\n      int buf_val = Math.min(Math.min(helper(word1,\\n              s1 + 1, e1, word2, s2, e2, memo),\\n            helper(word1, s1, e1, word2, s2 + 1, e2,\\n              memo)), helper(word1, s1 + 1, e1, word2,\\n              s2 + 1, e2, memo)) + 1;\\n      memo.put(key, buf_val);\\n      return buf_val;\\n    }\\n  }\\n  public int minDistance(String word1, String word2) {\\n    Map<Pair, Integer> dict = new HashMap<Pair, Integer>();\\n    return helper(word1, 0, word1.length() - 1,\\n        word2, 0, word2.length() - 1, dict);\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def helper(\\n        self, word1: str, s1: int, e1: int, word2: str, s2: int, e2: int, memo: dict\\n    ) -> int:\\n        if s1 > e1:\\n            return e2 - s2 + 1\\n        elif s2 > e2:\\n            return e1 - s1 + 1\\n        c1 = word1[s1]\\n        c2 = word2[s2]\\n        key = (s1, s2)\\n        if key in memo:\\n            return memo[key]\\n        if c1 == c2:\\n            memo[key] = self.helper(word1, s1 + 1, e1, word2, s2 + 1, e2, memo)\\n            return memo[key]\\n        else:\\n            memo[key] = (\\n                min(\\n                    self.helper(\\n                        word1, s1 + 1, e1, word2, s2, e2, memo\\n                    ),  # delete or add\\n                    self.helper(\\n                        word1, s1, e1, word2, s2 + 1, e2, memo\\n                    ),  # delete or add\\n                    self.helper(word1, s1 + 1, e1, word2, s2 + 1, e2, memo),  # replace\\n                )\\n                + 1\\n            )\\n\\n            return memo[key]\\n\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        return self.helper(word1, 0, len(word1) - 1, word2, 0, len(word2) - 1, dict())\\n\\n\"}]},{\"title\":\"代码19.3.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <cstdlib>\\n#include <string>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int minDistance(string word1, string word2) {\\n    int m = word1.length(), n = word2.length();\\n    int **dp = (int **)malloc((m + 1) * sizeof(int *));\\n    for (int i = 0; i <= m; i++) {\\n      dp[i] = (int *)malloc((n + 1) * sizeof(int));\\n      for (int j = 0; j <= n; j++)\\n        dp[i][j] = 0;\\n    }\\n    for (int i = 1; i <= m; i++) dp[i][0] = i;\\n    for (int j = 1; j <= n; j++) dp[0][j] = j;\\n    for (int i = 1; i <= m; i++)\\n      for (int j = 1; j <= n; j++) {\\n        if (word1[i - 1] == word2[j - 1])\\n          dp[i][j] = dp[i - 1][j - 1];\\n        else\\n          dp[i][j] = min(min(dp[i - 1][j - 1],\\\\\\n                dp[i][j - 1]), dp[i - 1][j]) + 1;\\n      }\\n    int ans = dp[m][n];\\n    for (int i = 0; i <= m; i++) free(dp[i]);\\n    free(dp);\\n    return ans;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.lang.Math\\n\\npublic class Solution {\\n  public int minDistance(String word1, String word2) {\\n    int m = word1.length(), n = word2.length();\\n    int[][] dp = new int[m + 1][n + 1];\\n    for (int i = 0; i <= m; i++)\\n      for (int j = 0; j <= n; j++) dp[i][j] = 0;\\n    for (int i = 1; i <= m; i++) dp[i][0] = i;\\n    for (int j = 1; j <= n; j++) dp[0][j] = j;\\n    for (int i = 1; i <= m; i++)\\n      for  (int j = 1; j <= n; j++)\\n        if (word1.charAt(i - 1) == word2.charAt(j - 1))\\n          dp[i][j] = dp[i - 1][j - 1];\\n        else\\n          dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1],\\n                dp[i][j - 1]), dp[i - 1][j]) + 1;\\n    return dp[m][n];\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m = len(word1)\\n        n = len(word2)\\n        dp = [[0 for j in range(n + 1)] for i in range(m + 1)]\\n\\n        for i in range(1, m + 1):\\n            dp[i][0] = i\\n        for j in range(1, n + 1):\\n            dp[0][j] = j\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                else:\\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1\\n        return dp[m][n]\\n\\n\"}]},{\"title\":\"代码19.3.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <string>\\n#include <cstdlib>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int minDistance(string word1, string word2) {\\n    int m = word1.length(), n = word2.length();\\n    int *pre = (int *)malloc((n + 1) * sizeof(int));\\n    int *cur = (int *)malloc((n + 1) * sizeof(int));\\n    for (int i = 0; i <= n; i++) pre[i] = cur[i] = 0;\\n    for (int i = 1; i <= n; i++) pre[i] = i;\\n    for (int i = 1; i <= m; i++) {\\n      cur[0] = i;\\n      for (int j = 1; j <= n; j++) {\\n        if (word1[i - 1] == word2[j - 1])\\n          cur[j] = pre[j - 1];\\n        else\\n          cur[j] = min(min(pre[j], pre[j - 1]),\\n              cur[j - 1]) + 1;\\n      }\\n      for (int k = 0; k <= n; k++) pre[k] = cur[k];\\n    }\\n    int ans = pre[n];\\n    free(pre);\\n    free(cur);\\n    return ans;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.lang.Math;\\n\\npublic class Solution {\\n  public int minDistance(String word1, String word2) {\\n    int m = word1.length(), n = word2.length();\\n    int[] pre = new int[n + 1];\\n    int[] cur = new int[n + 1];\\n    for (int i = 0; i <= n; i++) pre[i] = cur[i] = 0;\\n    for (int i = 1; i <= n; i++) pre[i] = i;\\n    for (int i = 1; i <= m; i++) {\\n      cur[0] = i;\\n      for (int j = 1; j <= n; j++) {\\n        if (word1.charAt(i - 1) == word2.charAt(j - 1))\\n          cur[j] = pre[j - 1];\\n        else\\n          cur[j] = Math.min(Math.min(pre[j], pre[j - 1]),\\n              cur[j - 1]) + 1;\\n      }\\n      for (int k = 0; k <= n; k++) pre[k] = cur[k];\\n    }\\n    return pre[n];\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m = len(word1)\\n        n = len(word2)\\n        pre = [0] * (n + 1)\\n        cur = [0] * (n + 1)\\n\\n        for i in range(1, n + 1):\\n            pre[i] = i\\n        for i in range(1, m + 1):\\n            cur[0] = i\\n            for j in range(1, n + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    cur[j] = pre[j - 1]\\n                else:\\n                    cur[j] = min(pre[j], pre[j - 1], cur[j - 1]) + 1\\n            # move on\\n            pre = cur.copy()\\n        # 最后进行了一次交换， cur变成了pre，因此我们应该取pre[n]，而不是cur[n]\\n        return pre[n]\\n\\n\"}]},{\"title\":\"代码19.3.4\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <cstdlib>\\n#include <string>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int minDistance(string word1, string word2) {\\n    int m = word1.size(), n = word2.size();\\n    int *cur = (int *)malloc((n + 1) * sizeof(int));\\n    cur[0] = 0;\\n    int pre;\\n    for (int i = 1; i <= n; i++) cur[i] = i;\\n    for (int i = 1; i <= m; i++) {\\n      pre = cur[0];\\n      cur[0] = i;\\n      for (int j = 1; j <= n; j++) {\\n        int temp = cur[j];\\n        if (word1[i - 1] == word2[j - 1])\\n          cur[j] = pre;\\n        else\\n          cur[j] = min(min(cur[j], cur[j - 1]), pre) + 1;\\n        pre = temp;\\n      }\\n    }\\n    int ans = cur[n];\\n    free(cur);\\n    return ans;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.lang.Math;\\n\\npublic class Solution {\\n  public int minDistance(String word1, String word2) {\\n    int m = word1.length(), n = word2.length();\\n    int[] cur = new int[n + 1];\\n    int pre;\\n    for (int i = 1; i <= n; i++) cur[i] = i;\\n    for (int i = 1; i <= m; i++) {\\n      pre = cur[0];\\n      cur[0] = i;\\n      for (int j = 1; j <= n; j++) {\\n        int temp = cur[j];\\n        if (word1.charAt(i - 1) == word2.charAt(j - 1))\\n          cur[j] = pre;\\n        else\\n          cur[j] = Math.min(Math.min(cur[j], cur[j - 1]),\\n              pre) + 1;\\n        pre = temp;\\n      }\\n    }\\n    return cur[n];\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m = len(word1)\\n        n = len(word2)\\n        cur = [0] * (n + 1)\\n        pre = None\\n\\n        for i in range(1, n + 1):\\n            cur[i] = i\\n        for i in range(1, m + 1):\\n            pre = cur[0]\\n            cur[0] = i\\n            for j in range(1, n + 1):\\n                temp = cur[j]\\n                if word1[i - 1] == word2[j - 1]:\\n                    cur[j] = pre\\n                else:\\n                    cur[j] = min(cur[j], cur[j - 1], pre) + 1\\n                pre = temp\\n        return cur[n]\\n\\n\"}]},{\"title\":\"代码19.4.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <ctime>\\n#include <cstdlib>\\n#include <algorithm>\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  // find the idx-th smallest element\\n  // 0-th smallest element is the smallest globally\\n  // time complexity is O(n)\\n  int locate(vector<int>& arr,\\n      int st, int ed, int idx) {\\n    if (st == ed) return arr[st];\\n\\n    // avoid the worst case\\n    int rd = st + rand() % (ed - st + 1);\\n    swap(arr[rd], arr[ed]);\\n\\n    int now = st;\\n    for (int i = st; i < ed; i++)\\n      if (arr[i] < arr[ed]) swap(arr[i], arr[now++]);\\n    swap(arr[now], arr[ed]);\\n    if (now == st + idx) return arr[now];\\n    else if (now < st + idx)\\n      return locate(arr, now + 1, ed,\\n          idx - (now - st) - 1);\\n    else return locate(arr, st, now - 1, idx);\\n  }\\n  int findKthLargest(vector<int>& nums, int k){\\n    return locate(nums, 0, nums.size() - 1,\\n        nums.size() - k);\\n  }\\n};\\n\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\n\\npublic class Solution {\\n  public int locate(int[] arr, int st, int ed, int idx) {\\n    if (st == ed) return arr[st];\\n    Random r = new Random();\\n    int rd = st + r.nextInt(ed - st + 1);\\n    int tmp = arr[rd];\\n    arr[rd] = arr[ed];\\n    arr[ed] = tmp;\\n    int now = st;\\n    for (int i = st; i < ed; i++)\\n      if (arr[i] < arr[ed]) {\\n        tmp = arr[i];\\n        arr[i] = arr[now];\\n        arr[now] = tmp;\\n        now += 1;\\n      }\\n    tmp = arr[now];\\n    arr[now] = arr[ed];\\n    arr[ed] = tmp;\\n    if (now == st + idx) return arr[now];\\n    else if (now < st + idx)\\n      return locate(arr, now + 1, ed,\\n          idx - (now - st) - 1);\\n    else return locate(arr, st, now - 1, idx);\\n  }\\n  int findKthLargest(int[] nums, int k) {\\n    return locate(nums, 0, nums.length - 1,\\n        nums.length - k);\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"from heapq import nlargest\\n\\n\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return nlargest(k, nums)[-1]\\n\\n\"}]},{\"title\":\"代码19.4.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <queue>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass KthLargest {\\npublic:\\n  priority_queue<int, vector<int>, less<int> > qlarge;\\n  priority_queue<int, vector<int>, greater<int> > qsmall;\\n  int k;\\n  KthLargest(int buf_k, vector<int>& nums) {\\n    while (!qlarge.empty()) qlarge.pop();\\n    while (!qsmall.empty()) qsmall.pop();\\n    k = buf_k;\\n    for (int i = 0; i < nums.size(); i++)\\n      qlarge.push(nums[i]);\\n    while (qsmall.size() < k - 1) {\\n      qsmall.push(qlarge.top());\\n      qlarge.pop();\\n    }\\n  }\\n  int add(int val) {\\n    int cmp;\\n    if (k > 1) cmp = qsmall.top();\\n    else {\\n      qlarge.push(val);\\n      return qlarge.top();\\n    }\\n    if (cmp < val) {\\n      qsmall.pop();\\n      qsmall.push(val);\\n      qlarge.push(cmp);\\n    } else {\\n      qlarge.push(val);\\n    }\\n    return qlarge.top();\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\n\\nclass KthLargest {\\n  public static Comparator<Integer> less = new\\n    Comparator<Integer>() {\\n      public int compare(Integer e1, Integer e2) {\\n        return e2 - e1;\\n      }\\n    };\\n  public static Comparator<Integer> greater = new\\n    Comparator<Integer>() {\\n      public int compare(Integer e1, Integer e2) {\\n        return e1 - e2;\\n      }\\n    };\\n  public Queue<Integer> qlarge;\\n  public Queue<Integer> qsmall;\\n  public int k;\\n  public KthLargest(int buf_k, int[] nums) {\\n    qlarge = new PriorityQueue<>(less);\\n    qsmall = new PriorityQueue<>(greater);\\n    k = buf_k;\\n    for (int i = 0; i < nums.length; i++)\\n      qlarge.add(nums[i]);\\n    while (qsmall.size() < k - 1) {\\n      qsmall.add(qlarge.peek());\\n      qlarge.poll();\\n    }\\n  }\\n  public int add(int val) {\\n    int cmp;\\n    if (k > 1) cmp = qsmall.peek();\\n    else {\\n      qlarge.add(val);\\n      return qlarge.peek();\\n    }\\n    if (cmp < val) {\\n      qsmall.poll();\\n      qsmall.add(val);\\n      qlarge.add(cmp);\\n    } else {\\n      qlarge.add(val);\\n    }\\n    return qlarge.peek();\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"import heapq\\n\\n\\nclass KthLargest:\\n    def __init__(self, k: int, nums: List[int]):\\n        self.k = k\\n        self.nums = heapq.nlargest(k, nums + [float(\\\"-inf\\\")])\\n        heapq.heapify(self.nums)\\n\\n    def add(self, val: int) -> int:\\n        heapq.heappushpop(self.nums, val)\\n        return self.nums[0]\\n\\n\"}]},{\"title\":\"代码19.4.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <cstdio>\\n\\nclass Solution {\\npublic:\\n  int countNodes(TreeNode *node) {\\n    if (node == NULL) return 0;\\n    int l = countNodes(node->left);\\n    int r = countNodes(node->right);\\n    return l + r + 1;\\n  }\\n  int kthSmallest(TreeNode *root, int k) {\\n    int cnt = countNodes(root->left);\\n    if (cnt == k - 1) return root->val;\\n    else if (cnt > k - 1)\\n      return kthSmallest(root->left, k);\\n    else\\n      return kthSmallest(root->right, k - cnt - 1);\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  public int countNodes(TreeNode node) {\\n    if (node == null) return 0;\\n    int l = countNodes(node.left);\\n    int r = countNodes(node.right);\\n    return l + r + 1;\\n  }\\n  public int kthSmallest(TreeNode root, int k) {\\n    int cnt = countNodes(root.left);\\n    if (cnt == k - 1) return root.val;\\n    else if (cnt > k - 1)\\n      return kthSmallest(root.left, k);\\n    else\\n      return kthSmallest(root.right, k - cnt - 1);\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def kthSmallest(self, root: TreeNode, k: int) -> int:\\n        # 返回该节点以及其所有子节点的个数\\n        def countNodes(node) -> int:\\n            if node == None:\\n                return 0\\n            l = countNodes(node.left)\\n            r = countNodes(node.right)\\n            return l + r + 1\\n\\n        cnt = countNodes(root.left)\\n        if cnt == k - 1:\\n            return root.val\\n        elif cnt > k - 1:\\n            return self.kthSmallest(root.left, k)\\n\\n        return self.kthSmallest(root.right, k - cnt - 1)\\n\\n\"}]},{\"title\":\"代码19.4.4\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int countNotGreater(const vector<vector<int> >& matrix,\\n      int target) {\\n    int n = matrix.size();\\n    int i = 0, j = n - 1, cnt = 0;\\n    while (i < n && j >= 0) {\\n      if (matrix[i][j] <= target) {\\n        cnt += j + 1;\\n        i += 1;\\n      } else {\\n        j -= 1;\\n      }\\n    }\\n    return cnt;\\n  }\\n  int kthSmallest(vector<vector<int> >& matrix, int k) {\\n    int n = matrix.size();\\n    int lo = matrix[0][0], hi = matrix[n - 1][n - 1];\\n    while (lo < hi) {\\n      int mid = (lo + hi) / 2;\\n      int cnt = countNotGreater(matrix, mid);\\n      if (cnt < k) lo = mid + 1;\\n      else hi = mid;\\n    }\\n    return lo;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Solution {\\n  public int countNotGreater(int[][] matrix, int target) {\\n    int n = matrix.length;\\n    int i = 0, j = n - 1, cnt = 0;\\n    while (i < n && j >= 0) {\\n      if (matrix[i][j] <= target) {\\n        cnt += j + 1;\\n        i += 1;\\n      }\\n      else j -= 1;\\n    }\\n    return cnt;\\n  }\\n  int kthSmallest(int[][] matrix, int k) {\\n    int n = matrix.length;\\n    int lo = matrix[0][0], hi = matrix[n - 1][n - 1];\\n    while (lo < hi) {\\n      int mid = (lo + hi) / 2;\\n      int cnt = countNotGreater(matrix, mid);\\n      if (cnt < k) lo = mid + 1;\\n      else hi = mid;\\n    }\\n    return lo;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        n = len(matrix)\\n        lo = matrix[0][0]\\n        hi = matrix[n - 1][n - 1]\\n\\n        def countNotGreater(target: int) -> int:\\n            i, j = 0, n - 1\\n            cnt = 0\\n            while i < n and j >= 0:\\n                if matrix[i][j] <= target:\\n                    cnt += j + 1\\n                    i += 1\\n                else:\\n                    j -= 1\\n            return cnt\\n\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            cnt = countNotGreater(mid)\\n\\n            if cnt < k:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo\\n\\n\"}]},{\"title\":\"代码19.4.5\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int countNotGreater(int mid, int m, int n) {\\n    int cnt = 0;\\n    for (int i = 1; i <= m; i++)\\n      cnt += min(mid / i, n);\\n    return cnt;\\n  }\\n  int findKthNumber(int m, int n, int k) {\\n    int lo = 1, hi = m * n;\\n    while (lo < hi) {\\n      int mid = (lo + hi) / 2;\\n      if (countNotGreater(mid, m, n) < k)\\n        lo = mid + 1;\\n      else\\n        hi = mid;\\n    }\\n    return lo;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.lang.Math;\\n\\npublic class Solution {\\n  public int countNotGreater(int mid, int m, int n) {\\n    int cnt = 0;\\n    for (int i = 1; i <= m; i++)\\n      cnt += Math.min(mid / i, n);\\n    return cnt;\\n  }\\n  public int findKthNumber(int m, int n, int k) {\\n    int lo = 1, hi = m * n;\\n    while (lo < hi) {\\n      int mid = (lo + hi) / 2;\\n      if (countNotGreater(mid, m, n) < k)\\n        lo = mid + 1;\\n      else\\n        hi = mid;\\n    }\\n    return lo;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def findKthNumber(self, m: int, n: int, k: int) -> int:\\n        lo = 1\\n        hi = m * n\\n\\n        def countNotGreater(mid: int, m: int, n: int) -> int:\\n            cnt = 0\\n            for i in range(1, m + 1):\\n                cnt += min(mid // i, n)\\n            return cnt\\n\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if countNotGreater(mid, m, n) < k:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo\\n\\n\"}]}]},{\"id\":\"20\",\"name\":\"第二十章\",\"list\":[{\"title\":\"代码20.1.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"\\n#include <vector>\\n#include <string>\\n#include <map>\\n#include <queue>\\n#include <set>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  void flip(map<string, string>& mapper, vector<string>& state, int i, int m, int n) {\\n    state[i] = mapper[state[i]];\\n    if (i % n != 0)\\n      state[i - 1] = mapper[state[i - 1]];\\n    if (i % n < n - 1)\\n      state[i + 1] = mapper[state[i + 1]];\\n    if (i >= n)\\n      state[i - n] = mapper[state[i - n]];\\n    if (i < (m - 1) * n)\\n      state[i + n] = mapper[state[i + n]];\\n  }\\n  int minFlips(vector<vector<int> >& mat) {\\n    map<string, string> mapper;\\n    int m = mat.size();\\n    int n = mat[0].size();\\n    string target(\\\"\\\"), cur(\\\"\\\");\\n    for (int i = 0; i < m; i++)\\n      for (int j = 0; j < n; j++) {\\n        target += \\\"0\\\";\\n        cur += to_string(mat[i][j]);\\n      }\\n    queue<string> q;\\n    q.push(cur);\\n    set<string> visited;\\n    int steps = 0;\\n    mapper[\\\"0\\\"] = \\\"1\\\";\\n    mapper[\\\"1\\\"] = \\\"0\\\";\\n    while (!q.empty()) {\\n      int last_q_size = q.size();\\n      for (int flg = 0; flg < last_q_size; flg++) {\\n        cur = q.front();\\n        q.pop();\\n        if (cur == target) return steps;\\n        if (visited.count(cur)) continue;\\n        visited.insert(cur);\\n        for (int j = 0; j < cur.length(); j++) {\\n          vector<string> s;\\n          for (int ww = 0; ww < cur.length(); ww++)\\n            s.push_back(string(1, cur[ww]));\\n          flip(mapper, s, j, m, n);\\n          string to_add(\\\"\\\");\\n          for (int ww = 0; ww < s.size(); ww++)\\n            to_add += s[ww];\\n          q.push(to_add);\\n        }\\n      }\\n      steps += 1;\\n    }\\n    return -1;\\n  }\\n};\\n\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\n\\npublic class Solution {\\n    Map<String, String> mapper = new HashMap<String, String>();\\n    int m;\\n    int n;\\n    private void flip(String[] state, int i) {\\n        state[i] = mapper.get(state[i]);\\n        if ((i % n) != 0) {\\n            state[i - 1] = mapper.get(state[i - 1]);\\n        }\\n        if ((i % n) < n - 1) {\\n            state[i + 1] = mapper.get(state[i + 1]);\\n        }\\n        if (i >= n) {\\n            state[i - n] = mapper.get(state[i - n]);\\n        }\\n        if (i < (m - 1) * n) {\\n            state[i + n] = mapper.get(state[i + n]);\\n        }\\n    }\\n    public int minFlips(int[][] mat) {\\n        m = mat.length;\\n        n = mat[0].length;\\n        int[][] initial = new int[m][n];\\n        StringBuffer targetBuffer = new StringBuffer();\\n        StringBuffer curBufffer = new StringBuffer();\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                targetBuffer.append(String.valueOf(initial[i][j]));\\n                curBufffer.append(String.valueOf(mat[i][j]));\\n            }\\n        }\\n        String target = targetBuffer.toString();\\n        String cur = curBufffer.toString();\\n        LinkedList<String> queue = new LinkedList<String>();\\n        queue.offer(cur);\\n\\t\\tSet visited = new HashSet();\\n        int steps = 0;\\n        mapper.put(\\\"0\\\", \\\"1\\\");\\n        mapper.put(\\\"1\\\", \\\"0\\\");\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++) {\\n                cur = queue.poll();\\n                if (cur.equals(target)) return steps;\\n                if (visited.contains(cur)) continue;\\n                visited.add(cur);\\n                \\n                for(int j = 0; j < cur.length(); j++) {\\n                    String[] s = cur.split(\\\"\\\");\\n                    flip(s, j);\\n                    queue.add(String.join(\\\"\\\", s));\\n                }\\n            }\\n            steps += 1;\\n        }\\n        return -1;\\n    }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def minFlips(self, mat: List[List[int]]) -> int:\\n        # 放到 flip 函数外面可以减少计算\\n        mapper = {\\\"0\\\": \\\"1\\\", \\\"1\\\": \\\"0\\\"}\\n\\n        def flip(state: List[str], i: int) -> None:\\n            state[i] = mapper[state[i]]\\n            if i % n != 0:\\n                state[i - 1] = mapper[state[i - 1]]\\n            if i % n < n - 1:\\n                state[i + 1] = mapper[state[i + 1]]\\n            if i >= n:\\n                state[i - n] = mapper[state[i - n]]\\n            if i < (m - 1) * n:\\n                state[i + n] = mapper[state[i + n]]\\n\\n        m = len(mat)\\n        n = len(mat[0])\\n        target = \\\"0\\\" * (m * n)\\n        cur = \\\"\\\".join(str(cell) for row in mat for cell in row)\\n\\n        queue = [cur]\\n        visited = set()\\n        steps = 0\\n\\n        while len(queue) > 0:\\n            for _ in range(len(queue)):\\n                cur = queue.pop(0)\\n                if cur == target:\\n                    return steps\\n                if cur in visited:\\n                    continue\\n\\n                visited.add(cur)\\n                for i in range(len(cur)):\\n                    s = list(cur)\\n                    flip(s, i)\\n                    queue.append(\\\"\\\".join(s))\\n            steps += 1\\n\\n        return -1\\n\\n\"}]},{\"title\":\"代码20.1.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  void setRowZeros(vector<vector<int> >& matrix, int i) {\\n    for (int j = 0; j < matrix[i].size(); j++)\\n      matrix[i][j] = 0;\\n  }\\n  void setColZeros(vector<vector<int> >& matrix, int j) {\\n    for (int i = 0; i < matrix.size(); i++)\\n      matrix[i][j] = 0;\\n  }\\n  void setZeroes(vector<vector<int> >& matrix) {\\n    bool isCol = false;\\n    int R = matrix.size(), C = matrix[0].size();\\n    for (int i = 0; i < R; i++) {\\n      if (matrix[i][0] == 0) isCol = true;\\n      for (int j = 1; j < C; j++)\\n        if (matrix[i][j] == 0) {\\n          matrix[i][0] = 0;\\n          matrix[0][j] = 0;\\n        }\\n    }\\n    for (int j = 1; j < C; j++)\\n      if (matrix[0][j] == 0)\\n        setColZeros(matrix, j);\\n    for (int i = 0; i < R; i++)\\n      if (matrix[i][0] == 0)\\n        setRowZeros(matrix, i);\\n    if (isCol) setColZeros(matrix, 0);\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"class Solution {\\n  public void setRowZeros(int[][] matrix, int i) {\\n    for (int j = 0; j < matrix[i].length; j++)\\n      matrix[i][j] = 0;\\n  }\\n  public void setColZeors(int[][] matrix, int j) {\\n    for (int i = 0; i < matrix.length; i++)\\n      matrix[i][j] = 0;\\n  }\\n  public void setZeroes(int[][] matrix) {\\n    boolean isCol = false;\\n    int R = matrix.length, C = matrix[0].length;\\n    for (int i = 0; i < R; i++) {\\n      if (matrix[i][0] == 0) isCol = true;\\n      for (int j = 1; j < C; j++)\\n        if (matrix[i][j] == 0) {\\n          matrix[i][0] = 0;\\n          matrix[0][j] = 0;\\n        }\\n    }\\n    for (int j = 1; j < C; j++)\\n      if (matrix[0][j] == 0)\\n        setColZeors(matrix, j);\\n    for (int i = 0; i < R; i++)\\n      if (matrix[i][0] == 0)\\n        setRowZeros(matrix, i);\\n    if (isCol) setColZeors(matrix, 0);\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \\\"\\\"\\\"\\n        Do not return anything, modify matrix in-place instead.\\n        \\\"\\\"\\\"\\n\\n        def setRowZeros(matrix: List[List[int]], i: int) -> None:\\n            C = len(matrix[0])\\n            matrix[i] = [0] * C\\n\\n        def setColZeros(matrix: List[List[int]], j: int) -> None:\\n            R = len(matrix)\\n            for i in range(R):\\n                matrix[i][j] = 0\\n\\n        isCol = False\\n        R = len(matrix)\\n        C = len(matrix[0])\\n\\n        for i in range(R):\\n            if matrix[i][0] == 0:\\n                isCol = True\\n            for j in range(1, C):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = 0\\n                    matrix[0][j] = 0\\n        for j in range(1, C):\\n            if matrix[0][j] == 0:\\n                setColZeros(matrix, j)\\n\\n        for i in range(R):\\n            if matrix[i][0] == 0:\\n                setRowZeros(matrix, i)\\n\\n        if isCol:\\n            setColZeros(matrix, 0)\\n\\n\"}]},{\"title\":\"代码20.1.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  void setZeroes(vector<vector<int> >& matrix) {\\n    const int none = -0x7fffffff;\\n    int rows = matrix.size(), cols = matrix[0].size();\\n    for (int r = 0; r < rows; r++)\\n      for (int c = 0; c < cols; c++)\\n        if (matrix[r][c] != none && matrix[r][c] == 0) {\\n          for (int i = 0; i < rows; i++)\\n            matrix[i][c] = ((matrix[i][c] != 0) ? none : 0);\\n          for (int j = 0; j < cols; j++)\\n            matrix[r][j] = ((matrix[r][j] != 0) ? none : 0);\\n        }\\n    for (int r = 0; r < rows; r++)\\n      for (int c = 0; c < cols; c++)\\n        if (matrix[r][c] == none)\\n          matrix[r][c] = 0;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Solution {\\n  public void setZeroes(int[][] matrix) {\\n    int none = -0x7fffffff;\\n    int rows = matrix.length, cols = matrix[0].length;\\n    for (int r = 0; r < rows; r++)\\n      for (int c = 0; c < cols; c++)\\n        if (matrix[r][c] != none && matrix[r][c] == 0) {\\n          for (int i = 0; i < rows; i++)\\n            matrix[i][c] = ((matrix[i][c] != 0) ? none: 0);\\n          for (int j = 0; j < cols; j++)\\n            matrix[r][j] = ((matrix[r][j] != 0) ? none: 0);\\n        }\\n    for (int r = 0; r < rows; r++)\\n      for (int c = 0; c < cols; c++)\\n        if (matrix[r][c] == none)\\n          matrix[r][c] = 0;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \\\"\\\"\\\"\\n        这题要解决的问题是，必须有个地方记录判断结果，但又不能影响下一步的判断条件；\\n        直接改为 0 的话，会影响下一步的判断条件；\\n        因此，有一种思路是先改为 None，最后再将 None 改为 0；\\n        从条件上看，如果可以将第一行、第二行作为记录空间，那么，用 None 应该也不算违背题目条件；\\n        \\\"\\\"\\\"\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        # 遍历矩阵，用 None 记录要改的地方，注意如果是 0 则要保留，否则会影响下一步判断\\n        for r in range(rows):\\n            for c in range(cols):\\n                if matrix[r][c] is not None and matrix[r][c] == 0:\\n                    # 改值\\n                    for i in range(rows):\\n                        matrix[i][c] = None if matrix[i][c] != 0 else 0\\n                    for j in range(cols):\\n                        matrix[r][j] = None if matrix[r][j] != 0 else 0\\n        # 再次遍历，将 None 改为 0\\n        for r in range(rows):\\n            for c in range(cols):\\n                if matrix[r][c] is None:\\n                    matrix[r][c] = 0\\n\\n\"}]},{\"title\":\"代码20.2.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\n#include <string>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  vector<int> sequentialDigits(int low, int high) {\\n    string numbers(\\\"123456789\\\");\\n    vector<int> ins;\\n    int n = numbers.size();\\n    for (int i = 1; i < n; i++)\\n      for (int j = 0; j < n - i; j++)\\n        ins.push_back(atoi(numbers.substr(j, i + 1).c_str()));\\n    vector<int> ans;\\n    for (int i = 0; i < ins.size(); i++)\\n      if (ins[i] >= low && ins[i] <= high)\\n        ans.push_back(ins[i]);\\n    return ans;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\n\\nclass Solution {\\n  public List<Integer> sequentialDigits(int low, int high) {\\n    String numbers = \\\"123456789\\\";\\n    List<Integer> ins = new ArrayList<>();\\n    int n = numbers.length();\\n    for (int i = 1; i < n; i++)\\n      for (int j = 0; j < n - i; j++)\\n        ins.add(Integer.parseInt(numbers.substring(\\n                j, i + j + 1\\n                )));\\n    List<Integer> ans = new ArrayList<>();\\n    for (int i = 0; i < ins.size(); i++)\\n      if (ins.get(i) >= low && ins.get(i) <= high)\\n        ans.add(ins.get(i));\\n    return ans;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        numbers = \\\"123456789\\\"\\n        ins = []\\n        n = len(numbers)\\n        for i in range(1, n):\\n            for j in range(n - i):\\n                ins.append(int(numbers[j : i + j + 1]))\\n        return [x for x in ins if x >= low and x <= high]\\n\\n\"}]},{\"title\":\"代码20.2.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\n#include <string>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  vector<int> sequentialDigits(int low, int high) {\\n    string numbers(\\\"123456789\\\");\\n    vector<int> ins;\\n    int n = numbers.length();\\n    for (int i = 1; i < n; i++)\\n      for (int j = 0; j < n - i; j++)\\n        ins.push_back(atoi(numbers.substr(j, i + 1).c_str()));\\n    vector<int>::iterator st = lower_bound(ins.begin(), ins.end(), low);\\n    vector<int>::iterator ed = upper_bound(ins.begin(), ins.end(), high);\\n    vector<int> ans;\\n    while (st != ed) ans.push_back(*st++);\\n    return ans;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\n\\npublic class Solution {\\n  public int lower_bound(List<Integer> arr, int first,\\n      int last, int value) {\\n    while (first < last) {\\n      int mid = first + (last - first) / 2;\\n      if (arr.get(mid) < value) first = mid + 1;\\n      else last = mid;\\n    }\\n    return first;\\n  }\\n  public int upper_bound(List<Integer> arr, int first,\\n      int last, int value) {\\n    while (first < last) {\\n      int mid = first + (last - first) / 2;\\n      if (arr.get(mid) <= value) first = mid + 1;\\n      else last = mid;\\n    }\\n    return first;\\n  }\\n  List<Integer> sequentialDigits(int low, int high) {\\n    String numbers = \\\"123456789\\\";\\n    List<Integer> ins = new ArrayList<>();\\n    int n = numbers.length();\\n    for (int i = 1; i < n; i++)\\n      for (int j = 0; j < n - i; j++)\\n        ins.add(Integer.parseInt(numbers.substring(\\n                j, i + j + 1\\n                )));\\n    int st = lower_bound(ins, 0, ins.size(), low);\\n    int ed = upper_bound(ins, 0, ins.size(), high);\\n    List<Integer> ans = new ArrayList<>();\\n    for (; st != ed; st++)\\n      ans.add(ins.get(st));\\n    return ans;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        numbers = \\\"123456789\\\"\\n        ins = []\\n        n = len(numbers)\\n        for i in range(1, n):\\n            for j in range(n - i):\\n                ins.append(int(numbers[j : i + j + 1]))\\n        return ins[bisect.bisect_left(ins, low) : bisect.bisect(ins, high)]\\n\\n\"}]},{\"title\":\"代码20.2.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <string>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  vector<int> sequentialDigits(int low, int high) {\\n    vector<int> ins {\\n            12,\\n            23,\\n            34,\\n            45,\\n            56,\\n            67,\\n            78,\\n            89,\\n            123,\\n            234,\\n            345,\\n            456,\\n            567,\\n            678,\\n            789,\\n            1234,\\n            2345,\\n            3456,\\n            4567,\\n            5678,\\n            6789,\\n            12345,\\n            23456,\\n            34567,\\n            45678,\\n            56789,\\n            123456,\\n            234567,\\n            345678,\\n            456789,\\n            1234567,\\n            2345678,\\n            3456789,\\n            12345678,\\n            23456789,\\n            123456789,\\n    };\\n    vector<int>::iterator st = lower_bound(ins.begin(),\\n        ins.end(), low);\\n    vector<int>::iterator ed = upper_bound(ins.begin(),\\n        ins.end(), high);\\n    vector<int> ans;\\n    while (st != ed) ans.push_back(*st++);\\n    return ans;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\n\\npublic class Solution {\\n  public int lower_bound(int[] arr, int first, int last,\\n      int value) {\\n    while (first < last) {\\n      int mid = first + (last - first) / 2;\\n      if (arr[mid] < value) first = mid + 1;\\n      else last = mid;\\n    }\\n    return first;\\n  }\\n  public int upper_bound(int[] arr, int first, int last,\\n      int value) {\\n    while (first < last) {\\n      int mid = first + (last - first) / 2;\\n      if (arr[mid] <= value) first = mid + 1;\\n      else last = mid;\\n    }\\n    return first;\\n  }\\n  public List<Integer> sequentialDigits(int low, int high) {\\n    int[] ins = {\\n            12,\\n            23,\\n            34,\\n            45,\\n            56,\\n            67,\\n            78,\\n            89,\\n            123,\\n            234,\\n            345,\\n            456,\\n            567,\\n            678,\\n            789,\\n            1234,\\n            2345,\\n            3456,\\n            4567,\\n            5678,\\n            6789,\\n            12345,\\n            23456,\\n            34567,\\n            45678,\\n            56789,\\n            123456,\\n            234567,\\n            345678,\\n            456789,\\n            1234567,\\n            2345678,\\n            3456789,\\n            12345678,\\n            23456789,\\n            123456789\\n    };\\n    int st = lower_bound(ins, 0, ins.length, low);\\n    int ed = upper_bound(ins, 0, ins.length, high);\\n    List<Integer> ans = new ArrayList<>();\\n    for (int i = st; i != ed; i++)\\n      ans.add(ins[i]);\\n    return ans;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        ins = [\\n            12,\\n            23,\\n            34,\\n            45,\\n            56,\\n            67,\\n            78,\\n            89,\\n            123,\\n            234,\\n            345,\\n            456,\\n            567,\\n            678,\\n            789,\\n            1234,\\n            2345,\\n            3456,\\n            4567,\\n            5678,\\n            6789,\\n            12345,\\n            23456,\\n            34567,\\n            45678,\\n            56789,\\n            123456,\\n            234567,\\n            345678,\\n            456789,\\n            1234567,\\n            2345678,\\n            3456789,\\n            12345678,\\n            23456789,\\n            123456789,\\n        ]\\n        return ins[bisect.bisect_left(ins, low) : bisect.bisect(ins, high)]\\n\\n\"}]},{\"title\":\"代码20.2.4\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\n#include <string>\\n#include <queue>\\n#include <set>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int ladderLength(string beginWord, string endWord,\\n      vector<string>& wordList) {\\n    queue<string> q;\\n    q.push(beginWord);\\n    set<string> visited;\\n    int steps = 1, L = beginWord.length();\\n    while (!q.empty()) {\\n      int last_q_size = q.size();\\n      for (int flg = 0; flg < last_q_size; flg++) {\\n        string cur = q.front();\\n        q.pop();\\n        if (visited.count(cur)) continue;\\n        visited.insert(cur);\\n        if (cur == endWord) return steps;\\n        for (int i = 0; i < L; i++)\\n          for (int j = 0; j < 26; j++) {\\n            string s = cur;\\n            s[i] = 'a' + j;\\n            for (int k = 0; k < wordList.size(); k++) {\\n              string& word = wordList[k];\\n              if (word == s)\\n                q.push(word);\\n            }\\n          }\\n      }\\n      steps += 1;\\n    }\\n    return 0;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\n\\nclass Solution {\\n  public int ladderLength(String beginWord,\\n      String endWord, List<String> wordList) {\\n    Queue<String> q = new LinkedList<String>();\\n    q.offer(beginWord);\\n    Set<String> visited = new HashSet<String>();\\n    int steps = 1, L = beginWord.length();\\n    while (q.size() != 0) {\\n      int last_q_size = q.size();\\n      for (int flg = 0; flg < last_q_size; flg++) {\\n        String cur = q.poll();\\n        if (visited.contains(cur)) continue;\\n        visited.add(cur);\\n        if (cur.equals(endWord)) return steps;\\n        for (int i = 0; i < L; i++)\\n          for (int j = 0; j < 26; j++) {\\n            String s = \\\"\\\";\\n            for (int ww = 0; ww < i; ww++)\\n              s = s + String.valueOf(cur.charAt(ww));\\n            s = s + String.valueOf((char)('a' + j));\\n            for (int ww = i + 1; ww < cur.length(); ww++)\\n              s = s + String.valueOf(cur.charAt(ww));\\n            for (int k = 0; k < wordList.size(); k++)\\n              if (wordList.get(k).equals(s)) {\\n                q.add(s);\\n              }\\n          }\\n      }\\n      steps += 1;\\n    }\\n    return 0;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"from collections import defaultdict\\n\\n\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        queue = [beginWord]\\n        visited = set()\\n        steps = 1\\n        L = len(beginWord)\\n\\n        while len(queue) > 0:\\n            for _ in range(len(queue)):\\n                cur = queue.pop(0)\\n                if cur in visited:\\n                    continue\\n                visited.add(cur)\\n                if cur == endWord:\\n                    return steps\\n                # 这里我们尝试枚举所有可能的转换，并查看是否在wordList中，如果在，我们将其加入队列\\n\\n                # 单词中的每一位都进行变换\\n                for i in range(L):\\n                    # cur[i] 依次变成26个小写字母中的每一个\\n                    for j in range(26):\\n                        s = list(cur)\\n                        s[i] = chr(ord(\\\"a\\\") + j)\\n                        for word in wordList:\\n                            if word == \\\"\\\".join(s):\\n                                queue.append(word)\\n            steps += 1\\n        return 0\\n\\n\"}]},{\"title\":\"代码20.2.5\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\n#include <string>\\n#include <map>\\n#include <queue>\\n#include <set>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int ladderLength(string beginWord, string endWord,\\n      vector<string>& wordList) {\\n    queue<string> q;\\n    q.push(beginWord);\\n    set<string> visited;\\n    int steps = 1, n = wordList.size(), L = beginWord.length();\\n    map<string, vector<string> > wizards;\\n    for (int i = 0; i < n; i++) {\\n      string word = wordList[i];\\n      for (int j = 0; j < L; j++) {\\n        string key = word.substr(0, j) + string(\\\"*\\\") + \\\\\\n                     word.substr(j + 1,\\n                         word.length() - j - 1);\\n        if (!wizards.count(key))\\n          wizards[key] = vector<string>();\\n        wizards[key].push_back(word);\\n      }\\n    }\\n    while (!q.empty()) {\\n      int last_q_size = q.size();\\n      for (int flg = 0; flg < last_q_size; flg++) {\\n        string cur = q.front();\\n        q.pop();\\n        if (visited.count(cur)) continue;\\n        visited.insert(cur);\\n        if (cur == endWord) return steps;\\n        for (int i = 0; i < L; i++) {\\n          string key = cur.substr(0, i) + string(\\\"*\\\") + \\\\\\n                       cur.substr(i + 1,\\n                           cur.length() - i - 1);\\n          if (!wizards.count(key)) continue;\\n          for (int j = 0; j < wizards[key].size(); j++)\\n            q.push(wizards[key][j]);\\n        }\\n      }\\n      steps += 1;\\n    }\\n    return 0;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\n\\nclass Solution {\\n  public int ladderLength(String beginWord, String endWord,\\n      List<String> wordList) {\\n    Queue<String> q = new LinkedList<String>();\\n    q.add(beginWord);\\n    Set<String> visited = new HashSet<String>();\\n    int steps = 1, n = wordList.size(),\\n        L = beginWord.length();\\n    Map<String, List<String> > wizards =\\n      new HashMap<String, List<String> >();\\n    for (int i = 0; i < n; i++) {\\n      String word = wordList.get(i);\\n      for (int j = 0; j < L; j++) {\\n        String key = word.substring(0, j) + \\\"*\\\"\\n          + word.substring(j + 1, word.length());\\n        if (wizards.get(key) == null) {\\n          List<String> magic = new ArrayList<>();\\n          wizards.put(key, magic);\\n        }\\n        List<String> magic = wizards.get(key);\\n        magic.add(word);\\n        wizards.put(key, magic);\\n      }\\n    }\\n    while (q.size() != 0) {\\n      int last_q_size = q.size();\\n      for (int flg = 0; flg < last_q_size; flg++) {\\n        String cur = q.poll();\\n        if (visited.contains(cur)) continue;\\n        visited.add(cur);\\n        if (cur.equals(endWord)) return steps;\\n        for (int i = 0; i < L; i++) {\\n          String key = cur.substring(0, i) + \\\"*\\\"\\n            + cur.substring(i + 1, cur.length());\\n          if (wizards.get(key) == null) continue;\\n          for (int j = 0; j < wizards.get(key).size(); j++)\\n            q.add(wizards.get(key).get(j));\\n        }\\n      }\\n      steps += 1;\\n    }\\n    return 0;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"from collections import defaultdict\\n\\n\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        queue = [beginWord]\\n        visited = set()\\n        steps = 1\\n        n = len(wordList)\\n        L = len(beginWord)\\n        wizards = defaultdict(list)\\n        for i in range(n):\\n            word = wordList[i]\\n            for j in range(L):\\n                wizards[word[:j] + \\\"*\\\" + word[j + 1 :]].append(word)\\n\\n        while len(queue) > 0:\\n            for _ in range(len(queue)):\\n                cur = queue.pop(0)\\n                if cur in visited:\\n                    continue\\n                visited.add(cur)\\n                if cur == endWord:\\n                    return steps\\n                for i in range(L):\\n                    for word in wizards.get(cur[:i] + \\\"*\\\" + cur[i + 1 :], []):\\n                        queue.append(word)\\n\\n            steps += 1\\n        return 0\\n\\n\"}]},{\"title\":\"代码20.3.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\n#include <cstdlib>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int countSquares(vector<vector<int> >& matrix) {\\n    int res = 0, m = matrix.size(), n = matrix[0].size();\\n    int **dp = (int **)malloc((m + 1) * sizeof(int *));\\n    for (int i = 0; i <= m; i++) {\\n      dp[i] = (int *)malloc((n + 1) * sizeof(int));\\n      for (int j = 0; j <= n; j++) dp[i][j] = 0;\\n    }\\n    for (int i = 1; i <= m; i++)\\n      for (int j = 1; j <= n; j++) {\\n        if (matrix[i - 1][j - 1] == 1)\\n          dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]),\\\\\\n              dp[i - 1][j - 1]) + 1;\\n        res += dp[i][j];\\n      }\\n    for (int i = 0; i <= m; i++) free(dp[i]);\\n    free(dp);\\n    return res;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.lang.Math;\\n\\npublic class Solution {\\n  public int countSquares(int[][] matrix) {\\n    int res = 0, m = matrix.length,\\n        n = matrix[0].length;\\n    int[][] dp = new int[m + 1][n + 1];\\n    for (int i = 0; i <= m; i++)\\n      for (int j = 0; j <= n; j++) dp[i][j] = 0;\\n    for (int i = 1; i <= m; i++)\\n      for (int j = 1; j <= n; j++) {\\n        if (matrix[i - 1][j - 1] == 1)\\n          dp[i][j] = Math.min(Math.min(dp[i - 1][j],\\n              dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\\n        res += dp[i][j];\\n      }\\n    return res;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def countSquares(self, matrix: List[List[int]]) -> int:\\n        res = 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if matrix[i - 1][j - 1] == 1:\\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\\n                res += dp[i][j]\\n        return res\\n\\n\"}]},{\"title\":\"代码20.3.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <string>\\n#include <map>\\n#include <algorithm>\\n#include <cstring>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int maxFreq(string s, int maxLetters, int minSize,\\n      int maxSize) {\\n    map<string, int> counter;\\n    int res = 0;\\n    for (int i = 0; i < s.size() - minSize + 1; i++)\\n      for (int length = minSize; length <= maxSize; length++) {\\n        if (i + length > s.length()) break;\\n        bool alpha[26];\\n        memset(alpha, 0, sizeof(alpha));\\n        int cnt = 0;\\n        string sub(\\\"\\\");\\n        for (int ww = 0; ww < length; ww++) {\\n          sub.push_back(s[i + ww]);\\n          if (!alpha[s[i + ww] - 'a']) {\\n            ++cnt;\\n            alpha[s[i + ww] - 'a'] = true;\\n          }\\n        }\\n        if (cnt <= maxLetters) {\\n          int buf_val;\\n          buf_val = counter[sub] = (counter.count(sub) ? \\\\\\n              counter[sub] : 0) + 1;\\n          res = max(res, buf_val);\\n        }\\n      }\\n    return res;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\nimport java.lang.Math;\\n\\nclass Solution {\\n  public int maxFreq(String s, int maxLetters,\\n      int minSize, int maxSize) {\\n    Map<String, Integer> counter =\\n      new HashMap<String, Integer>();\\n    int res = 0;\\n    for (int i = 0; i < s.length() - minSize + 1; i++)\\n      for (int length = minSize; length <= maxSize;\\n          length++) {\\n        if (i + length > s.length()) break;\\n        String sub = s.substring(i, i + length);\\n        boolean[] alpha = new boolean[26];\\n        int cnt = 0;\\n        for (int ww = 0; ww < sub.length(); ww++)\\n          if (!alpha[sub.charAt(ww) - 'a']) {\\n            cnt += 1;\\n            alpha[sub.charAt(ww) - 'a'] = true;\\n          }\\n        if (cnt <= maxLetters) {\\n          if (counter.get(sub) == null)\\n            counter.put(sub, 0);\\n          counter.put(sub, counter.get(sub) + 1);\\n          res = Math.max(res, counter.get(sub));\\n        }\\n      }\\n    return res;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        counter, res = {}, 0\\n        for i in range(0, len(s) - minSize + 1):\\n            for length in range(minSize, maxSize + 1):\\n                if i + length > len(s):\\n                    break\\n                sub = s[i : i + length]\\n                if len(set(sub)) <= maxLetters:\\n                    counter[sub] = counter.get(sub, 0) + 1\\n                    res = max(res, counter[sub])\\n        return res\\n\\n\"}]},{\"title\":\"代码20.3.3\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <string>\\n#include <algorithm>\\n#include <map>\\n#include <cstring>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int maxFreq(string s, int maxLetters, int minSize, \\\\\\n      int maxSize) {\\n    map<string, int> counter;\\n    int res = 0;\\n    for (int i = 0; i <= s.length() - minSize; i++) {\\n      string sub = s.substr(i, minSize);\\n      bool alpha[26];\\n      memset(alpha, 0, sizeof(alpha));\\n      int cnt = 0;\\n      for (int ww = 0; ww < sub.length(); ww++)\\n        if (!alpha[sub[ww] - 'a']) {\\n          ++cnt;\\n          alpha[sub[ww] - 'a'] = true;\\n        }\\n      if (cnt <= maxLetters) {\\n        counter[sub] = (counter.count(sub) ? \\\\\\n            counter[sub] : 0);\\n        counter[sub] += 1;\\n        res = max(res, counter[sub]);\\n      }\\n    }\\n    return res;\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"import java.util.*;\\nimport java.lang.Math;\\n\\nclass Solution {\\n  public int maxFreq(String s, int maxLetters,\\n      int minSize, int maxSize) {\\n    Map<String, Integer> counter =\\n      new HashMap<String, Integer>();\\n    int res = 0;\\n    for (int i = 0; i <= s.length() - minSize; i++) {\\n      String sub = s.substring(i, i + minSize);\\n      boolean[] alpha = new boolean[26];\\n      int cnt = 0;\\n      for (int ww = 0; ww < sub.length(); ww++)\\n        if (!alpha[sub.charAt(ww) - 'a']) {\\n          ++cnt;\\n          alpha[sub.charAt(ww) - 'a'] = true;\\n        }\\n      if (cnt <= maxLetters) {\\n        if (counter.get(sub) == null)\\n          counter.put(sub, 0);\\n        counter.put(sub, counter.get(sub) + 1);\\n        res = Math.max(res, counter.get(sub));\\n      }\\n    }\\n    return res;\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"class Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        counter, res = {}, 0\\n        for i in range(0, len(s) - minSize + 1):\\n            sub = s[i : i + minSize]\\n            if len(set(sub)) <= maxLetters:\\n                counter[sub] = counter.get(sub, 0) + 1\\n                res = max(res, counter[sub])\\n        return res\\n\\n\"}]},{\"title\":\"代码20.4.1\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int cntLiveCell(int i, int j, \\\\\\n      const vector<vector<int> >& old) {\\n    int cnt = 0, m = old.size(), n = old[0].size();\\n    int directions[8][2] = {\\n      {0, 1},\\n      {0, -1},\\n      {-1, 0},\\n      {1, 0},\\n      {1, 1},\\n      {1, -1},\\n      {-1, 1},\\n      {-1, -1}\\n    };\\n    for (int p = 0; p < 8; p++) {\\n      int dx = directions[p][0], dy = directions[p][1];\\n      if (i + dx >= 0 && i + dx < m && j + dy >= 0 && \\\\\\n          j + dy < n)\\n        cnt += old[i + dx][j + dy];\\n    }\\n    return cnt;\\n  }\\n  void gameOfLife(vector<vector<int> >& board) {\\n    int m = board.size();\\n    if (m <= 0) return;\\n    int n = board[0].size();\\n    if (n <= 0) return;\\n    vector<vector<int> > old = board;\\n    for (int i = 0; i < m; i++)\\n      for (int j = 0; j < n; j++) {\\n        int cnt = cntLiveCell(i, j, old);\\n        if (old[i][j] == 0 && cnt == 3)\\n          board[i][j] = 1;\\n        if (old[i][j] == 1 && (cnt > 3 || cnt < 2))\\n          board[i][j] = 0;\\n      }\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Solution {\\n  public int cntLiveCell(int i, int j,\\n      int[][] old) {\\n    int cnt = 0, m = old.length, n = old[0].length;\\n    int[][] directions = {\\n      {0,1},\\n      {0,-1},\\n      {-1,0},\\n      {1,0},\\n      {1,1},\\n      {1,-1},\\n      {-1,1},\\n      {-1,-1}\\n    };\\n    for (int p = 0; p < 8; p++) {\\n      int dx = directions[p][0], dy = directions[p][1];\\n      if (i + dx >= 0 && i + dx < m && j + dy >= 0 &&\\n          j + dy < n)\\n        cnt += old[i + dx][j + dy];\\n    }\\n    return cnt;\\n  }\\n  void gameOfLife(int[][] board) {\\n    int m = board.length;\\n    if (m <= 0) return;\\n    int n = board[0].length;\\n    if (n <= 0) return;\\n    int[][] old = new int[m][n];\\n    for (int i = 0; i < m; i++)\\n      for (int j = 0; j < n; j++) old[i][j] = board[i][j];\\n    for (int i = 0; i < m; i++)\\n      for (int j = 0; j < n; j++) {\\n        int cnt = cntLiveCell(i, j, old);\\n        if (old[i][j] == 0 && cnt == 3)\\n          board[i][j] = 1;\\n        if (old[i][j] == 1 && (cnt > 3 || cnt < 2))\\n          board[i][j] = 0;\\n      }\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"import copy\\n\\n\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        m = len(board)\\n        n = len(board[0])\\n        if m <= 0 or n <= 0:\\n            return []\\n        old = copy.deepcopy(board)\\n\\n        def cntLiveCell(i: int, j: int) -> int:\\n            cnt = 0\\n            directions = [\\n                (0, 1),\\n                (0, -1),\\n                (-1, 0),\\n                (1, 0),\\n                (1, 1),\\n                (1, -1),\\n                (-1, 1),\\n                (-1, -1),\\n            ]\\n            for (dx, dy) in directions:\\n                if i + dx >= 0 and i + dx < m and j + dy >= 0 and j + dy < n:\\n                    cnt += old[i + dx][j + dy]\\n\\n            return cnt\\n\\n        for i in range(m):\\n            for j in range(n):\\n                # 八个方向有几个活细胞\\n                cnt = cntLiveCell(i, j)\\n                if old[i][j] == 0 and cnt == 3:\\n                    board[i][j] = 1\\n                if old[i][j] == 1 and (cnt > 3 or cnt < 2):\\n                    board[i][j] = 0\\n\\n\"}]},{\"title\":\"代码20.4.2\",\"codes\":[{\"language\":\"Cpp\",\"content\":\"#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n  int cntLiveCell(int i, int j,\\n      const vector<vector<int> >& board) {\\n    int cnt = 0, directions[8][2] = {\\n      {0, 1},\\n      {0, -1},\\n      {-1, 0},\\n      {1, 0},\\n      {1, 1},\\n      {1, -1},\\n      {-1, 1},\\n      {-1, -1}\\n    };\\n    int m = board.size(), n = board[0].size();\\n    for (int p = 0; p < 8; p++) {\\n      int dx = directions[p][0], dy = directions[p][1];\\n      if (i + dx >= 0 && i + dx < m && j + dy >= 0 && \\\\\\n          j + dy < n)\\n        cnt += board[i + dx][j + dy] & 1;\\n    }\\n    return cnt;\\n  }\\n  void gameOfLife(vector<vector<int> >& board) {\\n    int m = board.size();\\n    if (m <= 0) return;\\n    int n = board[0].size();\\n    if (n <= 0) return;\\n    for (int i = 0; i < m; i++)\\n      for (int j = 0; j < n; j++) {\\n        int cnt = cntLiveCell(i, j, board);\\n        board[i][j] |= cnt << 1;\\n      }\\n    for (int i = 0; i < m; i++)\\n      for (int j = 0; j < n; j++) {\\n        int cell = board[i][j] & 1;\\n        int cnt = board[i][j] >> 1;\\n        if (cell == 0 && cnt == 3) board[i][j] = 1;\\n        else if (cell == 1 && (cnt > 3 || cnt < 2))\\n          board[i][j] = 0;\\n        else board[i][j] = cell;\\n      }\\n  }\\n};\\n\\n\"},{\"language\":\"Java\",\"content\":\"public class Solution {\\n  public int cntLiveCell(int i, int j,\\n      int[][] board) {\\n    int cnt = 0;\\n    int[][] directions = {\\n      {0, 1},\\n      {0, -1},\\n      {-1, 0},\\n      {1, 0},\\n      {1, 1},\\n      {1, -1},\\n      {-1, 1},\\n      {-1, -1}\\n    };\\n    int m = board.length, n = board[0].length;\\n    for (int p = 0; p < 8; p++) {\\n      int dx = directions[p][0], dy = directions[p][1];\\n      if (i + dx >= 0 && i + dx < m && j + dy >= 0 &&\\n          j + dy < n)\\n        cnt += board[i + dx][j + dy] & 1;\\n    }\\n    return cnt;\\n  }\\n  public void gameOfLife(int[][] board) {\\n    int m = board.length;\\n    if (m <= 0) return;\\n    int n = board[0].length;\\n    if (n <= 0) return;\\n    for (int i = 0; i < m; i++)\\n      for (int j = 0; j < n; j++) {\\n        int cnt = cntLiveCell(i, j, board);\\n        board[i][j] = board[i][j] | (cnt << 1);\\n      }\\n    for (int i = 0; i < m; i++)\\n      for (int j = 0; j < n; j++) {\\n        int cell = board[i][j] & 1;\\n        int cnt = board[i][j] >> 1;\\n        if (cell == 0 && cnt == 3) board[i][j] = 1;\\n        else if (cell == 1 && (cnt > 3 || cnt < 2))\\n          board[i][j] = 0;\\n        else board[i][j] = cell;\\n      }\\n  }\\n}\\n\\n\"},{\"language\":\"Py\",\"content\":\"import copy\\n\\n\\nclass Solution:\\n    def gameOfLife(self, board: List[List[int]]) -> None:\\n        m = len(board)\\n        n = len(board[0])\\n        if m <= 0 or n <= 0:\\n            return []\\n\\n        def cntLiveCell(i: int, j: int) -> int:\\n            cnt = 0\\n            directions = [\\n                (0, 1),\\n                (0, -1),\\n                (-1, 0),\\n                (1, 0),\\n                (1, 1),\\n                (1, -1),\\n                (-1, 1),\\n                (-1, -1),\\n            ]\\n            for (dx, dy) in directions:\\n                if i + dx >= 0 and i + dx < m and j + dy >= 0 and j + dy < n:\\n                    cnt += board[i + dx][j + dy] & 1\\n            return cnt\\n\\n        for i in range(m):\\n            for j in range(n):\\n                # 八个方向有几个活细胞\\n                cnt = cntLiveCell(i, j)\\n                board[i][j] |= cnt << 1\\n        for i in range(m):\\n            for j in range(n):\\n                # 变化之前当前cell的值\\n                cell = board[i][j] & 1\\n                cnt = board[i][j] >> 1\\n                if cell == 0 and cnt == 3:\\n                    board[i][j] = 1\\n                elif cell == 1 and (cnt > 3 or cnt < 2):\\n                    board[i][j] = 0\\n                else:\\n                    board[i][j] = cell\\n\\n\"}]}]}]\n"]}]}