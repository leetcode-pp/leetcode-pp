{"remainingRequest":"/Users/luxiaopeng/github/leetcode-pp/node_modules/thread-loader/dist/cjs.js!/Users/luxiaopeng/github/leetcode-pp/node_modules/babel-loader/lib/index.js!/Users/luxiaopeng/github/leetcode-pp/node_modules/eslint-loader/index.js??ref--13-0!/Users/luxiaopeng/github/leetcode-pp/src/views/solutionCode.js","dependencies":[{"path":"/Users/luxiaopeng/github/leetcode-pp/src/views/solutionCode.js","mtime":1648364288941},{"path":"/Users/luxiaopeng/github/leetcode-pp/node_modules/cache-loader/dist/cjs.js","mtime":1582876651155},{"path":"/Users/luxiaopeng/github/leetcode-pp/node_modules/thread-loader/dist/cjs.js","mtime":1582876651885},{"path":"/Users/luxiaopeng/github/leetcode-pp/node_modules/babel-loader/lib/index.js","mtime":1614915260754},{"path":"/Users/luxiaopeng/github/leetcode-pp/node_modules/eslint-loader/index.js","mtime":1584094539526}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyogZXNsaW50LWRpc2FibGUgKi8KZXhwb3J0IGRlZmF1bHQgW3sKICBpZDogJzAxJywKICBuYW1lOiAnMDEu5aCG5LiT6aKYJywKICBsaW5rOiAnaHR0cHM6Ly9sdWNpZmVyLnJlbi9ibG9nLzIwMjEvMDEvMTkvaGVhcC0yJywKICBsaXN0OiBbewogICAgdGl0bGU6ICfku6PnoIExLjMuMScsCiAgICBjb2RlczogW3sKICAgICAgbGFuZ3VhZ2U6ICdQeXRob24nLAogICAgICBjb250ZW50OiAiXG5jbGFzcyBNZWRpYW5GaW5kZXI6XG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxuICAgICAgICBzZWxmLm1pbl9oZWFwID0gW11cbiAgICAgICAgc2VsZi5tYXhfaGVhcCA9IFtdXG4gICAgZGVmIGFkZE51bShzZWxmLCBudW06IGludCkgLT4gTm9uZTpcbiAgICAgICAgaWYgbm90IHNlbGYubWF4X2hlYXAgb3IgbnVtIDwgLXNlbGYubWF4X2hlYXBbMF06XG4gICAgICAgICAgICBoZWFwcS5oZWFwcHVzaChzZWxmLm1heF9oZWFwLCAtbnVtKVxuICAgICAgICBlbHNlOlxuICAgICAgICAgICAgaGVhcHEuaGVhcHB1c2goc2VsZi5taW5faGVhcCwgbnVtKVxuICAgICAgICBpZiBsZW4oc2VsZi5tYXhfaGVhcCkgPiBsZW4oc2VsZi5taW5faGVhcCkgKyAxOlxuICAgICAgICAgICAgaGVhcHB1c2goc2VsZi5taW5faGVhcCwgLWhlYXBwb3Aoc2VsZi5tYXhfaGVhcCkpXG4gICAgICAgIGVsaWYgbGVuKHNlbGYubWluX2hlYXApID4gbGVuKHNlbGYubWF4X2hlYXApOlxuICAgICAgICAgICAgaGVhcHB1c2goc2VsZi5tYXhfaGVhcCwgLWhlYXBwb3Aoc2VsZi5taW5faGVhcCkpXG4gICAgZGVmIGZpbmRNZWRpYW4oc2VsZikgLT4gZmxvYXQ6XG4gICAgICAgIGlmIGxlbihzZWxmLm1pbl9oZWFwKSA9PSBsZW4oc2VsZi5tYXhfaGVhcCk6IHJldHVybiAoc2VsZi5taW5faGVhcFswXSAtIHNlbGYubWF4X2hlYXBbMF0pIC8gMlxuICAgICAgICByZXR1cm4gLXNlbGYubWF4X2hlYXBbMF1cbiIKICAgIH0sIHsKICAgICAgbGFuZ3VhZ2U6ICdKYXZhJywKICAgICAgY29udGVudDogIlxuY2xhc3MgTWVkaWFuRmluZGVyIHtcbiAgcHJpdmF0ZSBRdWV1ZTxMb25nPiBtaW5IZWFwID0gbmV3IFByaW9yaXR5UXVldWUoKSxcbiAgICAgICAgICBtYXhIZWFwID0gbmV3IFByaW9yaXR5UXVldWUoKTtcblxuICBwdWJsaWMgdm9pZCBhZGROdW0oaW50IG51bSkge1xuICAgICAgbWluSGVhcC5hZGQoKGxvbmcpIG51bSk7XG4gICAgICBtYXhIZWFwLmFkZCgtbWluSGVhcC5wb2xsKCkpO1xuICAgICAgaWYgKG1pbkhlYXAuc2l6ZSgpIDwgbWF4SGVhcC5zaXplKCkpXG4gICAgICAgICAgbWluSGVhcC5hZGQoLW1heEhlYXAucG9sbCgpKTtcbiAgfVxuXG4gIHB1YmxpYyBkb3VibGUgZmluZE1lZGlhbigpIHtcbiAgICAgIHJldHVybiBtaW5IZWFwLnNpemUoKSA+IG1heEhlYXAuc2l6ZSgpXG4gICAgICAgICAgICAgID8gbWluSGVhcC5wZWVrKClcbiAgICAgICAgICAgICAgOiAobWluSGVhcC5wZWVrKCkgLSBtYXhIZWFwLnBlZWsoKSkgLyAyLjA7XG4gIH1cbn1cbiIKICAgIH1dCiAgfSwgewogICAgdGl0bGU6ICfku6PnoIExLjMuMicsCiAgICBjb2RlczogW3sKICAgICAgbGFuZ3VhZ2U6ICdQeXRob24nLAogICAgICBjb250ZW50OiAiXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgbWluY29zdFRvSGlyZVdvcmtlcnMoc2VsZiwgcXVhbGl0eTogTGlzdFtpbnRdLCB3YWdlOiBMaXN0W2ludF0sIEs6IGludCkgLT4gZmxvYXQ6XG4gICAgICAgIGVmZiA9IFsocSAvIHcsIHEsIHcpIGZvciBhLCBiIGluIHppcChxdWFsaXR5LCB3YWdlKV1cbiAgICAgICAgZWZmLnNvcnQoa2V5PWxhbWJkYSBhOiAtYVswXSlcbiAgICAgICAgYW5zID0gZmxvYXQoJ2luZicpXG4gICAgICAgIGZvciBpIGluIHJhbmdlKEstMSwgbGVuKGVmZikpOlxuICAgICAgICAgICAgaCA9IFtdXG4gICAgICAgICAgICBrID0gSyAtIDFcbiAgICAgICAgICAgIHJhdGUsIF8sIHRvdGFsID0gZWZmW2ldXG4gICAgICAgICAgICAjIFx1NjI3RVx1NTFGQVx1NURFNVx1NEY1Q1x1NjU0OFx1NzM4N1x1NkJENFx1NUI4M1x1OUFEOFx1NzY4NCBrIFx1NEUyQVx1NEVCQVx1RkYwQ1x1OEZEOSBrIFx1NEUyQVx1NEVCQVx1NzY4NFx1NURFNVx1OEQ0NFx1NUMzRFx1NTNFRlx1ODBGRFx1NEY0RVx1MzAwMlxuICAgICAgICAgICAgIyBcdTc1MzFcdTRFOEVcdTVERjJcdTdFQ0ZcdTVERTVcdTRGNUNcdTY1NDhcdTczODdcdTUwMTJcdTVFOEZcdTYzOTJcdTRFODZcdUZGMENcdTU2RTBcdTZCNjRcdTUyNERcdTk3NjJcdTc2ODRcdTkwRkRcdTY2MkZcdTZCRDRcdTVCODNcdTlBRDhcdTc2ODRcdUZGMENcdTcxMzZcdTU0MEVcdTRGN0ZcdTc1MjhcdTU4MDZcdTVDMzFcdTUzRUZcdTVGOTdcdTUyMzAgayBcdTRFMkFcdTVERTVcdThENDRcdTY3MDBcdTRGNEVcdTc2ODRcdTMwMDJcbiAgICAgICAgICAgIGZvciBqIGluIHJhbmdlKGkpOlxuICAgICAgICAgICAgICAgIGhlYXBxLmhlYXBwdXNoKGgsIGVmZltqXVsxXSAvIHJhdGUpXG4gICAgICAgICAgICB3aGlsZSBrID4gMDpcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBoZWFwcS5oZWFwcG9wKGgpXG4gICAgICAgICAgICAgICAgayAtPSAxXG4gICAgICAgICAgICBhbnMgPSBtaW4oYW5zLCB0b3RhbClcbiAgICAgICAgcmV0dXJuIGFuc1xuIgogICAgfSwgewogICAgICBsYW5ndWFnZTogJ0phdmEnLAogICAgICBjb250ZW50OiAiXG5wdWJsaWMgZG91YmxlIG1pbmNvc3RUb0hpcmVXb3JrZXJzKGludFtdIHF1YWxpdHksIGludFtdIHdhZ2UsIGludCBLKSB7XG4gIGludCBuID0gcXVhbGl0eS5sZW5ndGg7XG4gIC8vIFx1NTM1NVx1NEY0RFx1ODVBQVx1OEQ0NFxuICBQYWlyPERvdWJsZSwgSW50ZWdlcj5bXSBwYWlycyA9IG5ldyBQYWlyW25dO1xuICBmb3IgKGludCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgUGFpcjxEb3VibGUsIEludGVnZXI+IHBhaXIgPSBuZXcgUGFpcih3YWdlW2ldIC8gKHF1YWxpdHlbaV0gKiAxZCksIHF1YWxpdHlbaV0pO1xuICAgICAgcGFpcnNbaV0gPSBwYWlyO1xuICB9XG4gIEFycmF5cy5zb3J0KHBhaXJzLCAobzEsIG8yKSAtPiBvMS5nZXRLZXkoKSAtIG8yLmdldEtleSgpID4gMCA/IDEgOiAtMSk7XG5cbiAgZG91YmxlIGFucyA9IERvdWJsZS5NQVhfVkFMVUU7XG4gIC8vIFx1NjAzQlx1NURFNVx1NjVGNlxuICBpbnQgc3VtUXVpbHR5ID0gMDtcbiAgUHJpb3JpdHlRdWV1ZTxJbnRlZ2VyPiBwcSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBQYWlyPERvdWJsZSwgSW50ZWdlcj4gcCA9IHBhaXJzW2ldO1xuICAgICAgLy8gXHU4RkQ5XHU5MUNDXHU1MDc3XHU2MUQyXHU3NkY0XHU2M0E1XHU0RjdGXHU3NTI4XHU0RTg2XHU2NzAwXHU1QzBGXHU1ODA2IFx1NTAxRlx1OTI3NFx1NUI5OFx1NjVCOVx1OTg5OFx1ODlFM1x1RkYwQ1x1NzUyOFx1NjcwMFx1NTkyN1x1NTgwNlx1NEU1Rlx1NTNFRlx1NEVFNVx1NzY4NFxuICAgICAgcHEub2ZmZXIoLXAuZ2V0VmFsdWUoKSk7XG4gICAgICBzdW1RdWlsdHkgKz0gcC5nZXRWYWx1ZSgpO1xuICAgICAgaWYgKHBxLnNpemUoKSA+IEspXG4gICAgICAgICAgLy8gXHU1OTgyXHU2NzlDXHU4RDg1XHU4RkM3a1x1NUMzMVx1ODk4MVx1NjI4QVx1NUY1M1x1NTI0RFx1NURFNVx1NjVGNi9cdTVERTVcdThENDRcdTY3MDBcdTlBRDhcdTc2ODRcdThENzZcdThENzBcdUZGMENcdThGRDlcdTY4MzdcdTYyNERcdTdCMjZcdTU0MDhcdThENDRcdTY3MkNcdTVCQjZcdTUyNjVcdTU5M0FcdTUyNjlcdTRGNTlcdTRFRjdcdTUwM0NcbiAgICAgICAgICBzdW1RdWlsdHkgKz0gcHEucG9sbCgpO1xuICAgICAgaWYgKHBxLnNpemUoKSA9PSBLKVxuICAgICAgICAgIGFucyA9IE1hdGgubWluKGFucywgc3VtUXVpbHR5ICogcC5nZXRLZXkoKSk7XG4gIH1cbiAgcmV0dXJuIGFucztcbn1cbiIKICAgIH1dCiAgfSwgewogICAgdGl0bGU6ICfku6PnoIExLjMuMycsCiAgICBjb2RlczogW3sKICAgICAgbGFuZ3VhZ2U6ICdQeXRob24nLAogICAgICBjb250ZW50OiAiXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgbWluY29zdFRvSGlyZVdvcmtlcnMoc2VsZiwgcXVhbGl0eTogTGlzdFtpbnRdLCB3YWdlOiBMaXN0W2ludF0sIEs6IGludCkgLT4gZmxvYXQ6XG4gICAgICAgIGVmZnMgPSBbKHEgLyB3LCBxKSBmb3IgcSwgdyBpbiB6aXAocXVhbGl0eSwgd2FnZSldXG4gICAgICAgIGVmZnMuc29ydChrZXk9bGFtYmRhIGE6IC1hWzBdKVxuICAgICAgICBhbnMgPSBmbG9hdCgnaW5mJylcbiAgICAgICAgaCA9IFtdXG4gICAgICAgIHRvdGFsID0gMFxuICAgICAgICBmb3IgcmF0ZSwgcSBpbiBlZmZzOlxuICAgICAgICAgICAgaGVhcHEuaGVhcHB1c2goaCwgLXEpXG4gICAgICAgICAgICB0b3RhbCArPSBxXG4gICAgICAgICAgICBpZiBsZW4oaCkgPiBLOlxuICAgICAgICAgICAgICAgIHRvdGFsICs9IGhlYXBxLmhlYXBwb3AoaClcbiAgICAgICAgICAgIGlmIGxlbihoKSA9PSBLOlxuICAgICAgICAgICAgICAgIGFucyA9IG1pbihhbnMsIHRvdGFsIC8gcmF0ZSlcbiAgICAgICAgcmV0dXJuIGFuc1xuIgogICAgfV0KICB9LCB7CiAgICB0aXRsZTogJ+S7o+eggTEuMy40JywKICAgIGNvZGVzOiBbewogICAgICBsYW5ndWFnZTogJ1B5dGhvbicsCiAgICAgIGNvbnRlbnQ6ICJcbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBrdGhTbWFsbGVzdChzZWxmLCBtYXQsIGs6IGludCkgLT4gaW50OlxuICAgICAgICBoID0gW11cbiAgICAgICAgY3VyID0gKHN1bSh2ZWNbMF0gZm9yIHZlYyBpbiBtYXQpLCB0dXBsZShbMF0gKiBsZW4obWF0KSkpXG4gICAgICAgIGhlYXBxLmhlYXBwdXNoKGgsIGN1cilcbiAgICAgICAgc2VlbiA9IHNldChjdXIpXG5cbiAgICAgICAgZm9yIF8gaW4gcmFuZ2Uoayk6XG4gICAgICAgICAgICBhY2MsIHBvaW50ZXJzID0gaGVhcHEuaGVhcHBvcChoKVxuICAgICAgICAgICAgZm9yIGksIHBvaW50ZXIgaW4gZW51bWVyYXRlKHBvaW50ZXJzKTpcbiAgICAgICAgICAgICAgICBpZiBwb2ludGVyICE9IGxlbihtYXRbMF0pIC0gMTpcbiAgICAgICAgICAgICAgICAgICAgdCA9IGxpc3QocG9pbnRlcnMpXG4gICAgICAgICAgICAgICAgICAgIHRbaV0gPSBwb2ludGVyICsgMVxuICAgICAgICAgICAgICAgICAgICB0dCA9IHR1cGxlKHQpXG4gICAgICAgICAgICAgICAgICAgIGlmIHR0IG5vdCBpbiBzZWVuOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vlbi5hZGQodHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFwcS5oZWFwcHVzaChoLCAoYWNjICsgbWF0W2ldW3BvaW50ZXIgKyAxXSAtIG1hdFtpXVtwb2ludGVyXSwgdHQpKVxuICAgICAgICByZXR1cm4gYWNjXG4iCiAgICB9LCB7CiAgICAgIGxhbmd1YWdlOiAnSmF2YScsCiAgICAgIGNvbnRlbnQ6ICJcbnB1YmxpYyBpbnQga3RoU21hbGxlc3QoaW50W11bXSBtYXQsIGludCBrKSB7XG4gIGludCBtID0gbWF0Lmxlbmd0aDtcbiAgaW50IG4gPSBtYXRbMF0ubGVuZ3RoO1xuICBQcmlvcml0eVF1ZXVlPFBhaXI8SW50ZWdlciwgaW50W10+PiBwcSA9IG5ldyBQcmlvcml0eVF1ZXVlPD4oKGEsIGIpIC0+IGEuZ2V0S2V5KCkgLSBiLmdldEtleSgpKTtcbiAgaW50W10gc3VtID0gbmV3IGludFttXTtcbiAgaW50IHRvdGFsID0gMDtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgIHRvdGFsICs9IG1hdFtpXVswXTtcbiAgfVxuICBQYWlyPEludGVnZXIsIGludFtdPiBwYWlyID0gbmV3IFBhaXI8Pih0b3RhbCwgc3VtKTtcbiAgcHEub2ZmZXIocGFpcik7XG4gIFNldDxTdHJpbmc+IHNlZW4gPSBuZXcgSGFzaFNldDw+KCk7XG5cbiAgLy8gXHU1QzBGXHU5ODc2XHU1ODA2IFx1NjI2N1x1ODg0Q2tcdTZCMjEgXHU2MjhBXHU1MjREXHU5NzYya1x1NUMwRlx1NzY4NFx1NjU3MFx1N0VDNFx1NzlGQlx1OTY2NCBcdTRFNEJcdTU0MEVcdTY4MDhcdTk4NzZcdTRGQkZcdTY2MkZcdTYyMTFcdTRFRUNcdTYyNDBcdTZDNDJcdTRFNEJcdTdFRDNcdTY3OUNcbiAgd2hpbGUgKC0tayA+IDApIHtcbiAgICAgIFBhaXI8SW50ZWdlciwgaW50W10+IGN1ciA9IHBxLnBvbGwoKTtcbiAgICAgIC8vIFx1ODg0Q1x1NTNGN1xuICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICBpZiAoY3VyLmdldFZhbHVlKClbaV0gPCBuIC0gMSkge1xuICAgICAgICAgICAgICBpbnRbXSBhcnIgPSBBcnJheXMuY29weU9mKGN1ci5nZXRWYWx1ZSgpLCBtKTtcbiAgICAgICAgICAgICAgLy8gXHU1MjE3XHU1M0Y3XG4gICAgICAgICAgICAgIGFycltpXSsrO1xuICAgICAgICAgICAgICBpZiAoIXNlZW4uY29udGFpbnMoQXJyYXlzLnRvU3RyaW5nKGFycikpKSB7XG4gICAgICAgICAgICAgICAgICBzZWVuLmFkZChBcnJheXMudG9TdHJpbmcoYXJyKSk7XG4gICAgICAgICAgICAgICAgICBpbnQgbmV4dCA9IGN1ci5nZXRLZXkoKSAtIG1hdFtpXVtjdXIuZ2V0VmFsdWUoKVtpXV0gKyBtYXRbaV1bYXJyW2ldXTtcbiAgICAgICAgICAgICAgICAgIHBxLm9mZmVyKG5ldyBQYWlyPD4obmV4dCwgYXJyKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHBxLnBlZWsoKS5nZXRLZXkoKTtcbn1cbiIKICAgIH1dCiAgfSwgewogICAgdGl0bGU6ICfku6PnoIExLjMuNScsCiAgICBjb2RlczogW3sKICAgICAgbGFuZ3VhZ2U6ICdQeXRob24nLAogICAgICBjb250ZW50OiAiXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgc21hbGxlc3REaXN0YW5jZVBhaXIoc2VsZiwgbnVtczogTGlzdFtpbnRdLCBrOiBpbnQpIC0+IGludDpcbiAgICAgICAgaCA9IFtdXG4gICAgICAgIGZvciBpIGluIHJhbmdlKGxlbihudW1zKSk6XG4gICAgICAgICAgICBmb3IgaiBpbiByYW5nZShpICsgMSwgbGVuKG51bXMpKTpcbiAgICAgICAgICAgICAgICBhLCBiID0gbnVtc1tpXSwgbnVtc1tqXVxuICAgICAgICAgICAgICAgICMgXHU3RUY0XHU2MzAxXHU1ODA2XHU1OTI3XHU1QzBGXHU0RTBEXHU4RDg1XHU4RkM3IGtcbiAgICAgICAgICAgICAgICBpZiBsZW4oaCkgPT0gayBhbmQgLWFicyhhIC0gYikgPiBoWzBdOlxuICAgICAgICAgICAgICAgICAgICBoZWFwcS5oZWFwcG9wKGgpXG4gICAgICAgICAgICAgICAgaWYgbGVuKGgpIDwgazpcbiAgICAgICAgICAgICAgICAgICAgaGVhcHEuaGVhcHB1c2goaCwgLWFicyhhIC0gYikpXG5cbiAgICAgICAgcmV0dXJuIC1oWzBdXG4iCiAgICB9XQogIH0sIHsKICAgIHRpdGxlOiAn5Luj56CBMS4zLjYnLAogICAgY29kZXM6IFt7CiAgICAgIGxhbmd1YWdlOiAnUHl0aG9uJywKICAgICAgY29udGVudDogIlxuY2xhc3MgU29sdXRpb24ob2JqZWN0KTpcbiAgICBkZWYgc21hbGxlc3REaXN0YW5jZVBhaXIoc2VsZiwgbnVtcywgayk6XG4gICAgICAgIG51bXMuc29ydCgpXG4gICAgICAgICMgbiBcdTc5Q0RcdTUwMTlcdTkwMDlcdTdCNTRcdTY4NDhcbiAgICAgICAgaCA9IFsobnVtc1tpKzFdIC0gbnVtc1tpXSwgaSwgaSsxKSBmb3IgaSBpbiByYW5nZShsZW4obnVtcykgLSAxKV1cbiAgICAgICAgaGVhcHEuaGVhcGlmeShoKVxuXG4gICAgICAgIGZvciBfIGluIHJhbmdlKGspOlxuICAgICAgICAgICAgZGlmZiwgZnIsIHRvID0gaGVhcHEuaGVhcHBvcChoKVxuICAgICAgICAgICAgaWYgdG8gKyAxIDwgbGVuKG51bXMpOlxuICAgICAgICAgICAgICAgIGhlYXBxLmhlYXBwdXNoKChudW1zW3RvICsgMV0gLSBudW1zW2ZyXSwgZnIsIHRvICsgMSkpXG5cbiAgICAgICAgcmV0dXJuIGRpZmZcbiIKICAgIH0sIHsKICAgICAgbGFuZ3VhZ2U6ICdKYXZhJywKICAgICAgY29udGVudDogIlxucHVibGljIGludCBzbWFsbGVzdERpc3RhbmNlUGFpcihpbnRbXSBudW1zLCBpbnQgaykge1xuICAvLyBcdTUxNDhcdTYzOTJcdTVFOEZcbiAgQXJyYXlzLnNvcnQobnVtcyk7XG4gIC8vIFx1NUMwRlx1OTg3Nlx1NTgwNlxuICBQcmlvcml0eVF1ZXVlPFBhaXI8SW50ZWdlciwgSW50ZWdlcj4+IHBxID0gbmV3IFByaW9yaXR5UXVldWU8PihDb21wYXJhdG9yLmNvbXBhcmluZ0ludChhIC0+IChudW1zW2EuZ2V0VmFsdWUoKV0gLSBudW1zW2EuZ2V0S2V5KCldKSkpO1xuICAvLyBpIFx1NEU4RSBpKzEgXHU1M0VGXHU0RUU1XHU2MjdFXHU1MjMwXHU2NzAwXHU1QzBGXHU3Njg0XHU1MTQzXHU3RDIwXG4gIGZvciAoaW50IGkgPSAwOyBpICsgMSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIFBhaXIgcGFpciA9IG5ldyBQYWlyKGksIGkgKyAxKTtcbiAgICAgIHBxLm9mZmVyKHBhaXIpO1xuICB9XG4gIFBhaXI8SW50ZWdlciwgSW50ZWdlcj4gcGFpciA9IG51bGw7XG4gIC8qKlxuICAgKiBcdTVCOUVcdTczQjBcdTUzOUZcdTc0MDZcdUZGMUFcbiAgICogXHU2NTcwXHU3RUM0XHU2MzA5XHU5ODdBXHU1RThGXHU2MzkyXHU1RThGXG4gICAqIFx1OTBBM1x1NEU0OFx1NjcwMFx1NUMwRlx1NzY4NFx1NURFRSBcdTRFRTVcdTUzQ0FcdTdCMkNcdTRFOENcdTVDMEZcdTc2ODRcdTVERUUgXHU1NzI4XHU3QjJDXHU0RTAwXHU4RjZFIFx1NEU1Rlx1NUMzMVx1NjYyRlx1NEUwQVx1OTc2Mlx1OTBBM1x1NEUyQSBmb3IgXHU5MUNDXHU5NzYyXHU1M0VGXHU0RUU1XHU2QzQyXHU1MUZBXHU2NzY1XHVGRjBDXG4gICAqIFx1NzUzMVx1NEU4RVx1NTQwRVx1N0VFRFx1NTE0M1x1N0QyMFx1NjYyRlx1NTcyOCBcdTUzOUZcdTY3MDlcdTU3RkFcdTc4NDBcdTRFMEFcdTZERkJcdTUyQTAgXHU1NDBFXHU3RUVEXHU1MTQzXHU3RDIwXHU4MEFGXHU1QjlBXHU2NjJGXHU2QkNGXHU0RTAwXHU4RjZFXHU5MDEwXHU2RTEwXHU1ODlFXHU1OTI3XHU3Njg0XHVGRjBDXHU0RTVGXHU1QzMxXHU2NjJGXHU4QkY0XHU0RTBBXHU0RTAwXHU4RjZFXHU5NkM2XHU1NDA4XHU1QzBGXHU0RThFXHU0RTBCXHU0RTAwXHU4RjZFXHVGRjA4XHU1NDBDXHU2ODM3XHU3Njg0XHU4RDc3XHU3MEI5XHU2MEM1XHU1MUI1XHVGRjA5XG4gICAqIFx1OEJDMVx1NjYwRVx1RkYxQVx1NTM5Rlx1NjcwOVx1OTZDNlx1NTQwOFx1NEUzQSBpLT5qICBcdTY1QjBcdTU4OUVcdTk2QzZcdTU0MDhcdTRFM0EgIGktPmorMSBcdTUzOUZcdTY3MDlcdTk2QzZcdTU0MDhcdTY2MkZcdTY1QjBcdTk2QzZcdTU0MDhcdTc2ODRcdTVCNTBcdTk2QzZcdUZGMENcdTYyNDBcdTRFRTVcdTY1QjBcdTc2ODRcdTk2QzZcdTU0MDhcdTVERUVcdTgwQUZcdTVCOUFcdTU5MjdcdTRFOEVcdTRFMEFcdTRFMDBcdThGNkUgXHVGRjBDXHU2NUIwXHU3Njg0XHU5NkM2XHU1NDA4XHU1NDBDXHU2NUY2XHU4OTg2XHU3NkQ2XHVGRjA4aS0+alx1RkYwOWFuZCAoaSsxLT5qKzEpIFx1NEUyNFx1NEUyQVx1OTZDNlx1NTQwOFxuICAgKiBcdThGRDlcdTY4MzdcdTUzRUZcdTRFRTVcdTRGRERcdThCQzFcdTUzNzNcdTRGQkZcdTVGMzlcdTUxRkFcdTRFMDBcdTRFMkFcdTUxNDNcdTdEMjAgcHEgXHU0RTJEXHU3Njg0XHU1ODA2XHU5ODc2XHU0RjlEXHU3MTM2XHU2NjJGXHU2NzAwXHU1QzBGXHU1MTQzXHU3RDIwXG4gICAqIFx1NTk4Mlx1NkI2NFx1NTNDRFx1NTkwRFxuICAgKiBcdTU4MDZcdTk4NzZcdTUxNDNcdTdEMjBcdTRGQkZcdTY2MkZcdTYyMTFcdTRFRUNcdTYyNDBcdTZDNDJcdTRFNEJcdTUxNDNcdTdEMjBcbiAgICovXG4gIHdoaWxlIChrID4gMCkge1xuICAgICAgay0tO1xuICAgICAgcGFpciA9IHBxLnBvbGwoKTtcbiAgICAgIGlmIChwYWlyLmdldFZhbHVlKCkgKyAxIDwgbnVtcy5sZW5ndGgpIHtcbiAgICAgICAgICBwcS5vZmZlcihuZXcgUGFpcihwYWlyLmdldEtleSgpLCBwYWlyLmdldFZhbHVlKCkgKyAxKSk7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIG51bXNbcGFpci5nZXRWYWx1ZSgpXSAtIG51bXNbcGFpci5nZXRLZXkoKV07XG59XG4iCiAgICB9XQogIH0sIHsKICAgIHRpdGxlOiAn5Luj56CBMS4zLjcnLAogICAgY29kZXM6IFt7CiAgICAgIGxhbmd1YWdlOiAnUHl0aG9uJywKICAgICAgY29udGVudDogIlxuY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHNtYWxsZXN0RGlzdGFuY2VQYWlyKHNlbGYsIEE6IExpc3RbaW50XSwgSzogaW50KSAtPiBpbnQ6XG4gICAgICAgIEEuc29ydCgpXG4gICAgICAgIGwsIHIgPSAwLCBBWy0xXSAtIEFbMF1cblxuICAgICAgICBkZWYgY291bnRfbmd0KG1pZCk6XG4gICAgICAgICAgICBzbG93ID0gMFxuICAgICAgICAgICAgYW5zID0gMFxuICAgICAgICAgICAgZm9yIGZhc3QgaW4gcmFuZ2UobGVuKEEpKTpcbiAgICAgICAgICAgICAgICB3aGlsZSBBW2Zhc3RdIC0gQVtzbG93XSA+IG1pZDpcbiAgICAgICAgICAgICAgICAgICAgc2xvdyArPSAxXG4gICAgICAgICAgICAgICAgYW5zICs9IGZhc3QgLSBzbG93XG4gICAgICAgICAgICByZXR1cm4gYW5zXG5cbiAgICAgICAgd2hpbGUgbCA8PSByOlxuICAgICAgICAgICAgbWlkID0gKGwgKyByKSAvLyAyXG4gICAgICAgICAgICBpZiBjb3VudF9uZ3QobWlkKSA+PSBLOlxuICAgICAgICAgICAgICAgIHIgPSBtaWQgLSAxXG4gICAgICAgICAgICBlbHNlOlxuICAgICAgICAgICAgICAgIGwgPSBtaWQgKyAxXG4gICAgICAgIHJldHVybiBsXG4iCiAgICB9LCB7CiAgICAgIGxhbmd1YWdlOiAnSmF2YScsCiAgICAgIGNvbnRlbnQ6ICJcbnB1YmxpYyBpbnQgc21hbGxlc3REaXN0YW5jZVBhaXIoaW50W10gbnVtcywgaW50IGspIHtcbiAgQXJyYXlzLnNvcnQobnVtcyk7XG5cbiAgaW50IGwgPSAwO1xuICBpbnQgciA9IG51bXNbbnVtcy5sZW5ndGggLSAxXSAtIG51bXNbMF07XG4gIHdoaWxlIChsIDwgcikge1xuICAgICAgaW50IG1pID0gKGwgKyByKSAvIDI7XG4gICAgICBpbnQgY291bnQgPSAwLCBsZWZ0ID0gMDtcbiAgICAgIGZvciAoaW50IHJpZ2h0ID0gMDsgcmlnaHQgPCBudW1zLmxlbmd0aDsgKytyaWdodCkge1xuICAgICAgICAgIHdoaWxlIChudW1zW3JpZ2h0XSAtIG51bXNbbGVmdF0gPiBtaSkgbGVmdCsrO1xuICAgICAgICAgIGNvdW50ICs9IHJpZ2h0IC0gbGVmdDtcbiAgICAgIH1cbiAgICAgIC8vY291bnQgPSBudW1iZXIgb2YgcGFpcnMgd2l0aCBkaXN0YW5jZSA8PSBtaVxuICAgICAgaWYgKGNvdW50ID49IGspIHIgPSBtaTtcbiAgICAgIGVsc2UgbCA9IG1pICsgMTtcbiAgfVxuICByZXR1cm4gcjtcbn1cbiIKICAgIH1dCiAgfSwgewogICAgdGl0bGU6ICfku6PnoIExLjMuOCcsCiAgICBjb2RlczogW3sKICAgICAgbGFuZ3VhZ2U6ICdQeXRob24nLAogICAgICBjb250ZW50OiAiXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgc21hbGxlc3RSYW5nZShzZWxmLCBtYXJ0cml4OiBMaXN0W0xpc3RbaW50XV0pIC0+IExpc3RbaW50XTpcbiAgICAgICAgbCwgciA9IC0xMCoqOSwgMTAqKjlcbiAgICAgICAgIyBcdTVDMDZcdTZCQ0ZcdTRFMDBcdTg4NENcdTY3MDBcdTVDMEZcdTc2ODRcdTkwRkRcdTY1M0VcdTUyMzBcdTU4MDZcdTRFMkRcdUZGMENcdTU0MENcdTY1RjZcdThCQjBcdTVGNTVcdTUxNzZcdTYyNDBcdTU3MjhcdTc2ODRcdTg4NENcdTUzRjdcdTU0OENcdTUyMTdcdTUzRjdcdUZGMENcdTRFMDBcdTUxNzEgbiBcdTRFMkFcdTlGNTBcdTU5MzRcdTVFNzZcdThGREJcbiAgICAgICAgaCA9IFsocm93WzBdLCBpLCAwKSBmb3IgaSwgcm93IGluIGVudW1lcmF0ZShtYXJ0cml4KV1cbiAgICAgICAgaGVhcHEuaGVhcGlmeShoKVxuICAgICAgICAjIFx1N0VGNFx1NjJBNFx1NjcwMFx1NTkyN1x1NTAzQ1xuICAgICAgICBtYXhfdiA9IG1heChyb3dbMF0gZm9yIHJvdyBpbiBtYXJ0cml4KVxuXG4gICAgICAgIHdoaWxlIFRydWU6XG4gICAgICAgICAgICBtaW5fdiwgcm93LCBjb2wgPSBoZWFwcS5oZWFwcG9wKGgpXG4gICAgICAgICAgICAjIG1heF92IC0gbWluX3YgXHU2NjJGXHU1RjUzXHU1MjREXHU3Njg0XHU2NzAwXHU1OTI3XHU2NzAwXHU1QzBGXHU1REVFXHU1MDNDXHVGRjBDIHIgLSBsIFx1NEUzQVx1NTE2OFx1NUM0MFx1NzY4NFx1NjcwMFx1NTkyN1x1NjcwMFx1NUMwRlx1NURFRVx1NTAzQ1x1MzAwMlx1NTZFMFx1NEUzQVx1NTk4Mlx1Njc5Q1x1NUY1M1x1NTI0RFx1NzY4NFx1NjZGNFx1NUMwRlx1RkYwQ1x1NjIxMVx1NEVFQ1x1NUMzMVx1NjZGNFx1NjVCMFx1NTE2OFx1NUM0MFx1N0VEM1x1Njc5Q1xuICAgICAgICAgICAgaWYgbWF4X3YgLSBtaW5fdiA8IHIgLSBsOlxuICAgICAgICAgICAgICAgIGwsIHIgPSBtaW5fdiwgbWF4X3ZcbiAgICAgICAgICAgIGlmIGNvbCA9PSBsZW4obWFydHJpeFtyb3ddKSAtIDE6IHJldHVybiBbbCwgcl1cbiAgICAgICAgICAgICMgXHU2NkY0XHU2NUIwXHU2MzA3XHU5NDg4XHVGRjBDXHU3RUU3XHU3RUVEXHU1RjgwXHU1NDBFXHU3OUZCXHU1MkE4XHU0RTAwXHU0RjREXG4gICAgICAgICAgICBoZWFwcS5oZWFwcHVzaChoLCAobWFydHJpeFtyb3ddW2NvbCArIDFdLCByb3csIGNvbCArIDEpKVxuICAgICAgICAgICAgbWF4X3YgPSBtYXgobWF4X3YsIG1hcnRyaXhbcm93XVtjb2wgKyAxXSlcbiIKICAgIH0sIHsKICAgICAgbGFuZ3VhZ2U6ICdKYXZhJywKICAgICAgY29udGVudDogIlxucHVibGljIGludFtdIHNtYWxsZXN0UmFuZ2UoTGlzdDxMaXN0PEludGVnZXI+PiBudW1zKSB7XG5cbiAgaW50IGwgPSAtMTAwMDAwMDAwMCwgciA9IDEwMDAwMDAwMDAsIG1heCA9IC0xMDAwMDAwMDAwO1xuXG4gIC8vIFx1NzUyOFx1NEUwMFx1NEUyQSBpbnRbM10gXHU2NTcwXHU3RUM0XHU2NzY1XHU0RkREXHU1QjU4IGxlblx1RkYwQyBoZWlnaHQgXHU0RUU1XHU1M0NBIHZhbFxuICBQcmlvcml0eVF1ZXVlPGludFtdPiBwcSA9IG5ldyBQcmlvcml0eVF1ZXVlKChDb21wYXJhdG9yPGludFtdPikgKGEsIGIpIC0+IGFbMl0gLSBiWzJdKTtcblxuICBmb3IgKGludCBpID0gMDsgaSA8IG51bXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgIHBxLm9mZmVyKG5ldyBpbnRbXXtpLCAwLCBudW1zLmdldChpKS5nZXQoMCl9KTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgbnVtcy5nZXQoaSkuZ2V0KDApKTtcbiAgfVxuXG4gIHdoaWxlICghcHEuaXNFbXB0eSgpKSB7XG4gICAgICBpbnRbXSBpdGVtID0gcHEucG9sbCgpO1xuICAgICAgaW50IG1pblYgPSBpdGVtWzJdLCByb3cgPSBpdGVtWzBdLCBjb2wgPSBpdGVtWzFdO1xuICAgICAgaWYgKG1heCAtIG1pblYgPCByIC0gbCkge1xuICAgICAgICAgIGwgPSBtaW5WO1xuICAgICAgICAgIHIgPSBtYXg7XG4gICAgICB9XG4gICAgICBpZiAoY29sID09IG51bXMuZ2V0KHJvdykuc2l6ZSgpIC0gMSkge1xuICAgICAgICAgIHJldHVybiBuZXcgaW50W117bCwgcn07XG4gICAgICB9XG4gICAgICBpbnQgbmV4dCA9IG51bXMuZ2V0KHJvdykuZ2V0KGNvbCArIDEpO1xuICAgICAgcHEub2ZmZXIobmV3IGludFtde3JvdywgY29sICsgMSwgbmV4dH0pO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobmV4dCwgbWF4KTtcbiAgfVxuXG4gIHJldHVybiBuZXcgaW50W117bCwgcn07XG59XG4iCiAgICB9XQogIH0sIHsKICAgIHRpdGxlOiAn5Luj56CBMS4zLjknLAogICAgY29kZXM6IFt7CiAgICAgIGxhbmd1YWdlOiAnUHl0aG9uJywKICAgICAgY29udGVudDogIlxuY2xhc3MgU29sdXRpb246XG4gICAgZGVmIHNtYWxsZXN0UmFuZ2Uoc2VsZiwgbWFydHJpeDogTGlzdFtMaXN0W2ludF1dKSAtPiBMaXN0W2ludF06XG4gICAgICAgIGwsIHIgPSAtMTAqKjksIDEwKio5XG4gICAgICAgICMgXHU1QzA2XHU2QkNGXHU0RTAwXHU4ODRDXHU2NzAwXHU1QzBGXHU3Njg0XHU5MEZEXHU2NTNFXHU1MjMwXHU1ODA2XHU0RTJEXHVGRjBDXHU1NDBDXHU2NUY2XHU4QkIwXHU1RjU1XHU1MTc2XHU2MjQwXHU1NzI4XHU3Njg0XHU4ODRDXHU1M0Y3XHU1NDhDXHU1MjE3XHU1M0Y3XHVGRjBDXHU0RTAwXHU1MTcxIG4gXHU0RTJBXHU5RjUwXHU1OTM0XHU1RTc2XHU4RkRCXG4gICAgICAgIGggPSBbKHJvd1swXSwgaSwgMCkgZm9yIGksIHJvdyBpbiBlbnVtZXJhdGUobWFydHJpeCldXG4gICAgICAgIGhlYXBxLmhlYXBpZnkoaClcbiAgICAgICAgIyBcdTdFRjRcdTYyQTRcdTY3MDBcdTU5MjdcdTUwM0NcbiAgICAgICAgbWF4X3YgPSBtYXgocm93WzBdIGZvciByb3cgaW4gbWFydHJpeClcblxuICAgICAgICB3aGlsZSBUcnVlOlxuICAgICAgICAgICAgbWluX3YsIHJvdywgY29sID0gaGVhcHEuaGVhcHBvcChoKVxuICAgICAgICAgICAgIyBtYXhfdiAtIG1pbl92IFx1NjYyRlx1NUY1M1x1NTI0RFx1NzY4NFx1NjcwMFx1NTkyN1x1NjcwMFx1NUMwRlx1NURFRVx1NTAzQ1x1RkYwQyByIC0gbCBcdTRFM0FcdTUxNjhcdTVDNDBcdTc2ODRcdTY3MDBcdTU5MjdcdTY3MDBcdTVDMEZcdTVERUVcdTUwM0NcdTMwMDJcdTU2RTBcdTRFM0FcdTU5ODJcdTY3OUNcdTVGNTNcdTUyNERcdTc2ODRcdTY2RjRcdTVDMEZcdUZGMENcdTYyMTFcdTRFRUNcdTVDMzFcdTY2RjRcdTY1QjBcdTUxNjhcdTVDNDBcdTdFRDNcdTY3OUNcbiAgICAgICAgICAgIGlmIG1heF92IC0gbWluX3YgPCByIC0gbDpcbiAgICAgICAgICAgICAgICBsLCByID0gbWluX3YsIG1heF92XG4gICAgICAgICAgICBpZiBjb2wgPT0gbGVuKG1hcnRyaXhbcm93XSkgLSAxOiByZXR1cm4gW2wsIHJdXG4gICAgICAgICAgICAjIFx1NjZGNFx1NjVCMFx1NjMwN1x1OTQ4OFx1RkYwQ1x1N0VFN1x1N0VFRFx1NUY4MFx1NTQwRVx1NzlGQlx1NTJBOFx1NEUwMFx1NEY0RFxuICAgICAgICAgICAgaGVhcHEuaGVhcHB1c2goaCwgKG1hcnRyaXhbcm93XVtjb2wgKyAxXSwgcm93LCBjb2wgKyAxKSlcbiAgICAgICAgICAgIG1heF92ID0gbWF4KG1heF92LCBtYXJ0cml4W3Jvd11bY29sICsgMV0pXG4gICAgZGVmIG1pbmltdW1EZXZpYXRpb24oc2VsZiwgbnVtczogTGlzdFtpbnRdKSAtPiBpbnQ6XG4gICAgICAgIG1hdHJpeCA9IFtbXSBmb3IgXyBpbiByYW5nZShsZW4obnVtcykpXVxuICAgICAgICBmb3IgaSwgbnVtIGluIGVudW1lcmF0ZShudW1zKTpcbiAgICAgICAgICAgIGlmIG51bSAmIDEgPT0gMTpcbiAgICAgICAgICAgICAgICBtYXRyaXhbaV0gKz0gW251bSwgbnVtICogMl1cbiAgICAgICAgICAgIGVsc2U6XG4gICAgICAgICAgICAgICAgdGVtcCA9IFtdXG4gICAgICAgICAgICAgICAgd2hpbGUgbnVtIGFuZCBudW0gJiAxID09IDA6XG4gICAgICAgICAgICAgICAgICAgIHRlbXAgKz0gW251bV1cbiAgICAgICAgICAgICAgICAgICAgbnVtIC8vPSAyXG4gICAgICAgICAgICAgICAgdGVtcCArPSBbbnVtXVxuICAgICAgICAgICAgICAgIG1hdHJpeFtpXSArPSB0ZW1wWzo6LTFdXG4gICAgICAgIGEsIGIgPSBzZWxmLnNtYWxsZXN0UmFuZ2UobWF0cml4KVxuICAgICAgICByZXR1cm4gYiAtIGFcbiIKICAgIH0sIHsKICAgICAgbGFuZ3VhZ2U6ICdKYXZhJywKICAgICAgY29udGVudDogIlxucHVibGljIGludCBtaW5pbXVtRGV2aWF0aW9uKGludFtdIG51bXMpIHtcbiAgaW50IG4gPSBudW1zLmxlbmd0aDtcbiAgTGlzdDxMaXN0PEludGVnZXI+PiBhcnIgPSBuZXcgQXJyYXlMaXN0PD4oKTtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGFyci5hZGQobmV3IEFycmF5TGlzdDw+KCkpO1xuICAgICAgaWYgKChudW1zW2ldICYgMSkgPT0gMSkge1xuICAgICAgICAgIGFyci5nZXQoaSkuYWRkKG51bXNbaV0pO1xuICAgICAgICAgIGFyci5nZXQoaSkuYWRkKG51bXNbaV0gKiAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hpbGUgKChudW1zW2ldICYgMSkgIT0gMCkge1xuICAgICAgICAgICAgICBhcnIuZ2V0KGkpLmFkZChudW1zW2ldKTtcbiAgICAgICAgICAgICAgbnVtc1tpXSA+Pj0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJyLmdldChpKS5hZGQobnVtc1tpXSk7XG4gICAgICAgICAgQ29sbGVjdGlvbnMucmV2ZXJzZShhcnIuZ2V0KGkpKTtcbiAgICAgIH1cbiAgfVxuXG4gIGludFtdIHJlcyA9IHNtYWxsZXN0UmFuZ2UoYXJyKTtcblxuICByZXR1cm4gcmVzWzFdIC0gcmVzWzBdO1xufVxuIgogICAgfV0KICB9LCB7CiAgICB0aXRsZTogJ+S7o+eggTEuMy4xMCcsCiAgICBjb2RlczogW3sKICAgICAgbGFuZ3VhZ2U6ICdQeXRob24nLAogICAgICBjb250ZW50OiAiXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgbWluUmVmdWVsU3RvcHMoc2VsZiwgdGFyZ2V0OiBpbnQsIHN0YXJ0RnVlbDogaW50LCBzdGF0aW9uczogTGlzdFtMaXN0W2ludF1dKSAtPiBpbnQ6XG4gICAgICAgIHN0YXRpb25zICs9IFsodGFyZ2V0LCAwKV1cbiAgICAgICAgY3VyID0gc3RhcnRGdWVsXG4gICAgICAgIGFucyA9IDBcblxuICAgICAgICBoID0gW11cbiAgICAgICAgbGFzdCA9IDBcbiAgICAgICAgZm9yIGksIGZ1ZWwgaW4gc3RhdGlvbnM6XG4gICAgICAgICAgICBjdXIgLT0gaSAtIGxhc3RcbiAgICAgICAgICAgIHdoaWxlIGN1ciA8IDAgYW5kIGg6XG4gICAgICAgICAgICAgICAgY3VyIC09IGhlYXBxLmhlYXBwb3AoaClcbiAgICAgICAgICAgICAgICBhbnMgKz0gMVxuICAgICAgICAgICAgaWYgY3VyIDwgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgICAgIGhlYXBwdXNoKGgsIC1mdWVsKVxuXG4gICAgICAgICAgICBsYXN0ID0gaVxuICAgICAgICByZXR1cm4gYW5zXG4iCiAgICB9LCB7CiAgICAgIGxhbmd1YWdlOiAnSmF2YScsCiAgICAgIGNvbnRlbnQ6ICJcbnB1YmxpYyBpbnQgbWluUmVmdWVsU3RvcHMoaW50IHRhcmdldCwgaW50IHN0YXJ0RnVlbCwgaW50W11bXSBzdGF0aW9ucykge1xuICBpZiAoc3RhdGlvbnMubGVuZ3RoID09IDApIHtcbiAgICAgIHJldHVybiBzdGFydEZ1ZWwgPj0gdGFyZ2V0ID8gMCA6IC0xO1xuICB9XG5cbiAgLy8gXHU1QjlBXHU0RTQ5XHU2QjIxXHU2NTcwIGFuc1x1RkYwQ1x1OEY2Nlx1NTE4NVx1NkNCOVx1OTFDRiBjdXJcbiAgaW50IGFucyA9IDAsIGN1ciA9IHN0YXJ0RnVlbDtcbiAgLy8gXHU1QjlBXHU0RTQ5IHBxIFx1NzUyOFx1Njc2NVx1NTcyOFx1OEY2Nlx1NTNBMlx1N0JCMVx1NEZERFx1NUI1OFx1NzFDM1x1NkNCOVxuICBQcmlvcml0eVF1ZXVlPEludGVnZXI+IHBxID0gbmV3IFByaW9yaXR5UXVldWU8PigoYSwgYikgLT4gYiAtIGEpO1xuXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgc3RhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFx1OEY2Nlx1NEUwQVx1NkNBMVx1NkNCOVx1NTU2NiBcdTk3MDBcdTg5ODFcdTUyMzBcdThGNjZcdTUzQTJcdTYyN0VcdTY3MDBcdTU5MjdcdTc2ODRcdTRFMDBcdTY4NzZcdTZDQjlcdTY3NjVcdTUyQTBcdTZFRTFcbiAgICAgIHdoaWxlIChjdXIgPCBzdGF0aW9uc1tpXVswXSkge1xuICAgICAgICAgIEludGVnZXIgZnVlbCA9IHBxLnBvbGwoKTtcbiAgICAgICAgICAvLyBcdThGNjZcdTUzQTJcdTZDQTFcdTZDQjlcdTRFODYgbWlzc2lvbiBmYWlsZWRcbiAgICAgICAgICBpZiAoZnVlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gXHU4ODRDXHU5QTc2XHU4REREXHU3OUJCXG4gICAgICAgICAgY3VyICs9IGZ1ZWw7XG4gICAgICAgICAgYW5zKys7XG4gICAgICB9XG4gICAgICBwcS5vZmZlcihzdGF0aW9uc1tpXVsxXSk7XG4gIH1cbiAgLy8gXHU1MjI0XHU2NUFEXHU2NjJGXHU1NDI2XHU1MjMwXHU4RkJFXHU3NkVFXHU3Njg0XHU1NzMwXG4gIHdoaWxlIChjdXIgPCB0YXJnZXQpIHtcbiAgICAgIEludGVnZXIgZnVlbCA9IHBxLnBvbGwoKTtcbiAgICAgIGlmIChmdWVsID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBjdXIgKz0gZnVlbDtcbiAgICAgIGFucysrO1xuICB9XG4gIHJldHVybiBhbnM7XG59XG4iCiAgICB9XQogIH0sIHsKICAgIHRpdGxlOiAn5Luj56CBMS4zLjExJywKICAgIGNvZGVzOiBbewogICAgICBsYW5ndWFnZTogJ1B5dGhvbicsCiAgICAgIGNvbnRlbnQ6ICJcbmNsYXNzIFNvbHV0aW9uOlxuICAgIGRlZiBhdm9pZEZsb29kKHNlbGYsIHJhaW5zOiBMaXN0W2ludF0pIC0+IExpc3RbaW50XTpcbiAgICAgICAgYW5zID0gWzFdICogbGVuKHJhaW5zKVxuICAgICAgICBsYWtlcyA9IGNvbGxlY3Rpb25zLmRlZmF1bHRkaWN0KGludClcbiAgICAgICAgc3VubnkgPSBbXVxuXG4gICAgICAgIGZvciBpLCByYWluIGluIGVudW1lcmF0ZShyYWlucyk6XG4gICAgICAgICAgICBpZiByYWluID4gMDpcbiAgICAgICAgICAgICAgICBhbnNbaV0gPSAtMVxuICAgICAgICAgICAgICAgIGlmIGxha2VzW3JhaW4gLSAxXSA9PSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAwID09IGxlbihzdW5ueSk6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgICAgICAgICAgICAgYW5zW3N1bm55LnBvcCgpXSA9IHJhaW5cbiAgICAgICAgICAgICAgICBsYWtlc1tyYWluIC0gMV0gPSAxXG4gICAgICAgICAgICBlbHNlOlxuICAgICAgICAgICAgICAgIHN1bm55LmFwcGVuZChpKVxuICAgICAgICByZXR1cm4gYW5zXG4iCiAgICB9LCB7CiAgICAgIGxhbmd1YWdlOiAnSmF2YScsCiAgICAgIGNvbnRlbnQ6ICJcbnB1YmxpYyAgaW50W10gYXZvaWRGbG9vZChpbnRbXSByYWlucykge1xuXG4gICAgTGlzdDxJbnRlZ2VyPnN1bm55cyA9IG5ldyBBcnJheUxpc3Q8PigpO1xuXG4gICAgTWFwPEludGVnZXIsSW50ZWdlcj4gcmFpbmluZ3MgPSBuZXcgSGFzaE1hcDw+KCk7XG4gICAgaW50IHJlc1tdID0gbmV3IGludFtyYWlucy5sZW5ndGhdO1xuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcmFpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gXHU1RjUzXHU1MjREXHU2RTU2XHU2Q0NBXHU0RTBCXHU5NkU4XHU1NTY2XG4gICAgICAgIGlmIChyYWluc1tpXT4wKXtcbiAgICAgICAgICAgIGlmIChyYWluaW5ncy5jb250YWluc0tleShyYWluc1tpXSkpIHtcbiAgICAgICAgICAgICAgICBpbnQgbGFzdFJhaW5pbmdEYXkgPSByYWluaW5ncy5nZXQocmFpbnNbaV0pO1xuICAgICAgICAgICAgICAgIGludCBpbmRleCA9ICBnZXRMZWZ0KHN1bm55cyxsYXN0UmFpbmluZ0RheSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4Pj1zdW5ueXMuc2l6ZSgpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbnRbXXt9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc1tzdW5ueXMuZ2V0KGluZGV4KV0gPSByYWluc1tpXTtcbiAgICAgICAgICAgICAgICBzdW5ueXMucmVtb3ZlKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhaW5pbmdzLnB1dChyYWluc1tpXSxpKTtcbiAgICAgICAgICAgIHJlc1tpXSA9IC0xO1xuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICBzdW5ueXMuYWRkKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoaW50IGkgPSAwOyBpIDxzdW5ueXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgcmVzW3N1bm55cy5nZXQoaSldID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbnB1YmxpYyBpbnQgZ2V0TGVmdChMaXN0PEludGVnZXI+IGFycixpbnQga2V5KXtcbiAgICBpbnQgbGVmdCA9IDA7XG4gICAgaW50IHJpZ2h0ID0gYXJyLnNpemUoKTtcbiAgICB3aGlsZSAobGVmdDxyaWdodCl7XG4gICAgICAgIGludCBtaWQgPSAobGVmdCtyaWdodCk+PjE7XG5cbiAgICAgICAgaWYgKGFyci5nZXQobWlkKT49a2V5KXtcbiAgICAgICAgICAgIHJpZ2h0PW1pZDtcbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgbGVmdCA9IG1pZCsxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xufVxuIgogICAgfV0KICB9LCB7CiAgICB0aXRsZTogJ+S7o+eggTEuMy4xMicsCiAgICBjb2RlczogW3sKICAgICAgbGFuZ3VhZ2U6ICdQeXRob24nLAogICAgICBjb250ZW50OiAiXG5jbGFzcyBTb2x1dGlvbjpcbiAgICBkZWYgZnVydGhlc3RCdWlsZGluZyhzZWxmLCBoZWlnaHRzOiBMaXN0W2ludF0sIGJyaWNrczogaW50LCBsYWRkZXJzOiBpbnQpIC0+IGludDpcbiAgICAgICAgaCA9IFtdXG4gICAgICAgIGZvciBpIGluIHJhbmdlKDEsIGxlbihoZWlnaHRzKSk6XG4gICAgICAgICAgICBkaWZmID0gaGVpZ2h0c1tpXSAtIGhlaWdodHNbaSAtIDFdXG4gICAgICAgICAgICBpZiBkaWZmIDw9IDA6XG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIGlmIGJyaWNrcyA8IGRpZmYgYW5kIGxhZGRlcnMgPiAwOlxuICAgICAgICAgICAgICAgIGxhZGRlcnMgLT0gMVxuICAgICAgICAgICAgICAgIGlmIGggYW5kIC1oWzBdID4gZGlmZjpcbiAgICAgICAgICAgICAgICAgICAgYnJpY2tzIC09IGhlYXBxLmhlYXBwb3AoaClcbiAgICAgICAgICAgICAgICBlbHNlOlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgYnJpY2tzIC09IGRpZmZcbiAgICAgICAgICAgIGlmIGJyaWNrcyA8IDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgLSAxXG4gICAgICAgICAgICBoZWFwcS5oZWFwcHVzaChoLCAtZGlmZilcbiAgICAgICAgcmV0dXJuIGxlbihoZWlnaHRzKSAtIDFcbiIKICAgIH0sIHsKICAgICAgbGFuZ3VhZ2U6ICdKYXZhJywKICAgICAgY29udGVudDogIlxucHVibGljIGludCBmdXJ0aGVzdEJ1aWxkaW5nKGludFtdIGhlaWdodHMsIGludCBicmlja3MsIGludCBsYWRkZXJzKSB7XG4gIGlmIChoZWlnaHRzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBoZWlnaHRzLmxlbmd0aDtcbiAgfVxuICBpbnQgbmVlZEJyaWNrID0gMDtcblxuICBQcmlvcml0eVF1ZXVlPEludGVnZXI+IHBxID0gbmV3IFByaW9yaXR5UXVldWUoKTtcbiAgZm9yIChpbnQgaSA9IDE7IGkgPCBoZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnQgZGlmZiA9IGhlaWdodHNbaV0gLSBoZWlnaHRzW2kgLSAxXTtcbiAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgIHBxLm9mZmVyKGRpZmYpO1xuICAgICAgICAgIGlmIChwcS5zaXplKCkgPiBsYWRkZXJzKSB7XG4gICAgICAgICAgICAgIGludCBicmljayA9IHBxLnBvbGwoKTtcbiAgICAgICAgICAgICAgbmVlZEJyaWNrICs9IGJyaWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmVlZEJyaWNrID4gYnJpY2tzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpIC0gMTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGhlaWdodHMubGVuZ3RoIC0gMTtcbn1cbiIKICAgIH1dCiAgfSwgewogICAgdGl0bGU6ICfku6PnoIExLjQuMScsCiAgICBjb2RlczogW3sKICAgICAgbGFuZ3VhZ2U6ICdQeXRob24nLAogICAgICBjb250ZW50OiAiXG5kZWYgZGlqa3N0cmEoZ3JhcGgsIHN0YXJ0LCBlbmQpOlxuICAgICMgXHU1ODA2XHU5MUNDXHU3Njg0XHU2NTcwXHU2MzZFXHU5MEZEXHU2NjJGIChjb3N0LCBpKSBcdTc2ODRcdTRFOENcdTUxNDNcdTc5NTZcdUZGMENcdTUxNzZcdTU0MkJcdTRFNDlcdTY2MkZcdTIwMUNcdTRFQ0Ugc3RhcnQgXHU4RDcwXHU1MjMwIGkgXHU3Njg0XHU4REREXHU3OUJCXHU2NjJGIGNvc3RcdTIwMURcdTMwMDJcbiAgICBoZWFwID0gWygwLCBzdGFydCldXG4gICAgdmlzaXRlZCA9IHNldCgpXG4gICAgd2hpbGUgaGVhcDpcbiAgICAgICAgKGNvc3QsIHUpID0gaGVhcHEuaGVhcHBvcChoZWFwKVxuICAgICAgICBpZiB1IGluIHZpc2l0ZWQ6XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICB2aXNpdGVkLmFkZCh1KVxuICAgICAgICBpZiB1ID09IGVuZDpcbiAgICAgICAgICAgIHJldHVybiBjb3N0XG4gICAgICAgIGZvciB2LCBjIGluIGdyYXBoW3VdOlxuICAgICAgICAgICAgaWYgdiBpbiB2aXNpdGVkOlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICBuZXh0ID0gY29zdCArIGNcbiAgICAgICAgICAgIGhlYXBxLmhlYXBwdXNoKGhlYXAsIChuZXh0LCB2KSlcbiAgICByZXR1cm4gLTFcbiIKICAgIH0sIHsKICAgICAgbGFuZ3VhZ2U6ICdKYXZhJywKICAgICAgY29udGVudDogIlxuICAgICAgICAgICAgXG4gICAgICAgICAgICAiCiAgICB9XQogIH0sIHsKICAgIHRpdGxlOiAn5Luj56CBMS40LjInLAogICAgY29kZXM6IFt7CiAgICAgIGxhbmd1YWdlOiAnUHl0aG9uJywKICAgICAgY29udGVudDogIlxuY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGRpamtzdHJhKHNlbGYsIGdyYXBoLCBzdGFydCwgZW5kKTpcbiAgICAgICAgaGVhcCA9IFsoMCwgc3RhcnQpXVxuICAgICAgICB2aXNpdGVkID0gc2V0KClcbiAgICAgICAgd2hpbGUgaGVhcDpcbiAgICAgICAgICAgIChjb3N0LCB1KSA9IGhlYXBxLmhlYXBwb3AoaGVhcClcbiAgICAgICAgICAgIGlmIHUgaW4gdmlzaXRlZDpcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgdmlzaXRlZC5hZGQodSlcbiAgICAgICAgICAgIGlmIHUgPT0gZW5kOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb3N0XG4gICAgICAgICAgICBmb3IgdiwgYyBpbiBncmFwaFt1XTpcbiAgICAgICAgICAgICAgICBpZiB2IGluIHZpc2l0ZWQ6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgbmV4dCA9IGNvc3QgKyBjXG4gICAgICAgICAgICAgICAgaGVhcHEuaGVhcHB1c2goaGVhcCwgKG5leHQsIHYpKVxuICAgICAgICByZXR1cm4gLTFcbiAgICBkZWYgbmV0d29ya0RlbGF5VGltZShzZWxmLCB0aW1lczogTGlzdFtMaXN0W2ludF1dLCBOOiBpbnQsIEs6IGludCkgLT4gaW50OlxuICAgICAgICBncmFwaCA9IGNvbGxlY3Rpb25zLmRlZmF1bHRkaWN0KGxpc3QpXG4gICAgICAgIGZvciBmciwgdG8sIHcgaW4gdGltZXM6XG4gICAgICAgICAgICBncmFwaFtmciAtIDFdLmFwcGVuZCgodG8gLSAxLCB3KSlcbiAgICAgICAgYW5zID0gLTFcbiAgICAgICAgZm9yIHRvIGluIHJhbmdlKE4pOlxuICAgICAgICAgICAgIyBcdThDMDNcdTc1MjhcdTVDMDFcdTg4QzVcdTU5N0RcdTc2ODQgZGlqa3N0cmEgXHU2NUI5XHU2Q0Q1XG4gICAgICAgICAgICBkaXN0ID0gc2VsZi5kaWprc3RyYShncmFwaCwgSyAtIDEsIHRvKVxuICAgICAgICAgICAgaWYgZGlzdCA9PSAtMTogcmV0dXJuIC0xXG4gICAgICAgICAgICBhbnMgPSBtYXgoYW5zLCBkaXN0KVxuICAgICAgICByZXR1cm4gYW5zXG4iCiAgICB9LCB7CiAgICAgIGxhbmd1YWdlOiAnSmF2YScsCiAgICAgIGNvbnRlbnQ6ICJcblByaW9yaXR5UXVldWU8Tm9kZT4gcHE7XG5wdWJsaWMgaW50IG5ldHdvcmtEZWxheVRpbWUoaW50W11bXSB0aW1lcywgaW50IG4sIGludCBrKSB7XG4gICAgLy8gXHU3NTI4XHU5MEJCXHU2M0E1XHU4ODY4XHU2Nzg0XHU1RUZBXHU1NkZFXG4gICAgTGlzdDxpbnRbXT5bXSBncmFwaCA9IG5ldyBMaXN0W24gKyAxXTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IGdyYXBoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdyYXBoW2ldID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIH1cbiAgICBmb3IgKGludCBpID0gMDsgaSA8IHRpbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludFtdIGVkZ2UgPSB0aW1lc1tpXTtcbiAgICAgICAgZ3JhcGhbZWRnZVswXV0uYWRkKGVkZ2UpO1xuICAgIH1cblxuICAgIGludCBkaXN0LGFucyA9IC0xO1xuXG4gICAgZm9yIChpbnQgdG8gPSAxOyB0byA8PSBuOyB0bysrKSB7XG4gICAgICAgIGRpc3QgPSBkaWprc3RyYShncmFwaCwgaywgdG8pO1xuICAgICAgICBpZiAoZGlzdCA9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGFucyA9IE1hdGgubWF4KGFucywgZGlzdCk7XG4gICAgfVxuICAgIHJldHVybiBhbnM7XG59XG5cbnB1YmxpYyBpbnQgZGlqa3N0cmEoTGlzdDxpbnRbXT5bXSBncmFwaCwgaW50IHN0YXJ0LCBpbnQgZW5kKSB7XG4gICAgQXJyYXlzLmZpbGwoY29zdCwgSW50ZWdlci5NQVhfVkFMVUUpO1xuICAgIGJvb2xlYW4gdmlzaXRlZFtdID0gbmV3IGJvb2xlYW5bZ3JhcGgubGVuZ3RoXTtcbiAgICBjb3N0W3N0YXJ0XSA9IDA7XG4gICAgcHEgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xuICAgIHBxLm9mZmVyKG5ldyBOb2RlKHN0YXJ0LCAwKSk7XG5cbiAgICB3aGlsZSAoIXBxLmlzRW1wdHkoKSkge1xuICAgICAgICAvL1x1NkJDRlx1NkIyMVx1NTNENlx1NTFGQVx1OERERFx1NzlCQlx1NjcwMFx1OEZEMVx1NzY4NFx1ODI4Mlx1NzBCOVxuICAgICAgICBOb2RlIG5vZGUgPSBwcS5wb2xsKCk7XG4gICAgICAgIGlmICh2aXNpdGVkW25vZGUudl0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZpc2l0ZWRbbm9kZS52XSA9IHRydWU7XG4gICAgICAgIGlmIChub2RlLnYgPT0gZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jb3N0O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpbnRbXSBlZGdlIDogZ3JhcGhbbm9kZS52XSkge1xuICAgICAgICAgICAgaW50IGMgPSBlZGdlWzJdO1xuICAgICAgICAgICAgLy8gXHU1OTgyXHU2NzlDXHU1MzlGXHU3MEI5XHU3RUNGXHU4RkM3XHU4QkU1XHU2NzYxXHU4RkI5XHU1MjMwXHU4RkJFXHU3NkVFXHU2ODA3XHU4MjgyXHU3MEI5IFx1ODJCMVx1OTUwMFx1NUMxMVx1NEU4RVx1NEU0Qlx1NTI0RFx1NzY4NFx1NTIzMFx1NzZFRVx1NjgwN1x1ODI4Mlx1NzBCOVx1ODJCMVx1OTUwMFx1RkYwQ1x1OTBBM1x1NEU0OFx1NjZGNFx1NjVCMFxuICAgICAgICAgICAgaWYgKHZpc2l0ZWRbZWRnZVsxXV0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGludCBuZXh0ID0gYyArIG5vZGUuY29zdDtcbiAgICAgICAgICAgIC8vIFx1NjI4QVx1NzZFRVx1NjgwN1x1ODI4Mlx1NzBCOVx1NTJBMFx1NTE2NVxuICAgICAgICAgICAgcHEub2ZmZXIobmV3IE5vZGUoZWRnZVsxXSwgbmV4dCkpO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG59XG4iCiAgICB9XQogIH0sIHsKICAgIHRpdGxlOiAn5Luj56CBMS40LjMnLAogICAgY29kZXM6IFt7CiAgICAgIGxhbmd1YWdlOiAnUHl0aG9uJywKICAgICAgY29udGVudDogIlxuY2xhc3MgU29sdXRpb246XG4gICAgZGVmIGRpamtzdHJhKHNlbGYsIGdyYXBoLCBzdGFydCwgZW5kKTpcbiAgICAgICAgaGVhcCA9IFsoMCwgc3RhcnQpXSAgIyBjb3N0IGZyb20gc3RhcnQgbm9kZSxlbmQgbm9kZVxuICAgICAgICBkaXN0ID0ge31cbiAgICAgICAgd2hpbGUgaGVhcDpcbiAgICAgICAgICAgIChjb3N0LCB1KSA9IGhlYXBxLmhlYXBwb3AoaGVhcClcbiAgICAgICAgICAgIGlmIHUgaW4gZGlzdDpcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgZGlzdFt1XSA9IGNvc3RcbiAgICAgICAgICAgIGZvciB2LCBjIGluIGdyYXBoW3VdOlxuICAgICAgICAgICAgICAgIGlmIHYgaW4gZGlzdDpcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICBuZXh0ID0gY29zdCArIGNcbiAgICAgICAgICAgICAgICBoZWFwcS5oZWFwcHVzaChoZWFwLCAobmV4dCwgdikpXG4gICAgICAgIHJldHVybiBkaXN0XG4gICAgZGVmIG5ldHdvcmtEZWxheVRpbWUoc2VsZiwgdGltZXM6IExpc3RbTGlzdFtpbnRdXSwgTjogaW50LCBLOiBpbnQpIC0+IGludDpcbiAgICAgICAgZ3JhcGggPSBjb2xsZWN0aW9ucy5kZWZhdWx0ZGljdChsaXN0KVxuICAgICAgICBmb3IgZnIsIHRvLCB3IGluIHRpbWVzOlxuICAgICAgICAgICAgZ3JhcGhbZnIgLSAxXS5hcHBlbmQoKHRvIC0gMSwgdykpXG4gICAgICAgIGFucyA9IC0xXG4gICAgICAgIGRpc3QgPSBzZWxmLmRpamtzdHJhKGdyYXBoLCBLIC0gMSwgdG8pXG4gICAgICAgIHJldHVybiAtMSBpZiBsZW4oZGlzdCkgIT0gTiBlbHNlIG1heChkaXN0LnZhbHVlcygpKVxuIgogICAgfSwgewogICAgICBsYW5ndWFnZTogJ0phdmEnLAogICAgICBjb250ZW50OiAiXG4gICAgICAgICAgICBpbnQgZGlzdFtdO1xuUHJpb3JpdHlRdWV1ZTxOb2RlPiBwcTtcblxucHVibGljIGludCBuZXR3b3JrRGVsYXlUaW1lKGludFtdW10gdGltZXMsIGludCBuLCBpbnQgaykge1xuICAgIC8vIFx1NzUyOFx1OTBCQlx1NjNBNVx1ODg2OFx1Njc4NFx1NUVGQVx1NTZGRVxuICAgIExpc3Q8aW50W10+W10gZ3JhcGggPSBuZXcgTGlzdFtuICsgMV07XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBncmFwaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBncmFwaFtpXSA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICB9XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCB0aW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnRbXSBlZGdlID0gdGltZXNbaV07XG4gICAgICAgIGdyYXBoW2VkZ2VbMF1dLmFkZChlZGdlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpamtzdHJhKGdyYXBoLCBrKTtcblxufVxuXG5cbnB1YmxpYyBpbnRbXSBkaWprc3RyYShMaXN0PGludFtdPltdIGdyYXBoLCBpbnQgc3RhcnQpIHtcbiAgICBkaXN0ID0gbmV3IGludFtncmFwaC5sZW5ndGhdO1xuICAgIEFycmF5cy5maWxsKGRpc3QsIEludGVnZXIuTUFYX1ZBTFVFKTtcbiAgICBib29sZWFuIHZpc2l0ZWRbXSA9IG5ldyBib29sZWFuW2dyYXBoLmxlbmd0aF07XG4gICAgZGlzdFtzdGFydF0gPSAwO1xuICAgIHBxID0gbmV3IFByaW9yaXR5UXVldWUoKTtcbiAgICBwcS5vZmZlcihuZXcgTm9kZShzdGFydCwgMCkpO1xuXG4gICAgd2hpbGUgKCFwcS5pc0VtcHR5KCkpIHtcbiAgICAgICAgLy9cdTZCQ0ZcdTZCMjFcdTUzRDZcdTUxRkFcdThERERcdTc5QkJcdTY3MDBcdThGRDFcdTc2ODRcdTgyODJcdTcwQjlcbiAgICAgICAgTm9kZSBub2RlID0gcHEucG9sbCgpO1xuICAgICAgICBpZiAodmlzaXRlZFtub2RlLnZdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2aXNpdGVkW25vZGUudl0gPSB0cnVlO1xuICAgICAgICBmb3IgKGludFtdIGVkZ2UgOiBncmFwaFtub2RlLnZdKSB7XG4gICAgICAgICAgICBpbnQgYyA9IGVkZ2VbMl07XG4gICAgICAgICAgICAvLyBcdTU5ODJcdTY3OUNcdTUzOUZcdTcwQjlcdTdFQ0ZcdThGQzdcdThCRTVcdTY3NjFcdThGQjlcdTUyMzBcdThGQkVcdTc2RUVcdTY4MDdcdTgyODJcdTcwQjkgXHU4MkIxXHU5NTAwXHU1QzExXHU0RThFXHU0RTRCXHU1MjREXHU3Njg0XHU1MjMwXHU3NkVFXHU2ODA3XHU4MjgyXHU3MEI5XHU4MkIxXHU5NTAwXHVGRjBDXHU5MEEzXHU0RTQ4XHU2NkY0XHU2NUIwXG4gICAgICAgICAgICBpZiAodmlzaXRlZFtlZGdlWzFdXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50IG5leHQgPSBjICsgbm9kZS5jb3N0O1xuICAgICAgICAgICAgLy8gXHU2MjhBXHU3NkVFXHU2ODA3XHU4MjgyXHU3MEI5XHU1MkEwXHU1MTY1XG4gICAgICAgICAgICBwcS5vZmZlcihuZXcgTm9kZShlZGdlWzFdLCBuZXh0KSk7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkaXN0O1xufVxuXG5jbGFzcyBOb2RlIGltcGxlbWVudHMgQ29tcGFyYWJsZTxOb2RlPiB7XG4gICAgaW50IHY7XG4gICAgaW50IGNvc3Q7XG5cbiAgICBwdWJsaWMgTm9kZShpbnQgdiwgaW50IGNvc3QpIHtcbiAgICAgICAgdGhpcy52ID0gdjtcbiAgICAgICAgdGhpcy5jb3N0ID0gY29zdDtcbiAgICB9XG5cbiAgICBAT3ZlcnJpZGVcbiAgICBwdWJsaWMgaW50IGNvbXBhcmVUbyhOb2RlIG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29zdCAtIG8uY29zdDtcbiAgICB9XG59XG4iCiAgICB9XQogIH0sIHsKICAgIHRpdGxlOiAn5Luj56CBMS40LjQnLAogICAgY29kZXM6IFt7CiAgICAgIGxhbmd1YWdlOiAnUHl0aG9uJywKICAgICAgY29udGVudDogIlxuY2xhc3MgU29sdXRpb246XG4gICAgIyBcdTY1MzlcdTkwMjBcdTRFMDBcdTRFMEJcdUZGMENcdTU4OUVcdTUyQTBcdTUzQzJcdTY1NzAgS1x1RkYwQ1x1NTgwNlx1NTkxQVx1NjQzQVx1NUUyNlx1NEUwMFx1NEUyQSBzdGVwcyBcdTUzNzNcdTUzRUZcbiAgICBkZWYgZGlqa3N0cmEoc2VsZiwgZ3JhcGgsIHN0YXJ0LCBlbmQsIEspOlxuICAgICAgICBoZWFwID0gWygwLCBzdGFydCwgMCldXG4gICAgICAgIHZpc2l0ZWQgPSBzZXQoKVxuICAgICAgICB3aGlsZSBoZWFwOlxuICAgICAgICAgICAgKGNvc3QsIHUsIHN0ZXBzKSA9IGhlYXBxLmhlYXBwb3AoaGVhcClcbiAgICAgICAgICAgIGlmIHUgaW4gdmlzaXRlZDpcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgdmlzaXRlZC5hZGQoKHUsIHN0ZXBzKSlcbiAgICAgICAgICAgIGlmIHN0ZXBzID4gSzogY29udGludWVcbiAgICAgICAgICAgIGlmIHUgPT0gZW5kOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb3N0XG4gICAgICAgICAgICBmb3IgdiwgYyBpbiBncmFwaFt1XTpcbiAgICAgICAgICAgICAgICBpZiAodiwgc3RlcHMpIGluIHZpc2l0ZWQ6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgbmV4dCA9IGNvc3QgKyBjXG4gICAgICAgICAgICAgICAgaGVhcHEuaGVhcHB1c2goaGVhcCwgKG5leHQsIHYsIHN0ZXBzICsgMSkpXG4gICAgICAgIHJldHVybiAtMVxuICAgIGRlZiBmaW5kQ2hlYXBlc3RQcmljZShzZWxmLCBuOiBpbnQsIGZsaWdodHM6IExpc3RbTGlzdFtpbnRdXSwgc3JjOiBpbnQsIGRzdDogaW50LCBLOiBpbnQpIC0+IGludDpcbiAgICAgICAgZ3JhcGggPSBjb2xsZWN0aW9ucy5kZWZhdWx0ZGljdChsaXN0KVxuICAgICAgICBmb3IgZnIsIHRvLCBwcmljZSBpbiBmbGlnaHRzOlxuICAgICAgICAgICAgZ3JhcGhbZnJdLmFwcGVuZCgodG8sIHByaWNlKSlcbiAgICAgICAgICAgICMgXHU4QzAzXHU3NTI4XHU1QzAxXHU4OEM1XHU1OTdEXHU3Njg0IGRpamtzdHJhIFx1NjVCOVx1NkNENVxuICAgICAgICByZXR1cm4gc2VsZi5kaWprc3RyYShncmFwaCwgc3JjLCBkc3QsIEsgKyAxKVxuIgogICAgfSwgewogICAgICBsYW5ndWFnZTogJ0phdmEnLAogICAgICBjb250ZW50OiAiXG5Qcmlvcml0eVF1ZXVlPE5vZGU+IHBxO1xuaW50IGs7XG5wdWJsaWMgaW50IGZpbmRDaGVhcGVzdFByaWNlKGludCBuLCBpbnRbXVtdIGZsaWdodHMsIGludCBzcmMsIGludCBkc3QsIGludCBLKSB7XG4gICAgayA9IEsgKyAxO1xuICAgIC8vIFx1NzUyOFx1OTBCQlx1NjNBNVx1ODg2OFx1Njc4NFx1NUVGQVx1NTZGRVxuICAgIExpc3Q8aW50W10+W10gZ3JhcGggPSBuZXcgTGlzdFtuXTtcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IGdyYXBoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdyYXBoW2ldID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIH1cbiAgICBmb3IgKGludCBpID0gMDsgaSA8IGZsaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW50W10gZWRnZSA9IGZsaWdodHNbaV07XG4gICAgICAgIGdyYXBoW2VkZ2VbMF1dLmFkZChlZGdlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpamtzdHJhKGdyYXBoLCBzcmMsIGRzdCk7XG59XG5cblxucHVibGljIGludCBkaWprc3RyYShMaXN0PGludFtdPltdIGdyYXBoLCBpbnQgc3RhcnQsIGludCBkc3QpIHtcbiAgICBpbnRbXSBkaXN0ID0gbmV3IGludFtncmFwaC5sZW5ndGhdO1xuICAgIEFycmF5cy5maWxsKGRpc3QsIEludGVnZXIuTUFYX1ZBTFVFKTtcbiAgICBTZXQgdmlzaXRlZCA9IG5ldyBIYXNoU2V0KCk7XG4gICAgcHEgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xuICAgIHBxLm9mZmVyKG5ldyBOb2RlKHN0YXJ0LCAwLCArMSkpO1xuICAgIHdoaWxlICghcHEuaXNFbXB0eSgpKSB7XG4gICAgICAgIC8vXHU2QkNGXHU2QjIxXHU1M0Q2XHU1MUZBXHU4REREXHU3OUJCXHU2NzAwXHU4RkQxXHU3Njg0XHU4MjgyXHU3MEI5XG4gICAgICAgIE5vZGUgbm9kZSA9IHBxLnBvbGwoKTtcbiAgICAgICAgaWYgKHZpc2l0ZWQuY29udGFpbnMobm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICAgICAgICBpZiAobm9kZS5zdGVwID4gayArIDEpIGNvbnRpbnVlO1xuICAgICAgICBpZiAobm9kZS52ID09IGRzdClcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNvc3Q7XG5cbiAgICAgICAgZm9yIChpbnRbXSBlZGdlIDogZ3JhcGhbbm9kZS52XSkge1xuICAgICAgICAgICAgaW50IG1vbmV5ID0gZWRnZVsyXTtcbiAgICAgICAgICAgIGRpc3RbZWRnZVsxXV0gPSBtb25leSArIG5vZGUuY29zdDtcbiAgICAgICAgICAgIE5vZGUgbmV4dE5vZGUgPSBuZXcgTm9kZShlZGdlWzFdLCBkaXN0W2VkZ2VbMV1dLCBub2RlLnN0ZXAgKyAxKTtcbiAgICAgICAgICAgIGlmKHZpc2l0ZWQuY29udGFpbnMobmV4dE5vZGUpKXtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBcdTYyOEFcdTc2RUVcdTY4MDdcdTgyODJcdTcwQjlcdTUyQTBcdTUxNjVcbiAgICAgICAgICAgIHBxLm9mZmVyKG5leHROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cblxuY2xhc3MgTm9kZSBpbXBsZW1lbnRzIENvbXBhcmFibGU8Tm9kZT4ge1xuICAgIGludCB2O1xuICAgIGludCBjb3N0O1xuICAgIGludCBzdGVwO1xuXG4gICAgcHVibGljIE5vZGUoaW50IHYsIGludCBjb3N0LCBpbnQgc3RlcCkge1xuICAgICAgICB0aGlzLnYgPSB2O1xuICAgICAgICB0aGlzLmNvc3QgPSBjb3N0O1xuICAgICAgICB0aGlzLnN0ZXAgPSBzdGVwO1xuICAgIH1cbiAgICBAT3ZlcnJpZGVcbiAgICBwdWJsaWMgaW50IGNvbXBhcmVUbyhOb2RlIG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29zdCAtIG8uY29zdDtcbiAgICB9XG5cbiAgICBAT3ZlcnJpZGVcbiAgICBwdWJsaWMgYm9vbGVhbiBlcXVhbHMoT2JqZWN0IG9iaikge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgTm9kZSl7XG4gICAgICAgICAgICByZXR1cm4gKChOb2RlKSBvYmopLnN0ZXA9PXRoaXMuc3RlcCYmKChOb2RlKSBvYmopLnY9PXRoaXMudjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuZXF1YWxzKG9iaik7XG4gICAgfVxufVxuIgogICAgfV0KICB9XQp9XTs="},{"version":3,"sources":["/Users/luxiaopeng/github/leetcode-pp/src/views/solutionCode.js"],"names":["id","name","link","list","title","codes","language","content"],"mappings":"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","sourcesContent":["/* eslint-disable */\nexport default [\n  {\n    id: '01',\n    name: '01.堆专题',\n    link: 'https://lucifer.ren/blog/2021/01/19/heap-2',\n    list: [\n      {\n        title: '代码1.3.1',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass MedianFinder:\n    def __init__(self):\n        self.min_heap = []\n        self.max_heap = []\n    def addNum(self, num: int) -> None:\n        if not self.max_heap or num < -self.max_heap[0]:\n            heapq.heappush(self.max_heap, -num)\n        else:\n            heapq.heappush(self.min_heap, num)\n        if len(self.max_heap) > len(self.min_heap) + 1:\n            heappush(self.min_heap, -heappop(self.max_heap))\n        elif len(self.min_heap) > len(self.max_heap):\n            heappush(self.max_heap, -heappop(self.min_heap))\n    def findMedian(self) -> float:\n        if len(self.min_heap) == len(self.max_heap): return (self.min_heap[0] - self.max_heap[0]) / 2\n        return -self.max_heap[0]\n`\n          },\n          {\n            language: 'Java',\n            content: `\nclass MedianFinder {\n  private Queue<Long> minHeap = new PriorityQueue(),\n          maxHeap = new PriorityQueue();\n\n  public void addNum(int num) {\n      minHeap.add((long) num);\n      maxHeap.add(-minHeap.poll());\n      if (minHeap.size() < maxHeap.size())\n          minHeap.add(-maxHeap.poll());\n  }\n\n  public double findMedian() {\n      return minHeap.size() > maxHeap.size()\n              ? minHeap.peek()\n              : (minHeap.peek() - maxHeap.peek()) / 2.0;\n  }\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.2',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        eff = [(q / w, q, w) for a, b in zip(quality, wage)]\n        eff.sort(key=lambda a: -a[0])\n        ans = float('inf')\n        for i in range(K-1, len(eff)):\n            h = []\n            k = K - 1\n            rate, _, total = eff[i]\n            # 找出工作效率比它高的 k 个人，这 k 个人的工资尽可能低。\n            # 由于已经工作效率倒序排了，因此前面的都是比它高的，然后使用堆就可得到 k 个工资最低的。\n            for j in range(i):\n                heapq.heappush(h, eff[j][1] / rate)\n            while k > 0:\n                total += heapq.heappop(h)\n                k -= 1\n            ans = min(ans, total)\n        return ans\n`\n          },\n          {\n            language: 'Java',\n            content: `\npublic double mincostToHireWorkers(int[] quality, int[] wage, int K) {\n  int n = quality.length;\n  // 单位薪资\n  Pair<Double, Integer>[] pairs = new Pair[n];\n  for (int i = 0; i < n; i++) {\n      Pair<Double, Integer> pair = new Pair(wage[i] / (quality[i] * 1d), quality[i]);\n      pairs[i] = pair;\n  }\n  Arrays.sort(pairs, (o1, o2) -> o1.getKey() - o2.getKey() > 0 ? 1 : -1);\n\n  double ans = Double.MAX_VALUE;\n  // 总工时\n  int sumQuilty = 0;\n  PriorityQueue<Integer> pq = new PriorityQueue();\n  for (int i = 0; i < n; i++) {\n      Pair<Double, Integer> p = pairs[i];\n      // 这里偷懒直接使用了最小堆 借鉴官方题解，用最大堆也可以的\n      pq.offer(-p.getValue());\n      sumQuilty += p.getValue();\n      if (pq.size() > K)\n          // 如果超过k就要把当前工时/工资最高的赶走，这样才符合资本家剥夺剩余价值\n          sumQuilty += pq.poll();\n      if (pq.size() == K)\n          ans = Math.min(ans, sumQuilty * p.getKey());\n  }\n  return ans;\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.3',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        effs = [(q / w, q) for q, w in zip(quality, wage)]\n        effs.sort(key=lambda a: -a[0])\n        ans = float('inf')\n        h = []\n        total = 0\n        for rate, q in effs:\n            heapq.heappush(h, -q)\n            total += q\n            if len(h) > K:\n                total += heapq.heappop(h)\n            if len(h) == K:\n                ans = min(ans, total / rate)\n        return ans\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.4',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def kthSmallest(self, mat, k: int) -> int:\n        h = []\n        cur = (sum(vec[0] for vec in mat), tuple([0] * len(mat)))\n        heapq.heappush(h, cur)\n        seen = set(cur)\n\n        for _ in range(k):\n            acc, pointers = heapq.heappop(h)\n            for i, pointer in enumerate(pointers):\n                if pointer != len(mat[0]) - 1:\n                    t = list(pointers)\n                    t[i] = pointer + 1\n                    tt = tuple(t)\n                    if tt not in seen:\n                        seen.add(tt)\n                        heapq.heappush(h, (acc + mat[i][pointer + 1] - mat[i][pointer], tt))\n        return acc\n`\n          },\n          {\n            language: 'Java',\n            content: `\npublic int kthSmallest(int[][] mat, int k) {\n  int m = mat.length;\n  int n = mat[0].length;\n  PriorityQueue<Pair<Integer, int[]>> pq = new PriorityQueue<>((a, b) -> a.getKey() - b.getKey());\n  int[] sum = new int[m];\n  int total = 0;\n  for (int i = 0; i < m; i++) {\n      total += mat[i][0];\n  }\n  Pair<Integer, int[]> pair = new Pair<>(total, sum);\n  pq.offer(pair);\n  Set<String> seen = new HashSet<>();\n\n  // 小顶堆 执行k次 把前面k小的数组移除 之后栈顶便是我们所求之结果\n  while (--k > 0) {\n      Pair<Integer, int[]> cur = pq.poll();\n      // 行号\n      for (int i = 0; i < m; i++) {\n          if (cur.getValue()[i] < n - 1) {\n              int[] arr = Arrays.copyOf(cur.getValue(), m);\n              // 列号\n              arr[i]++;\n              if (!seen.contains(Arrays.toString(arr))) {\n                  seen.add(Arrays.toString(arr));\n                  int next = cur.getKey() - mat[i][cur.getValue()[i]] + mat[i][arr[i]];\n                  pq.offer(new Pair<>(next, arr));\n              }\n          }\n      }\n  }\n  return pq.peek().getKey();\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.5',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        h = []\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                a, b = nums[i], nums[j]\n                # 维持堆大小不超过 k\n                if len(h) == k and -abs(a - b) > h[0]:\n                    heapq.heappop(h)\n                if len(h) < k:\n                    heapq.heappush(h, -abs(a - b))\n\n        return -h[0]\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.6',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution(object):\n    def smallestDistancePair(self, nums, k):\n        nums.sort()\n        # n 种候选答案\n        h = [(nums[i+1] - nums[i], i, i+1) for i in range(len(nums) - 1)]\n        heapq.heapify(h)\n\n        for _ in range(k):\n            diff, fr, to = heapq.heappop(h)\n            if to + 1 < len(nums):\n                heapq.heappush((nums[to + 1] - nums[fr], fr, to + 1))\n\n        return diff\n`\n          },\n          {\n            language: 'Java',\n            content: `\npublic int smallestDistancePair(int[] nums, int k) {\n  // 先排序\n  Arrays.sort(nums);\n  // 小顶堆\n  PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(Comparator.comparingInt(a -> (nums[a.getValue()] - nums[a.getKey()])));\n  // i 于 i+1 可以找到最小的元素\n  for (int i = 0; i + 1 < nums.length; i++) {\n      Pair pair = new Pair(i, i + 1);\n      pq.offer(pair);\n  }\n  Pair<Integer, Integer> pair = null;\n  /**\n   * 实现原理：\n   * 数组按顺序排序\n   * 那么最小的差 以及第二小的差 在第一轮 也就是上面那个 for 里面可以求出来，\n   * 由于后续元素是在 原有基础上添加 后续元素肯定是每一轮逐渐增大的，也就是说上一轮集合小于下一轮（同样的起点情况）\n   * 证明：原有集合为 i->j  新增集合为  i->j+1 原有集合是新集合的子集，所以新的集合差肯定大于上一轮 ，新的集合同时覆盖（i->j）and (i+1->j+1) 两个集合\n   * 这样可以保证即便弹出一个元素 pq 中的堆顶依然是最小元素\n   * 如此反复\n   * 堆顶元素便是我们所求之元素\n   */\n  while (k > 0) {\n      k--;\n      pair = pq.poll();\n      if (pair.getValue() + 1 < nums.length) {\n          pq.offer(new Pair(pair.getKey(), pair.getValue() + 1));\n      }\n  }\n  return nums[pair.getValue()] - nums[pair.getKey()];\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.7',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def smallestDistancePair(self, A: List[int], K: int) -> int:\n        A.sort()\n        l, r = 0, A[-1] - A[0]\n\n        def count_ngt(mid):\n            slow = 0\n            ans = 0\n            for fast in range(len(A)):\n                while A[fast] - A[slow] > mid:\n                    slow += 1\n                ans += fast - slow\n            return ans\n\n        while l <= r:\n            mid = (l + r) // 2\n            if count_ngt(mid) >= K:\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l\n`\n          },\n          {\n            language: 'Java',\n            content: `\npublic int smallestDistancePair(int[] nums, int k) {\n  Arrays.sort(nums);\n\n  int l = 0;\n  int r = nums[nums.length - 1] - nums[0];\n  while (l < r) {\n      int mi = (l + r) / 2;\n      int count = 0, left = 0;\n      for (int right = 0; right < nums.length; ++right) {\n          while (nums[right] - nums[left] > mi) left++;\n          count += right - left;\n      }\n      //count = number of pairs with distance <= mi\n      if (count >= k) r = mi;\n      else l = mi + 1;\n  }\n  return r;\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.8',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def smallestRange(self, martrix: List[List[int]]) -> List[int]:\n        l, r = -10**9, 10**9\n        # 将每一行最小的都放到堆中，同时记录其所在的行号和列号，一共 n 个齐头并进\n        h = [(row[0], i, 0) for i, row in enumerate(martrix)]\n        heapq.heapify(h)\n        # 维护最大值\n        max_v = max(row[0] for row in martrix)\n\n        while True:\n            min_v, row, col = heapq.heappop(h)\n            # max_v - min_v 是当前的最大最小差值， r - l 为全局的最大最小差值。因为如果当前的更小，我们就更新全局结果\n            if max_v - min_v < r - l:\n                l, r = min_v, max_v\n            if col == len(martrix[row]) - 1: return [l, r]\n            # 更新指针，继续往后移动一位\n            heapq.heappush(h, (martrix[row][col + 1], row, col + 1))\n            max_v = max(max_v, martrix[row][col + 1])\n`\n          },\n          {\n            language: 'Java',\n            content: `\npublic int[] smallestRange(List<List<Integer>> nums) {\n\n  int l = -1000000000, r = 1000000000, max = -1000000000;\n\n  // 用一个 int[3] 数组来保存 len， height 以及 val\n  PriorityQueue<int[]> pq = new PriorityQueue((Comparator<int[]>) (a, b) -> a[2] - b[2]);\n\n  for (int i = 0; i < nums.size(); i++) {\n      pq.offer(new int[]{i, 0, nums.get(i).get(0)});\n      max = Math.max(max, nums.get(i).get(0));\n  }\n\n  while (!pq.isEmpty()) {\n      int[] item = pq.poll();\n      int minV = item[2], row = item[0], col = item[1];\n      if (max - minV < r - l) {\n          l = minV;\n          r = max;\n      }\n      if (col == nums.get(row).size() - 1) {\n          return new int[]{l, r};\n      }\n      int next = nums.get(row).get(col + 1);\n      pq.offer(new int[]{row, col + 1, next});\n      max = Math.max(next, max);\n  }\n\n  return new int[]{l, r};\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.9',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def smallestRange(self, martrix: List[List[int]]) -> List[int]:\n        l, r = -10**9, 10**9\n        # 将每一行最小的都放到堆中，同时记录其所在的行号和列号，一共 n 个齐头并进\n        h = [(row[0], i, 0) for i, row in enumerate(martrix)]\n        heapq.heapify(h)\n        # 维护最大值\n        max_v = max(row[0] for row in martrix)\n\n        while True:\n            min_v, row, col = heapq.heappop(h)\n            # max_v - min_v 是当前的最大最小差值， r - l 为全局的最大最小差值。因为如果当前的更小，我们就更新全局结果\n            if max_v - min_v < r - l:\n                l, r = min_v, max_v\n            if col == len(martrix[row]) - 1: return [l, r]\n            # 更新指针，继续往后移动一位\n            heapq.heappush(h, (martrix[row][col + 1], row, col + 1))\n            max_v = max(max_v, martrix[row][col + 1])\n    def minimumDeviation(self, nums: List[int]) -> int:\n        matrix = [[] for _ in range(len(nums))]\n        for i, num in enumerate(nums):\n            if num & 1 == 1:\n                matrix[i] += [num, num * 2]\n            else:\n                temp = []\n                while num and num & 1 == 0:\n                    temp += [num]\n                    num //= 2\n                temp += [num]\n                matrix[i] += temp[::-1]\n        a, b = self.smallestRange(matrix)\n        return b - a\n`\n          },\n          {\n            language: 'Java',\n            content: `\npublic int minimumDeviation(int[] nums) {\n  int n = nums.length;\n  List<List<Integer>> arr = new ArrayList<>();\n  for (int i = 0; i < n; ++i) {\n      arr.add(new ArrayList<>());\n      if ((nums[i] & 1) == 1) {\n          arr.get(i).add(nums[i]);\n          arr.get(i).add(nums[i] * 2);\n      } else {\n          while ((nums[i] & 1) != 0) {\n              arr.get(i).add(nums[i]);\n              nums[i] >>= 1;\n          }\n          arr.get(i).add(nums[i]);\n          Collections.reverse(arr.get(i));\n      }\n  }\n\n  int[] res = smallestRange(arr);\n\n  return res[1] - res[0];\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.10',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        stations += [(target, 0)]\n        cur = startFuel\n        ans = 0\n\n        h = []\n        last = 0\n        for i, fuel in stations:\n            cur -= i - last\n            while cur < 0 and h:\n                cur -= heapq.heappop(h)\n                ans += 1\n            if cur < 0:\n                return -1\n            heappush(h, -fuel)\n\n            last = i\n        return ans\n`\n          },\n          {\n            language: 'Java',\n            content: `\npublic int minRefuelStops(int target, int startFuel, int[][] stations) {\n  if (stations.length == 0) {\n      return startFuel >= target ? 0 : -1;\n  }\n\n  // 定义次数 ans，车内油量 cur\n  int ans = 0, cur = startFuel;\n  // 定义 pq 用来在车厢箱保存燃油\n  PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n\n  for (int i = 0; i < stations.length; i++) {\n      // 车上没油啦 需要到车厢找最大的一桶油来加满\n      while (cur < stations[i][0]) {\n          Integer fuel = pq.poll();\n          // 车厢没油了 mission failed\n          if (fuel == null) {\n              return -1;\n          }\n          // 行驶距离\n          cur += fuel;\n          ans++;\n      }\n      pq.offer(stations[i][1]);\n  }\n  // 判断是否到达目的地\n  while (cur < target) {\n      Integer fuel = pq.poll();\n      if (fuel == null) {\n          return -1;\n      }\n      cur += fuel;\n      ans++;\n  }\n  return ans;\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.11',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        ans = [1] * len(rains)\n        lakes = collections.defaultdict(int)\n        sunny = []\n\n        for i, rain in enumerate(rains):\n            if rain > 0:\n                ans[i] = -1\n                if lakes[rain - 1] == 1:\n                    if 0 == len(sunny):\n                        return []\n                    ans[sunny.pop()] = rain\n                lakes[rain - 1] = 1\n            else:\n                sunny.append(i)\n        return ans\n`\n          },\n          {\n            language: 'Java',\n            content: `\npublic  int[] avoidFlood(int[] rains) {\n\n    List<Integer>sunnys = new ArrayList<>();\n\n    Map<Integer,Integer> rainings = new HashMap<>();\n    int res[] = new int[rains.length];\n    for (int i = 0; i < rains.length; i++) {\n        // 当前湖泊下雨啦\n        if (rains[i]>0){\n            if (rainings.containsKey(rains[i])) {\n                int lastRainingDay = rainings.get(rains[i]);\n                int index =  getLeft(sunnys,lastRainingDay);\n                if (index>=sunnys.size()){\n                    return new int[]{};\n                }\n\n                res[sunnys.get(index)] = rains[i];\n                sunnys.remove(index);\n            }\n            rainings.put(rains[i],i);\n            res[i] = -1;\n        }else {\n            sunnys.add(i);\n        }\n    }\n    for (int i = 0; i <sunnys.size(); i++) {\n        res[sunnys.get(i)] = 1;\n    }\n    return res;\n}\npublic int getLeft(List<Integer> arr,int key){\n    int left = 0;\n    int right = arr.size();\n    while (left<right){\n        int mid = (left+right)>>1;\n\n        if (arr.get(mid)>=key){\n            right=mid;\n        }else {\n            left = mid+1;\n        }\n    }\n    return left;\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.3.12',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:\n        h = []\n        for i in range(1, len(heights)):\n            diff = heights[i] - heights[i - 1]\n            if diff <= 0:\n                continue\n            if bricks < diff and ladders > 0:\n                ladders -= 1\n                if h and -h[0] > diff:\n                    bricks -= heapq.heappop(h)\n                else:\n                    continue\n            bricks -= diff\n            if bricks < 0:\n                return i - 1\n            heapq.heappush(h, -diff)\n        return len(heights) - 1\n`\n          },\n          {\n            language: 'Java',\n            content: `\npublic int furthestBuilding(int[] heights, int bricks, int ladders) {\n  if (heights.length < 1) {\n      return heights.length;\n  }\n  int needBrick = 0;\n\n  PriorityQueue<Integer> pq = new PriorityQueue();\n  for (int i = 1; i < heights.length; i++) {\n      int diff = heights[i] - heights[i - 1];\n      if (diff > 0) {\n          pq.offer(diff);\n          if (pq.size() > ladders) {\n              int brick = pq.poll();\n              needBrick += brick;\n          }\n          if (needBrick > bricks) {\n              return i - 1;\n          }\n      }\n  }\n  return heights.length - 1;\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.4.1',\n        codes: [\n          {\n            language: 'Python',\n            content: `\ndef dijkstra(graph, start, end):\n    # 堆里的数据都是 (cost, i) 的二元祖，其含义是“从 start 走到 i 的距离是 cost”。\n    heap = [(0, start)]\n    visited = set()\n    while heap:\n        (cost, u) = heapq.heappop(heap)\n        if u in visited:\n            continue\n        visited.add(u)\n        if u == end:\n            return cost\n        for v, c in graph[u]:\n            if v in visited:\n                continue\n            next = cost + c\n            heapq.heappush(heap, (next, v))\n    return -1\n`\n          },\n          {\n            language: 'Java',\n            content: `\n            \n            `\n          }\n        ]\n      },\n      {\n        title: '代码1.4.2',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def dijkstra(self, graph, start, end):\n        heap = [(0, start)]\n        visited = set()\n        while heap:\n            (cost, u) = heapq.heappop(heap)\n            if u in visited:\n                continue\n            visited.add(u)\n            if u == end:\n                return cost\n            for v, c in graph[u]:\n                if v in visited:\n                    continue\n                next = cost + c\n                heapq.heappush(heap, (next, v))\n        return -1\n    def networkDelayTime(self, times: List[List[int]], N: int, K: int) -> int:\n        graph = collections.defaultdict(list)\n        for fr, to, w in times:\n            graph[fr - 1].append((to - 1, w))\n        ans = -1\n        for to in range(N):\n            # 调用封装好的 dijkstra 方法\n            dist = self.dijkstra(graph, K - 1, to)\n            if dist == -1: return -1\n            ans = max(ans, dist)\n        return ans\n`\n          },\n          {\n            language: 'Java',\n            content: `\nPriorityQueue<Node> pq;\npublic int networkDelayTime(int[][] times, int n, int k) {\n    // 用邻接表构建图\n    List<int[]>[] graph = new List[n + 1];\n    for (int i = 0; i < graph.length; i++) {\n        graph[i] = new ArrayList();\n    }\n    for (int i = 0; i < times.length; i++) {\n        int[] edge = times[i];\n        graph[edge[0]].add(edge);\n    }\n\n    int dist,ans = -1;\n\n    for (int to = 1; to <= n; to++) {\n        dist = dijkstra(graph, k, to);\n        if (dist == -1) {\n            return -1;\n        }\n        ans = Math.max(ans, dist);\n    }\n    return ans;\n}\n\npublic int dijkstra(List<int[]>[] graph, int start, int end) {\n    Arrays.fill(cost, Integer.MAX_VALUE);\n    boolean visited[] = new boolean[graph.length];\n    cost[start] = 0;\n    pq = new PriorityQueue();\n    pq.offer(new Node(start, 0));\n\n    while (!pq.isEmpty()) {\n        //每次取出距离最近的节点\n        Node node = pq.poll();\n        if (visited[node.v]) {\n            continue;\n        }\n        visited[node.v] = true;\n        if (node.v == end) {\n            return node.cost;\n        }\n\n        for (int[] edge : graph[node.v]) {\n            int c = edge[2];\n            // 如果原点经过该条边到达目标节点 花销少于之前的到目标节点花销，那么更新\n            if (visited[edge[1]]) {\n                continue;\n            }\n            int next = c + node.cost;\n            // 把目标节点加入\n            pq.offer(new Node(edge[1], next));\n\n        }\n    }\n\n    return -1;\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.4.3',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    def dijkstra(self, graph, start, end):\n        heap = [(0, start)]  # cost from start node,end node\n        dist = {}\n        while heap:\n            (cost, u) = heapq.heappop(heap)\n            if u in dist:\n                continue\n            dist[u] = cost\n            for v, c in graph[u]:\n                if v in dist:\n                    continue\n                next = cost + c\n                heapq.heappush(heap, (next, v))\n        return dist\n    def networkDelayTime(self, times: List[List[int]], N: int, K: int) -> int:\n        graph = collections.defaultdict(list)\n        for fr, to, w in times:\n            graph[fr - 1].append((to - 1, w))\n        ans = -1\n        dist = self.dijkstra(graph, K - 1, to)\n        return -1 if len(dist) != N else max(dist.values())\n`\n          },\n          {\n            language: 'Java',\n            content: `\n            int dist[];\nPriorityQueue<Node> pq;\n\npublic int networkDelayTime(int[][] times, int n, int k) {\n    // 用邻接表构建图\n    List<int[]>[] graph = new List[n + 1];\n    for (int i = 0; i < graph.length; i++) {\n        graph[i] = new ArrayList();\n    }\n    for (int i = 0; i < times.length; i++) {\n        int[] edge = times[i];\n        graph[edge[0]].add(edge);\n    }\n    return dijkstra(graph, k);\n\n}\n\n\npublic int[] dijkstra(List<int[]>[] graph, int start) {\n    dist = new int[graph.length];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    boolean visited[] = new boolean[graph.length];\n    dist[start] = 0;\n    pq = new PriorityQueue();\n    pq.offer(new Node(start, 0));\n\n    while (!pq.isEmpty()) {\n        //每次取出距离最近的节点\n        Node node = pq.poll();\n        if (visited[node.v]) {\n            continue;\n        }\n        visited[node.v] = true;\n        for (int[] edge : graph[node.v]) {\n            int c = edge[2];\n            // 如果原点经过该条边到达目标节点 花销少于之前的到目标节点花销，那么更新\n            if (visited[edge[1]]) {\n                continue;\n            }\n            int next = c + node.cost;\n            // 把目标节点加入\n            pq.offer(new Node(edge[1], next));\n\n        }\n    }\n\n    return dist;\n}\n\nclass Node implements Comparable<Node> {\n    int v;\n    int cost;\n\n    public Node(int v, int cost) {\n        this.v = v;\n        this.cost = cost;\n    }\n\n    @Override\n    public int compareTo(Node o) {\n        return this.cost - o.cost;\n    }\n}\n`\n          }\n        ]\n      },\n      {\n        title: '代码1.4.4',\n        codes: [\n          {\n            language: 'Python',\n            content: `\nclass Solution:\n    # 改造一下，增加参数 K，堆多携带一个 steps 即可\n    def dijkstra(self, graph, start, end, K):\n        heap = [(0, start, 0)]\n        visited = set()\n        while heap:\n            (cost, u, steps) = heapq.heappop(heap)\n            if u in visited:\n                continue\n            visited.add((u, steps))\n            if steps > K: continue\n            if u == end:\n                return cost\n            for v, c in graph[u]:\n                if (v, steps) in visited:\n                    continue\n                next = cost + c\n                heapq.heappush(heap, (next, v, steps + 1))\n        return -1\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\n        graph = collections.defaultdict(list)\n        for fr, to, price in flights:\n            graph[fr].append((to, price))\n            # 调用封装好的 dijkstra 方法\n        return self.dijkstra(graph, src, dst, K + 1)\n`\n          },\n          {\n            language: 'Java',\n            content: `\nPriorityQueue<Node> pq;\nint k;\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\n    k = K + 1;\n    // 用邻接表构建图\n    List<int[]>[] graph = new List[n];\n    for (int i = 0; i < graph.length; i++) {\n        graph[i] = new ArrayList();\n    }\n    for (int i = 0; i < flights.length; i++) {\n        int[] edge = flights[i];\n        graph[edge[0]].add(edge);\n    }\n    return dijkstra(graph, src, dst);\n}\n\n\npublic int dijkstra(List<int[]>[] graph, int start, int dst) {\n    int[] dist = new int[graph.length];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    Set visited = new HashSet();\n    pq = new PriorityQueue();\n    pq.offer(new Node(start, 0, +1));\n    while (!pq.isEmpty()) {\n        //每次取出距离最近的节点\n        Node node = pq.poll();\n        if (visited.contains(node)) {\n            continue;\n        }\n        visited.add(node);\n        if (node.step > k + 1) continue;\n        if (node.v == dst)\n            return node.cost;\n\n        for (int[] edge : graph[node.v]) {\n            int money = edge[2];\n            dist[edge[1]] = money + node.cost;\n            Node nextNode = new Node(edge[1], dist[edge[1]], node.step + 1);\n            if(visited.contains(nextNode)){\n                continue;\n            }\n                // 把目标节点加入\n            pq.offer(nextNode);\n        }\n    }\n    return -1;\n}\n\n\nclass Node implements Comparable<Node> {\n    int v;\n    int cost;\n    int step;\n\n    public Node(int v, int cost, int step) {\n        this.v = v;\n        this.cost = cost;\n        this.step = step;\n    }\n    @Override\n    public int compareTo(Node o) {\n        return this.cost - o.cost;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof Node){\n            return ((Node) obj).step==this.step&&((Node) obj).v==this.v;\n        }\n        return super.equals(obj);\n    }\n}\n`\n          }\n        ]\n      }\n    ]\n  }\n]\n"]}]}